
02-MSC_Appli.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000002b0  90000000  90000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000d7e8  900002b0  900002b0  000012b0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000070  9000da98  9000da98  0000ea98  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  9000db08  9000db08  0000f100  2**0
                  CONTENTS, READONLY
  4 .ARM          00000000  9000db08  9000db08  0000f100  2**0
                  CONTENTS, READONLY
  5 .preinit_array 00000000  9000db08  9000db08  0000f100  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  9000db08  9000db08  0000eb08  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  9000db0c  9000db0c  0000eb0c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000100  24000000  9000db10  0000f000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000d3c  24000100  9000dc10  0000f100  2**2
                  ALLOC
 10 ._user_heap_stack 00001000  20000000  20000000  00001000  2**0
                  ALLOC
 11 .ARM.attributes 0000002e  00000000  00000000  0000f100  2**0
                  CONTENTS, READONLY
 12 .debug_info   0001b0e5  00000000  00000000  0000f12e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 000044b8  00000000  00000000  0002a213  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00001848  00000000  00000000  0002e6d0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_rnglists 00001224  00000000  00000000  0002ff18  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  00035244  00000000  00000000  0003113c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   000205a4  00000000  00000000  00066380  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    0013a66f  00000000  00000000  00086924  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000043  00000000  00000000  001c0f93  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00006478  00000000  00000000  001c0fd8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 00000081  00000000  00000000  001c7450  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

900002b0 <__do_global_dtors_aux>:
900002b0:	b510      	push	{r4, lr}
900002b2:	4c05      	ldr	r4, [pc, #20]	@ (900002c8 <__do_global_dtors_aux+0x18>)
900002b4:	7823      	ldrb	r3, [r4, #0]
900002b6:	b933      	cbnz	r3, 900002c6 <__do_global_dtors_aux+0x16>
900002b8:	4b04      	ldr	r3, [pc, #16]	@ (900002cc <__do_global_dtors_aux+0x1c>)
900002ba:	b113      	cbz	r3, 900002c2 <__do_global_dtors_aux+0x12>
900002bc:	4804      	ldr	r0, [pc, #16]	@ (900002d0 <__do_global_dtors_aux+0x20>)
900002be:	f3af 8000 	nop.w
900002c2:	2301      	movs	r3, #1
900002c4:	7023      	strb	r3, [r4, #0]
900002c6:	bd10      	pop	{r4, pc}
900002c8:	24000100 	.word	0x24000100
900002cc:	00000000 	.word	0x00000000
900002d0:	9000da80 	.word	0x9000da80

900002d4 <frame_dummy>:
900002d4:	b508      	push	{r3, lr}
900002d6:	4b03      	ldr	r3, [pc, #12]	@ (900002e4 <frame_dummy+0x10>)
900002d8:	b11b      	cbz	r3, 900002e2 <frame_dummy+0xe>
900002da:	4903      	ldr	r1, [pc, #12]	@ (900002e8 <frame_dummy+0x14>)
900002dc:	4803      	ldr	r0, [pc, #12]	@ (900002ec <frame_dummy+0x18>)
900002de:	f3af 8000 	nop.w
900002e2:	bd08      	pop	{r3, pc}
900002e4:	00000000 	.word	0x00000000
900002e8:	24000104 	.word	0x24000104
900002ec:	9000da80 	.word	0x9000da80

900002f0 <MX_GPIO_Init>:
/* USER CODE END 1 */

/** Configure pins
*/
void MX_GPIO_Init(void)
{
900002f0:	b580      	push	{r7, lr}
900002f2:	b08a      	sub	sp, #40	@ 0x28
900002f4:	af00      	add	r7, sp, #0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
900002f6:	f107 0314 	add.w	r3, r7, #20
900002fa:	2200      	movs	r2, #0
900002fc:	601a      	str	r2, [r3, #0]
900002fe:	605a      	str	r2, [r3, #4]
90000300:	609a      	str	r2, [r3, #8]
90000302:	60da      	str	r2, [r3, #12]
90000304:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
90000306:	4b32      	ldr	r3, [pc, #200]	@ (900003d0 <MX_GPIO_Init+0xe0>)
90000308:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
9000030c:	4a30      	ldr	r2, [pc, #192]	@ (900003d0 <MX_GPIO_Init+0xe0>)
9000030e:	f043 0304 	orr.w	r3, r3, #4
90000312:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
90000316:	4b2e      	ldr	r3, [pc, #184]	@ (900003d0 <MX_GPIO_Init+0xe0>)
90000318:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
9000031c:	613b      	str	r3, [r7, #16]
9000031e:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOD_CLK_ENABLE();
90000320:	4b2b      	ldr	r3, [pc, #172]	@ (900003d0 <MX_GPIO_Init+0xe0>)
90000322:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
90000326:	4a2a      	ldr	r2, [pc, #168]	@ (900003d0 <MX_GPIO_Init+0xe0>)
90000328:	f043 0308 	orr.w	r3, r3, #8
9000032c:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
90000330:	4b27      	ldr	r3, [pc, #156]	@ (900003d0 <MX_GPIO_Init+0xe0>)
90000332:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
90000336:	60fb      	str	r3, [r7, #12]
90000338:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
9000033a:	4b25      	ldr	r3, [pc, #148]	@ (900003d0 <MX_GPIO_Init+0xe0>)
9000033c:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
90000340:	4a23      	ldr	r2, [pc, #140]	@ (900003d0 <MX_GPIO_Init+0xe0>)
90000342:	f043 0301 	orr.w	r3, r3, #1
90000346:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
9000034a:	4b21      	ldr	r3, [pc, #132]	@ (900003d0 <MX_GPIO_Init+0xe0>)
9000034c:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
90000350:	60bb      	str	r3, [r7, #8]
90000352:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
90000354:	4b1e      	ldr	r3, [pc, #120]	@ (900003d0 <MX_GPIO_Init+0xe0>)
90000356:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
9000035a:	4a1d      	ldr	r2, [pc, #116]	@ (900003d0 <MX_GPIO_Init+0xe0>)
9000035c:	f043 0302 	orr.w	r3, r3, #2
90000360:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
90000364:	4b1a      	ldr	r3, [pc, #104]	@ (900003d0 <MX_GPIO_Init+0xe0>)
90000366:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
9000036a:	607b      	str	r3, [r7, #4]
9000036c:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2, GPIO_PIN_RESET);
9000036e:	2200      	movs	r2, #0
90000370:	2104      	movs	r1, #4
90000372:	4818      	ldr	r0, [pc, #96]	@ (900003d4 <MX_GPIO_Init+0xe4>)
90000374:	f001 fc7e 	bl	90001c74 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PC13 */
  GPIO_InitStruct.Pin = GPIO_PIN_13;
90000378:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
9000037c:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
9000037e:	2300      	movs	r3, #0
90000380:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
90000382:	2302      	movs	r3, #2
90000384:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
90000386:	f107 0314 	add.w	r3, r7, #20
9000038a:	4619      	mov	r1, r3
9000038c:	4812      	ldr	r0, [pc, #72]	@ (900003d8 <MX_GPIO_Init+0xe8>)
9000038e:	f001 faf9 	bl	90001984 <HAL_GPIO_Init>

  /*Configure GPIO pin : sd_dect_Pin */
  GPIO_InitStruct.Pin = sd_dect_Pin;
90000392:	f44f 7380 	mov.w	r3, #256	@ 0x100
90000396:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
90000398:	2300      	movs	r3, #0
9000039a:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
9000039c:	2301      	movs	r3, #1
9000039e:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(sd_dect_GPIO_Port, &GPIO_InitStruct);
900003a0:	f107 0314 	add.w	r3, r7, #20
900003a4:	4619      	mov	r1, r3
900003a6:	480d      	ldr	r0, [pc, #52]	@ (900003dc <MX_GPIO_Init+0xec>)
900003a8:	f001 faec 	bl	90001984 <HAL_GPIO_Init>

  /*Configure GPIO pin : PB2 */
  GPIO_InitStruct.Pin = GPIO_PIN_2;
900003ac:	2304      	movs	r3, #4
900003ae:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
900003b0:	2301      	movs	r3, #1
900003b2:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
900003b4:	2300      	movs	r3, #0
900003b6:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
900003b8:	2300      	movs	r3, #0
900003ba:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
900003bc:	f107 0314 	add.w	r3, r7, #20
900003c0:	4619      	mov	r1, r3
900003c2:	4804      	ldr	r0, [pc, #16]	@ (900003d4 <MX_GPIO_Init+0xe4>)
900003c4:	f001 fade 	bl	90001984 <HAL_GPIO_Init>

}
900003c8:	bf00      	nop
900003ca:	3728      	adds	r7, #40	@ 0x28
900003cc:	46bd      	mov	sp, r7
900003ce:	bd80      	pop	{r7, pc}
900003d0:	58024400 	.word	0x58024400
900003d4:	58020400 	.word	0x58020400
900003d8:	58020800 	.word	0x58020800
900003dc:	58020000 	.word	0x58020000

900003e0 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
900003e0:	b580      	push	{r7, lr}
900003e2:	b094      	sub	sp, #80	@ 0x50
900003e4:	af00      	add	r7, sp, #0
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
900003e6:	4b65      	ldr	r3, [pc, #404]	@ (9000057c <main+0x19c>)
900003e8:	695b      	ldr	r3, [r3, #20]
900003ea:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
900003ee:	2b00      	cmp	r3, #0
900003f0:	d11b      	bne.n	9000042a <main+0x4a>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
900003f2:	f3bf 8f4f 	dsb	sy
}
900003f6:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
900003f8:	f3bf 8f6f 	isb	sy
}
900003fc:	bf00      	nop

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
900003fe:	4b5f      	ldr	r3, [pc, #380]	@ (9000057c <main+0x19c>)
90000400:	2200      	movs	r2, #0
90000402:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
90000406:	f3bf 8f4f 	dsb	sy
}
9000040a:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
9000040c:	f3bf 8f6f 	isb	sy
}
90000410:	bf00      	nop
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
90000412:	4b5a      	ldr	r3, [pc, #360]	@ (9000057c <main+0x19c>)
90000414:	695b      	ldr	r3, [r3, #20]
90000416:	4a59      	ldr	r2, [pc, #356]	@ (9000057c <main+0x19c>)
90000418:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
9000041c:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
9000041e:	f3bf 8f4f 	dsb	sy
}
90000422:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
90000424:	f3bf 8f6f 	isb	sy
}
90000428:	e000      	b.n	9000042c <main+0x4c>
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
9000042a:	bf00      	nop
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
9000042c:	4b53      	ldr	r3, [pc, #332]	@ (9000057c <main+0x19c>)
9000042e:	695b      	ldr	r3, [r3, #20]
90000430:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
90000434:	2b00      	cmp	r3, #0
90000436:	d138      	bne.n	900004aa <main+0xca>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
90000438:	4b50      	ldr	r3, [pc, #320]	@ (9000057c <main+0x19c>)
9000043a:	2200      	movs	r2, #0
9000043c:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
90000440:	f3bf 8f4f 	dsb	sy
}
90000444:	bf00      	nop
    __DSB();

    ccsidr = SCB->CCSIDR;
90000446:	4b4d      	ldr	r3, [pc, #308]	@ (9000057c <main+0x19c>)
90000448:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
9000044c:	647b      	str	r3, [r7, #68]	@ 0x44

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
9000044e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
90000450:	0b5b      	lsrs	r3, r3, #13
90000452:	f3c3 030e 	ubfx	r3, r3, #0, #15
90000456:	643b      	str	r3, [r7, #64]	@ 0x40
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
90000458:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
9000045a:	08db      	lsrs	r3, r3, #3
9000045c:	f3c3 0309 	ubfx	r3, r3, #0, #10
90000460:	63fb      	str	r3, [r7, #60]	@ 0x3c
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
90000462:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
90000464:	015a      	lsls	r2, r3, #5
90000466:	f643 73e0 	movw	r3, #16352	@ 0x3fe0
9000046a:	4013      	ands	r3, r2
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
9000046c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
9000046e:	0792      	lsls	r2, r2, #30
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
90000470:	4942      	ldr	r1, [pc, #264]	@ (9000057c <main+0x19c>)
90000472:	4313      	orrs	r3, r2
90000474:	f8c1 3260 	str.w	r3, [r1, #608]	@ 0x260
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
90000478:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
9000047a:	1e5a      	subs	r2, r3, #1
9000047c:	63fa      	str	r2, [r7, #60]	@ 0x3c
9000047e:	2b00      	cmp	r3, #0
90000480:	d1ef      	bne.n	90000462 <main+0x82>
    } while(sets-- != 0U);
90000482:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
90000484:	1e5a      	subs	r2, r3, #1
90000486:	643a      	str	r2, [r7, #64]	@ 0x40
90000488:	2b00      	cmp	r3, #0
9000048a:	d1e5      	bne.n	90000458 <main+0x78>
  __ASM volatile ("dsb 0xF":::"memory");
9000048c:	f3bf 8f4f 	dsb	sy
}
90000490:	bf00      	nop
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
90000492:	4b3a      	ldr	r3, [pc, #232]	@ (9000057c <main+0x19c>)
90000494:	695b      	ldr	r3, [r3, #20]
90000496:	4a39      	ldr	r2, [pc, #228]	@ (9000057c <main+0x19c>)
90000498:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
9000049c:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
9000049e:	f3bf 8f4f 	dsb	sy
}
900004a2:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
900004a4:	f3bf 8f6f 	isb	sy
}
900004a8:	e000      	b.n	900004ac <main+0xcc>
    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
900004aa:	bf00      	nop
  SCB_EnableDCache();

  /* MCU Configuration--------------------------------------------------------*/

  /* Update SystemCoreClock variable according to RCC registers values. */
  SystemCoreClockUpdate();
900004ac:	f000 ff6a 	bl	90001384 <SystemCoreClockUpdate>

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
900004b0:	f001 f8a0 	bl	900015f4 <HAL_Init>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
900004b4:	f7ff ff1c 	bl	900002f0 <MX_GPIO_Init>
  MX_RTC_Init();
900004b8:	f000 f872 	bl	900005a0 <MX_RTC_Init>
  /* USER CODE BEGIN 2 */
  // Check sd card insertion
  if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_8) == GPIO_PIN_SET)
900004bc:	f44f 7180 	mov.w	r1, #256	@ 0x100
900004c0:	482f      	ldr	r0, [pc, #188]	@ (90000580 <main+0x1a0>)
900004c2:	f001 fbbf 	bl	90001c44 <HAL_GPIO_ReadPin>
900004c6:	4603      	mov	r3, r0
900004c8:	2b01      	cmp	r3, #1
900004ca:	d10c      	bne.n	900004e6 <main+0x106>
  {
    MX_SDMMC1_SD_Init();
900004cc:	f000 f926 	bl	9000071c <MX_SDMMC1_SD_Init>
    MX_USB_DEVICE_Init();
900004d0:	f000 fa4e 	bl	90000970 <MX_USB_DEVICE_Init>
      HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_2);
      HAL_Delay(50);
    }
  }
  uint32_t tick,tick_now;
  tick = HAL_GetTick() + 200;
900004d4:	f001 f8f6 	bl	900016c4 <HAL_GetTick>
900004d8:	4603      	mov	r3, r0
900004da:	33c8      	adds	r3, #200	@ 0xc8
900004dc:	64fb      	str	r3, [r7, #76]	@ 0x4c
  tick_now = HAL_GetTick();
900004de:	f001 f8f1 	bl	900016c4 <HAL_GetTick>
900004e2:	64b8      	str	r0, [r7, #72]	@ 0x48
900004e4:	e007      	b.n	900004f6 <main+0x116>
      HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_2);
900004e6:	2104      	movs	r1, #4
900004e8:	4826      	ldr	r0, [pc, #152]	@ (90000584 <main+0x1a4>)
900004ea:	f001 fbdb 	bl	90001ca4 <HAL_GPIO_TogglePin>
      HAL_Delay(50);
900004ee:	2032      	movs	r0, #50	@ 0x32
900004f0:	f001 f8f4 	bl	900016dc <HAL_Delay>
      HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_2);
900004f4:	e7f7      	b.n	900004e6 <main+0x106>

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    tick_now = HAL_GetTick();
900004f6:	f001 f8e5 	bl	900016c4 <HAL_GetTick>
900004fa:	64b8      	str	r0, [r7, #72]	@ 0x48
    if(HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_13))
900004fc:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
90000500:	4821      	ldr	r0, [pc, #132]	@ (90000588 <main+0x1a8>)
90000502:	f001 fb9f 	bl	90001c44 <HAL_GPIO_ReadPin>
90000506:	4603      	mov	r3, r0
90000508:	2b00      	cmp	r3, #0
9000050a:	d00b      	beq.n	90000524 <main+0x144>
    {
      if(tick_now >= tick)
9000050c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
9000050e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
90000510:	429a      	cmp	r2, r3
90000512:	d3f0      	bcc.n	900004f6 <main+0x116>
      {
        tick = tick_now + 200;
90000514:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
90000516:	33c8      	adds	r3, #200	@ 0xc8
90000518:	64fb      	str	r3, [r7, #76]	@ 0x4c
        HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_2);
9000051a:	2104      	movs	r1, #4
9000051c:	4819      	ldr	r0, [pc, #100]	@ (90000584 <main+0x1a4>)
9000051e:	f001 fbc1 	bl	90001ca4 <HAL_GPIO_TogglePin>
90000522:	e7e8      	b.n	900004f6 <main+0x116>
      }
    }
    else
    {
      if(tick_now >= tick)
90000524:	6cba      	ldr	r2, [r7, #72]	@ 0x48
90000526:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
90000528:	429a      	cmp	r2, r3
9000052a:	d3e4      	bcc.n	900004f6 <main+0x116>
      {
        tick = tick_now + 50;
9000052c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
9000052e:	3332      	adds	r3, #50	@ 0x32
90000530:	64fb      	str	r3, [r7, #76]	@ 0x4c
        RTC_TimeTypeDef stimestructureget;
        uint8_t text[30];
        static uint8_t Seconds_o;
        
        /* Get the RTC current Time */
        HAL_RTC_GetTime(&hrtc, &stimestructureget, RTC_FORMAT_BIN);
90000532:	f107 0324 	add.w	r3, r7, #36	@ 0x24
90000536:	2200      	movs	r2, #0
90000538:	4619      	mov	r1, r3
9000053a:	4814      	ldr	r0, [pc, #80]	@ (9000058c <main+0x1ac>)
9000053c:	f005 fef4 	bl	90006328 <HAL_RTC_GetTime>
        /* Get the RTC current Date */
        HAL_RTC_GetDate(&hrtc, &sdatestructureget, RTC_FORMAT_BIN);
90000540:	f107 0338 	add.w	r3, r7, #56	@ 0x38
90000544:	2200      	movs	r2, #0
90000546:	4619      	mov	r1, r3
90000548:	4810      	ldr	r0, [pc, #64]	@ (9000058c <main+0x1ac>)
9000054a:	f005 ffd5 	bl	900064f8 <HAL_RTC_GetDate>
        
        if(Seconds_o != stimestructureget.Seconds)
9000054e:	f897 2026 	ldrb.w	r2, [r7, #38]	@ 0x26
90000552:	4b0f      	ldr	r3, [pc, #60]	@ (90000590 <main+0x1b0>)
90000554:	781b      	ldrb	r3, [r3, #0]
90000556:	429a      	cmp	r2, r3
90000558:	d009      	beq.n	9000056e <main+0x18e>
        {
          Seconds_o = stimestructureget.Seconds;
9000055a:	f897 2026 	ldrb.w	r2, [r7, #38]	@ 0x26
9000055e:	4b0c      	ldr	r3, [pc, #48]	@ (90000590 <main+0x1b0>)
90000560:	701a      	strb	r2, [r3, #0]
          HAL_GPIO_WritePin(GPIOB,GPIO_PIN_2,GPIO_PIN_SET);
90000562:	2201      	movs	r2, #1
90000564:	2104      	movs	r1, #4
90000566:	4807      	ldr	r0, [pc, #28]	@ (90000584 <main+0x1a4>)
90000568:	f001 fb84 	bl	90001c74 <HAL_GPIO_WritePin>
9000056c:	e7c3      	b.n	900004f6 <main+0x116>
        }
        else
        {
          HAL_GPIO_WritePin(GPIOB,GPIO_PIN_2,GPIO_PIN_RESET);
9000056e:	2200      	movs	r2, #0
90000570:	2104      	movs	r1, #4
90000572:	4804      	ldr	r0, [pc, #16]	@ (90000584 <main+0x1a4>)
90000574:	f001 fb7e 	bl	90001c74 <HAL_GPIO_WritePin>
    tick_now = HAL_GetTick();
90000578:	e7bd      	b.n	900004f6 <main+0x116>
9000057a:	bf00      	nop
9000057c:	e000ed00 	.word	0xe000ed00
90000580:	58020000 	.word	0x58020000
90000584:	58020400 	.word	0x58020400
90000588:	58020800 	.word	0x58020800
9000058c:	24000120 	.word	0x24000120
90000590:	2400011c 	.word	0x2400011c

90000594 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
90000594:	b480      	push	{r7}
90000596:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
90000598:	b672      	cpsid	i
}
9000059a:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
9000059c:	bf00      	nop
9000059e:	e7fd      	b.n	9000059c <Error_Handler+0x8>

900005a0 <MX_RTC_Init>:

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
900005a0:	b580      	push	{r7, lr}
900005a2:	b08e      	sub	sp, #56	@ 0x38
900005a4:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN RTC_Init 0 */

  /* USER CODE END RTC_Init 0 */

  RTC_PrivilegeStateTypeDef privilegeState = {0};
900005a6:	f107 031c 	add.w	r3, r7, #28
900005aa:	2200      	movs	r2, #0
900005ac:	601a      	str	r2, [r3, #0]
900005ae:	605a      	str	r2, [r3, #4]
900005b0:	609a      	str	r2, [r3, #8]
900005b2:	60da      	str	r2, [r3, #12]
900005b4:	611a      	str	r2, [r3, #16]
900005b6:	615a      	str	r2, [r3, #20]
900005b8:	619a      	str	r2, [r3, #24]
  RTC_TimeTypeDef sTime = {0};
900005ba:	f107 0308 	add.w	r3, r7, #8
900005be:	2200      	movs	r2, #0
900005c0:	601a      	str	r2, [r3, #0]
900005c2:	605a      	str	r2, [r3, #4]
900005c4:	609a      	str	r2, [r3, #8]
900005c6:	60da      	str	r2, [r3, #12]
900005c8:	611a      	str	r2, [r3, #16]
  RTC_DateTypeDef sDate = {0};
900005ca:	2300      	movs	r3, #0
900005cc:	607b      	str	r3, [r7, #4]

  /* USER CODE END RTC_Init 1 */

  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
900005ce:	4b33      	ldr	r3, [pc, #204]	@ (9000069c <MX_RTC_Init+0xfc>)
900005d0:	4a33      	ldr	r2, [pc, #204]	@ (900006a0 <MX_RTC_Init+0x100>)
900005d2:	601a      	str	r2, [r3, #0]
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
900005d4:	4b31      	ldr	r3, [pc, #196]	@ (9000069c <MX_RTC_Init+0xfc>)
900005d6:	2200      	movs	r2, #0
900005d8:	605a      	str	r2, [r3, #4]
  hrtc.Init.AsynchPrediv = 127;
900005da:	4b30      	ldr	r3, [pc, #192]	@ (9000069c <MX_RTC_Init+0xfc>)
900005dc:	227f      	movs	r2, #127	@ 0x7f
900005de:	609a      	str	r2, [r3, #8]
  hrtc.Init.SynchPrediv = 255;
900005e0:	4b2e      	ldr	r3, [pc, #184]	@ (9000069c <MX_RTC_Init+0xfc>)
900005e2:	22ff      	movs	r2, #255	@ 0xff
900005e4:	60da      	str	r2, [r3, #12]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
900005e6:	4b2d      	ldr	r3, [pc, #180]	@ (9000069c <MX_RTC_Init+0xfc>)
900005e8:	2200      	movs	r2, #0
900005ea:	611a      	str	r2, [r3, #16]
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
900005ec:	4b2b      	ldr	r3, [pc, #172]	@ (9000069c <MX_RTC_Init+0xfc>)
900005ee:	2200      	movs	r2, #0
900005f0:	615a      	str	r2, [r3, #20]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
900005f2:	4b2a      	ldr	r3, [pc, #168]	@ (9000069c <MX_RTC_Init+0xfc>)
900005f4:	2200      	movs	r2, #0
900005f6:	619a      	str	r2, [r3, #24]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
900005f8:	4b28      	ldr	r3, [pc, #160]	@ (9000069c <MX_RTC_Init+0xfc>)
900005fa:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
900005fe:	61da      	str	r2, [r3, #28]
  hrtc.Init.OutPutPullUp = RTC_OUTPUT_PULLUP_NONE;
90000600:	4b26      	ldr	r3, [pc, #152]	@ (9000069c <MX_RTC_Init+0xfc>)
90000602:	2200      	movs	r2, #0
90000604:	621a      	str	r2, [r3, #32]
  hrtc.Init.BinMode = RTC_BINARY_NONE;
90000606:	4b25      	ldr	r3, [pc, #148]	@ (9000069c <MX_RTC_Init+0xfc>)
90000608:	2200      	movs	r2, #0
9000060a:	625a      	str	r2, [r3, #36]	@ 0x24
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
9000060c:	4823      	ldr	r0, [pc, #140]	@ (9000069c <MX_RTC_Init+0xfc>)
9000060e:	f005 fd6d 	bl	900060ec <HAL_RTC_Init>
90000612:	4603      	mov	r3, r0
90000614:	2b00      	cmp	r3, #0
90000616:	d001      	beq.n	9000061c <MX_RTC_Init+0x7c>
  {
    Error_Handler();
90000618:	f7ff ffbc 	bl	90000594 <Error_Handler>
  }
  privilegeState.rtcPrivilegeFull = RTC_PRIVILEGE_FULL_NO;
9000061c:	2300      	movs	r3, #0
9000061e:	61fb      	str	r3, [r7, #28]
  privilegeState.backupRegisterPrivZone = RTC_PRIVILEGE_BKUP_ZONE_NONE;
90000620:	2300      	movs	r3, #0
90000622:	62bb      	str	r3, [r7, #40]	@ 0x28
  privilegeState.backupRegisterStartZone2 = RTC_BKP_DR0;
90000624:	2300      	movs	r3, #0
90000626:	62fb      	str	r3, [r7, #44]	@ 0x2c
  privilegeState.backupRegisterStartZone3 = RTC_BKP_DR0;
90000628:	2300      	movs	r3, #0
9000062a:	633b      	str	r3, [r7, #48]	@ 0x30
  if (HAL_RTCEx_PrivilegeModeSet(&hrtc, &privilegeState) != HAL_OK)
9000062c:	f107 031c 	add.w	r3, r7, #28
90000630:	4619      	mov	r1, r3
90000632:	481a      	ldr	r0, [pc, #104]	@ (9000069c <MX_RTC_Init+0xfc>)
90000634:	f006 f896 	bl	90006764 <HAL_RTCEx_PrivilegeModeSet>
90000638:	4603      	mov	r3, r0
9000063a:	2b00      	cmp	r3, #0
9000063c:	d001      	beq.n	90000642 <MX_RTC_Init+0xa2>
  {
    Error_Handler();
9000063e:	f7ff ffa9 	bl	90000594 <Error_Handler>

  /* USER CODE END Check_RTC_BKUP */

  /** Initialize RTC and set the Time and Date
  */
  sTime.Hours = 0x0;
90000642:	2300      	movs	r3, #0
90000644:	723b      	strb	r3, [r7, #8]
  sTime.Minutes = 0x0;
90000646:	2300      	movs	r3, #0
90000648:	727b      	strb	r3, [r7, #9]
  sTime.Seconds = 0x0;
9000064a:	2300      	movs	r3, #0
9000064c:	72bb      	strb	r3, [r7, #10]
  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
9000064e:	2300      	movs	r3, #0
90000650:	617b      	str	r3, [r7, #20]
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
90000652:	2300      	movs	r3, #0
90000654:	61bb      	str	r3, [r7, #24]
  if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
90000656:	f107 0308 	add.w	r3, r7, #8
9000065a:	2201      	movs	r2, #1
9000065c:	4619      	mov	r1, r3
9000065e:	480f      	ldr	r0, [pc, #60]	@ (9000069c <MX_RTC_Init+0xfc>)
90000660:	f005 fdd0 	bl	90006204 <HAL_RTC_SetTime>
90000664:	4603      	mov	r3, r0
90000666:	2b00      	cmp	r3, #0
90000668:	d001      	beq.n	9000066e <MX_RTC_Init+0xce>
  {
    Error_Handler();
9000066a:	f7ff ff93 	bl	90000594 <Error_Handler>
  }
  sDate.WeekDay = RTC_WEEKDAY_MONDAY;
9000066e:	2301      	movs	r3, #1
90000670:	713b      	strb	r3, [r7, #4]
  sDate.Month = RTC_MONTH_JANUARY;
90000672:	2301      	movs	r3, #1
90000674:	717b      	strb	r3, [r7, #5]
  sDate.Date = 0x1;
90000676:	2301      	movs	r3, #1
90000678:	71bb      	strb	r3, [r7, #6]
  sDate.Year = 0x25;
9000067a:	2325      	movs	r3, #37	@ 0x25
9000067c:	71fb      	strb	r3, [r7, #7]

  if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
9000067e:	1d3b      	adds	r3, r7, #4
90000680:	2201      	movs	r2, #1
90000682:	4619      	mov	r1, r3
90000684:	4805      	ldr	r0, [pc, #20]	@ (9000069c <MX_RTC_Init+0xfc>)
90000686:	f005 feb1 	bl	900063ec <HAL_RTC_SetDate>
9000068a:	4603      	mov	r3, r0
9000068c:	2b00      	cmp	r3, #0
9000068e:	d001      	beq.n	90000694 <MX_RTC_Init+0xf4>
  {
    Error_Handler();
90000690:	f7ff ff80 	bl	90000594 <Error_Handler>
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}
90000694:	bf00      	nop
90000696:	3738      	adds	r7, #56	@ 0x38
90000698:	46bd      	mov	sp, r7
9000069a:	bd80      	pop	{r7, pc}
9000069c:	24000120 	.word	0x24000120
900006a0:	58004000 	.word	0x58004000

900006a4 <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle)
{
900006a4:	b580      	push	{r7, lr}
900006a6:	b0a4      	sub	sp, #144	@ 0x90
900006a8:	af00      	add	r7, sp, #0
900006aa:	6078      	str	r0, [r7, #4]

  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
900006ac:	f107 030c 	add.w	r3, r7, #12
900006b0:	2284      	movs	r2, #132	@ 0x84
900006b2:	2100      	movs	r1, #0
900006b4:	4618      	mov	r0, r3
900006b6:	f00d f9b6 	bl	9000da26 <memset>
  if(rtcHandle->Instance==RTC)
900006ba:	687b      	ldr	r3, [r7, #4]
900006bc:	681b      	ldr	r3, [r3, #0]
900006be:	4a15      	ldr	r2, [pc, #84]	@ (90000714 <HAL_RTC_MspInit+0x70>)
900006c0:	4293      	cmp	r3, r2
900006c2:	d123      	bne.n	9000070c <HAL_RTC_MspInit+0x68>

  /* USER CODE END RTC_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC;
900006c4:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
900006c8:	60fb      	str	r3, [r7, #12]
    PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
900006ca:	f44f 7380 	mov.w	r3, #256	@ 0x100
900006ce:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
900006d2:	f107 030c 	add.w	r3, r7, #12
900006d6:	4618      	mov	r0, r3
900006d8:	f003 fa78 	bl	90003bcc <HAL_RCCEx_PeriphCLKConfig>
900006dc:	4603      	mov	r3, r0
900006de:	2b00      	cmp	r3, #0
900006e0:	d001      	beq.n	900006e6 <HAL_RTC_MspInit+0x42>
    {
      Error_Handler();
900006e2:	f7ff ff57 	bl	90000594 <Error_Handler>
    }

    /* RTC clock enable */
    __HAL_RCC_RTC_ENABLE();
900006e6:	4b0c      	ldr	r3, [pc, #48]	@ (90000718 <HAL_RTC_MspInit+0x74>)
900006e8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
900006ea:	4a0b      	ldr	r2, [pc, #44]	@ (90000718 <HAL_RTC_MspInit+0x74>)
900006ec:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
900006f0:	6713      	str	r3, [r2, #112]	@ 0x70
    __HAL_RCC_RTCAPB_CLK_ENABLE();
900006f2:	4b09      	ldr	r3, [pc, #36]	@ (90000718 <HAL_RTC_MspInit+0x74>)
900006f4:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
900006f8:	4a07      	ldr	r2, [pc, #28]	@ (90000718 <HAL_RTC_MspInit+0x74>)
900006fa:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
900006fe:	f8c2 3154 	str.w	r3, [r2, #340]	@ 0x154
90000702:	4b05      	ldr	r3, [pc, #20]	@ (90000718 <HAL_RTC_MspInit+0x74>)
90000704:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
90000708:	60bb      	str	r3, [r7, #8]
9000070a:	68bb      	ldr	r3, [r7, #8]
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }
}
9000070c:	bf00      	nop
9000070e:	3790      	adds	r7, #144	@ 0x90
90000710:	46bd      	mov	sp, r7
90000712:	bd80      	pop	{r7, pc}
90000714:	58004000 	.word	0x58004000
90000718:	58024400 	.word	0x58024400

9000071c <MX_SDMMC1_SD_Init>:
SD_HandleTypeDef hsd1;

/* SDMMC1 init function */

void MX_SDMMC1_SD_Init(void)
{
9000071c:	b580      	push	{r7, lr}
9000071e:	af00      	add	r7, sp, #0
  /* USER CODE END SDMMC1_Init 0 */

  /* USER CODE BEGIN SDMMC1_Init 1 */

  /* USER CODE END SDMMC1_Init 1 */
  hsd1.Instance = SDMMC1;
90000720:	4b0e      	ldr	r3, [pc, #56]	@ (9000075c <MX_SDMMC1_SD_Init+0x40>)
90000722:	4a0f      	ldr	r2, [pc, #60]	@ (90000760 <MX_SDMMC1_SD_Init+0x44>)
90000724:	601a      	str	r2, [r3, #0]
  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
90000726:	4b0d      	ldr	r3, [pc, #52]	@ (9000075c <MX_SDMMC1_SD_Init+0x40>)
90000728:	2200      	movs	r2, #0
9000072a:	605a      	str	r2, [r3, #4]
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
9000072c:	4b0b      	ldr	r3, [pc, #44]	@ (9000075c <MX_SDMMC1_SD_Init+0x40>)
9000072e:	2200      	movs	r2, #0
90000730:	609a      	str	r2, [r3, #8]
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;
90000732:	4b0a      	ldr	r3, [pc, #40]	@ (9000075c <MX_SDMMC1_SD_Init+0x40>)
90000734:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
90000738:	60da      	str	r2, [r3, #12]
  hsd1.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
9000073a:	4b08      	ldr	r3, [pc, #32]	@ (9000075c <MX_SDMMC1_SD_Init+0x40>)
9000073c:	2200      	movs	r2, #0
9000073e:	611a      	str	r2, [r3, #16]
  hsd1.Init.ClockDiv = 2;
90000740:	4b06      	ldr	r3, [pc, #24]	@ (9000075c <MX_SDMMC1_SD_Init+0x40>)
90000742:	2202      	movs	r2, #2
90000744:	615a      	str	r2, [r3, #20]
  if (HAL_SD_Init(&hsd1) != HAL_OK)
90000746:	4805      	ldr	r0, [pc, #20]	@ (9000075c <MX_SDMMC1_SD_Init+0x40>)
90000748:	f006 f83a 	bl	900067c0 <HAL_SD_Init>
9000074c:	4603      	mov	r3, r0
9000074e:	2b00      	cmp	r3, #0
90000750:	d001      	beq.n	90000756 <MX_SDMMC1_SD_Init+0x3a>
  {
    Error_Handler();
90000752:	f7ff ff1f 	bl	90000594 <Error_Handler>
  }
  /* USER CODE BEGIN SDMMC1_Init 2 */

  /* USER CODE END SDMMC1_Init 2 */

}
90000756:	bf00      	nop
90000758:	bd80      	pop	{r7, pc}
9000075a:	bf00      	nop
9000075c:	24000150 	.word	0x24000150
90000760:	52007000 	.word	0x52007000

90000764 <HAL_SD_MspInit>:

void HAL_SD_MspInit(SD_HandleTypeDef* sdHandle)
{
90000764:	b580      	push	{r7, lr}
90000766:	b0ac      	sub	sp, #176	@ 0xb0
90000768:	af00      	add	r7, sp, #0
9000076a:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
9000076c:	f107 039c 	add.w	r3, r7, #156	@ 0x9c
90000770:	2200      	movs	r2, #0
90000772:	601a      	str	r2, [r3, #0]
90000774:	605a      	str	r2, [r3, #4]
90000776:	609a      	str	r2, [r3, #8]
90000778:	60da      	str	r2, [r3, #12]
9000077a:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
9000077c:	f107 0318 	add.w	r3, r7, #24
90000780:	2284      	movs	r2, #132	@ 0x84
90000782:	2100      	movs	r1, #0
90000784:	4618      	mov	r0, r3
90000786:	f00d f94e 	bl	9000da26 <memset>
  if(sdHandle->Instance==SDMMC1)
9000078a:	687b      	ldr	r3, [r7, #4]
9000078c:	681b      	ldr	r3, [r3, #0]
9000078e:	4a3f      	ldr	r2, [pc, #252]	@ (9000088c <HAL_SD_MspInit+0x128>)
90000790:	4293      	cmp	r3, r2
90000792:	d176      	bne.n	90000882 <HAL_SD_MspInit+0x11e>

  /* USER CODE END SDMMC1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_SDMMC12;
90000794:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
90000798:	61bb      	str	r3, [r7, #24]
    PeriphClkInit.Sdmmc12ClockSelection = RCC_SDMMC12CLKSOURCE_PLL2S;
9000079a:	2300      	movs	r3, #0
9000079c:	66fb      	str	r3, [r7, #108]	@ 0x6c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
9000079e:	f107 0318 	add.w	r3, r7, #24
900007a2:	4618      	mov	r0, r3
900007a4:	f003 fa12 	bl	90003bcc <HAL_RCCEx_PeriphCLKConfig>
900007a8:	4603      	mov	r3, r0
900007aa:	2b00      	cmp	r3, #0
900007ac:	d001      	beq.n	900007b2 <HAL_SD_MspInit+0x4e>
    {
      Error_Handler();
900007ae:	f7ff fef1 	bl	90000594 <Error_Handler>
    }

    /* SDMMC1 clock enable */
    __HAL_RCC_SDMMC1_CLK_ENABLE();
900007b2:	4b37      	ldr	r3, [pc, #220]	@ (90000890 <HAL_SD_MspInit+0x12c>)
900007b4:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
900007b8:	4a35      	ldr	r2, [pc, #212]	@ (90000890 <HAL_SD_MspInit+0x12c>)
900007ba:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
900007be:	f8c2 3134 	str.w	r3, [r2, #308]	@ 0x134
900007c2:	4b33      	ldr	r3, [pc, #204]	@ (90000890 <HAL_SD_MspInit+0x12c>)
900007c4:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
900007c8:	617b      	str	r3, [r7, #20]
900007ca:	697b      	ldr	r3, [r7, #20]

    __HAL_RCC_GPIOD_CLK_ENABLE();
900007cc:	4b30      	ldr	r3, [pc, #192]	@ (90000890 <HAL_SD_MspInit+0x12c>)
900007ce:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
900007d2:	4a2f      	ldr	r2, [pc, #188]	@ (90000890 <HAL_SD_MspInit+0x12c>)
900007d4:	f043 0308 	orr.w	r3, r3, #8
900007d8:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
900007dc:	4b2c      	ldr	r3, [pc, #176]	@ (90000890 <HAL_SD_MspInit+0x12c>)
900007de:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
900007e2:	613b      	str	r3, [r7, #16]
900007e4:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOC_CLK_ENABLE();
900007e6:	4b2a      	ldr	r3, [pc, #168]	@ (90000890 <HAL_SD_MspInit+0x12c>)
900007e8:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
900007ec:	4a28      	ldr	r2, [pc, #160]	@ (90000890 <HAL_SD_MspInit+0x12c>)
900007ee:	f043 0304 	orr.w	r3, r3, #4
900007f2:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
900007f6:	4b26      	ldr	r3, [pc, #152]	@ (90000890 <HAL_SD_MspInit+0x12c>)
900007f8:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
900007fc:	60fb      	str	r3, [r7, #12]
900007fe:	68fb      	ldr	r3, [r7, #12]
    PC10     ------> SDMMC1_D2
    PC11     ------> SDMMC1_D3
    PC9     ------> SDMMC1_D1
    PC8     ------> SDMMC1_D0
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2;
90000800:	2304      	movs	r3, #4
90000802:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000806:	2302      	movs	r3, #2
90000808:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
9000080c:	2300      	movs	r3, #0
9000080e:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000812:	2303      	movs	r3, #3
90000814:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    GPIO_InitStruct.Alternate = GPIO_AF11_SDMMC1;
90000818:	230b      	movs	r3, #11
9000081a:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
9000081e:	f107 039c 	add.w	r3, r7, #156	@ 0x9c
90000822:	4619      	mov	r1, r3
90000824:	481b      	ldr	r0, [pc, #108]	@ (90000894 <HAL_SD_MspInit+0x130>)
90000826:	f001 f8ad 	bl	90001984 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_11|GPIO_PIN_9|GPIO_PIN_8;
9000082a:	f44f 53d8 	mov.w	r3, #6912	@ 0x1b00
9000082e:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000832:	2302      	movs	r3, #2
90000834:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
90000838:	2300      	movs	r3, #0
9000083a:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
9000083e:	2303      	movs	r3, #3
90000840:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    GPIO_InitStruct.Alternate = GPIO_AF11_SDMMC1;
90000844:	230b      	movs	r3, #11
90000846:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
9000084a:	f107 039c 	add.w	r3, r7, #156	@ 0x9c
9000084e:	4619      	mov	r1, r3
90000850:	4811      	ldr	r0, [pc, #68]	@ (90000898 <HAL_SD_MspInit+0x134>)
90000852:	f001 f897 	bl	90001984 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_10;
90000856:	f44f 6380 	mov.w	r3, #1024	@ 0x400
9000085a:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
9000085e:	2302      	movs	r3, #2
90000860:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
90000864:	2300      	movs	r3, #0
90000866:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
9000086a:	2303      	movs	r3, #3
9000086c:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
90000870:	230c      	movs	r3, #12
90000872:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
90000876:	f107 039c 	add.w	r3, r7, #156	@ 0x9c
9000087a:	4619      	mov	r1, r3
9000087c:	4806      	ldr	r0, [pc, #24]	@ (90000898 <HAL_SD_MspInit+0x134>)
9000087e:	f001 f881 	bl	90001984 <HAL_GPIO_Init>

  /* USER CODE BEGIN SDMMC1_MspInit 1 */

  /* USER CODE END SDMMC1_MspInit 1 */
  }
}
90000882:	bf00      	nop
90000884:	37b0      	adds	r7, #176	@ 0xb0
90000886:	46bd      	mov	sp, r7
90000888:	bd80      	pop	{r7, pc}
9000088a:	bf00      	nop
9000088c:	52007000 	.word	0x52007000
90000890:	58024400 	.word	0x58024400
90000894:	58020c00 	.word	0x58020c00
90000898:	58020800 	.word	0x58020800

9000089c <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
9000089c:	b580      	push	{r7, lr}
9000089e:	af00      	add	r7, sp, #0

  /* USER CODE END MspInit 0 */

  /* System interrupt init*/

  HAL_PWREx_EnableUSBHSregulator();
900008a0:	f002 fd32 	bl	90003308 <HAL_PWREx_EnableUSBHSregulator>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
900008a4:	bf00      	nop
900008a6:	bd80      	pop	{r7, pc}

900008a8 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
900008a8:	b480      	push	{r7}
900008aa:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
900008ac:	bf00      	nop
900008ae:	e7fd      	b.n	900008ac <NMI_Handler+0x4>

900008b0 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
900008b0:	b480      	push	{r7}
900008b2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
900008b4:	bf00      	nop
900008b6:	e7fd      	b.n	900008b4 <HardFault_Handler+0x4>

900008b8 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
900008b8:	b480      	push	{r7}
900008ba:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
900008bc:	bf00      	nop
900008be:	e7fd      	b.n	900008bc <MemManage_Handler+0x4>

900008c0 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
900008c0:	b480      	push	{r7}
900008c2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
900008c4:	bf00      	nop
900008c6:	e7fd      	b.n	900008c4 <BusFault_Handler+0x4>

900008c8 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
900008c8:	b480      	push	{r7}
900008ca:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
900008cc:	bf00      	nop
900008ce:	e7fd      	b.n	900008cc <UsageFault_Handler+0x4>

900008d0 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
900008d0:	b480      	push	{r7}
900008d2:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
900008d4:	bf00      	nop
900008d6:	46bd      	mov	sp, r7
900008d8:	f85d 7b04 	ldr.w	r7, [sp], #4
900008dc:	4770      	bx	lr

900008de <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
900008de:	b480      	push	{r7}
900008e0:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
900008e2:	bf00      	nop
900008e4:	46bd      	mov	sp, r7
900008e6:	f85d 7b04 	ldr.w	r7, [sp], #4
900008ea:	4770      	bx	lr

900008ec <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
900008ec:	b480      	push	{r7}
900008ee:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
900008f0:	bf00      	nop
900008f2:	46bd      	mov	sp, r7
900008f4:	f85d 7b04 	ldr.w	r7, [sp], #4
900008f8:	4770      	bx	lr

900008fa <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
900008fa:	b580      	push	{r7, lr}
900008fc:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
900008fe:	f000 fecd 	bl	9000169c <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
90000902:	bf00      	nop
90000904:	bd80      	pop	{r7, pc}
	...

90000908 <OTG_HS_IRQHandler>:

/**
  * @brief This function handles USB OTG HS interrupt.
  */
void OTG_HS_IRQHandler(void)
{
90000908:	b580      	push	{r7, lr}
9000090a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN OTG_HS_IRQn 0 */

  /* USER CODE END OTG_HS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_HS);
9000090c:	4802      	ldr	r0, [pc, #8]	@ (90000918 <OTG_HS_IRQHandler+0x10>)
9000090e:	f001 fb30 	bl	90001f72 <HAL_PCD_IRQHandler>
  /* USER CODE BEGIN OTG_HS_IRQn 1 */

  /* USER CODE END OTG_HS_IRQn 1 */
}
90000912:	bf00      	nop
90000914:	bd80      	pop	{r7, pc}
90000916:	bf00      	nop
90000918:	240006a8 	.word	0x240006a8

9000091c <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
9000091c:	480d      	ldr	r0, [pc, #52]	@ (90000954 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
9000091e:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
90000920:	f000 fd1a 	bl	90001358 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
90000924:	480c      	ldr	r0, [pc, #48]	@ (90000958 <LoopForever+0x6>)
  ldr r1, =_edata
90000926:	490d      	ldr	r1, [pc, #52]	@ (9000095c <LoopForever+0xa>)
  ldr r2, =_sidata
90000928:	4a0d      	ldr	r2, [pc, #52]	@ (90000960 <LoopForever+0xe>)
  movs r3, #0
9000092a:	2300      	movs	r3, #0
  b LoopCopyDataInit
9000092c:	e002      	b.n	90000934 <LoopCopyDataInit>

9000092e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
9000092e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
90000930:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
90000932:	3304      	adds	r3, #4

90000934 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
90000934:	18c4      	adds	r4, r0, r3
  cmp r4, r1
90000936:	428c      	cmp	r4, r1
  bcc CopyDataInit
90000938:	d3f9      	bcc.n	9000092e <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
9000093a:	4a0a      	ldr	r2, [pc, #40]	@ (90000964 <LoopForever+0x12>)
  ldr r4, =_ebss
9000093c:	4c0a      	ldr	r4, [pc, #40]	@ (90000968 <LoopForever+0x16>)
  movs r3, #0
9000093e:	2300      	movs	r3, #0
  b LoopFillZerobss
90000940:	e001      	b.n	90000946 <LoopFillZerobss>

90000942 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
90000942:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
90000944:	3204      	adds	r2, #4

90000946 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
90000946:	42a2      	cmp	r2, r4
  bcc FillZerobss
90000948:	d3fb      	bcc.n	90000942 <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
9000094a:	f00d f875 	bl	9000da38 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
9000094e:	f7ff fd47 	bl	900003e0 <main>

90000952 <LoopForever>:

LoopForever:
  b LoopForever
90000952:	e7fe      	b.n	90000952 <LoopForever>
  ldr   r0, =_estack
90000954:	20010000 	.word	0x20010000
  ldr r0, =_sdata
90000958:	24000000 	.word	0x24000000
  ldr r1, =_edata
9000095c:	24000100 	.word	0x24000100
  ldr r2, =_sidata
90000960:	9000db10 	.word	0x9000db10
  ldr r2, =_sbss
90000964:	24000100 	.word	0x24000100
  ldr r4, =_ebss
90000968:	24000e3c 	.word	0x24000e3c

9000096c <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
9000096c:	e7fe      	b.n	9000096c <ADC1_2_IRQHandler>
	...

90000970 <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
90000970:	b580      	push	{r7, lr}
90000972:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */

  /* USER CODE END USB_DEVICE_Init_PreTreatment */

  /* Init Device Library, add supported class and start the library. */
  if (USBD_Init(&hUsbDeviceHS, &MSC_Desc, DEVICE_HS) != USBD_OK)
90000974:	2201      	movs	r2, #1
90000976:	4912      	ldr	r1, [pc, #72]	@ (900009c0 <MX_USB_DEVICE_Init+0x50>)
90000978:	4812      	ldr	r0, [pc, #72]	@ (900009c4 <MX_USB_DEVICE_Init+0x54>)
9000097a:	f009 fc85 	bl	9000a288 <USBD_Init>
9000097e:	4603      	mov	r3, r0
90000980:	2b00      	cmp	r3, #0
90000982:	d001      	beq.n	90000988 <MX_USB_DEVICE_Init+0x18>
  {
    Error_Handler();
90000984:	f7ff fe06 	bl	90000594 <Error_Handler>
  }
  if (USBD_RegisterClass(&hUsbDeviceHS, &USBD_MSC) != USBD_OK)
90000988:	490f      	ldr	r1, [pc, #60]	@ (900009c8 <MX_USB_DEVICE_Init+0x58>)
9000098a:	480e      	ldr	r0, [pc, #56]	@ (900009c4 <MX_USB_DEVICE_Init+0x54>)
9000098c:	f009 fcac 	bl	9000a2e8 <USBD_RegisterClass>
90000990:	4603      	mov	r3, r0
90000992:	2b00      	cmp	r3, #0
90000994:	d001      	beq.n	9000099a <MX_USB_DEVICE_Init+0x2a>
  {
    Error_Handler();
90000996:	f7ff fdfd 	bl	90000594 <Error_Handler>
  }
  if (USBD_MSC_RegisterStorage(&hUsbDeviceHS, &USBD_Storage_Interface_fops_HS) != USBD_OK)
9000099a:	490c      	ldr	r1, [pc, #48]	@ (900009cc <MX_USB_DEVICE_Init+0x5c>)
9000099c:	4809      	ldr	r0, [pc, #36]	@ (900009c4 <MX_USB_DEVICE_Init+0x54>)
9000099e:	f00b fa37 	bl	9000be10 <USBD_MSC_RegisterStorage>
900009a2:	4603      	mov	r3, r0
900009a4:	2b00      	cmp	r3, #0
900009a6:	d001      	beq.n	900009ac <MX_USB_DEVICE_Init+0x3c>
  {
    Error_Handler();
900009a8:	f7ff fdf4 	bl	90000594 <Error_Handler>
  }
  if (USBD_Start(&hUsbDeviceHS) != USBD_OK)
900009ac:	4805      	ldr	r0, [pc, #20]	@ (900009c4 <MX_USB_DEVICE_Init+0x54>)
900009ae:	f009 fcd1 	bl	9000a354 <USBD_Start>
900009b2:	4603      	mov	r3, r0
900009b4:	2b00      	cmp	r3, #0
900009b6:	d001      	beq.n	900009bc <MX_USB_DEVICE_Init+0x4c>
  {
    Error_Handler();
900009b8:	f7ff fdec 	bl	90000594 <Error_Handler>
  }

  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */

  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
900009bc:	bf00      	nop
900009be:	bd80      	pop	{r7, pc}
900009c0:	24000000 	.word	0x24000000
900009c4:	240001cc 	.word	0x240001cc
900009c8:	24000080 	.word	0x24000080
900009cc:	24000054 	.word	0x24000054

900009d0 <USBD_MSC_DeviceDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_MSC_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
900009d0:	b480      	push	{r7}
900009d2:	b083      	sub	sp, #12
900009d4:	af00      	add	r7, sp, #0
900009d6:	4603      	mov	r3, r0
900009d8:	6039      	str	r1, [r7, #0]
900009da:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = sizeof(USBD_MSC_DeviceDesc);
900009dc:	683b      	ldr	r3, [r7, #0]
900009de:	2212      	movs	r2, #18
900009e0:	801a      	strh	r2, [r3, #0]
  return USBD_MSC_DeviceDesc;
900009e2:	4b03      	ldr	r3, [pc, #12]	@ (900009f0 <USBD_MSC_DeviceDescriptor+0x20>)
}
900009e4:	4618      	mov	r0, r3
900009e6:	370c      	adds	r7, #12
900009e8:	46bd      	mov	sp, r7
900009ea:	f85d 7b04 	ldr.w	r7, [sp], #4
900009ee:	4770      	bx	lr
900009f0:	24000020 	.word	0x24000020

900009f4 <USBD_MSC_LangIDStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_MSC_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
900009f4:	b480      	push	{r7}
900009f6:	b083      	sub	sp, #12
900009f8:	af00      	add	r7, sp, #0
900009fa:	4603      	mov	r3, r0
900009fc:	6039      	str	r1, [r7, #0]
900009fe:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = sizeof(USBD_LangIDDesc);
90000a00:	683b      	ldr	r3, [r7, #0]
90000a02:	2204      	movs	r2, #4
90000a04:	801a      	strh	r2, [r3, #0]
  return USBD_LangIDDesc;
90000a06:	4b03      	ldr	r3, [pc, #12]	@ (90000a14 <USBD_MSC_LangIDStrDescriptor+0x20>)
}
90000a08:	4618      	mov	r0, r3
90000a0a:	370c      	adds	r7, #12
90000a0c:	46bd      	mov	sp, r7
90000a0e:	f85d 7b04 	ldr.w	r7, [sp], #4
90000a12:	4770      	bx	lr
90000a14:	24000034 	.word	0x24000034

90000a18 <USBD_MSC_ProductStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_MSC_ProductStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
90000a18:	b580      	push	{r7, lr}
90000a1a:	b082      	sub	sp, #8
90000a1c:	af00      	add	r7, sp, #0
90000a1e:	4603      	mov	r3, r0
90000a20:	6039      	str	r1, [r7, #0]
90000a22:	71fb      	strb	r3, [r7, #7]
  USBD_GetString((uint8_t *)USBD_PRODUCT_STRING, USBD_StrDesc, length);
90000a24:	683a      	ldr	r2, [r7, #0]
90000a26:	4904      	ldr	r1, [pc, #16]	@ (90000a38 <USBD_MSC_ProductStrDescriptor+0x20>)
90000a28:	4804      	ldr	r0, [pc, #16]	@ (90000a3c <USBD_MSC_ProductStrDescriptor+0x24>)
90000a2a:	f00a fe83 	bl	9000b734 <USBD_GetString>
  return USBD_StrDesc;
90000a2e:	4b02      	ldr	r3, [pc, #8]	@ (90000a38 <USBD_MSC_ProductStrDescriptor+0x20>)
}
90000a30:	4618      	mov	r0, r3
90000a32:	3708      	adds	r7, #8
90000a34:	46bd      	mov	sp, r7
90000a36:	bd80      	pop	{r7, pc}
90000a38:	240004a8 	.word	0x240004a8
90000a3c:	9000da98 	.word	0x9000da98

90000a40 <USBD_MSC_ManufacturerStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_MSC_ManufacturerStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
90000a40:	b580      	push	{r7, lr}
90000a42:	b082      	sub	sp, #8
90000a44:	af00      	add	r7, sp, #0
90000a46:	4603      	mov	r3, r0
90000a48:	6039      	str	r1, [r7, #0]
90000a4a:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
90000a4c:	683a      	ldr	r2, [r7, #0]
90000a4e:	4904      	ldr	r1, [pc, #16]	@ (90000a60 <USBD_MSC_ManufacturerStrDescriptor+0x20>)
90000a50:	4804      	ldr	r0, [pc, #16]	@ (90000a64 <USBD_MSC_ManufacturerStrDescriptor+0x24>)
90000a52:	f00a fe6f 	bl	9000b734 <USBD_GetString>
  return USBD_StrDesc;
90000a56:	4b02      	ldr	r3, [pc, #8]	@ (90000a60 <USBD_MSC_ManufacturerStrDescriptor+0x20>)
}
90000a58:	4618      	mov	r0, r3
90000a5a:	3708      	adds	r7, #8
90000a5c:	46bd      	mov	sp, r7
90000a5e:	bd80      	pop	{r7, pc}
90000a60:	240004a8 	.word	0x240004a8
90000a64:	9000daac 	.word	0x9000daac

90000a68 <USBD_MSC_SerialStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_MSC_SerialStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
90000a68:	b580      	push	{r7, lr}
90000a6a:	b082      	sub	sp, #8
90000a6c:	af00      	add	r7, sp, #0
90000a6e:	4603      	mov	r3, r0
90000a70:	6039      	str	r1, [r7, #0]
90000a72:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = USB_SIZ_STRING_SERIAL;
90000a74:	683b      	ldr	r3, [r7, #0]
90000a76:	221a      	movs	r2, #26
90000a78:	801a      	strh	r2, [r3, #0]

  /* Update the serial number string descriptor with the data from the unique
   * ID */
  Get_SerialNum();
90000a7a:	f000 f82f 	bl	90000adc <Get_SerialNum>
  /* USER CODE BEGIN USBD_MSC_SerialStrDescriptor */

  /* USER CODE END USBD_MSC_SerialStrDescriptor */

  return (uint8_t *) USBD_StringSerial;
90000a7e:	4b02      	ldr	r3, [pc, #8]	@ (90000a88 <USBD_MSC_SerialStrDescriptor+0x20>)
}
90000a80:	4618      	mov	r0, r3
90000a82:	3708      	adds	r7, #8
90000a84:	46bd      	mov	sp, r7
90000a86:	bd80      	pop	{r7, pc}
90000a88:	24000038 	.word	0x24000038

90000a8c <USBD_MSC_ConfigStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_MSC_ConfigStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
90000a8c:	b580      	push	{r7, lr}
90000a8e:	b082      	sub	sp, #8
90000a90:	af00      	add	r7, sp, #0
90000a92:	4603      	mov	r3, r0
90000a94:	6039      	str	r1, [r7, #0]
90000a96:	71fb      	strb	r3, [r7, #7]
  USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING, USBD_StrDesc, length);
90000a98:	683a      	ldr	r2, [r7, #0]
90000a9a:	4904      	ldr	r1, [pc, #16]	@ (90000aac <USBD_MSC_ConfigStrDescriptor+0x20>)
90000a9c:	4804      	ldr	r0, [pc, #16]	@ (90000ab0 <USBD_MSC_ConfigStrDescriptor+0x24>)
90000a9e:	f00a fe49 	bl	9000b734 <USBD_GetString>
  return USBD_StrDesc;
90000aa2:	4b02      	ldr	r3, [pc, #8]	@ (90000aac <USBD_MSC_ConfigStrDescriptor+0x20>)
}
90000aa4:	4618      	mov	r0, r3
90000aa6:	3708      	adds	r7, #8
90000aa8:	46bd      	mov	sp, r7
90000aaa:	bd80      	pop	{r7, pc}
90000aac:	240004a8 	.word	0x240004a8
90000ab0:	9000dac0 	.word	0x9000dac0

90000ab4 <USBD_MSC_InterfaceStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_MSC_InterfaceStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
90000ab4:	b580      	push	{r7, lr}
90000ab6:	b082      	sub	sp, #8
90000ab8:	af00      	add	r7, sp, #0
90000aba:	4603      	mov	r3, r0
90000abc:	6039      	str	r1, [r7, #0]
90000abe:	71fb      	strb	r3, [r7, #7]
  USBD_GetString((uint8_t *)USBD_INTERFACE_STRING, USBD_StrDesc, length);
90000ac0:	683a      	ldr	r2, [r7, #0]
90000ac2:	4904      	ldr	r1, [pc, #16]	@ (90000ad4 <USBD_MSC_InterfaceStrDescriptor+0x20>)
90000ac4:	4804      	ldr	r0, [pc, #16]	@ (90000ad8 <USBD_MSC_InterfaceStrDescriptor+0x24>)
90000ac6:	f00a fe35 	bl	9000b734 <USBD_GetString>
  return USBD_StrDesc;
90000aca:	4b02      	ldr	r3, [pc, #8]	@ (90000ad4 <USBD_MSC_InterfaceStrDescriptor+0x20>)
}
90000acc:	4618      	mov	r0, r3
90000ace:	3708      	adds	r7, #8
90000ad0:	46bd      	mov	sp, r7
90000ad2:	bd80      	pop	{r7, pc}
90000ad4:	240004a8 	.word	0x240004a8
90000ad8:	9000dacc 	.word	0x9000dacc

90000adc <Get_SerialNum>:
  * @brief  Create the serial number string descriptor
  * @param  None
  * @retval None
  */
static void Get_SerialNum(void)
{
90000adc:	b580      	push	{r7, lr}
90000ade:	b084      	sub	sp, #16
90000ae0:	af00      	add	r7, sp, #0
  uint32_t deviceserial0;
  uint32_t deviceserial1;
  uint32_t deviceserial2;

  deviceserial0 = *(uint32_t *) DEVICE_ID1;
90000ae2:	4b0f      	ldr	r3, [pc, #60]	@ (90000b20 <Get_SerialNum+0x44>)
90000ae4:	681b      	ldr	r3, [r3, #0]
90000ae6:	60fb      	str	r3, [r7, #12]
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
90000ae8:	4b0e      	ldr	r3, [pc, #56]	@ (90000b24 <Get_SerialNum+0x48>)
90000aea:	681b      	ldr	r3, [r3, #0]
90000aec:	60bb      	str	r3, [r7, #8]
  deviceserial2 = *(uint32_t *) DEVICE_ID3;
90000aee:	4b0e      	ldr	r3, [pc, #56]	@ (90000b28 <Get_SerialNum+0x4c>)
90000af0:	681b      	ldr	r3, [r3, #0]
90000af2:	607b      	str	r3, [r7, #4]

  deviceserial0 += deviceserial2;
90000af4:	68fa      	ldr	r2, [r7, #12]
90000af6:	687b      	ldr	r3, [r7, #4]
90000af8:	4413      	add	r3, r2
90000afa:	60fb      	str	r3, [r7, #12]

  if (deviceserial0 != 0)
90000afc:	68fb      	ldr	r3, [r7, #12]
90000afe:	2b00      	cmp	r3, #0
90000b00:	d009      	beq.n	90000b16 <Get_SerialNum+0x3a>
  {
    IntToUnicode(deviceserial0, &USBD_StringSerial[2], 8);
90000b02:	2208      	movs	r2, #8
90000b04:	4909      	ldr	r1, [pc, #36]	@ (90000b2c <Get_SerialNum+0x50>)
90000b06:	68f8      	ldr	r0, [r7, #12]
90000b08:	f000 f814 	bl	90000b34 <IntToUnicode>
    IntToUnicode(deviceserial1, &USBD_StringSerial[18], 4);
90000b0c:	2204      	movs	r2, #4
90000b0e:	4908      	ldr	r1, [pc, #32]	@ (90000b30 <Get_SerialNum+0x54>)
90000b10:	68b8      	ldr	r0, [r7, #8]
90000b12:	f000 f80f 	bl	90000b34 <IntToUnicode>
  }
}
90000b16:	bf00      	nop
90000b18:	3710      	adds	r7, #16
90000b1a:	46bd      	mov	sp, r7
90000b1c:	bd80      	pop	{r7, pc}
90000b1e:	bf00      	nop
90000b20:	08fff800 	.word	0x08fff800
90000b24:	08fff804 	.word	0x08fff804
90000b28:	08fff808 	.word	0x08fff808
90000b2c:	2400003a 	.word	0x2400003a
90000b30:	2400004a 	.word	0x2400004a

90000b34 <IntToUnicode>:
  * @param  pbuf: pointer to the buffer
  * @param  len: buffer length
  * @retval None
  */
static void IntToUnicode(uint32_t value, uint8_t * pbuf, uint8_t len)
{
90000b34:	b480      	push	{r7}
90000b36:	b087      	sub	sp, #28
90000b38:	af00      	add	r7, sp, #0
90000b3a:	60f8      	str	r0, [r7, #12]
90000b3c:	60b9      	str	r1, [r7, #8]
90000b3e:	4613      	mov	r3, r2
90000b40:	71fb      	strb	r3, [r7, #7]
  uint8_t idx = 0;
90000b42:	2300      	movs	r3, #0
90000b44:	75fb      	strb	r3, [r7, #23]

  for (idx = 0; idx < len; idx++)
90000b46:	2300      	movs	r3, #0
90000b48:	75fb      	strb	r3, [r7, #23]
90000b4a:	e027      	b.n	90000b9c <IntToUnicode+0x68>
  {
    if (((value >> 28)) < 0xA)
90000b4c:	68fb      	ldr	r3, [r7, #12]
90000b4e:	0f1b      	lsrs	r3, r3, #28
90000b50:	2b09      	cmp	r3, #9
90000b52:	d80b      	bhi.n	90000b6c <IntToUnicode+0x38>
    {
      pbuf[2 * idx] = (value >> 28) + '0';
90000b54:	68fb      	ldr	r3, [r7, #12]
90000b56:	0f1b      	lsrs	r3, r3, #28
90000b58:	b2da      	uxtb	r2, r3
90000b5a:	7dfb      	ldrb	r3, [r7, #23]
90000b5c:	005b      	lsls	r3, r3, #1
90000b5e:	4619      	mov	r1, r3
90000b60:	68bb      	ldr	r3, [r7, #8]
90000b62:	440b      	add	r3, r1
90000b64:	3230      	adds	r2, #48	@ 0x30
90000b66:	b2d2      	uxtb	r2, r2
90000b68:	701a      	strb	r2, [r3, #0]
90000b6a:	e00a      	b.n	90000b82 <IntToUnicode+0x4e>
    }
    else
    {
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
90000b6c:	68fb      	ldr	r3, [r7, #12]
90000b6e:	0f1b      	lsrs	r3, r3, #28
90000b70:	b2da      	uxtb	r2, r3
90000b72:	7dfb      	ldrb	r3, [r7, #23]
90000b74:	005b      	lsls	r3, r3, #1
90000b76:	4619      	mov	r1, r3
90000b78:	68bb      	ldr	r3, [r7, #8]
90000b7a:	440b      	add	r3, r1
90000b7c:	3237      	adds	r2, #55	@ 0x37
90000b7e:	b2d2      	uxtb	r2, r2
90000b80:	701a      	strb	r2, [r3, #0]
    }

    value = value << 4;
90000b82:	68fb      	ldr	r3, [r7, #12]
90000b84:	011b      	lsls	r3, r3, #4
90000b86:	60fb      	str	r3, [r7, #12]

    pbuf[2 * idx + 1] = 0;
90000b88:	7dfb      	ldrb	r3, [r7, #23]
90000b8a:	005b      	lsls	r3, r3, #1
90000b8c:	3301      	adds	r3, #1
90000b8e:	68ba      	ldr	r2, [r7, #8]
90000b90:	4413      	add	r3, r2
90000b92:	2200      	movs	r2, #0
90000b94:	701a      	strb	r2, [r3, #0]
  for (idx = 0; idx < len; idx++)
90000b96:	7dfb      	ldrb	r3, [r7, #23]
90000b98:	3301      	adds	r3, #1
90000b9a:	75fb      	strb	r3, [r7, #23]
90000b9c:	7dfa      	ldrb	r2, [r7, #23]
90000b9e:	79fb      	ldrb	r3, [r7, #7]
90000ba0:	429a      	cmp	r2, r3
90000ba2:	d3d3      	bcc.n	90000b4c <IntToUnicode+0x18>
  }
}
90000ba4:	bf00      	nop
90000ba6:	bf00      	nop
90000ba8:	371c      	adds	r7, #28
90000baa:	46bd      	mov	sp, r7
90000bac:	f85d 7b04 	ldr.w	r7, [sp], #4
90000bb0:	4770      	bx	lr

90000bb2 <STORAGE_Init_HS>:
  * @brief  Initializes the storage unit (medium).
  * @param  lun: Logical unit number.
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
int8_t STORAGE_Init_HS(uint8_t lun)
{
90000bb2:	b480      	push	{r7}
90000bb4:	b083      	sub	sp, #12
90000bb6:	af00      	add	r7, sp, #0
90000bb8:	4603      	mov	r3, r0
90000bba:	71fb      	strb	r3, [r7, #7]
  /* USER CODE BEGIN 9 */
  UNUSED(lun);

  return (USBD_OK);
90000bbc:	2300      	movs	r3, #0
  /* USER CODE END 9 */
}
90000bbe:	4618      	mov	r0, r3
90000bc0:	370c      	adds	r7, #12
90000bc2:	46bd      	mov	sp, r7
90000bc4:	f85d 7b04 	ldr.w	r7, [sp], #4
90000bc8:	4770      	bx	lr
	...

90000bcc <STORAGE_GetCapacity_HS>:
  * @param  block_num: Number of total block number.
  * @param  block_size: Block size.
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
int8_t STORAGE_GetCapacity_HS(uint8_t lun, uint32_t *block_num, uint16_t *block_size)
{
90000bcc:	b580      	push	{r7, lr}
90000bce:	b08e      	sub	sp, #56	@ 0x38
90000bd0:	af00      	add	r7, sp, #0
90000bd2:	4603      	mov	r3, r0
90000bd4:	60b9      	str	r1, [r7, #8]
90000bd6:	607a      	str	r2, [r7, #4]
90000bd8:	73fb      	strb	r3, [r7, #15]
  /* USER CODE BEGIN 10 */
  UNUSED(lun);

  HAL_SD_CardInfoTypeDef CardInfo;
	HAL_SD_GetCardInfo(&hsd1, &CardInfo);
90000bda:	f107 0314 	add.w	r3, r7, #20
90000bde:	4619      	mov	r1, r3
90000be0:	4807      	ldr	r0, [pc, #28]	@ (90000c00 <STORAGE_GetCapacity_HS+0x34>)
90000be2:	f006 fc8d 	bl	90007500 <HAL_SD_GetCardInfo>
	*block_num = CardInfo.LogBlockNbr - 1;
90000be6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
90000be8:	1e5a      	subs	r2, r3, #1
90000bea:	68bb      	ldr	r3, [r7, #8]
90000bec:	601a      	str	r2, [r3, #0]
  *block_size = CardInfo.LogBlockSize;
90000bee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
90000bf0:	b29a      	uxth	r2, r3
90000bf2:	687b      	ldr	r3, [r7, #4]
90000bf4:	801a      	strh	r2, [r3, #0]
  return (USBD_OK);
90000bf6:	2300      	movs	r3, #0
  /* USER CODE END 10 */
}
90000bf8:	4618      	mov	r0, r3
90000bfa:	3738      	adds	r7, #56	@ 0x38
90000bfc:	46bd      	mov	sp, r7
90000bfe:	bd80      	pop	{r7, pc}
90000c00:	24000150 	.word	0x24000150

90000c04 <STORAGE_IsReady_HS>:
  * @brief   Checks whether the medium is ready.
  * @param  lun:  Logical unit number.
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
int8_t STORAGE_IsReady_HS(uint8_t lun)
{
90000c04:	b480      	push	{r7}
90000c06:	b083      	sub	sp, #12
90000c08:	af00      	add	r7, sp, #0
90000c0a:	4603      	mov	r3, r0
90000c0c:	71fb      	strb	r3, [r7, #7]
  /* USER CODE BEGIN 11 */
  UNUSED(lun);

  return (USBD_OK);
90000c0e:	2300      	movs	r3, #0
  /* USER CODE END 11 */
}
90000c10:	4618      	mov	r0, r3
90000c12:	370c      	adds	r7, #12
90000c14:	46bd      	mov	sp, r7
90000c16:	f85d 7b04 	ldr.w	r7, [sp], #4
90000c1a:	4770      	bx	lr

90000c1c <STORAGE_IsWriteProtected_HS>:
  * @brief  Checks whether the medium is write protected.
  * @param  lun: Logical unit number.
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
int8_t STORAGE_IsWriteProtected_HS(uint8_t lun)
{
90000c1c:	b480      	push	{r7}
90000c1e:	b083      	sub	sp, #12
90000c20:	af00      	add	r7, sp, #0
90000c22:	4603      	mov	r3, r0
90000c24:	71fb      	strb	r3, [r7, #7]
  /* USER CODE BEGIN 12 */
  return (USBD_OK);
90000c26:	2300      	movs	r3, #0
  /* USER CODE END 12 */
}
90000c28:	4618      	mov	r0, r3
90000c2a:	370c      	adds	r7, #12
90000c2c:	46bd      	mov	sp, r7
90000c2e:	f85d 7b04 	ldr.w	r7, [sp], #4
90000c32:	4770      	bx	lr

90000c34 <STORAGE_Read_HS>:
  * @param  blk_addr: Logical block address.
  * @param  blk_len: Blocks number.
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
int8_t STORAGE_Read_HS(uint8_t lun, uint8_t *buf, uint32_t blk_addr, uint16_t blk_len)
{
90000c34:	b580      	push	{r7, lr}
90000c36:	b086      	sub	sp, #24
90000c38:	af02      	add	r7, sp, #8
90000c3a:	60b9      	str	r1, [r7, #8]
90000c3c:	607a      	str	r2, [r7, #4]
90000c3e:	461a      	mov	r2, r3
90000c40:	4603      	mov	r3, r0
90000c42:	73fb      	strb	r3, [r7, #15]
90000c44:	4613      	mov	r3, r2
90000c46:	81bb      	strh	r3, [r7, #12]
  /* USER CODE BEGIN 13 */
  UNUSED(lun);
  if(HAL_SD_ReadBlocks(&hsd1, buf, blk_addr, blk_len, 10000) != HAL_OK)
90000c48:	89bb      	ldrh	r3, [r7, #12]
90000c4a:	f242 7210 	movw	r2, #10000	@ 0x2710
90000c4e:	9200      	str	r2, [sp, #0]
90000c50:	687a      	ldr	r2, [r7, #4]
90000c52:	68b9      	ldr	r1, [r7, #8]
90000c54:	4809      	ldr	r0, [pc, #36]	@ (90000c7c <STORAGE_Read_HS+0x48>)
90000c56:	f005 fed9 	bl	90006a0c <HAL_SD_ReadBlocks>
90000c5a:	4603      	mov	r3, r0
90000c5c:	2b00      	cmp	r3, #0
90000c5e:	d001      	beq.n	90000c64 <STORAGE_Read_HS+0x30>
	{
		return USBD_FAIL;
90000c60:	2303      	movs	r3, #3
90000c62:	e007      	b.n	90000c74 <STORAGE_Read_HS+0x40>
	}
  
	while (HAL_SD_GetCardState(&hsd1) != HAL_SD_CARD_TRANSFER)
90000c64:	bf00      	nop
90000c66:	4805      	ldr	r0, [pc, #20]	@ (90000c7c <STORAGE_Read_HS+0x48>)
90000c68:	f006 fd86 	bl	90007778 <HAL_SD_GetCardState>
90000c6c:	4603      	mov	r3, r0
90000c6e:	2b04      	cmp	r3, #4
90000c70:	d1f9      	bne.n	90000c66 <STORAGE_Read_HS+0x32>
	{
	}

  return (USBD_OK);
90000c72:	2300      	movs	r3, #0
  /* USER CODE END 13 */
}
90000c74:	4618      	mov	r0, r3
90000c76:	3710      	adds	r7, #16
90000c78:	46bd      	mov	sp, r7
90000c7a:	bd80      	pop	{r7, pc}
90000c7c:	24000150 	.word	0x24000150

90000c80 <STORAGE_Write_HS>:
  * @param  blk_addr: Logical block address.
  * @param  blk_len: Blocks number.
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
int8_t STORAGE_Write_HS(uint8_t lun, uint8_t *buf, uint32_t blk_addr, uint16_t blk_len)
{
90000c80:	b580      	push	{r7, lr}
90000c82:	b086      	sub	sp, #24
90000c84:	af02      	add	r7, sp, #8
90000c86:	60b9      	str	r1, [r7, #8]
90000c88:	607a      	str	r2, [r7, #4]
90000c8a:	461a      	mov	r2, r3
90000c8c:	4603      	mov	r3, r0
90000c8e:	73fb      	strb	r3, [r7, #15]
90000c90:	4613      	mov	r3, r2
90000c92:	81bb      	strh	r3, [r7, #12]
  /* USER CODE BEGIN 14 */
  UNUSED(lun);
  if(HAL_SD_WriteBlocks(&hsd1, buf, blk_addr, blk_len, 10000) != HAL_OK)
90000c94:	89bb      	ldrh	r3, [r7, #12]
90000c96:	f242 7210 	movw	r2, #10000	@ 0x2710
90000c9a:	9200      	str	r2, [sp, #0]
90000c9c:	687a      	ldr	r2, [r7, #4]
90000c9e:	68b9      	ldr	r1, [r7, #8]
90000ca0:	4809      	ldr	r0, [pc, #36]	@ (90000cc8 <STORAGE_Write_HS+0x48>)
90000ca2:	f006 f83d 	bl	90006d20 <HAL_SD_WriteBlocks>
90000ca6:	4603      	mov	r3, r0
90000ca8:	2b00      	cmp	r3, #0
90000caa:	d001      	beq.n	90000cb0 <STORAGE_Write_HS+0x30>
	{
		return USBD_FAIL;
90000cac:	2303      	movs	r3, #3
90000cae:	e007      	b.n	90000cc0 <STORAGE_Write_HS+0x40>
	}
  
	while (HAL_SD_GetCardState(&hsd1) != HAL_SD_CARD_TRANSFER)
90000cb0:	bf00      	nop
90000cb2:	4805      	ldr	r0, [pc, #20]	@ (90000cc8 <STORAGE_Write_HS+0x48>)
90000cb4:	f006 fd60 	bl	90007778 <HAL_SD_GetCardState>
90000cb8:	4603      	mov	r3, r0
90000cba:	2b04      	cmp	r3, #4
90000cbc:	d1f9      	bne.n	90000cb2 <STORAGE_Write_HS+0x32>
	{
	}

  return (USBD_OK);
90000cbe:	2300      	movs	r3, #0
  /* USER CODE END 14 */
}
90000cc0:	4618      	mov	r0, r3
90000cc2:	3710      	adds	r7, #16
90000cc4:	46bd      	mov	sp, r7
90000cc6:	bd80      	pop	{r7, pc}
90000cc8:	24000150 	.word	0x24000150

90000ccc <STORAGE_GetMaxLun_HS>:
  * @brief  Returns the Max Supported LUNs.
  * @param  None
  * @retval Lun(s) number.
  */
int8_t STORAGE_GetMaxLun_HS(void)
{
90000ccc:	b480      	push	{r7}
90000cce:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 15 */
  return (STORAGE_LUN_NBR - 1);
90000cd0:	2300      	movs	r3, #0
  /* USER CODE END 15 */
}
90000cd2:	4618      	mov	r0, r3
90000cd4:	46bd      	mov	sp, r7
90000cd6:	f85d 7b04 	ldr.w	r7, [sp], #4
90000cda:	4770      	bx	lr

90000cdc <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
90000cdc:	b580      	push	{r7, lr}
90000cde:	b0a6      	sub	sp, #152	@ 0x98
90000ce0:	af00      	add	r7, sp, #0
90000ce2:	6078      	str	r0, [r7, #4]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
90000ce4:	f107 0314 	add.w	r3, r7, #20
90000ce8:	2284      	movs	r2, #132	@ 0x84
90000cea:	2100      	movs	r1, #0
90000cec:	4618      	mov	r0, r3
90000cee:	f00c fe9a 	bl	9000da26 <memset>
  if(pcdHandle->Instance==USB_OTG_HS)
90000cf2:	687b      	ldr	r3, [r7, #4]
90000cf4:	681b      	ldr	r3, [r3, #0]
90000cf6:	4a1d      	ldr	r2, [pc, #116]	@ (90000d6c <HAL_PCD_MspInit+0x90>)
90000cf8:	4293      	cmp	r3, r2
90000cfa:	d133      	bne.n	90000d64 <HAL_PCD_MspInit+0x88>

  /* USER CODE END USB_OTG_HS_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USBPHYC;
90000cfc:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
90000d00:	617b      	str	r3, [r7, #20]
    PeriphClkInit.UsbPhycClockSelection = RCC_USBPHYCCLKSOURCE_HSE;
90000d02:	2300      	movs	r3, #0
90000d04:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
90000d08:	f107 0314 	add.w	r3, r7, #20
90000d0c:	4618      	mov	r0, r3
90000d0e:	f002 ff5d 	bl	90003bcc <HAL_RCCEx_PeriphCLKConfig>
90000d12:	4603      	mov	r3, r0
90000d14:	2b00      	cmp	r3, #0
90000d16:	d001      	beq.n	90000d1c <HAL_PCD_MspInit+0x40>
    {
      Error_Handler();
90000d18:	f7ff fc3c 	bl	90000594 <Error_Handler>
    }

  /** Enable USB Voltage detector
  */
    HAL_PWREx_EnableUSBVoltageDetector();
90000d1c:	f002 fad0 	bl	900032c0 <HAL_PWREx_EnableUSBVoltageDetector>

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_HS_CLK_ENABLE();
90000d20:	4b13      	ldr	r3, [pc, #76]	@ (90000d70 <HAL_PCD_MspInit+0x94>)
90000d22:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
90000d26:	4a12      	ldr	r2, [pc, #72]	@ (90000d70 <HAL_PCD_MspInit+0x94>)
90000d28:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
90000d2c:	f8c2 3138 	str.w	r3, [r2, #312]	@ 0x138
90000d30:	4b0f      	ldr	r3, [pc, #60]	@ (90000d70 <HAL_PCD_MspInit+0x94>)
90000d32:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
90000d36:	613b      	str	r3, [r7, #16]
90000d38:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_USBPHYC_CLK_ENABLE();
90000d3a:	4b0d      	ldr	r3, [pc, #52]	@ (90000d70 <HAL_PCD_MspInit+0x94>)
90000d3c:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
90000d40:	4a0b      	ldr	r2, [pc, #44]	@ (90000d70 <HAL_PCD_MspInit+0x94>)
90000d42:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
90000d46:	f8c2 3138 	str.w	r3, [r2, #312]	@ 0x138
90000d4a:	4b09      	ldr	r3, [pc, #36]	@ (90000d70 <HAL_PCD_MspInit+0x94>)
90000d4c:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
90000d50:	60fb      	str	r3, [r7, #12]
90000d52:	68fb      	ldr	r3, [r7, #12]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_HS_IRQn, 6, 0);
90000d54:	2200      	movs	r2, #0
90000d56:	2106      	movs	r1, #6
90000d58:	205b      	movs	r0, #91	@ 0x5b
90000d5a:	f000 fdde 	bl	9000191a <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_HS_IRQn);
90000d5e:	205b      	movs	r0, #91	@ 0x5b
90000d60:	f000 fdf5 	bl	9000194e <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_HS_MspInit 1 */

  /* USER CODE END USB_OTG_HS_MspInit 1 */
  }
}
90000d64:	bf00      	nop
90000d66:	3798      	adds	r7, #152	@ 0x98
90000d68:	46bd      	mov	sp, r7
90000d6a:	bd80      	pop	{r7, pc}
90000d6c:	40040000 	.word	0x40040000
90000d70:	58024400 	.word	0x58024400

90000d74 <HAL_PCD_SetupStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
90000d74:	b580      	push	{r7, lr}
90000d76:	b082      	sub	sp, #8
90000d78:	af00      	add	r7, sp, #0
90000d7a:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN HAL_PCD_SetupStageCallback_PreTreatment */

  /* USER CODE END HAL_PCD_SetupStageCallback_PreTreatment */
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
90000d7c:	687b      	ldr	r3, [r7, #4]
90000d7e:	f8d3 24e0 	ldr.w	r2, [r3, #1248]	@ 0x4e0
90000d82:	687b      	ldr	r3, [r7, #4]
90000d84:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
90000d88:	4619      	mov	r1, r3
90000d8a:	4610      	mov	r0, r2
90000d8c:	f009 fb2f 	bl	9000a3ee <USBD_LL_SetupStage>
  /* USER CODE BEGIN HAL_PCD_SetupStageCallback_PostTreatment */

  /* USER CODE END HAL_PCD_SetupStageCallback_PostTreatment */

}
90000d90:	bf00      	nop
90000d92:	3708      	adds	r7, #8
90000d94:	46bd      	mov	sp, r7
90000d96:	bd80      	pop	{r7, pc}

90000d98 <HAL_PCD_DataOutStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
90000d98:	b580      	push	{r7, lr}
90000d9a:	b082      	sub	sp, #8
90000d9c:	af00      	add	r7, sp, #0
90000d9e:	6078      	str	r0, [r7, #4]
90000da0:	460b      	mov	r3, r1
90000da2:	70fb      	strb	r3, [r7, #3]
  /* USER CODE BEGIN HAL_PCD_DataOutStageCallback_PreTreatment */

  /* USER CODE END HAL_PCD_DataOutStageCallback_PreTreatment */
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
90000da4:	687b      	ldr	r3, [r7, #4]
90000da6:	f8d3 04e0 	ldr.w	r0, [r3, #1248]	@ 0x4e0
90000daa:	78fa      	ldrb	r2, [r7, #3]
90000dac:	6879      	ldr	r1, [r7, #4]
90000dae:	4613      	mov	r3, r2
90000db0:	00db      	lsls	r3, r3, #3
90000db2:	4413      	add	r3, r2
90000db4:	009b      	lsls	r3, r3, #2
90000db6:	440b      	add	r3, r1
90000db8:	f503 7318 	add.w	r3, r3, #608	@ 0x260
90000dbc:	681a      	ldr	r2, [r3, #0]
90000dbe:	78fb      	ldrb	r3, [r7, #3]
90000dc0:	4619      	mov	r1, r3
90000dc2:	f009 fb69 	bl	9000a498 <USBD_LL_DataOutStage>
  /* USER CODE BEGIN HAL_PCD_DataOutStageCallback_PostTreatment */

  /* USER CODE END HAL_PCD_DataOutStageCallback_PostTreatment */
}
90000dc6:	bf00      	nop
90000dc8:	3708      	adds	r7, #8
90000dca:	46bd      	mov	sp, r7
90000dcc:	bd80      	pop	{r7, pc}

90000dce <HAL_PCD_DataInStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
90000dce:	b580      	push	{r7, lr}
90000dd0:	b082      	sub	sp, #8
90000dd2:	af00      	add	r7, sp, #0
90000dd4:	6078      	str	r0, [r7, #4]
90000dd6:	460b      	mov	r3, r1
90000dd8:	70fb      	strb	r3, [r7, #3]
  /* USER CODE BEGIN HAL_PCD_DataInStageCallback_PreTreatment */

  /* USER CODE END HAL_PCD_DataInStageCallback_PreTreatment */
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
90000dda:	687b      	ldr	r3, [r7, #4]
90000ddc:	f8d3 04e0 	ldr.w	r0, [r3, #1248]	@ 0x4e0
90000de0:	78fa      	ldrb	r2, [r7, #3]
90000de2:	6879      	ldr	r1, [r7, #4]
90000de4:	4613      	mov	r3, r2
90000de6:	00db      	lsls	r3, r3, #3
90000de8:	4413      	add	r3, r2
90000dea:	009b      	lsls	r3, r3, #2
90000dec:	440b      	add	r3, r1
90000dee:	3320      	adds	r3, #32
90000df0:	681a      	ldr	r2, [r3, #0]
90000df2:	78fb      	ldrb	r3, [r7, #3]
90000df4:	4619      	mov	r1, r3
90000df6:	f009 fc0b 	bl	9000a610 <USBD_LL_DataInStage>
  /* USER CODE BEGIN HAL_PCD_DataInStageCallback_PostTreatment */

  /* USER CODE END HAL_PCD_DataInStageCallback_PostTreatment */
}
90000dfa:	bf00      	nop
90000dfc:	3708      	adds	r7, #8
90000dfe:	46bd      	mov	sp, r7
90000e00:	bd80      	pop	{r7, pc}

90000e02 <HAL_PCD_SOFCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
90000e02:	b580      	push	{r7, lr}
90000e04:	b082      	sub	sp, #8
90000e06:	af00      	add	r7, sp, #0
90000e08:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN HAL_PCD_SofCallback_PreTreatment */

  /* USER CODE END HAL_PCD_SofCallback_PreTreatment */
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
90000e0a:	687b      	ldr	r3, [r7, #4]
90000e0c:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
90000e10:	4618      	mov	r0, r3
90000e12:	f009 fd4f 	bl	9000a8b4 <USBD_LL_SOF>
  /* USER CODE BEGIN HAL_PCD_SofCallback_PostTreatment */

  /* USER CODE END HAL_PCD_SofCallback_PostTreatment */
}
90000e16:	bf00      	nop
90000e18:	3708      	adds	r7, #8
90000e1a:	46bd      	mov	sp, r7
90000e1c:	bd80      	pop	{r7, pc}

90000e1e <HAL_PCD_ResetCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
90000e1e:	b580      	push	{r7, lr}
90000e20:	b084      	sub	sp, #16
90000e22:	af00      	add	r7, sp, #0
90000e24:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN HAL_PCD_ResetCallback_PreTreatment */

  /* USER CODE END HAL_PCD_ResetCallback_PreTreatment */
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;
90000e26:	2301      	movs	r3, #1
90000e28:	73fb      	strb	r3, [r7, #15]

  if (hpcd->Init.speed == PCD_SPEED_HIGH)
90000e2a:	687b      	ldr	r3, [r7, #4]
90000e2c:	79db      	ldrb	r3, [r3, #7]
90000e2e:	2b00      	cmp	r3, #0
90000e30:	d102      	bne.n	90000e38 <HAL_PCD_ResetCallback+0x1a>
  {
    speed = USBD_SPEED_HIGH;
90000e32:	2300      	movs	r3, #0
90000e34:	73fb      	strb	r3, [r7, #15]
90000e36:	e008      	b.n	90000e4a <HAL_PCD_ResetCallback+0x2c>
  }
  else if (hpcd->Init.speed == PCD_SPEED_FULL)
90000e38:	687b      	ldr	r3, [r7, #4]
90000e3a:	79db      	ldrb	r3, [r3, #7]
90000e3c:	2b02      	cmp	r3, #2
90000e3e:	d102      	bne.n	90000e46 <HAL_PCD_ResetCallback+0x28>
  {
    speed = USBD_SPEED_FULL;
90000e40:	2301      	movs	r3, #1
90000e42:	73fb      	strb	r3, [r7, #15]
90000e44:	e001      	b.n	90000e4a <HAL_PCD_ResetCallback+0x2c>
  }
  else
  {
    Error_Handler();
90000e46:	f7ff fba5 	bl	90000594 <Error_Handler>
  }
    /* Set Speed. */
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
90000e4a:	687b      	ldr	r3, [r7, #4]
90000e4c:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
90000e50:	7bfa      	ldrb	r2, [r7, #15]
90000e52:	4611      	mov	r1, r2
90000e54:	4618      	mov	r0, r3
90000e56:	f009 fce9 	bl	9000a82c <USBD_LL_SetSpeed>

  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
90000e5a:	687b      	ldr	r3, [r7, #4]
90000e5c:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
90000e60:	4618      	mov	r0, r3
90000e62:	f009 fc90 	bl	9000a786 <USBD_LL_Reset>
  /* USER CODE BEGIN HAL_PCD_ResetCallback_PostTreatment */

  /* USER CODE END HAL_PCD_ResetCallback_PostTreatment */
}
90000e66:	bf00      	nop
90000e68:	3710      	adds	r7, #16
90000e6a:	46bd      	mov	sp, r7
90000e6c:	bd80      	pop	{r7, pc}
	...

90000e70 <HAL_PCD_SuspendCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
90000e70:	b580      	push	{r7, lr}
90000e72:	b082      	sub	sp, #8
90000e74:	af00      	add	r7, sp, #0
90000e76:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN HAL_PCD_SuspendCallback_PreTreatment */

  /* USER CODE END HAL_PCD_SuspendCallback_PreTreatment */

  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
90000e78:	687b      	ldr	r3, [r7, #4]
90000e7a:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
90000e7e:	4618      	mov	r0, r3
90000e80:	f009 fce4 	bl	9000a84c <USBD_LL_Suspend>
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
90000e84:	687b      	ldr	r3, [r7, #4]
90000e86:	7adb      	ldrb	r3, [r3, #11]
90000e88:	2b00      	cmp	r3, #0
90000e8a:	d007      	beq.n	90000e9c <HAL_PCD_SuspendCallback+0x2c>
  {
	HAL_SuspendTick();
90000e8c:	f000 fc4a 	bl	90001724 <HAL_SuspendTick>
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
90000e90:	4b04      	ldr	r3, [pc, #16]	@ (90000ea4 <HAL_PCD_SuspendCallback+0x34>)
90000e92:	691b      	ldr	r3, [r3, #16]
90000e94:	4a03      	ldr	r2, [pc, #12]	@ (90000ea4 <HAL_PCD_SuspendCallback+0x34>)
90000e96:	f043 0306 	orr.w	r3, r3, #6
90000e9a:	6113      	str	r3, [r2, #16]
  }
  /* USER CODE END 2 */
  /* USER CODE BEGIN HAL_PCD_SuspendCallback_PostTreatment */

  /* USER CODE END HAL_PCD_SuspendCallback_PostTreatment */
}
90000e9c:	bf00      	nop
90000e9e:	3708      	adds	r7, #8
90000ea0:	46bd      	mov	sp, r7
90000ea2:	bd80      	pop	{r7, pc}
90000ea4:	e000ed00 	.word	0xe000ed00

90000ea8 <HAL_PCD_ResumeCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
90000ea8:	b580      	push	{r7, lr}
90000eaa:	b082      	sub	sp, #8
90000eac:	af00      	add	r7, sp, #0
90000eae:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN HAL_PCD_ResumeCallback_PreTreatment */

  /* USER CODE END HAL_PCD_ResumeCallback_PreTreatment */

  /* USER CODE BEGIN 3 */
  if (hpcd->Init.low_power_enable)
90000eb0:	687b      	ldr	r3, [r7, #4]
90000eb2:	7adb      	ldrb	r3, [r3, #11]
90000eb4:	2b00      	cmp	r3, #0
90000eb6:	d007      	beq.n	90000ec8 <HAL_PCD_ResumeCallback+0x20>
  {
    HAL_ResumeTick();
90000eb8:	f000 fc44 	bl	90001744 <HAL_ResumeTick>
    /* Reset SLEEPDEEP bit of Cortex System Control Register. */
    SCB->SCR &= (uint32_t)~((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
90000ebc:	4b0d      	ldr	r3, [pc, #52]	@ (90000ef4 <HAL_PCD_ResumeCallback+0x4c>)
90000ebe:	691b      	ldr	r3, [r3, #16]
90000ec0:	4a0c      	ldr	r2, [pc, #48]	@ (90000ef4 <HAL_PCD_ResumeCallback+0x4c>)
90000ec2:	f023 0306 	bic.w	r3, r3, #6
90000ec6:	6113      	str	r3, [r2, #16]

  }
  /* USER CODE END 3 */
  __HAL_PCD_UNGATE_PHYCLOCK(hpcd);
90000ec8:	687b      	ldr	r3, [r7, #4]
90000eca:	681b      	ldr	r3, [r3, #0]
90000ecc:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
90000ed0:	681b      	ldr	r3, [r3, #0]
90000ed2:	687a      	ldr	r2, [r7, #4]
90000ed4:	6812      	ldr	r2, [r2, #0]
90000ed6:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
90000eda:	f023 0301 	bic.w	r3, r3, #1
90000ede:	6013      	str	r3, [r2, #0]
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
90000ee0:	687b      	ldr	r3, [r7, #4]
90000ee2:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
90000ee6:	4618      	mov	r0, r3
90000ee8:	f009 fccc 	bl	9000a884 <USBD_LL_Resume>

  /* USER CODE BEGIN HAL_PCD_ResumeCallback_PostTreatment */

  /* USER CODE END HAL_PCD_ResumeCallback_PostTreatment */
}
90000eec:	bf00      	nop
90000eee:	3708      	adds	r7, #8
90000ef0:	46bd      	mov	sp, r7
90000ef2:	bd80      	pop	{r7, pc}
90000ef4:	e000ed00 	.word	0xe000ed00

90000ef8 <HAL_PCD_ISOOUTIncompleteCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
90000ef8:	b580      	push	{r7, lr}
90000efa:	b082      	sub	sp, #8
90000efc:	af00      	add	r7, sp, #0
90000efe:	6078      	str	r0, [r7, #4]
90000f00:	460b      	mov	r3, r1
90000f02:	70fb      	strb	r3, [r7, #3]
  /* USER CODE BEGIN HAL_PCD_ISOOUTIncompleteCallback_PreTreatment */

  /* USER CODE END HAL_PCD_ISOOUTIncompleteCallback_PreTreatment */
  USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
90000f04:	687b      	ldr	r3, [r7, #4]
90000f06:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
90000f0a:	78fa      	ldrb	r2, [r7, #3]
90000f0c:	4611      	mov	r1, r2
90000f0e:	4618      	mov	r0, r3
90000f10:	f009 fd22 	bl	9000a958 <USBD_LL_IsoOUTIncomplete>
  /* USER CODE BEGIN HAL_PCD_ISOOUTIncompleteCallback_PostTreatment */

  /* USER CODE END HAL_PCD_ISOOUTIncompleteCallback_PostTreatment */

}
90000f14:	bf00      	nop
90000f16:	3708      	adds	r7, #8
90000f18:	46bd      	mov	sp, r7
90000f1a:	bd80      	pop	{r7, pc}

90000f1c <HAL_PCD_ISOINIncompleteCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
90000f1c:	b580      	push	{r7, lr}
90000f1e:	b082      	sub	sp, #8
90000f20:	af00      	add	r7, sp, #0
90000f22:	6078      	str	r0, [r7, #4]
90000f24:	460b      	mov	r3, r1
90000f26:	70fb      	strb	r3, [r7, #3]
  /* USER CODE BEGIN HAL_PCD_ISOINIncompleteCallback_PreTreatment */

  /* USER CODE END HAL_PCD_ISOINIncompleteCallback_PreTreatment */
  USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
90000f28:	687b      	ldr	r3, [r7, #4]
90000f2a:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
90000f2e:	78fa      	ldrb	r2, [r7, #3]
90000f30:	4611      	mov	r1, r2
90000f32:	4618      	mov	r0, r3
90000f34:	f009 fcde 	bl	9000a8f4 <USBD_LL_IsoINIncomplete>

  /* USER CODE BEGIN HAL_PCD_ISOINIncompleteCallback_PostTreatment */

  /* USER CODE END HAL_PCD_ISOINIncompleteCallback_PostTreatment */
}
90000f38:	bf00      	nop
90000f3a:	3708      	adds	r7, #8
90000f3c:	46bd      	mov	sp, r7
90000f3e:	bd80      	pop	{r7, pc}

90000f40 <HAL_PCD_ConnectCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
90000f40:	b580      	push	{r7, lr}
90000f42:	b082      	sub	sp, #8
90000f44:	af00      	add	r7, sp, #0
90000f46:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN HAL_PCD_ConnectCallback_PreTreatment */

  /* USER CODE END HAL_PCD_ConnectCallback_PreTreatment */
  USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
90000f48:	687b      	ldr	r3, [r7, #4]
90000f4a:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
90000f4e:	4618      	mov	r0, r3
90000f50:	f009 fd34 	bl	9000a9bc <USBD_LL_DevConnected>
  /* USER CODE BEGIN HAL_PCD_ConnectCallback_PostTreatment */

  /* USER CODE END HAL_PCD_ConnectCallback_PostTreatment */
}
90000f54:	bf00      	nop
90000f56:	3708      	adds	r7, #8
90000f58:	46bd      	mov	sp, r7
90000f5a:	bd80      	pop	{r7, pc}

90000f5c <HAL_PCD_DisconnectCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
90000f5c:	b580      	push	{r7, lr}
90000f5e:	b082      	sub	sp, #8
90000f60:	af00      	add	r7, sp, #0
90000f62:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN HAL_PCD_DisconnectCallback_PreTreatment */

  /* USER CODE END HAL_PCD_DisconnectCallback_PreTreatment */
  USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
90000f64:	687b      	ldr	r3, [r7, #4]
90000f66:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
90000f6a:	4618      	mov	r0, r3
90000f6c:	f009 fd31 	bl	9000a9d2 <USBD_LL_DevDisconnected>
  /* USER CODE BEGIN HAL_PCD_DisconnectCallback_PostTreatment */

  /* USER CODE END HAL_PCD_DisconnectCallback_PostTreatment */
}
90000f70:	bf00      	nop
90000f72:	3708      	adds	r7, #8
90000f74:	46bd      	mov	sp, r7
90000f76:	bd80      	pop	{r7, pc}

90000f78 <USBD_LL_Init>:
  * @brief  Initializes the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
90000f78:	b580      	push	{r7, lr}
90000f7a:	b082      	sub	sp, #8
90000f7c:	af00      	add	r7, sp, #0
90000f7e:	6078      	str	r0, [r7, #4]
  /* Init USB Ip. */
  if (pdev->id == DEVICE_HS) {
90000f80:	687b      	ldr	r3, [r7, #4]
90000f82:	781b      	ldrb	r3, [r3, #0]
90000f84:	2b01      	cmp	r3, #1
90000f86:	d13c      	bne.n	90001002 <USBD_LL_Init+0x8a>
  /* Link the driver to the stack. */
  hpcd_USB_OTG_HS.pData = pdev;
90000f88:	4a20      	ldr	r2, [pc, #128]	@ (9000100c <USBD_LL_Init+0x94>)
90000f8a:	687b      	ldr	r3, [r7, #4]
90000f8c:	f8c2 34e0 	str.w	r3, [r2, #1248]	@ 0x4e0
  pdev->pData = &hpcd_USB_OTG_HS;
90000f90:	687b      	ldr	r3, [r7, #4]
90000f92:	4a1e      	ldr	r2, [pc, #120]	@ (9000100c <USBD_LL_Init+0x94>)
90000f94:	f8c3 22c8 	str.w	r2, [r3, #712]	@ 0x2c8

  hpcd_USB_OTG_HS.Instance = USB_OTG_HS;
90000f98:	4b1c      	ldr	r3, [pc, #112]	@ (9000100c <USBD_LL_Init+0x94>)
90000f9a:	4a1d      	ldr	r2, [pc, #116]	@ (90001010 <USBD_LL_Init+0x98>)
90000f9c:	601a      	str	r2, [r3, #0]
  hpcd_USB_OTG_HS.Init.dev_endpoints = 9;
90000f9e:	4b1b      	ldr	r3, [pc, #108]	@ (9000100c <USBD_LL_Init+0x94>)
90000fa0:	2209      	movs	r2, #9
90000fa2:	711a      	strb	r2, [r3, #4]
  hpcd_USB_OTG_HS.Init.speed = PCD_SPEED_HIGH;
90000fa4:	4b19      	ldr	r3, [pc, #100]	@ (9000100c <USBD_LL_Init+0x94>)
90000fa6:	2200      	movs	r2, #0
90000fa8:	71da      	strb	r2, [r3, #7]
  hpcd_USB_OTG_HS.Init.phy_itface = USB_OTG_HS_EMBEDDED_PHY;
90000faa:	4b18      	ldr	r3, [pc, #96]	@ (9000100c <USBD_LL_Init+0x94>)
90000fac:	2203      	movs	r2, #3
90000fae:	725a      	strb	r2, [r3, #9]
  hpcd_USB_OTG_HS.Init.dma_enable = DISABLE;
90000fb0:	4b16      	ldr	r3, [pc, #88]	@ (9000100c <USBD_LL_Init+0x94>)
90000fb2:	2200      	movs	r2, #0
90000fb4:	719a      	strb	r2, [r3, #6]
  hpcd_USB_OTG_HS.Init.Sof_enable = DISABLE;
90000fb6:	4b15      	ldr	r3, [pc, #84]	@ (9000100c <USBD_LL_Init+0x94>)
90000fb8:	2200      	movs	r2, #0
90000fba:	729a      	strb	r2, [r3, #10]
  hpcd_USB_OTG_HS.Init.low_power_enable = DISABLE;
90000fbc:	4b13      	ldr	r3, [pc, #76]	@ (9000100c <USBD_LL_Init+0x94>)
90000fbe:	2200      	movs	r2, #0
90000fc0:	72da      	strb	r2, [r3, #11]
  hpcd_USB_OTG_HS.Init.lpm_enable = DISABLE;
90000fc2:	4b12      	ldr	r3, [pc, #72]	@ (9000100c <USBD_LL_Init+0x94>)
90000fc4:	2200      	movs	r2, #0
90000fc6:	731a      	strb	r2, [r3, #12]
  hpcd_USB_OTG_HS.Init.use_dedicated_ep1 = DISABLE;
90000fc8:	4b10      	ldr	r3, [pc, #64]	@ (9000100c <USBD_LL_Init+0x94>)
90000fca:	2200      	movs	r2, #0
90000fcc:	73da      	strb	r2, [r3, #15]
  hpcd_USB_OTG_HS.Init.vbus_sensing_enable = DISABLE;
90000fce:	4b0f      	ldr	r3, [pc, #60]	@ (9000100c <USBD_LL_Init+0x94>)
90000fd0:	2200      	movs	r2, #0
90000fd2:	739a      	strb	r2, [r3, #14]
  if (HAL_PCD_Init(&hpcd_USB_OTG_HS) != HAL_OK)
90000fd4:	480d      	ldr	r0, [pc, #52]	@ (9000100c <USBD_LL_Init+0x94>)
90000fd6:	f000 fe7f 	bl	90001cd8 <HAL_PCD_Init>
90000fda:	4603      	mov	r3, r0
90000fdc:	2b00      	cmp	r3, #0
90000fde:	d001      	beq.n	90000fe4 <USBD_LL_Init+0x6c>
  {
    Error_Handler();
90000fe0:	f7ff fad8 	bl	90000594 <Error_Handler>
  HAL_PCD_RegisterDataInStageCallback(&hpcd_USB_OTG_HS, PCD_DataInStageCallback);
  HAL_PCD_RegisterIsoOutIncpltCallback(&hpcd_USB_OTG_HS, PCD_ISOOUTIncompleteCallback);
  HAL_PCD_RegisterIsoInIncpltCallback(&hpcd_USB_OTG_HS, PCD_ISOINIncompleteCallback);
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
  /* USER CODE BEGIN USB_HS_FIFO_Configuration */
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_HS, 0x200);
90000fe4:	f44f 7100 	mov.w	r1, #512	@ 0x200
90000fe8:	4808      	ldr	r0, [pc, #32]	@ (9000100c <USBD_LL_Init+0x94>)
90000fea:	f002 f928 	bl	9000323e <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_HS, 0, 0x40);
90000fee:	2240      	movs	r2, #64	@ 0x40
90000ff0:	2100      	movs	r1, #0
90000ff2:	4806      	ldr	r0, [pc, #24]	@ (9000100c <USBD_LL_Init+0x94>)
90000ff4:	f002 f8dc 	bl	900031b0 <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_HS, 1, 0x80);
90000ff8:	2280      	movs	r2, #128	@ 0x80
90000ffa:	2101      	movs	r1, #1
90000ffc:	4803      	ldr	r0, [pc, #12]	@ (9000100c <USBD_LL_Init+0x94>)
90000ffe:	f002 f8d7 	bl	900031b0 <HAL_PCDEx_SetTxFiFo>
  /* USER CODE END USB_HS_FIFO_Configuration */
  }
  return USBD_OK;
90001002:	2300      	movs	r3, #0
}
90001004:	4618      	mov	r0, r3
90001006:	3708      	adds	r7, #8
90001008:	46bd      	mov	sp, r7
9000100a:	bd80      	pop	{r7, pc}
9000100c:	240006a8 	.word	0x240006a8
90001010:	40040000 	.word	0x40040000

90001014 <USBD_LL_Start>:
  * @brief  Starts the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
90001014:	b580      	push	{r7, lr}
90001016:	b084      	sub	sp, #16
90001018:	af00      	add	r7, sp, #0
9000101a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
9000101c:	2300      	movs	r3, #0
9000101e:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
90001020:	2300      	movs	r3, #0
90001022:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_Start(pdev->pData);
90001024:	687b      	ldr	r3, [r7, #4]
90001026:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
9000102a:	4618      	mov	r0, r3
9000102c:	f000 ff6c 	bl	90001f08 <HAL_PCD_Start>
90001030:	4603      	mov	r3, r0
90001032:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
90001034:	7bfb      	ldrb	r3, [r7, #15]
90001036:	4618      	mov	r0, r3
90001038:	f000 f962 	bl	90001300 <USBD_Get_USB_Status>
9000103c:	4603      	mov	r3, r0
9000103e:	73bb      	strb	r3, [r7, #14]

  return usb_status;
90001040:	7bbb      	ldrb	r3, [r7, #14]
}
90001042:	4618      	mov	r0, r3
90001044:	3710      	adds	r7, #16
90001046:	46bd      	mov	sp, r7
90001048:	bd80      	pop	{r7, pc}

9000104a <USBD_LL_OpenEP>:
  * @param  ep_type: Endpoint type
  * @param  ep_mps: Endpoint max packet size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
{
9000104a:	b580      	push	{r7, lr}
9000104c:	b084      	sub	sp, #16
9000104e:	af00      	add	r7, sp, #0
90001050:	6078      	str	r0, [r7, #4]
90001052:	4608      	mov	r0, r1
90001054:	4611      	mov	r1, r2
90001056:	461a      	mov	r2, r3
90001058:	4603      	mov	r3, r0
9000105a:	70fb      	strb	r3, [r7, #3]
9000105c:	460b      	mov	r3, r1
9000105e:	70bb      	strb	r3, [r7, #2]
90001060:	4613      	mov	r3, r2
90001062:	803b      	strh	r3, [r7, #0]
  HAL_StatusTypeDef hal_status = HAL_OK;
90001064:	2300      	movs	r3, #0
90001066:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
90001068:	2300      	movs	r3, #0
9000106a:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
9000106c:	687b      	ldr	r3, [r7, #4]
9000106e:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
90001072:	78bb      	ldrb	r3, [r7, #2]
90001074:	883a      	ldrh	r2, [r7, #0]
90001076:	78f9      	ldrb	r1, [r7, #3]
90001078:	f001 fc87 	bl	9000298a <HAL_PCD_EP_Open>
9000107c:	4603      	mov	r3, r0
9000107e:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
90001080:	7bfb      	ldrb	r3, [r7, #15]
90001082:	4618      	mov	r0, r3
90001084:	f000 f93c 	bl	90001300 <USBD_Get_USB_Status>
90001088:	4603      	mov	r3, r0
9000108a:	73bb      	strb	r3, [r7, #14]

  return usb_status;
9000108c:	7bbb      	ldrb	r3, [r7, #14]
}
9000108e:	4618      	mov	r0, r3
90001090:	3710      	adds	r7, #16
90001092:	46bd      	mov	sp, r7
90001094:	bd80      	pop	{r7, pc}

90001096 <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
90001096:	b580      	push	{r7, lr}
90001098:	b084      	sub	sp, #16
9000109a:	af00      	add	r7, sp, #0
9000109c:	6078      	str	r0, [r7, #4]
9000109e:	460b      	mov	r3, r1
900010a0:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
900010a2:	2300      	movs	r3, #0
900010a4:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
900010a6:	2300      	movs	r3, #0
900010a8:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
900010aa:	687b      	ldr	r3, [r7, #4]
900010ac:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
900010b0:	78fa      	ldrb	r2, [r7, #3]
900010b2:	4611      	mov	r1, r2
900010b4:	4618      	mov	r0, r3
900010b6:	f001 fcd2 	bl	90002a5e <HAL_PCD_EP_Close>
900010ba:	4603      	mov	r3, r0
900010bc:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
900010be:	7bfb      	ldrb	r3, [r7, #15]
900010c0:	4618      	mov	r0, r3
900010c2:	f000 f91d 	bl	90001300 <USBD_Get_USB_Status>
900010c6:	4603      	mov	r3, r0
900010c8:	73bb      	strb	r3, [r7, #14]

  return usb_status;
900010ca:	7bbb      	ldrb	r3, [r7, #14]
}
900010cc:	4618      	mov	r0, r3
900010ce:	3710      	adds	r7, #16
900010d0:	46bd      	mov	sp, r7
900010d2:	bd80      	pop	{r7, pc}

900010d4 <USBD_LL_FlushEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_FlushEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
900010d4:	b580      	push	{r7, lr}
900010d6:	b084      	sub	sp, #16
900010d8:	af00      	add	r7, sp, #0
900010da:	6078      	str	r0, [r7, #4]
900010dc:	460b      	mov	r3, r1
900010de:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
900010e0:	2300      	movs	r3, #0
900010e2:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
900010e4:	2300      	movs	r3, #0
900010e6:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Flush(pdev->pData, ep_addr);
900010e8:	687b      	ldr	r3, [r7, #4]
900010ea:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
900010ee:	78fa      	ldrb	r2, [r7, #3]
900010f0:	4611      	mov	r1, r2
900010f2:	4618      	mov	r0, r3
900010f4:	f001 fe74 	bl	90002de0 <HAL_PCD_EP_Flush>
900010f8:	4603      	mov	r3, r0
900010fa:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
900010fc:	7bfb      	ldrb	r3, [r7, #15]
900010fe:	4618      	mov	r0, r3
90001100:	f000 f8fe 	bl	90001300 <USBD_Get_USB_Status>
90001104:	4603      	mov	r3, r0
90001106:	73bb      	strb	r3, [r7, #14]

  return usb_status;
90001108:	7bbb      	ldrb	r3, [r7, #14]
}
9000110a:	4618      	mov	r0, r3
9000110c:	3710      	adds	r7, #16
9000110e:	46bd      	mov	sp, r7
90001110:	bd80      	pop	{r7, pc}

90001112 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
90001112:	b580      	push	{r7, lr}
90001114:	b084      	sub	sp, #16
90001116:	af00      	add	r7, sp, #0
90001118:	6078      	str	r0, [r7, #4]
9000111a:	460b      	mov	r3, r1
9000111c:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
9000111e:	2300      	movs	r3, #0
90001120:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
90001122:	2300      	movs	r3, #0
90001124:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
90001126:	687b      	ldr	r3, [r7, #4]
90001128:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
9000112c:	78fa      	ldrb	r2, [r7, #3]
9000112e:	4611      	mov	r1, r2
90001130:	4618      	mov	r0, r3
90001132:	f001 fd6b 	bl	90002c0c <HAL_PCD_EP_SetStall>
90001136:	4603      	mov	r3, r0
90001138:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
9000113a:	7bfb      	ldrb	r3, [r7, #15]
9000113c:	4618      	mov	r0, r3
9000113e:	f000 f8df 	bl	90001300 <USBD_Get_USB_Status>
90001142:	4603      	mov	r3, r0
90001144:	73bb      	strb	r3, [r7, #14]

  return usb_status;
90001146:	7bbb      	ldrb	r3, [r7, #14]
}
90001148:	4618      	mov	r0, r3
9000114a:	3710      	adds	r7, #16
9000114c:	46bd      	mov	sp, r7
9000114e:	bd80      	pop	{r7, pc}

90001150 <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
90001150:	b580      	push	{r7, lr}
90001152:	b084      	sub	sp, #16
90001154:	af00      	add	r7, sp, #0
90001156:	6078      	str	r0, [r7, #4]
90001158:	460b      	mov	r3, r1
9000115a:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
9000115c:	2300      	movs	r3, #0
9000115e:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
90001160:	2300      	movs	r3, #0
90001162:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
90001164:	687b      	ldr	r3, [r7, #4]
90001166:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
9000116a:	78fa      	ldrb	r2, [r7, #3]
9000116c:	4611      	mov	r1, r2
9000116e:	4618      	mov	r0, r3
90001170:	f001 fdaf 	bl	90002cd2 <HAL_PCD_EP_ClrStall>
90001174:	4603      	mov	r3, r0
90001176:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
90001178:	7bfb      	ldrb	r3, [r7, #15]
9000117a:	4618      	mov	r0, r3
9000117c:	f000 f8c0 	bl	90001300 <USBD_Get_USB_Status>
90001180:	4603      	mov	r3, r0
90001182:	73bb      	strb	r3, [r7, #14]

  return usb_status;
90001184:	7bbb      	ldrb	r3, [r7, #14]
}
90001186:	4618      	mov	r0, r3
90001188:	3710      	adds	r7, #16
9000118a:	46bd      	mov	sp, r7
9000118c:	bd80      	pop	{r7, pc}

9000118e <USBD_LL_IsStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
9000118e:	b480      	push	{r7}
90001190:	b085      	sub	sp, #20
90001192:	af00      	add	r7, sp, #0
90001194:	6078      	str	r0, [r7, #4]
90001196:	460b      	mov	r3, r1
90001198:	70fb      	strb	r3, [r7, #3]
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
9000119a:	687b      	ldr	r3, [r7, #4]
9000119c:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
900011a0:	60fb      	str	r3, [r7, #12]

  if((ep_addr & 0x80) == 0x80)
900011a2:	f997 3003 	ldrsb.w	r3, [r7, #3]
900011a6:	2b00      	cmp	r3, #0
900011a8:	da0b      	bge.n	900011c2 <USBD_LL_IsStallEP+0x34>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
900011aa:	78fb      	ldrb	r3, [r7, #3]
900011ac:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
900011b0:	68f9      	ldr	r1, [r7, #12]
900011b2:	4613      	mov	r3, r2
900011b4:	00db      	lsls	r3, r3, #3
900011b6:	4413      	add	r3, r2
900011b8:	009b      	lsls	r3, r3, #2
900011ba:	440b      	add	r3, r1
900011bc:	3316      	adds	r3, #22
900011be:	781b      	ldrb	r3, [r3, #0]
900011c0:	e00b      	b.n	900011da <USBD_LL_IsStallEP+0x4c>
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
900011c2:	78fb      	ldrb	r3, [r7, #3]
900011c4:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
900011c8:	68f9      	ldr	r1, [r7, #12]
900011ca:	4613      	mov	r3, r2
900011cc:	00db      	lsls	r3, r3, #3
900011ce:	4413      	add	r3, r2
900011d0:	009b      	lsls	r3, r3, #2
900011d2:	440b      	add	r3, r1
900011d4:	f203 2356 	addw	r3, r3, #598	@ 0x256
900011d8:	781b      	ldrb	r3, [r3, #0]
  }
}
900011da:	4618      	mov	r0, r3
900011dc:	3714      	adds	r7, #20
900011de:	46bd      	mov	sp, r7
900011e0:	f85d 7b04 	ldr.w	r7, [sp], #4
900011e4:	4770      	bx	lr

900011e6 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  dev_addr: Device address
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
{
900011e6:	b580      	push	{r7, lr}
900011e8:	b084      	sub	sp, #16
900011ea:	af00      	add	r7, sp, #0
900011ec:	6078      	str	r0, [r7, #4]
900011ee:	460b      	mov	r3, r1
900011f0:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
900011f2:	2300      	movs	r3, #0
900011f4:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
900011f6:	2300      	movs	r3, #0
900011f8:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
900011fa:	687b      	ldr	r3, [r7, #4]
900011fc:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
90001200:	78fa      	ldrb	r2, [r7, #3]
90001202:	4611      	mov	r1, r2
90001204:	4618      	mov	r0, r3
90001206:	f001 fb9c 	bl	90002942 <HAL_PCD_SetAddress>
9000120a:	4603      	mov	r3, r0
9000120c:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
9000120e:	7bfb      	ldrb	r3, [r7, #15]
90001210:	4618      	mov	r0, r3
90001212:	f000 f875 	bl	90001300 <USBD_Get_USB_Status>
90001216:	4603      	mov	r3, r0
90001218:	73bb      	strb	r3, [r7, #14]

  return usb_status;
9000121a:	7bbb      	ldrb	r3, [r7, #14]
}
9000121c:	4618      	mov	r0, r3
9000121e:	3710      	adds	r7, #16
90001220:	46bd      	mov	sp, r7
90001222:	bd80      	pop	{r7, pc}

90001224 <USBD_LL_Transmit>:
  * @param  pbuf: Pointer to data to be sent
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
90001224:	b580      	push	{r7, lr}
90001226:	b086      	sub	sp, #24
90001228:	af00      	add	r7, sp, #0
9000122a:	60f8      	str	r0, [r7, #12]
9000122c:	607a      	str	r2, [r7, #4]
9000122e:	603b      	str	r3, [r7, #0]
90001230:	460b      	mov	r3, r1
90001232:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef hal_status = HAL_OK;
90001234:	2300      	movs	r3, #0
90001236:	75fb      	strb	r3, [r7, #23]
  USBD_StatusTypeDef usb_status = USBD_OK;
90001238:	2300      	movs	r3, #0
9000123a:	75bb      	strb	r3, [r7, #22]

  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
9000123c:	68fb      	ldr	r3, [r7, #12]
9000123e:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
90001242:	7af9      	ldrb	r1, [r7, #11]
90001244:	683b      	ldr	r3, [r7, #0]
90001246:	687a      	ldr	r2, [r7, #4]
90001248:	f001 fca6 	bl	90002b98 <HAL_PCD_EP_Transmit>
9000124c:	4603      	mov	r3, r0
9000124e:	75fb      	strb	r3, [r7, #23]

  usb_status =  USBD_Get_USB_Status(hal_status);
90001250:	7dfb      	ldrb	r3, [r7, #23]
90001252:	4618      	mov	r0, r3
90001254:	f000 f854 	bl	90001300 <USBD_Get_USB_Status>
90001258:	4603      	mov	r3, r0
9000125a:	75bb      	strb	r3, [r7, #22]

  return usb_status;
9000125c:	7dbb      	ldrb	r3, [r7, #22]
}
9000125e:	4618      	mov	r0, r3
90001260:	3718      	adds	r7, #24
90001262:	46bd      	mov	sp, r7
90001264:	bd80      	pop	{r7, pc}

90001266 <USBD_LL_PrepareReceive>:
  * @param  pbuf: Pointer to data to be received
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
90001266:	b580      	push	{r7, lr}
90001268:	b086      	sub	sp, #24
9000126a:	af00      	add	r7, sp, #0
9000126c:	60f8      	str	r0, [r7, #12]
9000126e:	607a      	str	r2, [r7, #4]
90001270:	603b      	str	r3, [r7, #0]
90001272:	460b      	mov	r3, r1
90001274:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef hal_status = HAL_OK;
90001276:	2300      	movs	r3, #0
90001278:	75fb      	strb	r3, [r7, #23]
  USBD_StatusTypeDef usb_status = USBD_OK;
9000127a:	2300      	movs	r3, #0
9000127c:	75bb      	strb	r3, [r7, #22]

  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
9000127e:	68fb      	ldr	r3, [r7, #12]
90001280:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
90001284:	7af9      	ldrb	r1, [r7, #11]
90001286:	683b      	ldr	r3, [r7, #0]
90001288:	687a      	ldr	r2, [r7, #4]
9000128a:	f001 fc32 	bl	90002af2 <HAL_PCD_EP_Receive>
9000128e:	4603      	mov	r3, r0
90001290:	75fb      	strb	r3, [r7, #23]

  usb_status =  USBD_Get_USB_Status(hal_status);
90001292:	7dfb      	ldrb	r3, [r7, #23]
90001294:	4618      	mov	r0, r3
90001296:	f000 f833 	bl	90001300 <USBD_Get_USB_Status>
9000129a:	4603      	mov	r3, r0
9000129c:	75bb      	strb	r3, [r7, #22]

  return usb_status;
9000129e:	7dbb      	ldrb	r3, [r7, #22]
}
900012a0:	4618      	mov	r0, r3
900012a2:	3718      	adds	r7, #24
900012a4:	46bd      	mov	sp, r7
900012a6:	bd80      	pop	{r7, pc}

900012a8 <USBD_LL_GetRxDataSize>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Received Data Size
  */
uint32_t USBD_LL_GetRxDataSize(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
900012a8:	b580      	push	{r7, lr}
900012aa:	b082      	sub	sp, #8
900012ac:	af00      	add	r7, sp, #0
900012ae:	6078      	str	r0, [r7, #4]
900012b0:	460b      	mov	r3, r1
900012b2:	70fb      	strb	r3, [r7, #3]
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
900012b4:	687b      	ldr	r3, [r7, #4]
900012b6:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
900012ba:	78fa      	ldrb	r2, [r7, #3]
900012bc:	4611      	mov	r1, r2
900012be:	4618      	mov	r0, r3
900012c0:	f001 fc52 	bl	90002b68 <HAL_PCD_EP_GetRxCount>
900012c4:	4603      	mov	r3, r0
}
900012c6:	4618      	mov	r0, r3
900012c8:	3708      	adds	r7, #8
900012ca:	46bd      	mov	sp, r7
900012cc:	bd80      	pop	{r7, pc}
	...

900012d0 <USBD_static_malloc>:
  * @brief  Static single allocation.
  * @param  size: Size of allocated memory
  * @retval None
  */
void *USBD_static_malloc(uint32_t size)
{
900012d0:	b480      	push	{r7}
900012d2:	b083      	sub	sp, #12
900012d4:	af00      	add	r7, sp, #0
900012d6:	6078      	str	r0, [r7, #4]
  UNUSED(size);
  static uint32_t mem[(sizeof(USBD_MSC_BOT_HandleTypeDef)/4)+1];/* On 32-bit boundary */
  return mem;
900012d8:	4b03      	ldr	r3, [pc, #12]	@ (900012e8 <USBD_static_malloc+0x18>)
}
900012da:	4618      	mov	r0, r3
900012dc:	370c      	adds	r7, #12
900012de:	46bd      	mov	sp, r7
900012e0:	f85d 7b04 	ldr.w	r7, [sp], #4
900012e4:	4770      	bx	lr
900012e6:	bf00      	nop
900012e8:	24000b8c 	.word	0x24000b8c

900012ec <USBD_static_free>:
  * @brief  Dummy memory free
  * @param  p: Pointer to allocated  memory address
  * @retval None
  */
void USBD_static_free(void *p)
{
900012ec:	b480      	push	{r7}
900012ee:	b083      	sub	sp, #12
900012f0:	af00      	add	r7, sp, #0
900012f2:	6078      	str	r0, [r7, #4]
  UNUSED(p);
}
900012f4:	bf00      	nop
900012f6:	370c      	adds	r7, #12
900012f8:	46bd      	mov	sp, r7
900012fa:	f85d 7b04 	ldr.w	r7, [sp], #4
900012fe:	4770      	bx	lr

90001300 <USBD_Get_USB_Status>:
  * @brief  Returns the USB status depending on the HAL status:
  * @param  hal_status: HAL status
  * @retval USB status
  */
USBD_StatusTypeDef USBD_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
90001300:	b480      	push	{r7}
90001302:	b085      	sub	sp, #20
90001304:	af00      	add	r7, sp, #0
90001306:	4603      	mov	r3, r0
90001308:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef usb_status = USBD_OK;
9000130a:	2300      	movs	r3, #0
9000130c:	73fb      	strb	r3, [r7, #15]

  switch (hal_status)
9000130e:	79fb      	ldrb	r3, [r7, #7]
90001310:	2b03      	cmp	r3, #3
90001312:	d817      	bhi.n	90001344 <USBD_Get_USB_Status+0x44>
90001314:	a201      	add	r2, pc, #4	@ (adr r2, 9000131c <USBD_Get_USB_Status+0x1c>)
90001316:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
9000131a:	bf00      	nop
9000131c:	9000132d 	.word	0x9000132d
90001320:	90001333 	.word	0x90001333
90001324:	90001339 	.word	0x90001339
90001328:	9000133f 	.word	0x9000133f
  {
    case HAL_OK :
      usb_status = USBD_OK;
9000132c:	2300      	movs	r3, #0
9000132e:	73fb      	strb	r3, [r7, #15]
    break;
90001330:	e00b      	b.n	9000134a <USBD_Get_USB_Status+0x4a>
    case HAL_ERROR :
      usb_status = USBD_FAIL;
90001332:	2303      	movs	r3, #3
90001334:	73fb      	strb	r3, [r7, #15]
    break;
90001336:	e008      	b.n	9000134a <USBD_Get_USB_Status+0x4a>
    case HAL_BUSY :
      usb_status = USBD_BUSY;
90001338:	2301      	movs	r3, #1
9000133a:	73fb      	strb	r3, [r7, #15]
    break;
9000133c:	e005      	b.n	9000134a <USBD_Get_USB_Status+0x4a>
    case HAL_TIMEOUT :
      usb_status = USBD_FAIL;
9000133e:	2303      	movs	r3, #3
90001340:	73fb      	strb	r3, [r7, #15]
    break;
90001342:	e002      	b.n	9000134a <USBD_Get_USB_Status+0x4a>
    default :
      usb_status = USBD_FAIL;
90001344:	2303      	movs	r3, #3
90001346:	73fb      	strb	r3, [r7, #15]
    break;
90001348:	bf00      	nop
  }
  return usb_status;
9000134a:	7bfb      	ldrb	r3, [r7, #15]
}
9000134c:	4618      	mov	r0, r3
9000134e:	3714      	adds	r7, #20
90001350:	46bd      	mov	sp, r7
90001352:	f85d 7b04 	ldr.w	r7, [sp], #4
90001356:	4770      	bx	lr

90001358 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
90001358:	b480      	push	{r7}
9000135a:	af00      	add	r7, sp, #0
  /* Configure the Vector Table location -------------------------------------*/
  SCB->VTOR = INTVECT_START;
9000135c:	4b07      	ldr	r3, [pc, #28]	@ (9000137c <SystemInit+0x24>)
9000135e:	4a08      	ldr	r2, [pc, #32]	@ (90001380 <SystemInit+0x28>)
90001360:	609a      	str	r2, [r3, #8]

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
90001362:	4b06      	ldr	r3, [pc, #24]	@ (9000137c <SystemInit+0x24>)
90001364:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
90001368:	4a04      	ldr	r2, [pc, #16]	@ (9000137c <SystemInit+0x24>)
9000136a:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
9000136e:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif
}
90001372:	bf00      	nop
90001374:	46bd      	mov	sp, r7
90001376:	f85d 7b04 	ldr.w	r7, [sp], #4
9000137a:	4770      	bx	lr
9000137c:	e000ed00 	.word	0xe000ed00
90001380:	90000000 	.word	0x90000000

90001384 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
90001384:	b480      	push	{r7}
90001386:	b089      	sub	sp, #36	@ 0x24
90001388:	af00      	add	r7, sp, #0
  uint32_t sysclk, hsivalue, pllsource, pllm, pllp, core_presc;
  float_t pllfracn, pllvco;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
9000138a:	4b92      	ldr	r3, [pc, #584]	@ (900015d4 <SystemCoreClockUpdate+0x250>)
9000138c:	691b      	ldr	r3, [r3, #16]
9000138e:	f003 0338 	and.w	r3, r3, #56	@ 0x38
90001392:	2b18      	cmp	r3, #24
90001394:	f200 80fb 	bhi.w	9000158e <SystemCoreClockUpdate+0x20a>
90001398:	a201      	add	r2, pc, #4	@ (adr r2, 900013a0 <SystemCoreClockUpdate+0x1c>)
9000139a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
9000139e:	bf00      	nop
900013a0:	90001405 	.word	0x90001405
900013a4:	9000158f 	.word	0x9000158f
900013a8:	9000158f 	.word	0x9000158f
900013ac:	9000158f 	.word	0x9000158f
900013b0:	9000158f 	.word	0x9000158f
900013b4:	9000158f 	.word	0x9000158f
900013b8:	9000158f 	.word	0x9000158f
900013bc:	9000158f 	.word	0x9000158f
900013c0:	90001419 	.word	0x90001419
900013c4:	9000158f 	.word	0x9000158f
900013c8:	9000158f 	.word	0x9000158f
900013cc:	9000158f 	.word	0x9000158f
900013d0:	9000158f 	.word	0x9000158f
900013d4:	9000158f 	.word	0x9000158f
900013d8:	9000158f 	.word	0x9000158f
900013dc:	9000158f 	.word	0x9000158f
900013e0:	9000141f 	.word	0x9000141f
900013e4:	9000158f 	.word	0x9000158f
900013e8:	9000158f 	.word	0x9000158f
900013ec:	9000158f 	.word	0x9000158f
900013f0:	9000158f 	.word	0x9000158f
900013f4:	9000158f 	.word	0x9000158f
900013f8:	9000158f 	.word	0x9000158f
900013fc:	9000158f 	.word	0x9000158f
90001400:	90001425 	.word	0x90001425
  {
  case 0x00:  /* HSI used as system clock source (default after reset) */
    sysclk = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV) >> RCC_CR_HSIDIV_Pos));
90001404:	4b73      	ldr	r3, [pc, #460]	@ (900015d4 <SystemCoreClockUpdate+0x250>)
90001406:	681b      	ldr	r3, [r3, #0]
90001408:	08db      	lsrs	r3, r3, #3
9000140a:	f003 0303 	and.w	r3, r3, #3
9000140e:	4a72      	ldr	r2, [pc, #456]	@ (900015d8 <SystemCoreClockUpdate+0x254>)
90001410:	fa22 f303 	lsr.w	r3, r2, r3
90001414:	61fb      	str	r3, [r7, #28]
    break;
90001416:	e0c4      	b.n	900015a2 <SystemCoreClockUpdate+0x21e>

  case 0x08:  /* CSI used as system clock source */
    sysclk = CSI_VALUE;
90001418:	4b70      	ldr	r3, [pc, #448]	@ (900015dc <SystemCoreClockUpdate+0x258>)
9000141a:	61fb      	str	r3, [r7, #28]
    break;
9000141c:	e0c1      	b.n	900015a2 <SystemCoreClockUpdate+0x21e>

  case 0x10:  /* HSE used as system clock source */
    sysclk = HSE_VALUE;
9000141e:	4b70      	ldr	r3, [pc, #448]	@ (900015e0 <SystemCoreClockUpdate+0x25c>)
90001420:	61fb      	str	r3, [r7, #28]
    break;
90001422:	e0be      	b.n	900015a2 <SystemCoreClockUpdate+0x21e>

  case 0x18:  /* PLL1 used as system clock  source */
    /* PLL1_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
       SYSCLK = PLL1_VCO / PLL1R
       */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
90001424:	4b6b      	ldr	r3, [pc, #428]	@ (900015d4 <SystemCoreClockUpdate+0x250>)
90001426:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
90001428:	f003 0303 	and.w	r3, r3, #3
9000142c:	613b      	str	r3, [r7, #16]
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos)  ;
9000142e:	4b69      	ldr	r3, [pc, #420]	@ (900015d4 <SystemCoreClockUpdate+0x250>)
90001430:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
90001432:	091b      	lsrs	r3, r3, #4
90001434:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
90001438:	60fb      	str	r3, [r7, #12]
    if ((RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) != 0U)
9000143a:	4b66      	ldr	r3, [pc, #408]	@ (900015d4 <SystemCoreClockUpdate+0x250>)
9000143c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000143e:	f003 0301 	and.w	r3, r3, #1
90001442:	2b00      	cmp	r3, #0
90001444:	d00b      	beq.n	9000145e <SystemCoreClockUpdate+0xda>
    {
      pllfracn = (float_t)(uint32_t)(((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN)>> RCC_PLL1FRACR_FRACN_Pos));
90001446:	4b63      	ldr	r3, [pc, #396]	@ (900015d4 <SystemCoreClockUpdate+0x250>)
90001448:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
9000144a:	08db      	lsrs	r3, r3, #3
9000144c:	f3c3 030c 	ubfx	r3, r3, #0, #13
90001450:	ee07 3a90 	vmov	s15, r3
90001454:	eef8 7a67 	vcvt.f32.u32	s15, s15
90001458:	edc7 7a06 	vstr	s15, [r7, #24]
9000145c:	e002      	b.n	90001464 <SystemCoreClockUpdate+0xe0>
    }
    else
    {
      pllfracn = (float_t)0U;
9000145e:	f04f 0300 	mov.w	r3, #0
90001462:	61bb      	str	r3, [r7, #24]
    }

    if (pllm != 0U)
90001464:	68fb      	ldr	r3, [r7, #12]
90001466:	2b00      	cmp	r3, #0
90001468:	f000 808e 	beq.w	90001588 <SystemCoreClockUpdate+0x204>
    {
      switch (pllsource)
9000146c:	693b      	ldr	r3, [r7, #16]
9000146e:	2b01      	cmp	r3, #1
90001470:	d024      	beq.n	900014bc <SystemCoreClockUpdate+0x138>
90001472:	693b      	ldr	r3, [r7, #16]
90001474:	2b02      	cmp	r3, #2
90001476:	d143      	bne.n	90001500 <SystemCoreClockUpdate+0x17c>
      {
      case 0x02:  /* HSE used as PLL1 clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (pllfracn/(float_t)0x2000) +(float_t)1 );
90001478:	68fb      	ldr	r3, [r7, #12]
9000147a:	ee07 3a90 	vmov	s15, r3
9000147e:	eef8 7a67 	vcvt.f32.u32	s15, s15
90001482:	eddf 6a58 	vldr	s13, [pc, #352]	@ 900015e4 <SystemCoreClockUpdate+0x260>
90001486:	ee86 7aa7 	vdiv.f32	s14, s13, s15
9000148a:	4b52      	ldr	r3, [pc, #328]	@ (900015d4 <SystemCoreClockUpdate+0x250>)
9000148c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
9000148e:	f3c3 0308 	ubfx	r3, r3, #0, #9
90001492:	ee07 3a90 	vmov	s15, r3
90001496:	eef8 6a67 	vcvt.f32.u32	s13, s15
9000149a:	ed97 6a06 	vldr	s12, [r7, #24]
9000149e:	eddf 5a52 	vldr	s11, [pc, #328]	@ 900015e8 <SystemCoreClockUpdate+0x264>
900014a2:	eec6 7a25 	vdiv.f32	s15, s12, s11
900014a6:	ee76 7aa7 	vadd.f32	s15, s13, s15
900014aa:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
900014ae:	ee77 7aa6 	vadd.f32	s15, s15, s13
900014b2:	ee67 7a27 	vmul.f32	s15, s14, s15
900014b6:	edc7 7a05 	vstr	s15, [r7, #20]
        break;
900014ba:	e04f      	b.n	9000155c <SystemCoreClockUpdate+0x1d8>

      case 0x01:  /* CSI used as PLL1 clock source */
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (pllfracn/(float_t)0x2000) +(float_t)1 );
900014bc:	68fb      	ldr	r3, [r7, #12]
900014be:	ee07 3a90 	vmov	s15, r3
900014c2:	eef8 7a67 	vcvt.f32.u32	s15, s15
900014c6:	eddf 6a49 	vldr	s13, [pc, #292]	@ 900015ec <SystemCoreClockUpdate+0x268>
900014ca:	ee86 7aa7 	vdiv.f32	s14, s13, s15
900014ce:	4b41      	ldr	r3, [pc, #260]	@ (900015d4 <SystemCoreClockUpdate+0x250>)
900014d0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
900014d2:	f3c3 0308 	ubfx	r3, r3, #0, #9
900014d6:	ee07 3a90 	vmov	s15, r3
900014da:	eef8 6a67 	vcvt.f32.u32	s13, s15
900014de:	ed97 6a06 	vldr	s12, [r7, #24]
900014e2:	eddf 5a41 	vldr	s11, [pc, #260]	@ 900015e8 <SystemCoreClockUpdate+0x264>
900014e6:	eec6 7a25 	vdiv.f32	s15, s12, s11
900014ea:	ee76 7aa7 	vadd.f32	s15, s13, s15
900014ee:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
900014f2:	ee77 7aa6 	vadd.f32	s15, s15, s13
900014f6:	ee67 7a27 	vmul.f32	s15, s14, s15
900014fa:	edc7 7a05 	vstr	s15, [r7, #20]
        break;
900014fe:	e02d      	b.n	9000155c <SystemCoreClockUpdate+0x1d8>

      case 0x00:  /* HSI used as PLL1 clock source */
      default:
        hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV) >> RCC_CR_HSIDIV_Pos));
90001500:	4b34      	ldr	r3, [pc, #208]	@ (900015d4 <SystemCoreClockUpdate+0x250>)
90001502:	681b      	ldr	r3, [r3, #0]
90001504:	08db      	lsrs	r3, r3, #3
90001506:	f003 0303 	and.w	r3, r3, #3
9000150a:	4a33      	ldr	r2, [pc, #204]	@ (900015d8 <SystemCoreClockUpdate+0x254>)
9000150c:	fa22 f303 	lsr.w	r3, r2, r3
90001510:	60bb      	str	r3, [r7, #8]
        pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (pllfracn/(float_t)0x2000) +(float_t)1 );
90001512:	68bb      	ldr	r3, [r7, #8]
90001514:	ee07 3a90 	vmov	s15, r3
90001518:	eef8 6a67 	vcvt.f32.u32	s13, s15
9000151c:	68fb      	ldr	r3, [r7, #12]
9000151e:	ee07 3a90 	vmov	s15, r3
90001522:	eef8 7a67 	vcvt.f32.u32	s15, s15
90001526:	ee86 7aa7 	vdiv.f32	s14, s13, s15
9000152a:	4b2a      	ldr	r3, [pc, #168]	@ (900015d4 <SystemCoreClockUpdate+0x250>)
9000152c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
9000152e:	f3c3 0308 	ubfx	r3, r3, #0, #9
90001532:	ee07 3a90 	vmov	s15, r3
90001536:	eef8 6a67 	vcvt.f32.u32	s13, s15
9000153a:	ed97 6a06 	vldr	s12, [r7, #24]
9000153e:	eddf 5a2a 	vldr	s11, [pc, #168]	@ 900015e8 <SystemCoreClockUpdate+0x264>
90001542:	eec6 7a25 	vdiv.f32	s15, s12, s11
90001546:	ee76 7aa7 	vadd.f32	s15, s13, s15
9000154a:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
9000154e:	ee77 7aa6 	vadd.f32	s15, s15, s13
90001552:	ee67 7a27 	vmul.f32	s15, s14, s15
90001556:	edc7 7a05 	vstr	s15, [r7, #20]
        break;
9000155a:	bf00      	nop
      }
      pllp = (((RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVP) >> RCC_PLL1DIVR1_DIVP_Pos) + 1U ) ;
9000155c:	4b1d      	ldr	r3, [pc, #116]	@ (900015d4 <SystemCoreClockUpdate+0x250>)
9000155e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
90001560:	0a5b      	lsrs	r3, r3, #9
90001562:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
90001566:	3301      	adds	r3, #1
90001568:	607b      	str	r3, [r7, #4]
      sysclk =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
9000156a:	687b      	ldr	r3, [r7, #4]
9000156c:	ee07 3a90 	vmov	s15, r3
90001570:	eeb8 7a67 	vcvt.f32.u32	s14, s15
90001574:	edd7 6a05 	vldr	s13, [r7, #20]
90001578:	eec6 7a87 	vdiv.f32	s15, s13, s14
9000157c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
90001580:	ee17 3a90 	vmov	r3, s15
90001584:	61fb      	str	r3, [r7, #28]
    }
    else
    {
      sysclk = 0U;
    }
    break;
90001586:	e00c      	b.n	900015a2 <SystemCoreClockUpdate+0x21e>
      sysclk = 0U;
90001588:	2300      	movs	r3, #0
9000158a:	61fb      	str	r3, [r7, #28]
    break;
9000158c:	e009      	b.n	900015a2 <SystemCoreClockUpdate+0x21e>

  default:  /* Unexpected, default to HSI used as system clock source (default after reset) */
    sysclk = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV) >> RCC_CR_HSIDIV_Pos));
9000158e:	4b11      	ldr	r3, [pc, #68]	@ (900015d4 <SystemCoreClockUpdate+0x250>)
90001590:	681b      	ldr	r3, [r3, #0]
90001592:	08db      	lsrs	r3, r3, #3
90001594:	f003 0303 	and.w	r3, r3, #3
90001598:	4a0f      	ldr	r2, [pc, #60]	@ (900015d8 <SystemCoreClockUpdate+0x254>)
9000159a:	fa22 f303 	lsr.w	r3, r2, r3
9000159e:	61fb      	str	r3, [r7, #28]
    break;
900015a0:	bf00      	nop
  }

  /* system clock frequency : CM7 CPU frequency  */
  core_presc = (RCC->CDCFGR & RCC_CDCFGR_CPRE);
900015a2:	4b0c      	ldr	r3, [pc, #48]	@ (900015d4 <SystemCoreClockUpdate+0x250>)
900015a4:	699b      	ldr	r3, [r3, #24]
900015a6:	f003 030f 	and.w	r3, r3, #15
900015aa:	603b      	str	r3, [r7, #0]
  if (core_presc >= 8U)
900015ac:	683b      	ldr	r3, [r7, #0]
900015ae:	2b07      	cmp	r3, #7
900015b0:	d907      	bls.n	900015c2 <SystemCoreClockUpdate+0x23e>
  {
    SystemCoreClock = (sysclk >> (core_presc - RCC_CDCFGR_CPRE_3 + 1U));
900015b2:	683b      	ldr	r3, [r7, #0]
900015b4:	3b07      	subs	r3, #7
900015b6:	69fa      	ldr	r2, [r7, #28]
900015b8:	fa22 f303 	lsr.w	r3, r2, r3
900015bc:	4a0c      	ldr	r2, [pc, #48]	@ (900015f0 <SystemCoreClockUpdate+0x26c>)
900015be:	6013      	str	r3, [r2, #0]
  }
  else
  {
    SystemCoreClock = sysclk;
  }
}
900015c0:	e002      	b.n	900015c8 <SystemCoreClockUpdate+0x244>
    SystemCoreClock = sysclk;
900015c2:	4a0b      	ldr	r2, [pc, #44]	@ (900015f0 <SystemCoreClockUpdate+0x26c>)
900015c4:	69fb      	ldr	r3, [r7, #28]
900015c6:	6013      	str	r3, [r2, #0]
}
900015c8:	bf00      	nop
900015ca:	3724      	adds	r7, #36	@ 0x24
900015cc:	46bd      	mov	sp, r7
900015ce:	f85d 7b04 	ldr.w	r7, [sp], #4
900015d2:	4770      	bx	lr
900015d4:	58024400 	.word	0x58024400
900015d8:	03d09000 	.word	0x03d09000
900015dc:	003d0900 	.word	0x003d0900
900015e0:	016e3600 	.word	0x016e3600
900015e4:	4bb71b00 	.word	0x4bb71b00
900015e8:	46000000 	.word	0x46000000
900015ec:	4a742400 	.word	0x4a742400
900015f0:	24000074 	.word	0x24000074

900015f4 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
900015f4:	b580      	push	{r7, lr}
900015f6:	b082      	sub	sp, #8
900015f8:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
900015fa:	2300      	movs	r3, #0
900015fc:	71fb      	strb	r3, [r7, #7]

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
900015fe:	2003      	movs	r0, #3
90001600:	f000 f980 	bl	90001904 <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
90001604:	200f      	movs	r0, #15
90001606:	f000 f80d 	bl	90001624 <HAL_InitTick>
9000160a:	4603      	mov	r3, r0
9000160c:	2b00      	cmp	r3, #0
9000160e:	d002      	beq.n	90001616 <HAL_Init+0x22>
  {
    status = HAL_ERROR;
90001610:	2301      	movs	r3, #1
90001612:	71fb      	strb	r3, [r7, #7]
90001614:	e001      	b.n	9000161a <HAL_Init+0x26>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
90001616:	f7ff f941 	bl	9000089c <HAL_MspInit>
  }

  /* Return function status */
  return status;
9000161a:	79fb      	ldrb	r3, [r7, #7]
}
9000161c:	4618      	mov	r0, r3
9000161e:	3708      	adds	r7, #8
90001620:	46bd      	mov	sp, r7
90001622:	bd80      	pop	{r7, pc}

90001624 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
90001624:	b580      	push	{r7, lr}
90001626:	b084      	sub	sp, #16
90001628:	af00      	add	r7, sp, #0
9000162a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
9000162c:	2300      	movs	r3, #0
9000162e:	73fb      	strb	r3, [r7, #15]

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that doesn't take the value zero)*/
  if ((uint32_t)uwTickFreq != 0U)
90001630:	4b17      	ldr	r3, [pc, #92]	@ (90001690 <HAL_InitTick+0x6c>)
90001632:	781b      	ldrb	r3, [r3, #0]
90001634:	2b00      	cmp	r3, #0
90001636:	d023      	beq.n	90001680 <HAL_InitTick+0x5c>
  {
    /*Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / (uint32_t)uwTickFreq)) == 0U)
90001638:	4b16      	ldr	r3, [pc, #88]	@ (90001694 <HAL_InitTick+0x70>)
9000163a:	681a      	ldr	r2, [r3, #0]
9000163c:	4b14      	ldr	r3, [pc, #80]	@ (90001690 <HAL_InitTick+0x6c>)
9000163e:	781b      	ldrb	r3, [r3, #0]
90001640:	4619      	mov	r1, r3
90001642:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
90001646:	fbb3 f3f1 	udiv	r3, r3, r1
9000164a:	fbb2 f3f3 	udiv	r3, r2, r3
9000164e:	4618      	mov	r0, r3
90001650:	f000 f98b 	bl	9000196a <HAL_SYSTICK_Config>
90001654:	4603      	mov	r3, r0
90001656:	2b00      	cmp	r3, #0
90001658:	d10f      	bne.n	9000167a <HAL_InitTick+0x56>
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
9000165a:	687b      	ldr	r3, [r7, #4]
9000165c:	2b0f      	cmp	r3, #15
9000165e:	d809      	bhi.n	90001674 <HAL_InitTick+0x50>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
90001660:	2200      	movs	r2, #0
90001662:	6879      	ldr	r1, [r7, #4]
90001664:	f04f 30ff 	mov.w	r0, #4294967295
90001668:	f000 f957 	bl	9000191a <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
9000166c:	4a0a      	ldr	r2, [pc, #40]	@ (90001698 <HAL_InitTick+0x74>)
9000166e:	687b      	ldr	r3, [r7, #4]
90001670:	6013      	str	r3, [r2, #0]
90001672:	e007      	b.n	90001684 <HAL_InitTick+0x60>
      }
      else
      {
        status = HAL_ERROR;
90001674:	2301      	movs	r3, #1
90001676:	73fb      	strb	r3, [r7, #15]
90001678:	e004      	b.n	90001684 <HAL_InitTick+0x60>
      }
    }
    else
    {
      status = HAL_ERROR;
9000167a:	2301      	movs	r3, #1
9000167c:	73fb      	strb	r3, [r7, #15]
9000167e:	e001      	b.n	90001684 <HAL_InitTick+0x60>
    }
  }
  else
  {
    status = HAL_ERROR;
90001680:	2301      	movs	r3, #1
90001682:	73fb      	strb	r3, [r7, #15]
  }

  /* Return function status */
  return status;
90001684:	7bfb      	ldrb	r3, [r7, #15]
}
90001686:	4618      	mov	r0, r3
90001688:	3710      	adds	r7, #16
9000168a:	46bd      	mov	sp, r7
9000168c:	bd80      	pop	{r7, pc}
9000168e:	bf00      	nop
90001690:	2400007c 	.word	0x2400007c
90001694:	24000074 	.word	0x24000074
90001698:	24000078 	.word	0x24000078

9000169c <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
9000169c:	b480      	push	{r7}
9000169e:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
900016a0:	4b06      	ldr	r3, [pc, #24]	@ (900016bc <HAL_IncTick+0x20>)
900016a2:	781b      	ldrb	r3, [r3, #0]
900016a4:	461a      	mov	r2, r3
900016a6:	4b06      	ldr	r3, [pc, #24]	@ (900016c0 <HAL_IncTick+0x24>)
900016a8:	681b      	ldr	r3, [r3, #0]
900016aa:	4413      	add	r3, r2
900016ac:	4a04      	ldr	r2, [pc, #16]	@ (900016c0 <HAL_IncTick+0x24>)
900016ae:	6013      	str	r3, [r2, #0]
}
900016b0:	bf00      	nop
900016b2:	46bd      	mov	sp, r7
900016b4:	f85d 7b04 	ldr.w	r7, [sp], #4
900016b8:	4770      	bx	lr
900016ba:	bf00      	nop
900016bc:	2400007c 	.word	0x2400007c
900016c0:	24000e14 	.word	0x24000e14

900016c4 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
900016c4:	b480      	push	{r7}
900016c6:	af00      	add	r7, sp, #0
  return uwTick;
900016c8:	4b03      	ldr	r3, [pc, #12]	@ (900016d8 <HAL_GetTick+0x14>)
900016ca:	681b      	ldr	r3, [r3, #0]
}
900016cc:	4618      	mov	r0, r3
900016ce:	46bd      	mov	sp, r7
900016d0:	f85d 7b04 	ldr.w	r7, [sp], #4
900016d4:	4770      	bx	lr
900016d6:	bf00      	nop
900016d8:	24000e14 	.word	0x24000e14

900016dc <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
900016dc:	b580      	push	{r7, lr}
900016de:	b084      	sub	sp, #16
900016e0:	af00      	add	r7, sp, #0
900016e2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
900016e4:	f7ff ffee 	bl	900016c4 <HAL_GetTick>
900016e8:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
900016ea:	687b      	ldr	r3, [r7, #4]
900016ec:	60fb      	str	r3, [r7, #12]

  /* Add a period to ensure minimum wait */
  if (wait < HAL_MAX_DELAY)
900016ee:	68fb      	ldr	r3, [r7, #12]
900016f0:	f1b3 3fff 	cmp.w	r3, #4294967295
900016f4:	d005      	beq.n	90001702 <HAL_Delay+0x26>
  {
    wait += (uint32_t)uwTickFreq;
900016f6:	4b0a      	ldr	r3, [pc, #40]	@ (90001720 <HAL_Delay+0x44>)
900016f8:	781b      	ldrb	r3, [r3, #0]
900016fa:	461a      	mov	r2, r3
900016fc:	68fb      	ldr	r3, [r7, #12]
900016fe:	4413      	add	r3, r2
90001700:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
90001702:	bf00      	nop
90001704:	f7ff ffde 	bl	900016c4 <HAL_GetTick>
90001708:	4602      	mov	r2, r0
9000170a:	68bb      	ldr	r3, [r7, #8]
9000170c:	1ad3      	subs	r3, r2, r3
9000170e:	68fa      	ldr	r2, [r7, #12]
90001710:	429a      	cmp	r2, r3
90001712:	d8f7      	bhi.n	90001704 <HAL_Delay+0x28>
  {
  }
}
90001714:	bf00      	nop
90001716:	bf00      	nop
90001718:	3710      	adds	r7, #16
9000171a:	46bd      	mov	sp, r7
9000171c:	bd80      	pop	{r7, pc}
9000171e:	bf00      	nop
90001720:	2400007c 	.word	0x2400007c

90001724 <HAL_SuspendTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
90001724:	b480      	push	{r7}
90001726:	af00      	add	r7, sp, #0
  /* Disable SysTick Interrupt */
  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
90001728:	4b05      	ldr	r3, [pc, #20]	@ (90001740 <HAL_SuspendTick+0x1c>)
9000172a:	681b      	ldr	r3, [r3, #0]
9000172c:	4a04      	ldr	r2, [pc, #16]	@ (90001740 <HAL_SuspendTick+0x1c>)
9000172e:	f023 0302 	bic.w	r3, r3, #2
90001732:	6013      	str	r3, [r2, #0]
}
90001734:	bf00      	nop
90001736:	46bd      	mov	sp, r7
90001738:	f85d 7b04 	ldr.w	r7, [sp], #4
9000173c:	4770      	bx	lr
9000173e:	bf00      	nop
90001740:	e000e010 	.word	0xe000e010

90001744 <HAL_ResumeTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
90001744:	b480      	push	{r7}
90001746:	af00      	add	r7, sp, #0
  /* Enable SysTick Interrupt */
  SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
90001748:	4b05      	ldr	r3, [pc, #20]	@ (90001760 <HAL_ResumeTick+0x1c>)
9000174a:	681b      	ldr	r3, [r3, #0]
9000174c:	4a04      	ldr	r2, [pc, #16]	@ (90001760 <HAL_ResumeTick+0x1c>)
9000174e:	f043 0302 	orr.w	r3, r3, #2
90001752:	6013      	str	r3, [r2, #0]
}
90001754:	bf00      	nop
90001756:	46bd      	mov	sp, r7
90001758:	f85d 7b04 	ldr.w	r7, [sp], #4
9000175c:	4770      	bx	lr
9000175e:	bf00      	nop
90001760:	e000e010 	.word	0xe000e010

90001764 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
90001764:	b480      	push	{r7}
90001766:	b085      	sub	sp, #20
90001768:	af00      	add	r7, sp, #0
9000176a:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
9000176c:	687b      	ldr	r3, [r7, #4]
9000176e:	f003 0307 	and.w	r3, r3, #7
90001772:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
90001774:	4b0b      	ldr	r3, [pc, #44]	@ (900017a4 <__NVIC_SetPriorityGrouping+0x40>)
90001776:	68db      	ldr	r3, [r3, #12]
90001778:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
9000177a:	68ba      	ldr	r2, [r7, #8]
9000177c:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
90001780:	4013      	ands	r3, r2
90001782:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
90001784:	68fb      	ldr	r3, [r7, #12]
90001786:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
90001788:	68bb      	ldr	r3, [r7, #8]
9000178a:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
9000178c:	4b06      	ldr	r3, [pc, #24]	@ (900017a8 <__NVIC_SetPriorityGrouping+0x44>)
9000178e:	4313      	orrs	r3, r2
90001790:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
90001792:	4a04      	ldr	r2, [pc, #16]	@ (900017a4 <__NVIC_SetPriorityGrouping+0x40>)
90001794:	68bb      	ldr	r3, [r7, #8]
90001796:	60d3      	str	r3, [r2, #12]
}
90001798:	bf00      	nop
9000179a:	3714      	adds	r7, #20
9000179c:	46bd      	mov	sp, r7
9000179e:	f85d 7b04 	ldr.w	r7, [sp], #4
900017a2:	4770      	bx	lr
900017a4:	e000ed00 	.word	0xe000ed00
900017a8:	05fa0000 	.word	0x05fa0000

900017ac <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
900017ac:	b480      	push	{r7}
900017ae:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
900017b0:	4b04      	ldr	r3, [pc, #16]	@ (900017c4 <__NVIC_GetPriorityGrouping+0x18>)
900017b2:	68db      	ldr	r3, [r3, #12]
900017b4:	0a1b      	lsrs	r3, r3, #8
900017b6:	f003 0307 	and.w	r3, r3, #7
}
900017ba:	4618      	mov	r0, r3
900017bc:	46bd      	mov	sp, r7
900017be:	f85d 7b04 	ldr.w	r7, [sp], #4
900017c2:	4770      	bx	lr
900017c4:	e000ed00 	.word	0xe000ed00

900017c8 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
900017c8:	b480      	push	{r7}
900017ca:	b083      	sub	sp, #12
900017cc:	af00      	add	r7, sp, #0
900017ce:	4603      	mov	r3, r0
900017d0:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
900017d2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
900017d6:	2b00      	cmp	r3, #0
900017d8:	db0b      	blt.n	900017f2 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
900017da:	88fb      	ldrh	r3, [r7, #6]
900017dc:	f003 021f 	and.w	r2, r3, #31
900017e0:	4907      	ldr	r1, [pc, #28]	@ (90001800 <__NVIC_EnableIRQ+0x38>)
900017e2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
900017e6:	095b      	lsrs	r3, r3, #5
900017e8:	2001      	movs	r0, #1
900017ea:	fa00 f202 	lsl.w	r2, r0, r2
900017ee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
900017f2:	bf00      	nop
900017f4:	370c      	adds	r7, #12
900017f6:	46bd      	mov	sp, r7
900017f8:	f85d 7b04 	ldr.w	r7, [sp], #4
900017fc:	4770      	bx	lr
900017fe:	bf00      	nop
90001800:	e000e100 	.word	0xe000e100

90001804 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
90001804:	b480      	push	{r7}
90001806:	b083      	sub	sp, #12
90001808:	af00      	add	r7, sp, #0
9000180a:	4603      	mov	r3, r0
9000180c:	6039      	str	r1, [r7, #0]
9000180e:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
90001810:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
90001814:	2b00      	cmp	r3, #0
90001816:	db0a      	blt.n	9000182e <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
90001818:	683b      	ldr	r3, [r7, #0]
9000181a:	b2da      	uxtb	r2, r3
9000181c:	490c      	ldr	r1, [pc, #48]	@ (90001850 <__NVIC_SetPriority+0x4c>)
9000181e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
90001822:	0112      	lsls	r2, r2, #4
90001824:	b2d2      	uxtb	r2, r2
90001826:	440b      	add	r3, r1
90001828:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
9000182c:	e00a      	b.n	90001844 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
9000182e:	683b      	ldr	r3, [r7, #0]
90001830:	b2da      	uxtb	r2, r3
90001832:	4908      	ldr	r1, [pc, #32]	@ (90001854 <__NVIC_SetPriority+0x50>)
90001834:	88fb      	ldrh	r3, [r7, #6]
90001836:	f003 030f 	and.w	r3, r3, #15
9000183a:	3b04      	subs	r3, #4
9000183c:	0112      	lsls	r2, r2, #4
9000183e:	b2d2      	uxtb	r2, r2
90001840:	440b      	add	r3, r1
90001842:	761a      	strb	r2, [r3, #24]
}
90001844:	bf00      	nop
90001846:	370c      	adds	r7, #12
90001848:	46bd      	mov	sp, r7
9000184a:	f85d 7b04 	ldr.w	r7, [sp], #4
9000184e:	4770      	bx	lr
90001850:	e000e100 	.word	0xe000e100
90001854:	e000ed00 	.word	0xe000ed00

90001858 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
90001858:	b480      	push	{r7}
9000185a:	b089      	sub	sp, #36	@ 0x24
9000185c:	af00      	add	r7, sp, #0
9000185e:	60f8      	str	r0, [r7, #12]
90001860:	60b9      	str	r1, [r7, #8]
90001862:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
90001864:	68fb      	ldr	r3, [r7, #12]
90001866:	f003 0307 	and.w	r3, r3, #7
9000186a:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
9000186c:	69fb      	ldr	r3, [r7, #28]
9000186e:	f1c3 0307 	rsb	r3, r3, #7
90001872:	2b04      	cmp	r3, #4
90001874:	bf28      	it	cs
90001876:	2304      	movcs	r3, #4
90001878:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
9000187a:	69fb      	ldr	r3, [r7, #28]
9000187c:	3304      	adds	r3, #4
9000187e:	2b06      	cmp	r3, #6
90001880:	d902      	bls.n	90001888 <NVIC_EncodePriority+0x30>
90001882:	69fb      	ldr	r3, [r7, #28]
90001884:	3b03      	subs	r3, #3
90001886:	e000      	b.n	9000188a <NVIC_EncodePriority+0x32>
90001888:	2300      	movs	r3, #0
9000188a:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
9000188c:	f04f 32ff 	mov.w	r2, #4294967295
90001890:	69bb      	ldr	r3, [r7, #24]
90001892:	fa02 f303 	lsl.w	r3, r2, r3
90001896:	43da      	mvns	r2, r3
90001898:	68bb      	ldr	r3, [r7, #8]
9000189a:	401a      	ands	r2, r3
9000189c:	697b      	ldr	r3, [r7, #20]
9000189e:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
900018a0:	f04f 31ff 	mov.w	r1, #4294967295
900018a4:	697b      	ldr	r3, [r7, #20]
900018a6:	fa01 f303 	lsl.w	r3, r1, r3
900018aa:	43d9      	mvns	r1, r3
900018ac:	687b      	ldr	r3, [r7, #4]
900018ae:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
900018b0:	4313      	orrs	r3, r2
         );
}
900018b2:	4618      	mov	r0, r3
900018b4:	3724      	adds	r7, #36	@ 0x24
900018b6:	46bd      	mov	sp, r7
900018b8:	f85d 7b04 	ldr.w	r7, [sp], #4
900018bc:	4770      	bx	lr
	...

900018c0 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
900018c0:	b580      	push	{r7, lr}
900018c2:	b082      	sub	sp, #8
900018c4:	af00      	add	r7, sp, #0
900018c6:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
900018c8:	687b      	ldr	r3, [r7, #4]
900018ca:	3b01      	subs	r3, #1
900018cc:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
900018d0:	d301      	bcc.n	900018d6 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
900018d2:	2301      	movs	r3, #1
900018d4:	e00f      	b.n	900018f6 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
900018d6:	4a0a      	ldr	r2, [pc, #40]	@ (90001900 <SysTick_Config+0x40>)
900018d8:	687b      	ldr	r3, [r7, #4]
900018da:	3b01      	subs	r3, #1
900018dc:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
900018de:	210f      	movs	r1, #15
900018e0:	f04f 30ff 	mov.w	r0, #4294967295
900018e4:	f7ff ff8e 	bl	90001804 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
900018e8:	4b05      	ldr	r3, [pc, #20]	@ (90001900 <SysTick_Config+0x40>)
900018ea:	2200      	movs	r2, #0
900018ec:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
900018ee:	4b04      	ldr	r3, [pc, #16]	@ (90001900 <SysTick_Config+0x40>)
900018f0:	2207      	movs	r2, #7
900018f2:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
900018f4:	2300      	movs	r3, #0
}
900018f6:	4618      	mov	r0, r3
900018f8:	3708      	adds	r7, #8
900018fa:	46bd      	mov	sp, r7
900018fc:	bd80      	pop	{r7, pc}
900018fe:	bf00      	nop
90001900:	e000e010 	.word	0xe000e010

90001904 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
90001904:	b580      	push	{r7, lr}
90001906:	b082      	sub	sp, #8
90001908:	af00      	add	r7, sp, #0
9000190a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
9000190c:	6878      	ldr	r0, [r7, #4]
9000190e:	f7ff ff29 	bl	90001764 <__NVIC_SetPriorityGrouping>
}
90001912:	bf00      	nop
90001914:	3708      	adds	r7, #8
90001916:	46bd      	mov	sp, r7
90001918:	bd80      	pop	{r7, pc}

9000191a <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
9000191a:	b580      	push	{r7, lr}
9000191c:	b086      	sub	sp, #24
9000191e:	af00      	add	r7, sp, #0
90001920:	4603      	mov	r3, r0
90001922:	60b9      	str	r1, [r7, #8]
90001924:	607a      	str	r2, [r7, #4]
90001926:	81fb      	strh	r3, [r7, #14]
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_PRIO_INTERRUPT(IRQn));
  prioritygroup = NVIC_GetPriorityGrouping();
90001928:	f7ff ff40 	bl	900017ac <__NVIC_GetPriorityGrouping>
9000192c:	6178      	str	r0, [r7, #20]
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority, prioritygroup));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority, prioritygroup));

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
9000192e:	687a      	ldr	r2, [r7, #4]
90001930:	68b9      	ldr	r1, [r7, #8]
90001932:	6978      	ldr	r0, [r7, #20]
90001934:	f7ff ff90 	bl	90001858 <NVIC_EncodePriority>
90001938:	4602      	mov	r2, r0
9000193a:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
9000193e:	4611      	mov	r1, r2
90001940:	4618      	mov	r0, r3
90001942:	f7ff ff5f 	bl	90001804 <__NVIC_SetPriority>
}
90001946:	bf00      	nop
90001948:	3718      	adds	r7, #24
9000194a:	46bd      	mov	sp, r7
9000194c:	bd80      	pop	{r7, pc}

9000194e <HAL_NVIC_EnableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer
  *         to the appropriate CMSIS device file (stm32h7rsxxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
9000194e:	b580      	push	{r7, lr}
90001950:	b082      	sub	sp, #8
90001952:	af00      	add	r7, sp, #0
90001954:	4603      	mov	r3, r0
90001956:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
90001958:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
9000195c:	4618      	mov	r0, r3
9000195e:	f7ff ff33 	bl	900017c8 <__NVIC_EnableIRQ>
}
90001962:	bf00      	nop
90001964:	3708      	adds	r7, #8
90001966:	46bd      	mov	sp, r7
90001968:	bd80      	pop	{r7, pc}

9000196a <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
9000196a:	b580      	push	{r7, lr}
9000196c:	b082      	sub	sp, #8
9000196e:	af00      	add	r7, sp, #0
90001970:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
90001972:	6878      	ldr	r0, [r7, #4]
90001974:	f7ff ffa4 	bl	900018c0 <SysTick_Config>
90001978:	4603      	mov	r3, r0
}
9000197a:	4618      	mov	r0, r3
9000197c:	3708      	adds	r7, #8
9000197e:	46bd      	mov	sp, r7
90001980:	bd80      	pop	{r7, pc}
	...

90001984 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
90001984:	b480      	push	{r7}
90001986:	b087      	sub	sp, #28
90001988:	af00      	add	r7, sp, #0
9000198a:	6078      	str	r0, [r7, #4]
9000198c:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
9000198e:	2300      	movs	r3, #0
90001990:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
90001992:	e143      	b.n	90001c1c <HAL_GPIO_Init+0x298>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
90001994:	683b      	ldr	r3, [r7, #0]
90001996:	681a      	ldr	r2, [r3, #0]
90001998:	2101      	movs	r1, #1
9000199a:	697b      	ldr	r3, [r7, #20]
9000199c:	fa01 f303 	lsl.w	r3, r1, r3
900019a0:	4013      	ands	r3, r2
900019a2:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00U)
900019a4:	68fb      	ldr	r3, [r7, #12]
900019a6:	2b00      	cmp	r3, #0
900019a8:	f000 8135 	beq.w	90001c16 <HAL_GPIO_Init+0x292>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
900019ac:	683b      	ldr	r3, [r7, #0]
900019ae:	685b      	ldr	r3, [r3, #4]
900019b0:	f003 0303 	and.w	r3, r3, #3
900019b4:	2b01      	cmp	r3, #1
900019b6:	d005      	beq.n	900019c4 <HAL_GPIO_Init+0x40>
900019b8:	683b      	ldr	r3, [r7, #0]
900019ba:	685b      	ldr	r3, [r3, #4]
900019bc:	f003 0303 	and.w	r3, r3, #3
900019c0:	2b02      	cmp	r3, #2
900019c2:	d130      	bne.n	90001a26 <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
900019c4:	687b      	ldr	r3, [r7, #4]
900019c6:	689b      	ldr	r3, [r3, #8]
900019c8:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
900019ca:	697b      	ldr	r3, [r7, #20]
900019cc:	005b      	lsls	r3, r3, #1
900019ce:	2203      	movs	r2, #3
900019d0:	fa02 f303 	lsl.w	r3, r2, r3
900019d4:	43db      	mvns	r3, r3
900019d6:	693a      	ldr	r2, [r7, #16]
900019d8:	4013      	ands	r3, r2
900019da:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
900019dc:	683b      	ldr	r3, [r7, #0]
900019de:	68da      	ldr	r2, [r3, #12]
900019e0:	697b      	ldr	r3, [r7, #20]
900019e2:	005b      	lsls	r3, r3, #1
900019e4:	fa02 f303 	lsl.w	r3, r2, r3
900019e8:	693a      	ldr	r2, [r7, #16]
900019ea:	4313      	orrs	r3, r2
900019ec:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
900019ee:	687b      	ldr	r3, [r7, #4]
900019f0:	693a      	ldr	r2, [r7, #16]
900019f2:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
900019f4:	687b      	ldr	r3, [r7, #4]
900019f6:	685b      	ldr	r3, [r3, #4]
900019f8:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
900019fa:	2201      	movs	r2, #1
900019fc:	697b      	ldr	r3, [r7, #20]
900019fe:	fa02 f303 	lsl.w	r3, r2, r3
90001a02:	43db      	mvns	r3, r3
90001a04:	693a      	ldr	r2, [r7, #16]
90001a06:	4013      	ands	r3, r2
90001a08:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
90001a0a:	683b      	ldr	r3, [r7, #0]
90001a0c:	685b      	ldr	r3, [r3, #4]
90001a0e:	091b      	lsrs	r3, r3, #4
90001a10:	f003 0201 	and.w	r2, r3, #1
90001a14:	697b      	ldr	r3, [r7, #20]
90001a16:	fa02 f303 	lsl.w	r3, r2, r3
90001a1a:	693a      	ldr	r2, [r7, #16]
90001a1c:	4313      	orrs	r3, r2
90001a1e:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
90001a20:	687b      	ldr	r3, [r7, #4]
90001a22:	693a      	ldr	r2, [r7, #16]
90001a24:	605a      	str	r2, [r3, #4]
      }

      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
90001a26:	683b      	ldr	r3, [r7, #0]
90001a28:	685b      	ldr	r3, [r3, #4]
90001a2a:	f003 0303 	and.w	r3, r3, #3
90001a2e:	2b03      	cmp	r3, #3
90001a30:	d109      	bne.n	90001a46 <HAL_GPIO_Init+0xc2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
90001a32:	683b      	ldr	r3, [r7, #0]
90001a34:	685b      	ldr	r3, [r3, #4]
90001a36:	f003 0303 	and.w	r3, r3, #3
      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
90001a3a:	2b03      	cmp	r3, #3
90001a3c:	d11b      	bne.n	90001a76 <HAL_GPIO_Init+0xf2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
90001a3e:	683b      	ldr	r3, [r7, #0]
90001a40:	689b      	ldr	r3, [r3, #8]
90001a42:	2b01      	cmp	r3, #1
90001a44:	d017      	beq.n	90001a76 <HAL_GPIO_Init+0xf2>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
90001a46:	687b      	ldr	r3, [r7, #4]
90001a48:	68db      	ldr	r3, [r3, #12]
90001a4a:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
90001a4c:	697b      	ldr	r3, [r7, #20]
90001a4e:	005b      	lsls	r3, r3, #1
90001a50:	2203      	movs	r2, #3
90001a52:	fa02 f303 	lsl.w	r3, r2, r3
90001a56:	43db      	mvns	r3, r3
90001a58:	693a      	ldr	r2, [r7, #16]
90001a5a:	4013      	ands	r3, r2
90001a5c:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
90001a5e:	683b      	ldr	r3, [r7, #0]
90001a60:	689a      	ldr	r2, [r3, #8]
90001a62:	697b      	ldr	r3, [r7, #20]
90001a64:	005b      	lsls	r3, r3, #1
90001a66:	fa02 f303 	lsl.w	r3, r2, r3
90001a6a:	693a      	ldr	r2, [r7, #16]
90001a6c:	4313      	orrs	r3, r2
90001a6e:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
90001a70:	687b      	ldr	r3, [r7, #4]
90001a72:	693a      	ldr	r2, [r7, #16]
90001a74:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
90001a76:	683b      	ldr	r3, [r7, #0]
90001a78:	685b      	ldr	r3, [r3, #4]
90001a7a:	f003 0303 	and.w	r3, r3, #3
90001a7e:	2b02      	cmp	r3, #2
90001a80:	d123      	bne.n	90001aca <HAL_GPIO_Init+0x146>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
90001a82:	697b      	ldr	r3, [r7, #20]
90001a84:	08da      	lsrs	r2, r3, #3
90001a86:	687b      	ldr	r3, [r7, #4]
90001a88:	3208      	adds	r2, #8
90001a8a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
90001a8e:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFuL << ((position & 0x07U) * GPIO_AFRL_AFSEL1_Pos));
90001a90:	697b      	ldr	r3, [r7, #20]
90001a92:	f003 0307 	and.w	r3, r3, #7
90001a96:	009b      	lsls	r3, r3, #2
90001a98:	220f      	movs	r2, #15
90001a9a:	fa02 f303 	lsl.w	r3, r2, r3
90001a9e:	43db      	mvns	r3, r3
90001aa0:	693a      	ldr	r2, [r7, #16]
90001aa2:	4013      	ands	r3, r2
90001aa4:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * GPIO_AFRL_AFSEL1_Pos));
90001aa6:	683b      	ldr	r3, [r7, #0]
90001aa8:	691a      	ldr	r2, [r3, #16]
90001aaa:	697b      	ldr	r3, [r7, #20]
90001aac:	f003 0307 	and.w	r3, r3, #7
90001ab0:	009b      	lsls	r3, r3, #2
90001ab2:	fa02 f303 	lsl.w	r3, r2, r3
90001ab6:	693a      	ldr	r2, [r7, #16]
90001ab8:	4313      	orrs	r3, r2
90001aba:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3U] = temp;
90001abc:	697b      	ldr	r3, [r7, #20]
90001abe:	08da      	lsrs	r2, r3, #3
90001ac0:	687b      	ldr	r3, [r7, #4]
90001ac2:	3208      	adds	r2, #8
90001ac4:	6939      	ldr	r1, [r7, #16]
90001ac6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
90001aca:	687b      	ldr	r3, [r7, #4]
90001acc:	681b      	ldr	r3, [r3, #0]
90001ace:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
90001ad0:	697b      	ldr	r3, [r7, #20]
90001ad2:	005b      	lsls	r3, r3, #1
90001ad4:	2203      	movs	r2, #3
90001ad6:	fa02 f303 	lsl.w	r3, r2, r3
90001ada:	43db      	mvns	r3, r3
90001adc:	693a      	ldr	r2, [r7, #16]
90001ade:	4013      	ands	r3, r2
90001ae0:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
90001ae2:	683b      	ldr	r3, [r7, #0]
90001ae4:	685b      	ldr	r3, [r3, #4]
90001ae6:	f003 0203 	and.w	r2, r3, #3
90001aea:	697b      	ldr	r3, [r7, #20]
90001aec:	005b      	lsls	r3, r3, #1
90001aee:	fa02 f303 	lsl.w	r3, r2, r3
90001af2:	693a      	ldr	r2, [r7, #16]
90001af4:	4313      	orrs	r3, r2
90001af6:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
90001af8:	687b      	ldr	r3, [r7, #4]
90001afa:	693a      	ldr	r2, [r7, #16]
90001afc:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
90001afe:	683b      	ldr	r3, [r7, #0]
90001b00:	685b      	ldr	r3, [r3, #4]
90001b02:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
90001b06:	2b00      	cmp	r3, #0
90001b08:	f000 8085 	beq.w	90001c16 <HAL_GPIO_Init+0x292>
      {
        temp = SBS->EXTICR[position >> 2U];
90001b0c:	4a4b      	ldr	r2, [pc, #300]	@ (90001c3c <HAL_GPIO_Init+0x2b8>)
90001b0e:	697b      	ldr	r3, [r7, #20]
90001b10:	089b      	lsrs	r3, r3, #2
90001b12:	334c      	adds	r3, #76	@ 0x4c
90001b14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
90001b18:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << ((position & 0x03U) * SBS_EXTICR1_PC_EXTI1_Pos));
90001b1a:	697b      	ldr	r3, [r7, #20]
90001b1c:	f003 0303 	and.w	r3, r3, #3
90001b20:	009b      	lsls	r3, r3, #2
90001b22:	220f      	movs	r2, #15
90001b24:	fa02 f303 	lsl.w	r3, r2, r3
90001b28:	43db      	mvns	r3, r3
90001b2a:	693a      	ldr	r2, [r7, #16]
90001b2c:	4013      	ands	r3, r2
90001b2e:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03U) * SBS_EXTICR1_PC_EXTI1_Pos));
90001b30:	687b      	ldr	r3, [r7, #4]
90001b32:	0a9a      	lsrs	r2, r3, #10
90001b34:	4b42      	ldr	r3, [pc, #264]	@ (90001c40 <HAL_GPIO_Init+0x2bc>)
90001b36:	4013      	ands	r3, r2
90001b38:	697a      	ldr	r2, [r7, #20]
90001b3a:	f002 0203 	and.w	r2, r2, #3
90001b3e:	0092      	lsls	r2, r2, #2
90001b40:	4093      	lsls	r3, r2
90001b42:	693a      	ldr	r2, [r7, #16]
90001b44:	4313      	orrs	r3, r2
90001b46:	613b      	str	r3, [r7, #16]
        SBS->EXTICR[position >> 2U] = temp;
90001b48:	493c      	ldr	r1, [pc, #240]	@ (90001c3c <HAL_GPIO_Init+0x2b8>)
90001b4a:	697b      	ldr	r3, [r7, #20]
90001b4c:	089b      	lsrs	r3, r3, #2
90001b4e:	334c      	adds	r3, #76	@ 0x4c
90001b50:	693a      	ldr	r2, [r7, #16]
90001b52:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
90001b56:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
90001b5a:	681b      	ldr	r3, [r3, #0]
90001b5c:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
90001b5e:	68fb      	ldr	r3, [r7, #12]
90001b60:	43db      	mvns	r3, r3
90001b62:	693a      	ldr	r2, [r7, #16]
90001b64:	4013      	ands	r3, r2
90001b66:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
90001b68:	683b      	ldr	r3, [r7, #0]
90001b6a:	685b      	ldr	r3, [r3, #4]
90001b6c:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
90001b70:	2b00      	cmp	r3, #0
90001b72:	d003      	beq.n	90001b7c <HAL_GPIO_Init+0x1f8>
        {
          temp |= iocurrent;
90001b74:	693a      	ldr	r2, [r7, #16]
90001b76:	68fb      	ldr	r3, [r7, #12]
90001b78:	4313      	orrs	r3, r2
90001b7a:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
90001b7c:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
90001b80:	693b      	ldr	r3, [r7, #16]
90001b82:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
90001b84:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
90001b88:	685b      	ldr	r3, [r3, #4]
90001b8a:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
90001b8c:	68fb      	ldr	r3, [r7, #12]
90001b8e:	43db      	mvns	r3, r3
90001b90:	693a      	ldr	r2, [r7, #16]
90001b92:	4013      	ands	r3, r2
90001b94:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
90001b96:	683b      	ldr	r3, [r7, #0]
90001b98:	685b      	ldr	r3, [r3, #4]
90001b9a:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
90001b9e:	2b00      	cmp	r3, #0
90001ba0:	d003      	beq.n	90001baa <HAL_GPIO_Init+0x226>
        {
          temp |= iocurrent;
90001ba2:	693a      	ldr	r2, [r7, #16]
90001ba4:	68fb      	ldr	r3, [r7, #12]
90001ba6:	4313      	orrs	r3, r2
90001ba8:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
90001baa:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
90001bae:	693b      	ldr	r3, [r7, #16]
90001bb0:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->EMR1;
90001bb2:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
90001bb6:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
90001bba:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
90001bbc:	68fb      	ldr	r3, [r7, #12]
90001bbe:	43db      	mvns	r3, r3
90001bc0:	693a      	ldr	r2, [r7, #16]
90001bc2:	4013      	ands	r3, r2
90001bc4:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
90001bc6:	683b      	ldr	r3, [r7, #0]
90001bc8:	685b      	ldr	r3, [r3, #4]
90001bca:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
90001bce:	2b00      	cmp	r3, #0
90001bd0:	d003      	beq.n	90001bda <HAL_GPIO_Init+0x256>
        {
          temp |= iocurrent;
90001bd2:	693a      	ldr	r2, [r7, #16]
90001bd4:	68fb      	ldr	r3, [r7, #12]
90001bd6:	4313      	orrs	r3, r2
90001bd8:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
90001bda:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
90001bde:	693b      	ldr	r3, [r7, #16]
90001be0:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84

        temp = EXTI->IMR1;
90001be4:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
90001be8:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
90001bec:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
90001bee:	68fb      	ldr	r3, [r7, #12]
90001bf0:	43db      	mvns	r3, r3
90001bf2:	693a      	ldr	r2, [r7, #16]
90001bf4:	4013      	ands	r3, r2
90001bf6:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
90001bf8:	683b      	ldr	r3, [r7, #0]
90001bfa:	685b      	ldr	r3, [r3, #4]
90001bfc:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
90001c00:	2b00      	cmp	r3, #0
90001c02:	d003      	beq.n	90001c0c <HAL_GPIO_Init+0x288>
        {
          temp |= iocurrent;
90001c04:	693a      	ldr	r2, [r7, #16]
90001c06:	68fb      	ldr	r3, [r7, #12]
90001c08:	4313      	orrs	r3, r2
90001c0a:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
90001c0c:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
90001c10:	693b      	ldr	r3, [r7, #16]
90001c12:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
      }
    }

    position++;
90001c16:	697b      	ldr	r3, [r7, #20]
90001c18:	3301      	adds	r3, #1
90001c1a:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00U)
90001c1c:	683b      	ldr	r3, [r7, #0]
90001c1e:	681a      	ldr	r2, [r3, #0]
90001c20:	697b      	ldr	r3, [r7, #20]
90001c22:	fa22 f303 	lsr.w	r3, r2, r3
90001c26:	2b00      	cmp	r3, #0
90001c28:	f47f aeb4 	bne.w	90001994 <HAL_GPIO_Init+0x10>
  }
}
90001c2c:	bf00      	nop
90001c2e:	bf00      	nop
90001c30:	371c      	adds	r7, #28
90001c32:	46bd      	mov	sp, r7
90001c34:	f85d 7b04 	ldr.w	r7, [sp], #4
90001c38:	4770      	bx	lr
90001c3a:	bf00      	nop
90001c3c:	58000400 	.word	0x58000400
90001c40:	0029ff7f 	.word	0x0029ff7f

90001c44 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin specifies the port bit to read.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(const GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
90001c44:	b480      	push	{r7}
90001c46:	b085      	sub	sp, #20
90001c48:	af00      	add	r7, sp, #0
90001c4a:	6078      	str	r0, [r7, #4]
90001c4c:	460b      	mov	r3, r1
90001c4e:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00U)
90001c50:	687b      	ldr	r3, [r7, #4]
90001c52:	691a      	ldr	r2, [r3, #16]
90001c54:	887b      	ldrh	r3, [r7, #2]
90001c56:	4013      	ands	r3, r2
90001c58:	2b00      	cmp	r3, #0
90001c5a:	d002      	beq.n	90001c62 <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
90001c5c:	2301      	movs	r3, #1
90001c5e:	73fb      	strb	r3, [r7, #15]
90001c60:	e001      	b.n	90001c66 <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
90001c62:	2300      	movs	r3, #0
90001c64:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
90001c66:	7bfb      	ldrb	r3, [r7, #15]
}
90001c68:	4618      	mov	r0, r3
90001c6a:	3714      	adds	r7, #20
90001c6c:	46bd      	mov	sp, r7
90001c6e:	f85d 7b04 	ldr.w	r7, [sp], #4
90001c72:	4770      	bx	lr

90001c74 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
90001c74:	b480      	push	{r7}
90001c76:	b083      	sub	sp, #12
90001c78:	af00      	add	r7, sp, #0
90001c7a:	6078      	str	r0, [r7, #4]
90001c7c:	460b      	mov	r3, r1
90001c7e:	807b      	strh	r3, [r7, #2]
90001c80:	4613      	mov	r3, r2
90001c82:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
90001c84:	787b      	ldrb	r3, [r7, #1]
90001c86:	2b00      	cmp	r3, #0
90001c88:	d003      	beq.n	90001c92 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
90001c8a:	887a      	ldrh	r2, [r7, #2]
90001c8c:	687b      	ldr	r3, [r7, #4]
90001c8e:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
90001c90:	e002      	b.n	90001c98 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
90001c92:	887a      	ldrh	r2, [r7, #2]
90001c94:	687b      	ldr	r3, [r7, #4]
90001c96:	629a      	str	r2, [r3, #40]	@ 0x28
}
90001c98:	bf00      	nop
90001c9a:	370c      	adds	r7, #12
90001c9c:	46bd      	mov	sp, r7
90001c9e:	f85d 7b04 	ldr.w	r7, [sp], #4
90001ca2:	4770      	bx	lr

90001ca4 <HAL_GPIO_TogglePin>:
  * @param  GPIO_Pin specifies the pin to be toggled.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
90001ca4:	b480      	push	{r7}
90001ca6:	b085      	sub	sp, #20
90001ca8:	af00      	add	r7, sp, #0
90001caa:	6078      	str	r0, [r7, #4]
90001cac:	460b      	mov	r3, r1
90001cae:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
90001cb0:	687b      	ldr	r3, [r7, #4]
90001cb2:	695b      	ldr	r3, [r3, #20]
90001cb4:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
90001cb6:	887a      	ldrh	r2, [r7, #2]
90001cb8:	68fb      	ldr	r3, [r7, #12]
90001cba:	4013      	ands	r3, r2
90001cbc:	041a      	lsls	r2, r3, #16
90001cbe:	68fb      	ldr	r3, [r7, #12]
90001cc0:	43d9      	mvns	r1, r3
90001cc2:	887b      	ldrh	r3, [r7, #2]
90001cc4:	400b      	ands	r3, r1
90001cc6:	431a      	orrs	r2, r3
90001cc8:	687b      	ldr	r3, [r7, #4]
90001cca:	619a      	str	r2, [r3, #24]
}
90001ccc:	bf00      	nop
90001cce:	3714      	adds	r7, #20
90001cd0:	46bd      	mov	sp, r7
90001cd2:	f85d 7b04 	ldr.w	r7, [sp], #4
90001cd6:	4770      	bx	lr

90001cd8 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
90001cd8:	b580      	push	{r7, lr}
90001cda:	b086      	sub	sp, #24
90001cdc:	af02      	add	r7, sp, #8
90001cde:	6078      	str	r0, [r7, #4]
  const USB_OTG_GlobalTypeDef *USBx;
#endif /* defined (USB_OTG_FS) */
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
90001ce0:	687b      	ldr	r3, [r7, #4]
90001ce2:	2b00      	cmp	r3, #0
90001ce4:	d101      	bne.n	90001cea <HAL_PCD_Init+0x12>
  {
    return HAL_ERROR;
90001ce6:	2301      	movs	r3, #1
90001ce8:	e108      	b.n	90001efc <HAL_PCD_Init+0x224>

  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

#if defined (USB_OTG_FS)
  USBx = hpcd->Instance;
90001cea:	687b      	ldr	r3, [r7, #4]
90001cec:	681b      	ldr	r3, [r3, #0]
90001cee:	60bb      	str	r3, [r7, #8]
#endif /* defined (USB_OTG_FS) */

  if (hpcd->State == HAL_PCD_STATE_RESET)
90001cf0:	687b      	ldr	r3, [r7, #4]
90001cf2:	f893 3495 	ldrb.w	r3, [r3, #1173]	@ 0x495
90001cf6:	b2db      	uxtb	r3, r3
90001cf8:	2b00      	cmp	r3, #0
90001cfa:	d106      	bne.n	90001d0a <HAL_PCD_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
90001cfc:	687b      	ldr	r3, [r7, #4]
90001cfe:	2200      	movs	r2, #0
90001d00:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

    /* Init the low level hardware */
    hpcd->MspInitCallback(hpcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
90001d04:	6878      	ldr	r0, [r7, #4]
90001d06:	f7fe ffe9 	bl	90000cdc <HAL_PCD_MspInit>
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
90001d0a:	687b      	ldr	r3, [r7, #4]
90001d0c:	2203      	movs	r2, #3
90001d0e:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495

#if defined (USB_OTG_FS)
  /* Disable DMA mode for FS instance */
  if (USBx == USB_OTG_FS)
90001d12:	68bb      	ldr	r3, [r7, #8]
90001d14:	4a7b      	ldr	r2, [pc, #492]	@ (90001f04 <HAL_PCD_Init+0x22c>)
90001d16:	4293      	cmp	r3, r2
90001d18:	d102      	bne.n	90001d20 <HAL_PCD_Init+0x48>
  {
    hpcd->Init.dma_enable = 0U;
90001d1a:	687b      	ldr	r3, [r7, #4]
90001d1c:	2200      	movs	r2, #0
90001d1e:	719a      	strb	r2, [r3, #6]
  }
#endif /* defined (USB_OTG_FS) */

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
90001d20:	687b      	ldr	r3, [r7, #4]
90001d22:	681b      	ldr	r3, [r3, #0]
90001d24:	4618      	mov	r0, r3
90001d26:	f006 ffe4 	bl	90008cf2 <USB_DisableGlobalInt>

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
90001d2a:	687b      	ldr	r3, [r7, #4]
90001d2c:	6818      	ldr	r0, [r3, #0]
90001d2e:	687b      	ldr	r3, [r7, #4]
90001d30:	7c1a      	ldrb	r2, [r3, #16]
90001d32:	f88d 2000 	strb.w	r2, [sp]
90001d36:	3304      	adds	r3, #4
90001d38:	cb0e      	ldmia	r3, {r1, r2, r3}
90001d3a:	f006 fec1 	bl	90008ac0 <USB_CoreInit>
90001d3e:	4603      	mov	r3, r0
90001d40:	2b00      	cmp	r3, #0
90001d42:	d005      	beq.n	90001d50 <HAL_PCD_Init+0x78>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
90001d44:	687b      	ldr	r3, [r7, #4]
90001d46:	2202      	movs	r2, #2
90001d48:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
90001d4c:	2301      	movs	r3, #1
90001d4e:	e0d5      	b.n	90001efc <HAL_PCD_Init+0x224>
  }

  /* Force Device Mode */
  if (USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE) != HAL_OK)
90001d50:	687b      	ldr	r3, [r7, #4]
90001d52:	681b      	ldr	r3, [r3, #0]
90001d54:	2100      	movs	r1, #0
90001d56:	4618      	mov	r0, r3
90001d58:	f006 ffdc 	bl	90008d14 <USB_SetCurrentMode>
90001d5c:	4603      	mov	r3, r0
90001d5e:	2b00      	cmp	r3, #0
90001d60:	d005      	beq.n	90001d6e <HAL_PCD_Init+0x96>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
90001d62:	687b      	ldr	r3, [r7, #4]
90001d64:	2202      	movs	r2, #2
90001d66:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
90001d6a:	2301      	movs	r3, #1
90001d6c:	e0c6      	b.n	90001efc <HAL_PCD_Init+0x224>
  }

  /* Init endpoints structures */
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
90001d6e:	2300      	movs	r3, #0
90001d70:	73fb      	strb	r3, [r7, #15]
90001d72:	e04a      	b.n	90001e0a <HAL_PCD_Init+0x132>
  {
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1U;
90001d74:	7bfa      	ldrb	r2, [r7, #15]
90001d76:	6879      	ldr	r1, [r7, #4]
90001d78:	4613      	mov	r3, r2
90001d7a:	00db      	lsls	r3, r3, #3
90001d7c:	4413      	add	r3, r2
90001d7e:	009b      	lsls	r3, r3, #2
90001d80:	440b      	add	r3, r1
90001d82:	3315      	adds	r3, #21
90001d84:	2201      	movs	r2, #1
90001d86:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].num = i;
90001d88:	7bfa      	ldrb	r2, [r7, #15]
90001d8a:	6879      	ldr	r1, [r7, #4]
90001d8c:	4613      	mov	r3, r2
90001d8e:	00db      	lsls	r3, r3, #3
90001d90:	4413      	add	r3, r2
90001d92:	009b      	lsls	r3, r3, #2
90001d94:	440b      	add	r3, r1
90001d96:	3314      	adds	r3, #20
90001d98:	7bfa      	ldrb	r2, [r7, #15]
90001d9a:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].tx_fifo_num = i;
90001d9c:	7bfa      	ldrb	r2, [r7, #15]
90001d9e:	7bfb      	ldrb	r3, [r7, #15]
90001da0:	b298      	uxth	r0, r3
90001da2:	6879      	ldr	r1, [r7, #4]
90001da4:	4613      	mov	r3, r2
90001da6:	00db      	lsls	r3, r3, #3
90001da8:	4413      	add	r3, r2
90001daa:	009b      	lsls	r3, r3, #2
90001dac:	440b      	add	r3, r1
90001dae:	332e      	adds	r3, #46	@ 0x2e
90001db0:	4602      	mov	r2, r0
90001db2:	801a      	strh	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
90001db4:	7bfa      	ldrb	r2, [r7, #15]
90001db6:	6879      	ldr	r1, [r7, #4]
90001db8:	4613      	mov	r3, r2
90001dba:	00db      	lsls	r3, r3, #3
90001dbc:	4413      	add	r3, r2
90001dbe:	009b      	lsls	r3, r3, #2
90001dc0:	440b      	add	r3, r1
90001dc2:	3318      	adds	r3, #24
90001dc4:	2200      	movs	r2, #0
90001dc6:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].maxpacket = 0U;
90001dc8:	7bfa      	ldrb	r2, [r7, #15]
90001dca:	6879      	ldr	r1, [r7, #4]
90001dcc:	4613      	mov	r3, r2
90001dce:	00db      	lsls	r3, r3, #3
90001dd0:	4413      	add	r3, r2
90001dd2:	009b      	lsls	r3, r3, #2
90001dd4:	440b      	add	r3, r1
90001dd6:	331c      	adds	r3, #28
90001dd8:	2200      	movs	r2, #0
90001dda:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_buff = 0U;
90001ddc:	7bfa      	ldrb	r2, [r7, #15]
90001dde:	6879      	ldr	r1, [r7, #4]
90001de0:	4613      	mov	r3, r2
90001de2:	00db      	lsls	r3, r3, #3
90001de4:	4413      	add	r3, r2
90001de6:	009b      	lsls	r3, r3, #2
90001de8:	440b      	add	r3, r1
90001dea:	3320      	adds	r3, #32
90001dec:	2200      	movs	r2, #0
90001dee:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_len = 0U;
90001df0:	7bfa      	ldrb	r2, [r7, #15]
90001df2:	6879      	ldr	r1, [r7, #4]
90001df4:	4613      	mov	r3, r2
90001df6:	00db      	lsls	r3, r3, #3
90001df8:	4413      	add	r3, r2
90001dfa:	009b      	lsls	r3, r3, #2
90001dfc:	440b      	add	r3, r1
90001dfe:	3324      	adds	r3, #36	@ 0x24
90001e00:	2200      	movs	r2, #0
90001e02:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
90001e04:	7bfb      	ldrb	r3, [r7, #15]
90001e06:	3301      	adds	r3, #1
90001e08:	73fb      	strb	r3, [r7, #15]
90001e0a:	687b      	ldr	r3, [r7, #4]
90001e0c:	791b      	ldrb	r3, [r3, #4]
90001e0e:	7bfa      	ldrb	r2, [r7, #15]
90001e10:	429a      	cmp	r2, r3
90001e12:	d3af      	bcc.n	90001d74 <HAL_PCD_Init+0x9c>
  }

  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
90001e14:	2300      	movs	r3, #0
90001e16:	73fb      	strb	r3, [r7, #15]
90001e18:	e044      	b.n	90001ea4 <HAL_PCD_Init+0x1cc>
  {
    hpcd->OUT_ep[i].is_in = 0U;
90001e1a:	7bfa      	ldrb	r2, [r7, #15]
90001e1c:	6879      	ldr	r1, [r7, #4]
90001e1e:	4613      	mov	r3, r2
90001e20:	00db      	lsls	r3, r3, #3
90001e22:	4413      	add	r3, r2
90001e24:	009b      	lsls	r3, r3, #2
90001e26:	440b      	add	r3, r1
90001e28:	f203 2355 	addw	r3, r3, #597	@ 0x255
90001e2c:	2200      	movs	r2, #0
90001e2e:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].num = i;
90001e30:	7bfa      	ldrb	r2, [r7, #15]
90001e32:	6879      	ldr	r1, [r7, #4]
90001e34:	4613      	mov	r3, r2
90001e36:	00db      	lsls	r3, r3, #3
90001e38:	4413      	add	r3, r2
90001e3a:	009b      	lsls	r3, r3, #2
90001e3c:	440b      	add	r3, r1
90001e3e:	f503 7315 	add.w	r3, r3, #596	@ 0x254
90001e42:	7bfa      	ldrb	r2, [r7, #15]
90001e44:	701a      	strb	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
90001e46:	7bfa      	ldrb	r2, [r7, #15]
90001e48:	6879      	ldr	r1, [r7, #4]
90001e4a:	4613      	mov	r3, r2
90001e4c:	00db      	lsls	r3, r3, #3
90001e4e:	4413      	add	r3, r2
90001e50:	009b      	lsls	r3, r3, #2
90001e52:	440b      	add	r3, r1
90001e54:	f503 7316 	add.w	r3, r3, #600	@ 0x258
90001e58:	2200      	movs	r2, #0
90001e5a:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].maxpacket = 0U;
90001e5c:	7bfa      	ldrb	r2, [r7, #15]
90001e5e:	6879      	ldr	r1, [r7, #4]
90001e60:	4613      	mov	r3, r2
90001e62:	00db      	lsls	r3, r3, #3
90001e64:	4413      	add	r3, r2
90001e66:	009b      	lsls	r3, r3, #2
90001e68:	440b      	add	r3, r1
90001e6a:	f503 7317 	add.w	r3, r3, #604	@ 0x25c
90001e6e:	2200      	movs	r2, #0
90001e70:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_buff = 0U;
90001e72:	7bfa      	ldrb	r2, [r7, #15]
90001e74:	6879      	ldr	r1, [r7, #4]
90001e76:	4613      	mov	r3, r2
90001e78:	00db      	lsls	r3, r3, #3
90001e7a:	4413      	add	r3, r2
90001e7c:	009b      	lsls	r3, r3, #2
90001e7e:	440b      	add	r3, r1
90001e80:	f503 7318 	add.w	r3, r3, #608	@ 0x260
90001e84:	2200      	movs	r2, #0
90001e86:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_len = 0U;
90001e88:	7bfa      	ldrb	r2, [r7, #15]
90001e8a:	6879      	ldr	r1, [r7, #4]
90001e8c:	4613      	mov	r3, r2
90001e8e:	00db      	lsls	r3, r3, #3
90001e90:	4413      	add	r3, r2
90001e92:	009b      	lsls	r3, r3, #2
90001e94:	440b      	add	r3, r1
90001e96:	f503 7319 	add.w	r3, r3, #612	@ 0x264
90001e9a:	2200      	movs	r2, #0
90001e9c:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
90001e9e:	7bfb      	ldrb	r3, [r7, #15]
90001ea0:	3301      	adds	r3, #1
90001ea2:	73fb      	strb	r3, [r7, #15]
90001ea4:	687b      	ldr	r3, [r7, #4]
90001ea6:	791b      	ldrb	r3, [r3, #4]
90001ea8:	7bfa      	ldrb	r2, [r7, #15]
90001eaa:	429a      	cmp	r2, r3
90001eac:	d3b5      	bcc.n	90001e1a <HAL_PCD_Init+0x142>
  }

  /* Init Device */
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
90001eae:	687b      	ldr	r3, [r7, #4]
90001eb0:	6818      	ldr	r0, [r3, #0]
90001eb2:	687b      	ldr	r3, [r7, #4]
90001eb4:	7c1a      	ldrb	r2, [r3, #16]
90001eb6:	f88d 2000 	strb.w	r2, [sp]
90001eba:	3304      	adds	r3, #4
90001ebc:	cb0e      	ldmia	r3, {r1, r2, r3}
90001ebe:	f006 ff75 	bl	90008dac <USB_DevInit>
90001ec2:	4603      	mov	r3, r0
90001ec4:	2b00      	cmp	r3, #0
90001ec6:	d005      	beq.n	90001ed4 <HAL_PCD_Init+0x1fc>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
90001ec8:	687b      	ldr	r3, [r7, #4]
90001eca:	2202      	movs	r2, #2
90001ecc:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
90001ed0:	2301      	movs	r3, #1
90001ed2:	e013      	b.n	90001efc <HAL_PCD_Init+0x224>
  }

  hpcd->USB_Address = 0U;
90001ed4:	687b      	ldr	r3, [r7, #4]
90001ed6:	2200      	movs	r2, #0
90001ed8:	745a      	strb	r2, [r3, #17]
  hpcd->State = HAL_PCD_STATE_READY;
90001eda:	687b      	ldr	r3, [r7, #4]
90001edc:	2201      	movs	r2, #1
90001ede:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495

  /* Activate LPM */
  if (hpcd->Init.lpm_enable == 1U)
90001ee2:	687b      	ldr	r3, [r7, #4]
90001ee4:	7b1b      	ldrb	r3, [r3, #12]
90001ee6:	2b01      	cmp	r3, #1
90001ee8:	d102      	bne.n	90001ef0 <HAL_PCD_Init+0x218>
  {
    (void)HAL_PCDEx_ActivateLPM(hpcd);
90001eea:	6878      	ldr	r0, [r7, #4]
90001eec:	f001 f9b8 	bl	90003260 <HAL_PCDEx_ActivateLPM>
  }

  (void)USB_DevDisconnect(hpcd->Instance);
90001ef0:	687b      	ldr	r3, [r7, #4]
90001ef2:	681b      	ldr	r3, [r3, #0]
90001ef4:	4618      	mov	r0, r3
90001ef6:	f008 f84b 	bl	90009f90 <USB_DevDisconnect>

  return HAL_OK;
90001efa:	2300      	movs	r3, #0
}
90001efc:	4618      	mov	r0, r3
90001efe:	3710      	adds	r7, #16
90001f00:	46bd      	mov	sp, r7
90001f02:	bd80      	pop	{r7, pc}
90001f04:	40080000 	.word	0x40080000

90001f08 <HAL_PCD_Start>:
  * @brief  Start the USB device
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
90001f08:	b580      	push	{r7, lr}
90001f0a:	b084      	sub	sp, #16
90001f0c:	af00      	add	r7, sp, #0
90001f0e:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
90001f10:	687b      	ldr	r3, [r7, #4]
90001f12:	681b      	ldr	r3, [r3, #0]
90001f14:	60fb      	str	r3, [r7, #12]

  __HAL_LOCK(hpcd);
90001f16:	687b      	ldr	r3, [r7, #4]
90001f18:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
90001f1c:	2b01      	cmp	r3, #1
90001f1e:	d101      	bne.n	90001f24 <HAL_PCD_Start+0x1c>
90001f20:	2302      	movs	r3, #2
90001f22:	e022      	b.n	90001f6a <HAL_PCD_Start+0x62>
90001f24:	687b      	ldr	r3, [r7, #4]
90001f26:	2201      	movs	r2, #1
90001f28:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  if (((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) != 0U) &&
90001f2c:	68fb      	ldr	r3, [r7, #12]
90001f2e:	68db      	ldr	r3, [r3, #12]
90001f30:	f003 0340 	and.w	r3, r3, #64	@ 0x40
90001f34:	2b00      	cmp	r3, #0
90001f36:	d009      	beq.n	90001f4c <HAL_PCD_Start+0x44>
      (hpcd->Init.battery_charging_enable == 1U))
90001f38:	687b      	ldr	r3, [r7, #4]
90001f3a:	7b5b      	ldrb	r3, [r3, #13]
  if (((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) != 0U) &&
90001f3c:	2b01      	cmp	r3, #1
90001f3e:	d105      	bne.n	90001f4c <HAL_PCD_Start+0x44>
  {
    /* Enable USB Transceiver */
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
90001f40:	68fb      	ldr	r3, [r7, #12]
90001f42:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90001f44:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
90001f48:	68fb      	ldr	r3, [r7, #12]
90001f4a:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  __HAL_PCD_ENABLE(hpcd);
90001f4c:	687b      	ldr	r3, [r7, #4]
90001f4e:	681b      	ldr	r3, [r3, #0]
90001f50:	4618      	mov	r0, r3
90001f52:	f006 febd 	bl	90008cd0 <USB_EnableGlobalInt>
  (void)USB_DevConnect(hpcd->Instance);
90001f56:	687b      	ldr	r3, [r7, #4]
90001f58:	681b      	ldr	r3, [r3, #0]
90001f5a:	4618      	mov	r0, r3
90001f5c:	f007 fff7 	bl	90009f4e <USB_DevConnect>
  __HAL_UNLOCK(hpcd);
90001f60:	687b      	ldr	r3, [r7, #4]
90001f62:	2200      	movs	r2, #0
90001f64:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
90001f68:	2300      	movs	r3, #0
}
90001f6a:	4618      	mov	r0, r3
90001f6c:	3710      	adds	r7, #16
90001f6e:	46bd      	mov	sp, r7
90001f70:	bd80      	pop	{r7, pc}

90001f72 <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
90001f72:	b590      	push	{r4, r7, lr}
90001f74:	b08d      	sub	sp, #52	@ 0x34
90001f76:	af00      	add	r7, sp, #0
90001f78:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
90001f7a:	687b      	ldr	r3, [r7, #4]
90001f7c:	681b      	ldr	r3, [r3, #0]
90001f7e:	623b      	str	r3, [r7, #32]
  uint32_t USBx_BASE = (uint32_t)USBx;
90001f80:	6a3b      	ldr	r3, [r7, #32]
90001f82:	61fb      	str	r3, [r7, #28]
  uint32_t epnum;
  uint32_t fifoemptymsk;
  uint32_t RegVal;

  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
90001f84:	687b      	ldr	r3, [r7, #4]
90001f86:	681b      	ldr	r3, [r3, #0]
90001f88:	4618      	mov	r0, r3
90001f8a:	f008 f8b5 	bl	9000a0f8 <USB_GetMode>
90001f8e:	4603      	mov	r3, r0
90001f90:	2b00      	cmp	r3, #0
90001f92:	f040 84d3 	bne.w	9000293c <HAL_PCD_IRQHandler+0x9ca>
  {
    /* avoid spurious interrupt */
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
90001f96:	687b      	ldr	r3, [r7, #4]
90001f98:	681b      	ldr	r3, [r3, #0]
90001f9a:	4618      	mov	r0, r3
90001f9c:	f008 f819 	bl	90009fd2 <USB_ReadInterrupts>
90001fa0:	4603      	mov	r3, r0
90001fa2:	2b00      	cmp	r3, #0
90001fa4:	f000 84c9 	beq.w	9000293a <HAL_PCD_IRQHandler+0x9c8>
    {
      return;
    }

    /* store current frame number */
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
90001fa8:	69fb      	ldr	r3, [r7, #28]
90001faa:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90001fae:	689b      	ldr	r3, [r3, #8]
90001fb0:	0a1b      	lsrs	r3, r3, #8
90001fb2:	f3c3 020d 	ubfx	r2, r3, #0, #14
90001fb6:	687b      	ldr	r3, [r7, #4]
90001fb8:	f8c3 24d4 	str.w	r2, [r3, #1236]	@ 0x4d4

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
90001fbc:	687b      	ldr	r3, [r7, #4]
90001fbe:	681b      	ldr	r3, [r3, #0]
90001fc0:	4618      	mov	r0, r3
90001fc2:	f008 f806 	bl	90009fd2 <USB_ReadInterrupts>
90001fc6:	4603      	mov	r3, r0
90001fc8:	f003 0302 	and.w	r3, r3, #2
90001fcc:	2b02      	cmp	r3, #2
90001fce:	d107      	bne.n	90001fe0 <HAL_PCD_IRQHandler+0x6e>
    {
      /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
90001fd0:	687b      	ldr	r3, [r7, #4]
90001fd2:	681b      	ldr	r3, [r3, #0]
90001fd4:	695a      	ldr	r2, [r3, #20]
90001fd6:	687b      	ldr	r3, [r7, #4]
90001fd8:	681b      	ldr	r3, [r3, #0]
90001fda:	f002 0202 	and.w	r2, r2, #2
90001fde:	615a      	str	r2, [r3, #20]
    }

    /* Handle RxQLevel Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
90001fe0:	687b      	ldr	r3, [r7, #4]
90001fe2:	681b      	ldr	r3, [r3, #0]
90001fe4:	4618      	mov	r0, r3
90001fe6:	f007 fff4 	bl	90009fd2 <USB_ReadInterrupts>
90001fea:	4603      	mov	r3, r0
90001fec:	f003 0310 	and.w	r3, r3, #16
90001ff0:	2b10      	cmp	r3, #16
90001ff2:	d161      	bne.n	900020b8 <HAL_PCD_IRQHandler+0x146>
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
90001ff4:	687b      	ldr	r3, [r7, #4]
90001ff6:	681b      	ldr	r3, [r3, #0]
90001ff8:	699a      	ldr	r2, [r3, #24]
90001ffa:	687b      	ldr	r3, [r7, #4]
90001ffc:	681b      	ldr	r3, [r3, #0]
90001ffe:	f022 0210 	bic.w	r2, r2, #16
90002002:	619a      	str	r2, [r3, #24]

      RegVal = USBx->GRXSTSP;
90002004:	6a3b      	ldr	r3, [r7, #32]
90002006:	6a1b      	ldr	r3, [r3, #32]
90002008:	61bb      	str	r3, [r7, #24]

      ep = &hpcd->OUT_ep[RegVal & USB_OTG_GRXSTSP_EPNUM];
9000200a:	69bb      	ldr	r3, [r7, #24]
9000200c:	f003 020f 	and.w	r2, r3, #15
90002010:	4613      	mov	r3, r2
90002012:	00db      	lsls	r3, r3, #3
90002014:	4413      	add	r3, r2
90002016:	009b      	lsls	r3, r3, #2
90002018:	f503 7314 	add.w	r3, r3, #592	@ 0x250
9000201c:	687a      	ldr	r2, [r7, #4]
9000201e:	4413      	add	r3, r2
90002020:	3304      	adds	r3, #4
90002022:	617b      	str	r3, [r7, #20]

      if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
90002024:	69bb      	ldr	r3, [r7, #24]
90002026:	f403 13f0 	and.w	r3, r3, #1966080	@ 0x1e0000
9000202a:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
9000202e:	d124      	bne.n	9000207a <HAL_PCD_IRQHandler+0x108>
      {
        if ((RegVal & USB_OTG_GRXSTSP_BCNT) != 0U)
90002030:	69ba      	ldr	r2, [r7, #24]
90002032:	f647 73f0 	movw	r3, #32752	@ 0x7ff0
90002036:	4013      	ands	r3, r2
90002038:	2b00      	cmp	r3, #0
9000203a:	d035      	beq.n	900020a8 <HAL_PCD_IRQHandler+0x136>
        {
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
9000203c:	697b      	ldr	r3, [r7, #20]
9000203e:	68d9      	ldr	r1, [r3, #12]
                               (uint16_t)((RegVal & USB_OTG_GRXSTSP_BCNT) >> 4));
90002040:	69bb      	ldr	r3, [r7, #24]
90002042:	091b      	lsrs	r3, r3, #4
90002044:	b29b      	uxth	r3, r3
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
90002046:	f3c3 030a 	ubfx	r3, r3, #0, #11
9000204a:	b29b      	uxth	r3, r3
9000204c:	461a      	mov	r2, r3
9000204e:	6a38      	ldr	r0, [r7, #32]
90002050:	f007 feff 	bl	90009e52 <USB_ReadPacket>

          ep->xfer_buff += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
90002054:	697b      	ldr	r3, [r7, #20]
90002056:	68da      	ldr	r2, [r3, #12]
90002058:	69bb      	ldr	r3, [r7, #24]
9000205a:	091b      	lsrs	r3, r3, #4
9000205c:	f3c3 030a 	ubfx	r3, r3, #0, #11
90002060:	441a      	add	r2, r3
90002062:	697b      	ldr	r3, [r7, #20]
90002064:	60da      	str	r2, [r3, #12]
          ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
90002066:	697b      	ldr	r3, [r7, #20]
90002068:	695a      	ldr	r2, [r3, #20]
9000206a:	69bb      	ldr	r3, [r7, #24]
9000206c:	091b      	lsrs	r3, r3, #4
9000206e:	f3c3 030a 	ubfx	r3, r3, #0, #11
90002072:	441a      	add	r2, r3
90002074:	697b      	ldr	r3, [r7, #20]
90002076:	615a      	str	r2, [r3, #20]
90002078:	e016      	b.n	900020a8 <HAL_PCD_IRQHandler+0x136>
        }
      }
      else if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) == STS_SETUP_UPDT)
9000207a:	69bb      	ldr	r3, [r7, #24]
9000207c:	f403 13f0 	and.w	r3, r3, #1966080	@ 0x1e0000
90002080:	f5b3 2f40 	cmp.w	r3, #786432	@ 0xc0000
90002084:	d110      	bne.n	900020a8 <HAL_PCD_IRQHandler+0x136>
      {
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
90002086:	687b      	ldr	r3, [r7, #4]
90002088:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
9000208c:	2208      	movs	r2, #8
9000208e:	4619      	mov	r1, r3
90002090:	6a38      	ldr	r0, [r7, #32]
90002092:	f007 fede 	bl	90009e52 <USB_ReadPacket>
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
90002096:	697b      	ldr	r3, [r7, #20]
90002098:	695a      	ldr	r2, [r3, #20]
9000209a:	69bb      	ldr	r3, [r7, #24]
9000209c:	091b      	lsrs	r3, r3, #4
9000209e:	f3c3 030a 	ubfx	r3, r3, #0, #11
900020a2:	441a      	add	r2, r3
900020a4:	697b      	ldr	r3, [r7, #20]
900020a6:	615a      	str	r2, [r3, #20]
      else
      {
        /* ... */
      }

      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
900020a8:	687b      	ldr	r3, [r7, #4]
900020aa:	681b      	ldr	r3, [r3, #0]
900020ac:	699a      	ldr	r2, [r3, #24]
900020ae:	687b      	ldr	r3, [r7, #4]
900020b0:	681b      	ldr	r3, [r3, #0]
900020b2:	f042 0210 	orr.w	r2, r2, #16
900020b6:	619a      	str	r2, [r3, #24]
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
900020b8:	687b      	ldr	r3, [r7, #4]
900020ba:	681b      	ldr	r3, [r3, #0]
900020bc:	4618      	mov	r0, r3
900020be:	f007 ff88 	bl	90009fd2 <USB_ReadInterrupts>
900020c2:	4603      	mov	r3, r0
900020c4:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
900020c8:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
900020cc:	f040 80a7 	bne.w	9000221e <HAL_PCD_IRQHandler+0x2ac>
    {
      epnum = 0U;
900020d0:	2300      	movs	r3, #0
900020d2:	627b      	str	r3, [r7, #36]	@ 0x24

      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
900020d4:	687b      	ldr	r3, [r7, #4]
900020d6:	681b      	ldr	r3, [r3, #0]
900020d8:	4618      	mov	r0, r3
900020da:	f007 ff8d 	bl	90009ff8 <USB_ReadDevAllOutEpInterrupt>
900020de:	62b8      	str	r0, [r7, #40]	@ 0x28

      while (ep_intr != 0U)
900020e0:	e099      	b.n	90002216 <HAL_PCD_IRQHandler+0x2a4>
      {
        if ((ep_intr & 0x1U) != 0U)
900020e2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
900020e4:	f003 0301 	and.w	r3, r3, #1
900020e8:	2b00      	cmp	r3, #0
900020ea:	f000 808e 	beq.w	9000220a <HAL_PCD_IRQHandler+0x298>
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
900020ee:	687b      	ldr	r3, [r7, #4]
900020f0:	681b      	ldr	r3, [r3, #0]
900020f2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
900020f4:	b2d2      	uxtb	r2, r2
900020f6:	4611      	mov	r1, r2
900020f8:	4618      	mov	r0, r3
900020fa:	f007 ffb1 	bl	9000a060 <USB_ReadDevOutEPInterrupt>
900020fe:	6138      	str	r0, [r7, #16]

          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
90002100:	693b      	ldr	r3, [r7, #16]
90002102:	f003 0301 	and.w	r3, r3, #1
90002106:	2b00      	cmp	r3, #0
90002108:	d00c      	beq.n	90002124 <HAL_PCD_IRQHandler+0x1b2>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
9000210a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
9000210c:	015a      	lsls	r2, r3, #5
9000210e:	69fb      	ldr	r3, [r7, #28]
90002110:	4413      	add	r3, r2
90002112:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90002116:	461a      	mov	r2, r3
90002118:	2301      	movs	r3, #1
9000211a:	6093      	str	r3, [r2, #8]
            (void)PCD_EP_OutXfrComplete_int(hpcd, epnum);
9000211c:	6a79      	ldr	r1, [r7, #36]	@ 0x24
9000211e:	6878      	ldr	r0, [r7, #4]
90002120:	f000 ff18 	bl	90002f54 <PCD_EP_OutXfrComplete_int>
          }

          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
90002124:	693b      	ldr	r3, [r7, #16]
90002126:	f003 0308 	and.w	r3, r3, #8
9000212a:	2b00      	cmp	r3, #0
9000212c:	d00c      	beq.n	90002148 <HAL_PCD_IRQHandler+0x1d6>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
9000212e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
90002130:	015a      	lsls	r2, r3, #5
90002132:	69fb      	ldr	r3, [r7, #28]
90002134:	4413      	add	r3, r2
90002136:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
9000213a:	461a      	mov	r2, r3
9000213c:	2308      	movs	r3, #8
9000213e:	6093      	str	r3, [r2, #8]
            /* Class B setup phase done for previous decoded setup */
            (void)PCD_EP_OutSetupPacket_int(hpcd, epnum);
90002140:	6a79      	ldr	r1, [r7, #36]	@ 0x24
90002142:	6878      	ldr	r0, [r7, #4]
90002144:	f000 ffee 	bl	90003124 <PCD_EP_OutSetupPacket_int>
          }

          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
90002148:	693b      	ldr	r3, [r7, #16]
9000214a:	f003 0310 	and.w	r3, r3, #16
9000214e:	2b00      	cmp	r3, #0
90002150:	d008      	beq.n	90002164 <HAL_PCD_IRQHandler+0x1f2>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
90002152:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
90002154:	015a      	lsls	r2, r3, #5
90002156:	69fb      	ldr	r3, [r7, #28]
90002158:	4413      	add	r3, r2
9000215a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
9000215e:	461a      	mov	r2, r3
90002160:	2310      	movs	r3, #16
90002162:	6093      	str	r3, [r2, #8]
          }

          /* Clear OUT Endpoint disable interrupt */
          if ((epint & USB_OTG_DOEPINT_EPDISD) == USB_OTG_DOEPINT_EPDISD)
90002164:	693b      	ldr	r3, [r7, #16]
90002166:	f003 0302 	and.w	r3, r3, #2
9000216a:	2b00      	cmp	r3, #0
9000216c:	d030      	beq.n	900021d0 <HAL_PCD_IRQHandler+0x25e>
          {
            if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == USB_OTG_GINTSTS_BOUTNAKEFF)
9000216e:	6a3b      	ldr	r3, [r7, #32]
90002170:	695b      	ldr	r3, [r3, #20]
90002172:	f003 0380 	and.w	r3, r3, #128	@ 0x80
90002176:	2b80      	cmp	r3, #128	@ 0x80
90002178:	d109      	bne.n	9000218e <HAL_PCD_IRQHandler+0x21c>
            {
              USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
9000217a:	69fb      	ldr	r3, [r7, #28]
9000217c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90002180:	685b      	ldr	r3, [r3, #4]
90002182:	69fa      	ldr	r2, [r7, #28]
90002184:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
90002188:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
9000218c:	6053      	str	r3, [r2, #4]
            }

            ep = &hpcd->OUT_ep[epnum];
9000218e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
90002190:	4613      	mov	r3, r2
90002192:	00db      	lsls	r3, r3, #3
90002194:	4413      	add	r3, r2
90002196:	009b      	lsls	r3, r3, #2
90002198:	f503 7314 	add.w	r3, r3, #592	@ 0x250
9000219c:	687a      	ldr	r2, [r7, #4]
9000219e:	4413      	add	r3, r2
900021a0:	3304      	adds	r3, #4
900021a2:	617b      	str	r3, [r7, #20]

            if (ep->is_iso_incomplete == 1U)
900021a4:	697b      	ldr	r3, [r7, #20]
900021a6:	78db      	ldrb	r3, [r3, #3]
900021a8:	2b01      	cmp	r3, #1
900021aa:	d108      	bne.n	900021be <HAL_PCD_IRQHandler+0x24c>
            {
              ep->is_iso_incomplete = 0U;
900021ac:	697b      	ldr	r3, [r7, #20]
900021ae:	2200      	movs	r2, #0
900021b0:	70da      	strb	r2, [r3, #3]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
              hpcd->ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
#else
              HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
900021b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
900021b4:	b2db      	uxtb	r3, r3
900021b6:	4619      	mov	r1, r3
900021b8:	6878      	ldr	r0, [r7, #4]
900021ba:	f7fe fe9d 	bl	90000ef8 <HAL_PCD_ISOOUTIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
            }

            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_EPDISD);
900021be:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
900021c0:	015a      	lsls	r2, r3, #5
900021c2:	69fb      	ldr	r3, [r7, #28]
900021c4:	4413      	add	r3, r2
900021c6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
900021ca:	461a      	mov	r2, r3
900021cc:	2302      	movs	r3, #2
900021ce:	6093      	str	r3, [r2, #8]
          }

          /* Clear Status Phase Received interrupt */
          if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
900021d0:	693b      	ldr	r3, [r7, #16]
900021d2:	f003 0320 	and.w	r3, r3, #32
900021d6:	2b00      	cmp	r3, #0
900021d8:	d008      	beq.n	900021ec <HAL_PCD_IRQHandler+0x27a>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
900021da:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
900021dc:	015a      	lsls	r2, r3, #5
900021de:	69fb      	ldr	r3, [r7, #28]
900021e0:	4413      	add	r3, r2
900021e2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
900021e6:	461a      	mov	r2, r3
900021e8:	2320      	movs	r3, #32
900021ea:	6093      	str	r3, [r2, #8]
          }

          /* Clear OUT NAK interrupt */
          if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
900021ec:	693b      	ldr	r3, [r7, #16]
900021ee:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
900021f2:	2b00      	cmp	r3, #0
900021f4:	d009      	beq.n	9000220a <HAL_PCD_IRQHandler+0x298>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
900021f6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
900021f8:	015a      	lsls	r2, r3, #5
900021fa:	69fb      	ldr	r3, [r7, #28]
900021fc:	4413      	add	r3, r2
900021fe:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90002202:	461a      	mov	r2, r3
90002204:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
90002208:	6093      	str	r3, [r2, #8]
          }
        }
        epnum++;
9000220a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
9000220c:	3301      	adds	r3, #1
9000220e:	627b      	str	r3, [r7, #36]	@ 0x24
        ep_intr >>= 1U;
90002210:	6abb      	ldr	r3, [r7, #40]	@ 0x28
90002212:	085b      	lsrs	r3, r3, #1
90002214:	62bb      	str	r3, [r7, #40]	@ 0x28
      while (ep_intr != 0U)
90002216:	6abb      	ldr	r3, [r7, #40]	@ 0x28
90002218:	2b00      	cmp	r3, #0
9000221a:	f47f af62 	bne.w	900020e2 <HAL_PCD_IRQHandler+0x170>
      }
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
9000221e:	687b      	ldr	r3, [r7, #4]
90002220:	681b      	ldr	r3, [r3, #0]
90002222:	4618      	mov	r0, r3
90002224:	f007 fed5 	bl	90009fd2 <USB_ReadInterrupts>
90002228:	4603      	mov	r3, r0
9000222a:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
9000222e:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
90002232:	f040 80db 	bne.w	900023ec <HAL_PCD_IRQHandler+0x47a>
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
90002236:	687b      	ldr	r3, [r7, #4]
90002238:	681b      	ldr	r3, [r3, #0]
9000223a:	4618      	mov	r0, r3
9000223c:	f007 fef6 	bl	9000a02c <USB_ReadDevAllInEpInterrupt>
90002240:	62b8      	str	r0, [r7, #40]	@ 0x28

      epnum = 0U;
90002242:	2300      	movs	r3, #0
90002244:	627b      	str	r3, [r7, #36]	@ 0x24

      while (ep_intr != 0U)
90002246:	e0cd      	b.n	900023e4 <HAL_PCD_IRQHandler+0x472>
      {
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
90002248:	6abb      	ldr	r3, [r7, #40]	@ 0x28
9000224a:	f003 0301 	and.w	r3, r3, #1
9000224e:	2b00      	cmp	r3, #0
90002250:	f000 80c2 	beq.w	900023d8 <HAL_PCD_IRQHandler+0x466>
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
90002254:	687b      	ldr	r3, [r7, #4]
90002256:	681b      	ldr	r3, [r3, #0]
90002258:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
9000225a:	b2d2      	uxtb	r2, r2
9000225c:	4611      	mov	r1, r2
9000225e:	4618      	mov	r0, r3
90002260:	f007 ff1c 	bl	9000a09c <USB_ReadDevInEPInterrupt>
90002264:	6138      	str	r0, [r7, #16]

          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
90002266:	693b      	ldr	r3, [r7, #16]
90002268:	f003 0301 	and.w	r3, r3, #1
9000226c:	2b00      	cmp	r3, #0
9000226e:	d057      	beq.n	90002320 <HAL_PCD_IRQHandler+0x3ae>
          {
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
90002270:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
90002272:	f003 030f 	and.w	r3, r3, #15
90002276:	2201      	movs	r2, #1
90002278:	fa02 f303 	lsl.w	r3, r2, r3
9000227c:	60fb      	str	r3, [r7, #12]
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
9000227e:	69fb      	ldr	r3, [r7, #28]
90002280:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90002284:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
90002286:	68fb      	ldr	r3, [r7, #12]
90002288:	43db      	mvns	r3, r3
9000228a:	69f9      	ldr	r1, [r7, #28]
9000228c:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
90002290:	4013      	ands	r3, r2
90002292:	634b      	str	r3, [r1, #52]	@ 0x34

            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
90002294:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
90002296:	015a      	lsls	r2, r3, #5
90002298:	69fb      	ldr	r3, [r7, #28]
9000229a:	4413      	add	r3, r2
9000229c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
900022a0:	461a      	mov	r2, r3
900022a2:	2301      	movs	r3, #1
900022a4:	6093      	str	r3, [r2, #8]

            if (hpcd->Init.dma_enable == 1U)
900022a6:	687b      	ldr	r3, [r7, #4]
900022a8:	799b      	ldrb	r3, [r3, #6]
900022aa:	2b01      	cmp	r3, #1
900022ac:	d132      	bne.n	90002314 <HAL_PCD_IRQHandler+0x3a2>
            {
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket;
900022ae:	6879      	ldr	r1, [r7, #4]
900022b0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
900022b2:	4613      	mov	r3, r2
900022b4:	00db      	lsls	r3, r3, #3
900022b6:	4413      	add	r3, r2
900022b8:	009b      	lsls	r3, r3, #2
900022ba:	440b      	add	r3, r1
900022bc:	3320      	adds	r3, #32
900022be:	6819      	ldr	r1, [r3, #0]
900022c0:	6878      	ldr	r0, [r7, #4]
900022c2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
900022c4:	4613      	mov	r3, r2
900022c6:	00db      	lsls	r3, r3, #3
900022c8:	4413      	add	r3, r2
900022ca:	009b      	lsls	r3, r3, #2
900022cc:	4403      	add	r3, r0
900022ce:	331c      	adds	r3, #28
900022d0:	681b      	ldr	r3, [r3, #0]
900022d2:	4419      	add	r1, r3
900022d4:	6878      	ldr	r0, [r7, #4]
900022d6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
900022d8:	4613      	mov	r3, r2
900022da:	00db      	lsls	r3, r3, #3
900022dc:	4413      	add	r3, r2
900022de:	009b      	lsls	r3, r3, #2
900022e0:	4403      	add	r3, r0
900022e2:	3320      	adds	r3, #32
900022e4:	6019      	str	r1, [r3, #0]

              /* this is ZLP, so prepare EP0 for next setup */
              if ((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
900022e6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
900022e8:	2b00      	cmp	r3, #0
900022ea:	d113      	bne.n	90002314 <HAL_PCD_IRQHandler+0x3a2>
900022ec:	6879      	ldr	r1, [r7, #4]
900022ee:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
900022f0:	4613      	mov	r3, r2
900022f2:	00db      	lsls	r3, r3, #3
900022f4:	4413      	add	r3, r2
900022f6:	009b      	lsls	r3, r3, #2
900022f8:	440b      	add	r3, r1
900022fa:	3324      	adds	r3, #36	@ 0x24
900022fc:	681b      	ldr	r3, [r3, #0]
900022fe:	2b00      	cmp	r3, #0
90002300:	d108      	bne.n	90002314 <HAL_PCD_IRQHandler+0x3a2>
              {
                /* prepare to rx more setup packets */
                (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
90002302:	687b      	ldr	r3, [r7, #4]
90002304:	6818      	ldr	r0, [r3, #0]
90002306:	687b      	ldr	r3, [r7, #4]
90002308:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
9000230c:	461a      	mov	r2, r3
9000230e:	2101      	movs	r1, #1
90002310:	f007 ff24 	bl	9000a15c <USB_EP0_OutStart>
            }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
            hpcd->DataInStageCallback(hpcd, (uint8_t)epnum);
#else
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
90002314:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
90002316:	b2db      	uxtb	r3, r3
90002318:	4619      	mov	r1, r3
9000231a:	6878      	ldr	r0, [r7, #4]
9000231c:	f7fe fd57 	bl	90000dce <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
          }
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
90002320:	693b      	ldr	r3, [r7, #16]
90002322:	f003 0308 	and.w	r3, r3, #8
90002326:	2b00      	cmp	r3, #0
90002328:	d008      	beq.n	9000233c <HAL_PCD_IRQHandler+0x3ca>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
9000232a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
9000232c:	015a      	lsls	r2, r3, #5
9000232e:	69fb      	ldr	r3, [r7, #28]
90002330:	4413      	add	r3, r2
90002332:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90002336:	461a      	mov	r2, r3
90002338:	2308      	movs	r3, #8
9000233a:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
9000233c:	693b      	ldr	r3, [r7, #16]
9000233e:	f003 0310 	and.w	r3, r3, #16
90002342:	2b00      	cmp	r3, #0
90002344:	d008      	beq.n	90002358 <HAL_PCD_IRQHandler+0x3e6>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
90002346:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
90002348:	015a      	lsls	r2, r3, #5
9000234a:	69fb      	ldr	r3, [r7, #28]
9000234c:	4413      	add	r3, r2
9000234e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90002352:	461a      	mov	r2, r3
90002354:	2310      	movs	r3, #16
90002356:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
90002358:	693b      	ldr	r3, [r7, #16]
9000235a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
9000235e:	2b00      	cmp	r3, #0
90002360:	d008      	beq.n	90002374 <HAL_PCD_IRQHandler+0x402>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
90002362:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
90002364:	015a      	lsls	r2, r3, #5
90002366:	69fb      	ldr	r3, [r7, #28]
90002368:	4413      	add	r3, r2
9000236a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
9000236e:	461a      	mov	r2, r3
90002370:	2340      	movs	r3, #64	@ 0x40
90002372:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
90002374:	693b      	ldr	r3, [r7, #16]
90002376:	f003 0302 	and.w	r3, r3, #2
9000237a:	2b00      	cmp	r3, #0
9000237c:	d023      	beq.n	900023c6 <HAL_PCD_IRQHandler+0x454>
          {
            (void)USB_FlushTxFifo(USBx, epnum);
9000237e:	6a79      	ldr	r1, [r7, #36]	@ 0x24
90002380:	6a38      	ldr	r0, [r7, #32]
90002382:	f006 feb1 	bl	900090e8 <USB_FlushTxFifo>

            ep = &hpcd->IN_ep[epnum];
90002386:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
90002388:	4613      	mov	r3, r2
9000238a:	00db      	lsls	r3, r3, #3
9000238c:	4413      	add	r3, r2
9000238e:	009b      	lsls	r3, r3, #2
90002390:	3310      	adds	r3, #16
90002392:	687a      	ldr	r2, [r7, #4]
90002394:	4413      	add	r3, r2
90002396:	3304      	adds	r3, #4
90002398:	617b      	str	r3, [r7, #20]

            if (ep->is_iso_incomplete == 1U)
9000239a:	697b      	ldr	r3, [r7, #20]
9000239c:	78db      	ldrb	r3, [r3, #3]
9000239e:	2b01      	cmp	r3, #1
900023a0:	d108      	bne.n	900023b4 <HAL_PCD_IRQHandler+0x442>
            {
              ep->is_iso_incomplete = 0U;
900023a2:	697b      	ldr	r3, [r7, #20]
900023a4:	2200      	movs	r2, #0
900023a6:	70da      	strb	r2, [r3, #3]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
              hpcd->ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
#else
              HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
900023a8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
900023aa:	b2db      	uxtb	r3, r3
900023ac:	4619      	mov	r1, r3
900023ae:	6878      	ldr	r0, [r7, #4]
900023b0:	f7fe fdb4 	bl	90000f1c <HAL_PCD_ISOINIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
            }

            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
900023b4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
900023b6:	015a      	lsls	r2, r3, #5
900023b8:	69fb      	ldr	r3, [r7, #28]
900023ba:	4413      	add	r3, r2
900023bc:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
900023c0:	461a      	mov	r2, r3
900023c2:	2302      	movs	r3, #2
900023c4:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
900023c6:	693b      	ldr	r3, [r7, #16]
900023c8:	f003 0380 	and.w	r3, r3, #128	@ 0x80
900023cc:	2b00      	cmp	r3, #0
900023ce:	d003      	beq.n	900023d8 <HAL_PCD_IRQHandler+0x466>
          {
            (void)PCD_WriteEmptyTxFifo(hpcd, epnum);
900023d0:	6a79      	ldr	r1, [r7, #36]	@ 0x24
900023d2:	6878      	ldr	r0, [r7, #4]
900023d4:	f000 fd31 	bl	90002e3a <PCD_WriteEmptyTxFifo>
          }
        }
        epnum++;
900023d8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
900023da:	3301      	adds	r3, #1
900023dc:	627b      	str	r3, [r7, #36]	@ 0x24
        ep_intr >>= 1U;
900023de:	6abb      	ldr	r3, [r7, #40]	@ 0x28
900023e0:	085b      	lsrs	r3, r3, #1
900023e2:	62bb      	str	r3, [r7, #40]	@ 0x28
      while (ep_intr != 0U)
900023e4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
900023e6:	2b00      	cmp	r3, #0
900023e8:	f47f af2e 	bne.w	90002248 <HAL_PCD_IRQHandler+0x2d6>
      }
    }

    /* Handle Resume Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
900023ec:	687b      	ldr	r3, [r7, #4]
900023ee:	681b      	ldr	r3, [r3, #0]
900023f0:	4618      	mov	r0, r3
900023f2:	f007 fdee 	bl	90009fd2 <USB_ReadInterrupts>
900023f6:	4603      	mov	r3, r0
900023f8:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
900023fc:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
90002400:	d122      	bne.n	90002448 <HAL_PCD_IRQHandler+0x4d6>
    {
      /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
90002402:	69fb      	ldr	r3, [r7, #28]
90002404:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90002408:	685b      	ldr	r3, [r3, #4]
9000240a:	69fa      	ldr	r2, [r7, #28]
9000240c:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
90002410:	f023 0301 	bic.w	r3, r3, #1
90002414:	6053      	str	r3, [r2, #4]

      if (hpcd->LPM_State == LPM_L1)
90002416:	687b      	ldr	r3, [r7, #4]
90002418:	f893 34cc 	ldrb.w	r3, [r3, #1228]	@ 0x4cc
9000241c:	2b01      	cmp	r3, #1
9000241e:	d108      	bne.n	90002432 <HAL_PCD_IRQHandler+0x4c0>
      {
        hpcd->LPM_State = LPM_L0;
90002420:	687b      	ldr	r3, [r7, #4]
90002422:	2200      	movs	r2, #0
90002424:	f883 24cc 	strb.w	r2, [r3, #1228]	@ 0x4cc

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->LPMCallback(hpcd, PCD_LPM_L0_ACTIVE);
#else
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
90002428:	2100      	movs	r1, #0
9000242a:	6878      	ldr	r0, [r7, #4]
9000242c:	f000 ff3c 	bl	900032a8 <HAL_PCDEx_LPM_Callback>
90002430:	e002      	b.n	90002438 <HAL_PCD_IRQHandler+0x4c6>
      else
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->ResumeCallback(hpcd);
#else
        HAL_PCD_ResumeCallback(hpcd);
90002432:	6878      	ldr	r0, [r7, #4]
90002434:	f7fe fd38 	bl	90000ea8 <HAL_PCD_ResumeCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
90002438:	687b      	ldr	r3, [r7, #4]
9000243a:	681b      	ldr	r3, [r3, #0]
9000243c:	695a      	ldr	r2, [r3, #20]
9000243e:	687b      	ldr	r3, [r7, #4]
90002440:	681b      	ldr	r3, [r3, #0]
90002442:	f002 4200 	and.w	r2, r2, #2147483648	@ 0x80000000
90002446:	615a      	str	r2, [r3, #20]
    }

    /* Handle Suspend Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
90002448:	687b      	ldr	r3, [r7, #4]
9000244a:	681b      	ldr	r3, [r3, #0]
9000244c:	4618      	mov	r0, r3
9000244e:	f007 fdc0 	bl	90009fd2 <USB_ReadInterrupts>
90002452:	4603      	mov	r3, r0
90002454:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
90002458:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
9000245c:	d112      	bne.n	90002484 <HAL_PCD_IRQHandler+0x512>
    {
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
9000245e:	69fb      	ldr	r3, [r7, #28]
90002460:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90002464:	689b      	ldr	r3, [r3, #8]
90002466:	f003 0301 	and.w	r3, r3, #1
9000246a:	2b01      	cmp	r3, #1
9000246c:	d102      	bne.n	90002474 <HAL_PCD_IRQHandler+0x502>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->SuspendCallback(hpcd);
#else
        HAL_PCD_SuspendCallback(hpcd);
9000246e:	6878      	ldr	r0, [r7, #4]
90002470:	f7fe fcfe 	bl	90000e70 <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
90002474:	687b      	ldr	r3, [r7, #4]
90002476:	681b      	ldr	r3, [r3, #0]
90002478:	695a      	ldr	r2, [r3, #20]
9000247a:	687b      	ldr	r3, [r7, #4]
9000247c:	681b      	ldr	r3, [r3, #0]
9000247e:	f402 6200 	and.w	r2, r2, #2048	@ 0x800
90002482:	615a      	str	r2, [r3, #20]
    }

    /* Handle LPM Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))
90002484:	687b      	ldr	r3, [r7, #4]
90002486:	681b      	ldr	r3, [r3, #0]
90002488:	4618      	mov	r0, r3
9000248a:	f007 fda2 	bl	90009fd2 <USB_ReadInterrupts>
9000248e:	4603      	mov	r3, r0
90002490:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
90002494:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
90002498:	d121      	bne.n	900024de <HAL_PCD_IRQHandler+0x56c>
    {
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);
9000249a:	687b      	ldr	r3, [r7, #4]
9000249c:	681b      	ldr	r3, [r3, #0]
9000249e:	695a      	ldr	r2, [r3, #20]
900024a0:	687b      	ldr	r3, [r7, #4]
900024a2:	681b      	ldr	r3, [r3, #0]
900024a4:	f002 6200 	and.w	r2, r2, #134217728	@ 0x8000000
900024a8:	615a      	str	r2, [r3, #20]

      if (hpcd->LPM_State == LPM_L0)
900024aa:	687b      	ldr	r3, [r7, #4]
900024ac:	f893 34cc 	ldrb.w	r3, [r3, #1228]	@ 0x4cc
900024b0:	2b00      	cmp	r3, #0
900024b2:	d111      	bne.n	900024d8 <HAL_PCD_IRQHandler+0x566>
      {
        hpcd->LPM_State = LPM_L1;
900024b4:	687b      	ldr	r3, [r7, #4]
900024b6:	2201      	movs	r2, #1
900024b8:	f883 24cc 	strb.w	r2, [r3, #1228]	@ 0x4cc
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
900024bc:	687b      	ldr	r3, [r7, #4]
900024be:	681b      	ldr	r3, [r3, #0]
900024c0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
900024c2:	089b      	lsrs	r3, r3, #2
900024c4:	f003 020f 	and.w	r2, r3, #15
900024c8:	687b      	ldr	r3, [r7, #4]
900024ca:	f8c3 24d0 	str.w	r2, [r3, #1232]	@ 0x4d0

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->LPMCallback(hpcd, PCD_LPM_L1_ACTIVE);
#else
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
900024ce:	2101      	movs	r1, #1
900024d0:	6878      	ldr	r0, [r7, #4]
900024d2:	f000 fee9 	bl	900032a8 <HAL_PCDEx_LPM_Callback>
900024d6:	e002      	b.n	900024de <HAL_PCD_IRQHandler+0x56c>
      else
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->SuspendCallback(hpcd);
#else
        HAL_PCD_SuspendCallback(hpcd);
900024d8:	6878      	ldr	r0, [r7, #4]
900024da:	f7fe fcc9 	bl	90000e70 <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
    }

    /* Handle Reset Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
900024de:	687b      	ldr	r3, [r7, #4]
900024e0:	681b      	ldr	r3, [r3, #0]
900024e2:	4618      	mov	r0, r3
900024e4:	f007 fd75 	bl	90009fd2 <USB_ReadInterrupts>
900024e8:	4603      	mov	r3, r0
900024ea:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
900024ee:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
900024f2:	f040 80b7 	bne.w	90002664 <HAL_PCD_IRQHandler+0x6f2>
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
900024f6:	69fb      	ldr	r3, [r7, #28]
900024f8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
900024fc:	685b      	ldr	r3, [r3, #4]
900024fe:	69fa      	ldr	r2, [r7, #28]
90002500:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
90002504:	f023 0301 	bic.w	r3, r3, #1
90002508:	6053      	str	r3, [r2, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
9000250a:	687b      	ldr	r3, [r7, #4]
9000250c:	681b      	ldr	r3, [r3, #0]
9000250e:	2110      	movs	r1, #16
90002510:	4618      	mov	r0, r3
90002512:	f006 fde9 	bl	900090e8 <USB_FlushTxFifo>

      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
90002516:	2300      	movs	r3, #0
90002518:	62fb      	str	r3, [r7, #44]	@ 0x2c
9000251a:	e046      	b.n	900025aa <HAL_PCD_IRQHandler+0x638>
      {
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
9000251c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
9000251e:	015a      	lsls	r2, r3, #5
90002520:	69fb      	ldr	r3, [r7, #28]
90002522:	4413      	add	r3, r2
90002524:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90002528:	461a      	mov	r2, r3
9000252a:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
9000252e:	6093      	str	r3, [r2, #8]
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
90002530:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
90002532:	015a      	lsls	r2, r3, #5
90002534:	69fb      	ldr	r3, [r7, #28]
90002536:	4413      	add	r3, r2
90002538:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
9000253c:	681b      	ldr	r3, [r3, #0]
9000253e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
90002540:	0151      	lsls	r1, r2, #5
90002542:	69fa      	ldr	r2, [r7, #28]
90002544:	440a      	add	r2, r1
90002546:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
9000254a:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
9000254e:	6013      	str	r3, [r2, #0]
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
90002550:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
90002552:	015a      	lsls	r2, r3, #5
90002554:	69fb      	ldr	r3, [r7, #28]
90002556:	4413      	add	r3, r2
90002558:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
9000255c:	461a      	mov	r2, r3
9000255e:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
90002562:	6093      	str	r3, [r2, #8]
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
90002564:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
90002566:	015a      	lsls	r2, r3, #5
90002568:	69fb      	ldr	r3, [r7, #28]
9000256a:	4413      	add	r3, r2
9000256c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90002570:	681b      	ldr	r3, [r3, #0]
90002572:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
90002574:	0151      	lsls	r1, r2, #5
90002576:	69fa      	ldr	r2, [r7, #28]
90002578:	440a      	add	r2, r1
9000257a:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
9000257e:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
90002582:	6013      	str	r3, [r2, #0]
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
90002584:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
90002586:	015a      	lsls	r2, r3, #5
90002588:	69fb      	ldr	r3, [r7, #28]
9000258a:	4413      	add	r3, r2
9000258c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90002590:	681b      	ldr	r3, [r3, #0]
90002592:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
90002594:	0151      	lsls	r1, r2, #5
90002596:	69fa      	ldr	r2, [r7, #28]
90002598:	440a      	add	r2, r1
9000259a:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
9000259e:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
900025a2:	6013      	str	r3, [r2, #0]
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
900025a4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
900025a6:	3301      	adds	r3, #1
900025a8:	62fb      	str	r3, [r7, #44]	@ 0x2c
900025aa:	687b      	ldr	r3, [r7, #4]
900025ac:	791b      	ldrb	r3, [r3, #4]
900025ae:	461a      	mov	r2, r3
900025b0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
900025b2:	4293      	cmp	r3, r2
900025b4:	d3b2      	bcc.n	9000251c <HAL_PCD_IRQHandler+0x5aa>
      }
      USBx_DEVICE->DAINTMSK |= 0x10001U;
900025b6:	69fb      	ldr	r3, [r7, #28]
900025b8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
900025bc:	69db      	ldr	r3, [r3, #28]
900025be:	69fa      	ldr	r2, [r7, #28]
900025c0:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
900025c4:	f043 1301 	orr.w	r3, r3, #65537	@ 0x10001
900025c8:	61d3      	str	r3, [r2, #28]

      if (hpcd->Init.use_dedicated_ep1 != 0U)
900025ca:	687b      	ldr	r3, [r7, #4]
900025cc:	7bdb      	ldrb	r3, [r3, #15]
900025ce:	2b00      	cmp	r3, #0
900025d0:	d016      	beq.n	90002600 <HAL_PCD_IRQHandler+0x68e>
      {
        USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
900025d2:	69fb      	ldr	r3, [r7, #28]
900025d4:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
900025d8:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
900025dc:	69fa      	ldr	r2, [r7, #28]
900025de:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
900025e2:	f043 030b 	orr.w	r3, r3, #11
900025e6:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
                                   USB_OTG_DOEPMSK_XFRCM |
                                   USB_OTG_DOEPMSK_EPDM;

        USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
900025ea:	69fb      	ldr	r3, [r7, #28]
900025ec:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
900025f0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
900025f2:	69fa      	ldr	r2, [r7, #28]
900025f4:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
900025f8:	f043 030b 	orr.w	r3, r3, #11
900025fc:	6453      	str	r3, [r2, #68]	@ 0x44
900025fe:	e015      	b.n	9000262c <HAL_PCD_IRQHandler+0x6ba>
                                  USB_OTG_DIEPMSK_XFRCM |
                                  USB_OTG_DIEPMSK_EPDM;
      }
      else
      {
        USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
90002600:	69fb      	ldr	r3, [r7, #28]
90002602:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90002606:	695a      	ldr	r2, [r3, #20]
90002608:	69fb      	ldr	r3, [r7, #28]
9000260a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
9000260e:	4619      	mov	r1, r3
90002610:	f242 032b 	movw	r3, #8235	@ 0x202b
90002614:	4313      	orrs	r3, r2
90002616:	614b      	str	r3, [r1, #20]
                                USB_OTG_DOEPMSK_XFRCM |
                                USB_OTG_DOEPMSK_EPDM |
                                USB_OTG_DOEPMSK_OTEPSPRM |
                                USB_OTG_DOEPMSK_NAKM;

        USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
90002618:	69fb      	ldr	r3, [r7, #28]
9000261a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
9000261e:	691b      	ldr	r3, [r3, #16]
90002620:	69fa      	ldr	r2, [r7, #28]
90002622:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
90002626:	f043 030b 	orr.w	r3, r3, #11
9000262a:	6113      	str	r3, [r2, #16]
                                USB_OTG_DIEPMSK_XFRCM |
                                USB_OTG_DIEPMSK_EPDM;
      }

      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
9000262c:	69fb      	ldr	r3, [r7, #28]
9000262e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90002632:	681b      	ldr	r3, [r3, #0]
90002634:	69fa      	ldr	r2, [r7, #28]
90002636:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
9000263a:	f423 63fe 	bic.w	r3, r3, #2032	@ 0x7f0
9000263e:	6013      	str	r3, [r2, #0]

      /* setup EP0 to receive SETUP packets */
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
90002640:	687b      	ldr	r3, [r7, #4]
90002642:	6818      	ldr	r0, [r3, #0]
90002644:	687b      	ldr	r3, [r7, #4]
90002646:	7999      	ldrb	r1, [r3, #6]
                             (uint8_t *)hpcd->Setup);
90002648:	687b      	ldr	r3, [r7, #4]
9000264a:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
9000264e:	461a      	mov	r2, r3
90002650:	f007 fd84 	bl	9000a15c <USB_EP0_OutStart>

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
90002654:	687b      	ldr	r3, [r7, #4]
90002656:	681b      	ldr	r3, [r3, #0]
90002658:	695a      	ldr	r2, [r3, #20]
9000265a:	687b      	ldr	r3, [r7, #4]
9000265c:	681b      	ldr	r3, [r3, #0]
9000265e:	f402 5280 	and.w	r2, r2, #4096	@ 0x1000
90002662:	615a      	str	r2, [r3, #20]
    }

    /* Handle Enumeration done Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
90002664:	687b      	ldr	r3, [r7, #4]
90002666:	681b      	ldr	r3, [r3, #0]
90002668:	4618      	mov	r0, r3
9000266a:	f007 fcb2 	bl	90009fd2 <USB_ReadInterrupts>
9000266e:	4603      	mov	r3, r0
90002670:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
90002674:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
90002678:	d123      	bne.n	900026c2 <HAL_PCD_IRQHandler+0x750>
    {
      (void)USB_ActivateSetup(hpcd->Instance);
9000267a:	687b      	ldr	r3, [r7, #4]
9000267c:	681b      	ldr	r3, [r3, #0]
9000267e:	4618      	mov	r0, r3
90002680:	f007 fd48 	bl	9000a114 <USB_ActivateSetup>
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
90002684:	687b      	ldr	r3, [r7, #4]
90002686:	681b      	ldr	r3, [r3, #0]
90002688:	4618      	mov	r0, r3
9000268a:	f006 fda6 	bl	900091da <USB_GetDevSpeed>
9000268e:	4603      	mov	r3, r0
90002690:	461a      	mov	r2, r3
90002692:	687b      	ldr	r3, [r7, #4]
90002694:	71da      	strb	r2, [r3, #7]

      /* Set USB Turnaround time */
      (void)USB_SetTurnaroundTime(hpcd->Instance,
90002696:	687b      	ldr	r3, [r7, #4]
90002698:	681c      	ldr	r4, [r3, #0]
9000269a:	f000 ffab 	bl	900035f4 <HAL_RCC_GetHCLKFreq>
9000269e:	4601      	mov	r1, r0
                                  HAL_RCC_GetHCLKFreq(),
                                  (uint8_t)hpcd->Init.speed);
900026a0:	687b      	ldr	r3, [r7, #4]
900026a2:	79db      	ldrb	r3, [r3, #7]
      (void)USB_SetTurnaroundTime(hpcd->Instance,
900026a4:	461a      	mov	r2, r3
900026a6:	4620      	mov	r0, r4
900026a8:	f006 fa70 	bl	90008b8c <USB_SetTurnaroundTime>

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ResetCallback(hpcd);
#else
      HAL_PCD_ResetCallback(hpcd);
900026ac:	6878      	ldr	r0, [r7, #4]
900026ae:	f7fe fbb6 	bl	90000e1e <HAL_PCD_ResetCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
900026b2:	687b      	ldr	r3, [r7, #4]
900026b4:	681b      	ldr	r3, [r3, #0]
900026b6:	695a      	ldr	r2, [r3, #20]
900026b8:	687b      	ldr	r3, [r7, #4]
900026ba:	681b      	ldr	r3, [r3, #0]
900026bc:	f402 5200 	and.w	r2, r2, #8192	@ 0x2000
900026c0:	615a      	str	r2, [r3, #20]
    }

    /* Handle SOF Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
900026c2:	687b      	ldr	r3, [r7, #4]
900026c4:	681b      	ldr	r3, [r3, #0]
900026c6:	4618      	mov	r0, r3
900026c8:	f007 fc83 	bl	90009fd2 <USB_ReadInterrupts>
900026cc:	4603      	mov	r3, r0
900026ce:	f003 0308 	and.w	r3, r3, #8
900026d2:	2b08      	cmp	r3, #8
900026d4:	d10a      	bne.n	900026ec <HAL_PCD_IRQHandler+0x77a>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->SOFCallback(hpcd);
#else
      HAL_PCD_SOFCallback(hpcd);
900026d6:	6878      	ldr	r0, [r7, #4]
900026d8:	f7fe fb93 	bl	90000e02 <HAL_PCD_SOFCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
900026dc:	687b      	ldr	r3, [r7, #4]
900026de:	681b      	ldr	r3, [r3, #0]
900026e0:	695a      	ldr	r2, [r3, #20]
900026e2:	687b      	ldr	r3, [r7, #4]
900026e4:	681b      	ldr	r3, [r3, #0]
900026e6:	f002 0208 	and.w	r2, r2, #8
900026ea:	615a      	str	r2, [r3, #20]
    }

    /* Handle Global OUT NAK effective Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_BOUTNAKEFF))
900026ec:	687b      	ldr	r3, [r7, #4]
900026ee:	681b      	ldr	r3, [r3, #0]
900026f0:	4618      	mov	r0, r3
900026f2:	f007 fc6e 	bl	90009fd2 <USB_ReadInterrupts>
900026f6:	4603      	mov	r3, r0
900026f8:	f003 0380 	and.w	r3, r3, #128	@ 0x80
900026fc:	2b80      	cmp	r3, #128	@ 0x80
900026fe:	d13d      	bne.n	9000277c <HAL_PCD_IRQHandler+0x80a>
    {
      USBx->GINTMSK &= ~USB_OTG_GINTMSK_GONAKEFFM;
90002700:	6a3b      	ldr	r3, [r7, #32]
90002702:	699b      	ldr	r3, [r3, #24]
90002704:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
90002708:	6a3b      	ldr	r3, [r7, #32]
9000270a:	619a      	str	r2, [r3, #24]

      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
9000270c:	2301      	movs	r3, #1
9000270e:	627b      	str	r3, [r7, #36]	@ 0x24
90002710:	e02e      	b.n	90002770 <HAL_PCD_IRQHandler+0x7fe>
      {
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
90002712:	6879      	ldr	r1, [r7, #4]
90002714:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
90002716:	4613      	mov	r3, r2
90002718:	00db      	lsls	r3, r3, #3
9000271a:	4413      	add	r3, r2
9000271c:	009b      	lsls	r3, r3, #2
9000271e:	440b      	add	r3, r1
90002720:	f203 2357 	addw	r3, r3, #599	@ 0x257
90002724:	781b      	ldrb	r3, [r3, #0]
90002726:	2b01      	cmp	r3, #1
90002728:	d11f      	bne.n	9000276a <HAL_PCD_IRQHandler+0x7f8>
        {
          /* disable the EP */
          USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_SNAK);
9000272a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
9000272c:	015a      	lsls	r2, r3, #5
9000272e:	69fb      	ldr	r3, [r7, #28]
90002730:	4413      	add	r3, r2
90002732:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90002736:	681b      	ldr	r3, [r3, #0]
90002738:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
9000273a:	0151      	lsls	r1, r2, #5
9000273c:	69fa      	ldr	r2, [r7, #28]
9000273e:	440a      	add	r2, r1
90002740:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
90002744:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
90002748:	6013      	str	r3, [r2, #0]
          USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_EPDIS);
9000274a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
9000274c:	015a      	lsls	r2, r3, #5
9000274e:	69fb      	ldr	r3, [r7, #28]
90002750:	4413      	add	r3, r2
90002752:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90002756:	681b      	ldr	r3, [r3, #0]
90002758:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
9000275a:	0151      	lsls	r1, r2, #5
9000275c:	69fa      	ldr	r2, [r7, #28]
9000275e:	440a      	add	r2, r1
90002760:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
90002764:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
90002768:	6013      	str	r3, [r2, #0]
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
9000276a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
9000276c:	3301      	adds	r3, #1
9000276e:	627b      	str	r3, [r7, #36]	@ 0x24
90002770:	687b      	ldr	r3, [r7, #4]
90002772:	791b      	ldrb	r3, [r3, #4]
90002774:	461a      	mov	r2, r3
90002776:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
90002778:	4293      	cmp	r3, r2
9000277a:	d3ca      	bcc.n	90002712 <HAL_PCD_IRQHandler+0x7a0>
        }
      }
    }

    /* Handle Incomplete ISO IN Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
9000277c:	687b      	ldr	r3, [r7, #4]
9000277e:	681b      	ldr	r3, [r3, #0]
90002780:	4618      	mov	r0, r3
90002782:	f007 fc26 	bl	90009fd2 <USB_ReadInterrupts>
90002786:	4603      	mov	r3, r0
90002788:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
9000278c:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
90002790:	d13c      	bne.n	9000280c <HAL_PCD_IRQHandler+0x89a>
    {
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
90002792:	2301      	movs	r3, #1
90002794:	627b      	str	r3, [r7, #36]	@ 0x24
90002796:	e02b      	b.n	900027f0 <HAL_PCD_IRQHandler+0x87e>
      {
        RegVal = USBx_INEP(epnum)->DIEPCTL;
90002798:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
9000279a:	015a      	lsls	r2, r3, #5
9000279c:	69fb      	ldr	r3, [r7, #28]
9000279e:	4413      	add	r3, r2
900027a0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
900027a4:	681b      	ldr	r3, [r3, #0]
900027a6:	61bb      	str	r3, [r7, #24]

        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
900027a8:	6879      	ldr	r1, [r7, #4]
900027aa:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
900027ac:	4613      	mov	r3, r2
900027ae:	00db      	lsls	r3, r3, #3
900027b0:	4413      	add	r3, r2
900027b2:	009b      	lsls	r3, r3, #2
900027b4:	440b      	add	r3, r1
900027b6:	3318      	adds	r3, #24
900027b8:	781b      	ldrb	r3, [r3, #0]
900027ba:	2b01      	cmp	r3, #1
900027bc:	d115      	bne.n	900027ea <HAL_PCD_IRQHandler+0x878>
            ((RegVal & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA))
900027be:	69bb      	ldr	r3, [r7, #24]
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
900027c0:	2b00      	cmp	r3, #0
900027c2:	da12      	bge.n	900027ea <HAL_PCD_IRQHandler+0x878>
        {
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
900027c4:	6879      	ldr	r1, [r7, #4]
900027c6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
900027c8:	4613      	mov	r3, r2
900027ca:	00db      	lsls	r3, r3, #3
900027cc:	4413      	add	r3, r2
900027ce:	009b      	lsls	r3, r3, #2
900027d0:	440b      	add	r3, r1
900027d2:	3317      	adds	r3, #23
900027d4:	2201      	movs	r2, #1
900027d6:	701a      	strb	r2, [r3, #0]

          /* Abort current transaction and disable the EP */
          (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)(epnum | 0x80U));
900027d8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
900027da:	b2db      	uxtb	r3, r3
900027dc:	f063 037f 	orn	r3, r3, #127	@ 0x7f
900027e0:	b2db      	uxtb	r3, r3
900027e2:	4619      	mov	r1, r3
900027e4:	6878      	ldr	r0, [r7, #4]
900027e6:	f000 faca 	bl	90002d7e <HAL_PCD_EP_Abort>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
900027ea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
900027ec:	3301      	adds	r3, #1
900027ee:	627b      	str	r3, [r7, #36]	@ 0x24
900027f0:	687b      	ldr	r3, [r7, #4]
900027f2:	791b      	ldrb	r3, [r3, #4]
900027f4:	461a      	mov	r2, r3
900027f6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
900027f8:	4293      	cmp	r3, r2
900027fa:	d3cd      	bcc.n	90002798 <HAL_PCD_IRQHandler+0x826>
        }
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
900027fc:	687b      	ldr	r3, [r7, #4]
900027fe:	681b      	ldr	r3, [r3, #0]
90002800:	695a      	ldr	r2, [r3, #20]
90002802:	687b      	ldr	r3, [r7, #4]
90002804:	681b      	ldr	r3, [r3, #0]
90002806:	f402 1280 	and.w	r2, r2, #1048576	@ 0x100000
9000280a:	615a      	str	r2, [r3, #20]
    }

    /* Handle Incomplete ISO OUT Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
9000280c:	687b      	ldr	r3, [r7, #4]
9000280e:	681b      	ldr	r3, [r3, #0]
90002810:	4618      	mov	r0, r3
90002812:	f007 fbde 	bl	90009fd2 <USB_ReadInterrupts>
90002816:	4603      	mov	r3, r0
90002818:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
9000281c:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
90002820:	d156      	bne.n	900028d0 <HAL_PCD_IRQHandler+0x95e>
    {
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
90002822:	2301      	movs	r3, #1
90002824:	627b      	str	r3, [r7, #36]	@ 0x24
90002826:	e045      	b.n	900028b4 <HAL_PCD_IRQHandler+0x942>
      {
        RegVal = USBx_OUTEP(epnum)->DOEPCTL;
90002828:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
9000282a:	015a      	lsls	r2, r3, #5
9000282c:	69fb      	ldr	r3, [r7, #28]
9000282e:	4413      	add	r3, r2
90002830:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90002834:	681b      	ldr	r3, [r3, #0]
90002836:	61bb      	str	r3, [r7, #24]

        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
90002838:	6879      	ldr	r1, [r7, #4]
9000283a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
9000283c:	4613      	mov	r3, r2
9000283e:	00db      	lsls	r3, r3, #3
90002840:	4413      	add	r3, r2
90002842:	009b      	lsls	r3, r3, #2
90002844:	440b      	add	r3, r1
90002846:	f503 7316 	add.w	r3, r3, #600	@ 0x258
9000284a:	781b      	ldrb	r3, [r3, #0]
9000284c:	2b01      	cmp	r3, #1
9000284e:	d12e      	bne.n	900028ae <HAL_PCD_IRQHandler+0x93c>
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
90002850:	69bb      	ldr	r3, [r7, #24]
        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
90002852:	2b00      	cmp	r3, #0
90002854:	da2b      	bge.n	900028ae <HAL_PCD_IRQHandler+0x93c>
            (((RegVal & (0x1UL << 16)) >> 16U) == (hpcd->FrameNumber & 0x1U)))
90002856:	69bb      	ldr	r3, [r7, #24]
90002858:	0c1a      	lsrs	r2, r3, #16
9000285a:	687b      	ldr	r3, [r7, #4]
9000285c:	f8d3 34d4 	ldr.w	r3, [r3, #1236]	@ 0x4d4
90002860:	4053      	eors	r3, r2
90002862:	f003 0301 	and.w	r3, r3, #1
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
90002866:	2b00      	cmp	r3, #0
90002868:	d121      	bne.n	900028ae <HAL_PCD_IRQHandler+0x93c>
        {
          hpcd->OUT_ep[epnum].is_iso_incomplete = 1U;
9000286a:	6879      	ldr	r1, [r7, #4]
9000286c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
9000286e:	4613      	mov	r3, r2
90002870:	00db      	lsls	r3, r3, #3
90002872:	4413      	add	r3, r2
90002874:	009b      	lsls	r3, r3, #2
90002876:	440b      	add	r3, r1
90002878:	f203 2357 	addw	r3, r3, #599	@ 0x257
9000287c:	2201      	movs	r2, #1
9000287e:	701a      	strb	r2, [r3, #0]

          USBx->GINTMSK |= USB_OTG_GINTMSK_GONAKEFFM;
90002880:	6a3b      	ldr	r3, [r7, #32]
90002882:	699b      	ldr	r3, [r3, #24]
90002884:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
90002888:	6a3b      	ldr	r3, [r7, #32]
9000288a:	619a      	str	r2, [r3, #24]

          if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == 0U)
9000288c:	6a3b      	ldr	r3, [r7, #32]
9000288e:	695b      	ldr	r3, [r3, #20]
90002890:	f003 0380 	and.w	r3, r3, #128	@ 0x80
90002894:	2b00      	cmp	r3, #0
90002896:	d10a      	bne.n	900028ae <HAL_PCD_IRQHandler+0x93c>
          {
            USBx_DEVICE->DCTL |= USB_OTG_DCTL_SGONAK;
90002898:	69fb      	ldr	r3, [r7, #28]
9000289a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
9000289e:	685b      	ldr	r3, [r3, #4]
900028a0:	69fa      	ldr	r2, [r7, #28]
900028a2:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
900028a6:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
900028aa:	6053      	str	r3, [r2, #4]
            break;
900028ac:	e008      	b.n	900028c0 <HAL_PCD_IRQHandler+0x94e>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
900028ae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
900028b0:	3301      	adds	r3, #1
900028b2:	627b      	str	r3, [r7, #36]	@ 0x24
900028b4:	687b      	ldr	r3, [r7, #4]
900028b6:	791b      	ldrb	r3, [r3, #4]
900028b8:	461a      	mov	r2, r3
900028ba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
900028bc:	4293      	cmp	r3, r2
900028be:	d3b3      	bcc.n	90002828 <HAL_PCD_IRQHandler+0x8b6>
          }
        }
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
900028c0:	687b      	ldr	r3, [r7, #4]
900028c2:	681b      	ldr	r3, [r3, #0]
900028c4:	695a      	ldr	r2, [r3, #20]
900028c6:	687b      	ldr	r3, [r7, #4]
900028c8:	681b      	ldr	r3, [r3, #0]
900028ca:	f402 1200 	and.w	r2, r2, #2097152	@ 0x200000
900028ce:	615a      	str	r2, [r3, #20]
    }

    /* Handle Connection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
900028d0:	687b      	ldr	r3, [r7, #4]
900028d2:	681b      	ldr	r3, [r3, #0]
900028d4:	4618      	mov	r0, r3
900028d6:	f007 fb7c 	bl	90009fd2 <USB_ReadInterrupts>
900028da:	4603      	mov	r3, r0
900028dc:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
900028e0:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
900028e4:	d10a      	bne.n	900028fc <HAL_PCD_IRQHandler+0x98a>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ConnectCallback(hpcd);
#else
      HAL_PCD_ConnectCallback(hpcd);
900028e6:	6878      	ldr	r0, [r7, #4]
900028e8:	f7fe fb2a 	bl	90000f40 <HAL_PCD_ConnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
900028ec:	687b      	ldr	r3, [r7, #4]
900028ee:	681b      	ldr	r3, [r3, #0]
900028f0:	695a      	ldr	r2, [r3, #20]
900028f2:	687b      	ldr	r3, [r7, #4]
900028f4:	681b      	ldr	r3, [r3, #0]
900028f6:	f002 4280 	and.w	r2, r2, #1073741824	@ 0x40000000
900028fa:	615a      	str	r2, [r3, #20]
    }

    /* Handle Disconnection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
900028fc:	687b      	ldr	r3, [r7, #4]
900028fe:	681b      	ldr	r3, [r3, #0]
90002900:	4618      	mov	r0, r3
90002902:	f007 fb66 	bl	90009fd2 <USB_ReadInterrupts>
90002906:	4603      	mov	r3, r0
90002908:	f003 0304 	and.w	r3, r3, #4
9000290c:	2b04      	cmp	r3, #4
9000290e:	d115      	bne.n	9000293c <HAL_PCD_IRQHandler+0x9ca>
    {
      RegVal = hpcd->Instance->GOTGINT;
90002910:	687b      	ldr	r3, [r7, #4]
90002912:	681b      	ldr	r3, [r3, #0]
90002914:	685b      	ldr	r3, [r3, #4]
90002916:	61bb      	str	r3, [r7, #24]

      if ((RegVal & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
90002918:	69bb      	ldr	r3, [r7, #24]
9000291a:	f003 0304 	and.w	r3, r3, #4
9000291e:	2b00      	cmp	r3, #0
90002920:	d002      	beq.n	90002928 <HAL_PCD_IRQHandler+0x9b6>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DisconnectCallback(hpcd);
#else
        HAL_PCD_DisconnectCallback(hpcd);
90002922:	6878      	ldr	r0, [r7, #4]
90002924:	f7fe fb1a 	bl	90000f5c <HAL_PCD_DisconnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      hpcd->Instance->GOTGINT |= RegVal;
90002928:	687b      	ldr	r3, [r7, #4]
9000292a:	681b      	ldr	r3, [r3, #0]
9000292c:	6859      	ldr	r1, [r3, #4]
9000292e:	687b      	ldr	r3, [r7, #4]
90002930:	681b      	ldr	r3, [r3, #0]
90002932:	69ba      	ldr	r2, [r7, #24]
90002934:	430a      	orrs	r2, r1
90002936:	605a      	str	r2, [r3, #4]
90002938:	e000      	b.n	9000293c <HAL_PCD_IRQHandler+0x9ca>
      return;
9000293a:	bf00      	nop
    }
  }
}
9000293c:	3734      	adds	r7, #52	@ 0x34
9000293e:	46bd      	mov	sp, r7
90002940:	bd90      	pop	{r4, r7, pc}

90002942 <HAL_PCD_SetAddress>:
  * @param  hpcd PCD handle
  * @param  address new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
90002942:	b580      	push	{r7, lr}
90002944:	b082      	sub	sp, #8
90002946:	af00      	add	r7, sp, #0
90002948:	6078      	str	r0, [r7, #4]
9000294a:	460b      	mov	r3, r1
9000294c:	70fb      	strb	r3, [r7, #3]
  __HAL_LOCK(hpcd);
9000294e:	687b      	ldr	r3, [r7, #4]
90002950:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
90002954:	2b01      	cmp	r3, #1
90002956:	d101      	bne.n	9000295c <HAL_PCD_SetAddress+0x1a>
90002958:	2302      	movs	r3, #2
9000295a:	e012      	b.n	90002982 <HAL_PCD_SetAddress+0x40>
9000295c:	687b      	ldr	r3, [r7, #4]
9000295e:	2201      	movs	r2, #1
90002960:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  hpcd->USB_Address = address;
90002964:	687b      	ldr	r3, [r7, #4]
90002966:	78fa      	ldrb	r2, [r7, #3]
90002968:	745a      	strb	r2, [r3, #17]
  (void)USB_SetDevAddress(hpcd->Instance, address);
9000296a:	687b      	ldr	r3, [r7, #4]
9000296c:	681b      	ldr	r3, [r3, #0]
9000296e:	78fa      	ldrb	r2, [r7, #3]
90002970:	4611      	mov	r1, r2
90002972:	4618      	mov	r0, r3
90002974:	f007 fac5 	bl	90009f02 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
90002978:	687b      	ldr	r3, [r7, #4]
9000297a:	2200      	movs	r2, #0
9000297c:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
90002980:	2300      	movs	r3, #0
}
90002982:	4618      	mov	r0, r3
90002984:	3708      	adds	r7, #8
90002986:	46bd      	mov	sp, r7
90002988:	bd80      	pop	{r7, pc}

9000298a <HAL_PCD_EP_Open>:
  * @param  ep_type endpoint type
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr,
                                  uint16_t ep_mps, uint8_t ep_type)
{
9000298a:	b580      	push	{r7, lr}
9000298c:	b084      	sub	sp, #16
9000298e:	af00      	add	r7, sp, #0
90002990:	6078      	str	r0, [r7, #4]
90002992:	4608      	mov	r0, r1
90002994:	4611      	mov	r1, r2
90002996:	461a      	mov	r2, r3
90002998:	4603      	mov	r3, r0
9000299a:	70fb      	strb	r3, [r7, #3]
9000299c:	460b      	mov	r3, r1
9000299e:	803b      	strh	r3, [r7, #0]
900029a0:	4613      	mov	r3, r2
900029a2:	70bb      	strb	r3, [r7, #2]
  HAL_StatusTypeDef ret = HAL_OK;
900029a4:	2300      	movs	r3, #0
900029a6:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
900029a8:	f997 3003 	ldrsb.w	r3, [r7, #3]
900029ac:	2b00      	cmp	r3, #0
900029ae:	da0f      	bge.n	900029d0 <HAL_PCD_EP_Open+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
900029b0:	78fb      	ldrb	r3, [r7, #3]
900029b2:	f003 020f 	and.w	r2, r3, #15
900029b6:	4613      	mov	r3, r2
900029b8:	00db      	lsls	r3, r3, #3
900029ba:	4413      	add	r3, r2
900029bc:	009b      	lsls	r3, r3, #2
900029be:	3310      	adds	r3, #16
900029c0:	687a      	ldr	r2, [r7, #4]
900029c2:	4413      	add	r3, r2
900029c4:	3304      	adds	r3, #4
900029c6:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
900029c8:	68fb      	ldr	r3, [r7, #12]
900029ca:	2201      	movs	r2, #1
900029cc:	705a      	strb	r2, [r3, #1]
900029ce:	e00f      	b.n	900029f0 <HAL_PCD_EP_Open+0x66>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
900029d0:	78fb      	ldrb	r3, [r7, #3]
900029d2:	f003 020f 	and.w	r2, r3, #15
900029d6:	4613      	mov	r3, r2
900029d8:	00db      	lsls	r3, r3, #3
900029da:	4413      	add	r3, r2
900029dc:	009b      	lsls	r3, r3, #2
900029de:	f503 7314 	add.w	r3, r3, #592	@ 0x250
900029e2:	687a      	ldr	r2, [r7, #4]
900029e4:	4413      	add	r3, r2
900029e6:	3304      	adds	r3, #4
900029e8:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
900029ea:	68fb      	ldr	r3, [r7, #12]
900029ec:	2200      	movs	r2, #0
900029ee:	705a      	strb	r2, [r3, #1]
  }

  ep->num = ep_addr & EP_ADDR_MSK;
900029f0:	78fb      	ldrb	r3, [r7, #3]
900029f2:	f003 030f 	and.w	r3, r3, #15
900029f6:	b2da      	uxtb	r2, r3
900029f8:	68fb      	ldr	r3, [r7, #12]
900029fa:	701a      	strb	r2, [r3, #0]
  ep->maxpacket = (uint32_t)ep_mps & 0x7FFU;
900029fc:	883b      	ldrh	r3, [r7, #0]
900029fe:	f3c3 020a 	ubfx	r2, r3, #0, #11
90002a02:	68fb      	ldr	r3, [r7, #12]
90002a04:	609a      	str	r2, [r3, #8]
  ep->type = ep_type;
90002a06:	68fb      	ldr	r3, [r7, #12]
90002a08:	78ba      	ldrb	r2, [r7, #2]
90002a0a:	711a      	strb	r2, [r3, #4]

  if (ep->is_in != 0U)
90002a0c:	68fb      	ldr	r3, [r7, #12]
90002a0e:	785b      	ldrb	r3, [r3, #1]
90002a10:	2b00      	cmp	r3, #0
90002a12:	d004      	beq.n	90002a1e <HAL_PCD_EP_Open+0x94>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
90002a14:	68fb      	ldr	r3, [r7, #12]
90002a16:	781b      	ldrb	r3, [r3, #0]
90002a18:	461a      	mov	r2, r3
90002a1a:	68fb      	ldr	r3, [r7, #12]
90002a1c:	835a      	strh	r2, [r3, #26]
  }

  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK)
90002a1e:	78bb      	ldrb	r3, [r7, #2]
90002a20:	2b02      	cmp	r3, #2
90002a22:	d102      	bne.n	90002a2a <HAL_PCD_EP_Open+0xa0>
  {
    ep->data_pid_start = 0U;
90002a24:	68fb      	ldr	r3, [r7, #12]
90002a26:	2200      	movs	r2, #0
90002a28:	715a      	strb	r2, [r3, #5]
  }

  __HAL_LOCK(hpcd);
90002a2a:	687b      	ldr	r3, [r7, #4]
90002a2c:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
90002a30:	2b01      	cmp	r3, #1
90002a32:	d101      	bne.n	90002a38 <HAL_PCD_EP_Open+0xae>
90002a34:	2302      	movs	r3, #2
90002a36:	e00e      	b.n	90002a56 <HAL_PCD_EP_Open+0xcc>
90002a38:	687b      	ldr	r3, [r7, #4]
90002a3a:	2201      	movs	r2, #1
90002a3c:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
90002a40:	687b      	ldr	r3, [r7, #4]
90002a42:	681b      	ldr	r3, [r3, #0]
90002a44:	68f9      	ldr	r1, [r7, #12]
90002a46:	4618      	mov	r0, r3
90002a48:	f006 fbec 	bl	90009224 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
90002a4c:	687b      	ldr	r3, [r7, #4]
90002a4e:	2200      	movs	r2, #0
90002a50:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return ret;
90002a54:	7afb      	ldrb	r3, [r7, #11]
}
90002a56:	4618      	mov	r0, r3
90002a58:	3710      	adds	r7, #16
90002a5a:	46bd      	mov	sp, r7
90002a5c:	bd80      	pop	{r7, pc}

90002a5e <HAL_PCD_EP_Close>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
90002a5e:	b580      	push	{r7, lr}
90002a60:	b084      	sub	sp, #16
90002a62:	af00      	add	r7, sp, #0
90002a64:	6078      	str	r0, [r7, #4]
90002a66:	460b      	mov	r3, r1
90002a68:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
90002a6a:	f997 3003 	ldrsb.w	r3, [r7, #3]
90002a6e:	2b00      	cmp	r3, #0
90002a70:	da0f      	bge.n	90002a92 <HAL_PCD_EP_Close+0x34>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
90002a72:	78fb      	ldrb	r3, [r7, #3]
90002a74:	f003 020f 	and.w	r2, r3, #15
90002a78:	4613      	mov	r3, r2
90002a7a:	00db      	lsls	r3, r3, #3
90002a7c:	4413      	add	r3, r2
90002a7e:	009b      	lsls	r3, r3, #2
90002a80:	3310      	adds	r3, #16
90002a82:	687a      	ldr	r2, [r7, #4]
90002a84:	4413      	add	r3, r2
90002a86:	3304      	adds	r3, #4
90002a88:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
90002a8a:	68fb      	ldr	r3, [r7, #12]
90002a8c:	2201      	movs	r2, #1
90002a8e:	705a      	strb	r2, [r3, #1]
90002a90:	e00f      	b.n	90002ab2 <HAL_PCD_EP_Close+0x54>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
90002a92:	78fb      	ldrb	r3, [r7, #3]
90002a94:	f003 020f 	and.w	r2, r3, #15
90002a98:	4613      	mov	r3, r2
90002a9a:	00db      	lsls	r3, r3, #3
90002a9c:	4413      	add	r3, r2
90002a9e:	009b      	lsls	r3, r3, #2
90002aa0:	f503 7314 	add.w	r3, r3, #592	@ 0x250
90002aa4:	687a      	ldr	r2, [r7, #4]
90002aa6:	4413      	add	r3, r2
90002aa8:	3304      	adds	r3, #4
90002aaa:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
90002aac:	68fb      	ldr	r3, [r7, #12]
90002aae:	2200      	movs	r2, #0
90002ab0:	705a      	strb	r2, [r3, #1]
  }
  ep->num = ep_addr & EP_ADDR_MSK;
90002ab2:	78fb      	ldrb	r3, [r7, #3]
90002ab4:	f003 030f 	and.w	r3, r3, #15
90002ab8:	b2da      	uxtb	r2, r3
90002aba:	68fb      	ldr	r3, [r7, #12]
90002abc:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
90002abe:	687b      	ldr	r3, [r7, #4]
90002ac0:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
90002ac4:	2b01      	cmp	r3, #1
90002ac6:	d101      	bne.n	90002acc <HAL_PCD_EP_Close+0x6e>
90002ac8:	2302      	movs	r3, #2
90002aca:	e00e      	b.n	90002aea <HAL_PCD_EP_Close+0x8c>
90002acc:	687b      	ldr	r3, [r7, #4]
90002ace:	2201      	movs	r2, #1
90002ad0:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
90002ad4:	687b      	ldr	r3, [r7, #4]
90002ad6:	681b      	ldr	r3, [r3, #0]
90002ad8:	68f9      	ldr	r1, [r7, #12]
90002ada:	4618      	mov	r0, r3
90002adc:	f006 fc2a 	bl	90009334 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
90002ae0:	687b      	ldr	r3, [r7, #4]
90002ae2:	2200      	movs	r2, #0
90002ae4:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  return HAL_OK;
90002ae8:	2300      	movs	r3, #0
}
90002aea:	4618      	mov	r0, r3
90002aec:	3710      	adds	r7, #16
90002aee:	46bd      	mov	sp, r7
90002af0:	bd80      	pop	{r7, pc}

90002af2 <HAL_PCD_EP_Receive>:
  * @param  pBuf pointer to the reception buffer
  * @param  len amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
90002af2:	b580      	push	{r7, lr}
90002af4:	b086      	sub	sp, #24
90002af6:	af00      	add	r7, sp, #0
90002af8:	60f8      	str	r0, [r7, #12]
90002afa:	607a      	str	r2, [r7, #4]
90002afc:	603b      	str	r3, [r7, #0]
90002afe:	460b      	mov	r3, r1
90002b00:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
90002b02:	7afb      	ldrb	r3, [r7, #11]
90002b04:	f003 020f 	and.w	r2, r3, #15
90002b08:	4613      	mov	r3, r2
90002b0a:	00db      	lsls	r3, r3, #3
90002b0c:	4413      	add	r3, r2
90002b0e:	009b      	lsls	r3, r3, #2
90002b10:	f503 7314 	add.w	r3, r3, #592	@ 0x250
90002b14:	68fa      	ldr	r2, [r7, #12]
90002b16:	4413      	add	r3, r2
90002b18:	3304      	adds	r3, #4
90002b1a:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
90002b1c:	697b      	ldr	r3, [r7, #20]
90002b1e:	687a      	ldr	r2, [r7, #4]
90002b20:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
90002b22:	697b      	ldr	r3, [r7, #20]
90002b24:	683a      	ldr	r2, [r7, #0]
90002b26:	611a      	str	r2, [r3, #16]
  ep->xfer_count = 0U;
90002b28:	697b      	ldr	r3, [r7, #20]
90002b2a:	2200      	movs	r2, #0
90002b2c:	615a      	str	r2, [r3, #20]
  ep->is_in = 0U;
90002b2e:	697b      	ldr	r3, [r7, #20]
90002b30:	2200      	movs	r2, #0
90002b32:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
90002b34:	7afb      	ldrb	r3, [r7, #11]
90002b36:	f003 030f 	and.w	r3, r3, #15
90002b3a:	b2da      	uxtb	r2, r3
90002b3c:	697b      	ldr	r3, [r7, #20]
90002b3e:	701a      	strb	r2, [r3, #0]

  if (hpcd->Init.dma_enable == 1U)
90002b40:	68fb      	ldr	r3, [r7, #12]
90002b42:	799b      	ldrb	r3, [r3, #6]
90002b44:	2b01      	cmp	r3, #1
90002b46:	d102      	bne.n	90002b4e <HAL_PCD_EP_Receive+0x5c>
  {
    ep->dma_addr = (uint32_t)pBuf;
90002b48:	687a      	ldr	r2, [r7, #4]
90002b4a:	697b      	ldr	r3, [r7, #20]
90002b4c:	61da      	str	r2, [r3, #28]
  }

  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
90002b4e:	68fb      	ldr	r3, [r7, #12]
90002b50:	6818      	ldr	r0, [r3, #0]
90002b52:	68fb      	ldr	r3, [r7, #12]
90002b54:	799b      	ldrb	r3, [r3, #6]
90002b56:	461a      	mov	r2, r3
90002b58:	6979      	ldr	r1, [r7, #20]
90002b5a:	f006 fcc7 	bl	900094ec <USB_EPStartXfer>

  return HAL_OK;
90002b5e:	2300      	movs	r3, #0
}
90002b60:	4618      	mov	r0, r3
90002b62:	3718      	adds	r7, #24
90002b64:	46bd      	mov	sp, r7
90002b66:	bd80      	pop	{r7, pc}

90002b68 <HAL_PCD_EP_GetRxCount>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval Data Size
  */
uint32_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef const *hpcd, uint8_t ep_addr)
{
90002b68:	b480      	push	{r7}
90002b6a:	b083      	sub	sp, #12
90002b6c:	af00      	add	r7, sp, #0
90002b6e:	6078      	str	r0, [r7, #4]
90002b70:	460b      	mov	r3, r1
90002b72:	70fb      	strb	r3, [r7, #3]
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
90002b74:	78fb      	ldrb	r3, [r7, #3]
90002b76:	f003 020f 	and.w	r2, r3, #15
90002b7a:	6879      	ldr	r1, [r7, #4]
90002b7c:	4613      	mov	r3, r2
90002b7e:	00db      	lsls	r3, r3, #3
90002b80:	4413      	add	r3, r2
90002b82:	009b      	lsls	r3, r3, #2
90002b84:	440b      	add	r3, r1
90002b86:	f503 731a 	add.w	r3, r3, #616	@ 0x268
90002b8a:	681b      	ldr	r3, [r3, #0]
}
90002b8c:	4618      	mov	r0, r3
90002b8e:	370c      	adds	r7, #12
90002b90:	46bd      	mov	sp, r7
90002b92:	f85d 7b04 	ldr.w	r7, [sp], #4
90002b96:	4770      	bx	lr

90002b98 <HAL_PCD_EP_Transmit>:
  * @param  pBuf pointer to the transmission buffer
  * @param  len amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
90002b98:	b580      	push	{r7, lr}
90002b9a:	b086      	sub	sp, #24
90002b9c:	af00      	add	r7, sp, #0
90002b9e:	60f8      	str	r0, [r7, #12]
90002ba0:	607a      	str	r2, [r7, #4]
90002ba2:	603b      	str	r3, [r7, #0]
90002ba4:	460b      	mov	r3, r1
90002ba6:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
90002ba8:	7afb      	ldrb	r3, [r7, #11]
90002baa:	f003 020f 	and.w	r2, r3, #15
90002bae:	4613      	mov	r3, r2
90002bb0:	00db      	lsls	r3, r3, #3
90002bb2:	4413      	add	r3, r2
90002bb4:	009b      	lsls	r3, r3, #2
90002bb6:	3310      	adds	r3, #16
90002bb8:	68fa      	ldr	r2, [r7, #12]
90002bba:	4413      	add	r3, r2
90002bbc:	3304      	adds	r3, #4
90002bbe:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
90002bc0:	697b      	ldr	r3, [r7, #20]
90002bc2:	687a      	ldr	r2, [r7, #4]
90002bc4:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
90002bc6:	697b      	ldr	r3, [r7, #20]
90002bc8:	683a      	ldr	r2, [r7, #0]
90002bca:	611a      	str	r2, [r3, #16]
  ep->xfer_count = 0U;
90002bcc:	697b      	ldr	r3, [r7, #20]
90002bce:	2200      	movs	r2, #0
90002bd0:	615a      	str	r2, [r3, #20]
  ep->is_in = 1U;
90002bd2:	697b      	ldr	r3, [r7, #20]
90002bd4:	2201      	movs	r2, #1
90002bd6:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
90002bd8:	7afb      	ldrb	r3, [r7, #11]
90002bda:	f003 030f 	and.w	r3, r3, #15
90002bde:	b2da      	uxtb	r2, r3
90002be0:	697b      	ldr	r3, [r7, #20]
90002be2:	701a      	strb	r2, [r3, #0]

  if (hpcd->Init.dma_enable == 1U)
90002be4:	68fb      	ldr	r3, [r7, #12]
90002be6:	799b      	ldrb	r3, [r3, #6]
90002be8:	2b01      	cmp	r3, #1
90002bea:	d102      	bne.n	90002bf2 <HAL_PCD_EP_Transmit+0x5a>
  {
    ep->dma_addr = (uint32_t)pBuf;
90002bec:	687a      	ldr	r2, [r7, #4]
90002bee:	697b      	ldr	r3, [r7, #20]
90002bf0:	61da      	str	r2, [r3, #28]
  }

  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
90002bf2:	68fb      	ldr	r3, [r7, #12]
90002bf4:	6818      	ldr	r0, [r3, #0]
90002bf6:	68fb      	ldr	r3, [r7, #12]
90002bf8:	799b      	ldrb	r3, [r3, #6]
90002bfa:	461a      	mov	r2, r3
90002bfc:	6979      	ldr	r1, [r7, #20]
90002bfe:	f006 fc75 	bl	900094ec <USB_EPStartXfer>

  return HAL_OK;
90002c02:	2300      	movs	r3, #0
}
90002c04:	4618      	mov	r0, r3
90002c06:	3718      	adds	r7, #24
90002c08:	46bd      	mov	sp, r7
90002c0a:	bd80      	pop	{r7, pc}

90002c0c <HAL_PCD_EP_SetStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
90002c0c:	b580      	push	{r7, lr}
90002c0e:	b084      	sub	sp, #16
90002c10:	af00      	add	r7, sp, #0
90002c12:	6078      	str	r0, [r7, #4]
90002c14:	460b      	mov	r3, r1
90002c16:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
90002c18:	78fb      	ldrb	r3, [r7, #3]
90002c1a:	f003 030f 	and.w	r3, r3, #15
90002c1e:	687a      	ldr	r2, [r7, #4]
90002c20:	7912      	ldrb	r2, [r2, #4]
90002c22:	4293      	cmp	r3, r2
90002c24:	d901      	bls.n	90002c2a <HAL_PCD_EP_SetStall+0x1e>
  {
    return HAL_ERROR;
90002c26:	2301      	movs	r3, #1
90002c28:	e04f      	b.n	90002cca <HAL_PCD_EP_SetStall+0xbe>
  }

  if ((0x80U & ep_addr) == 0x80U)
90002c2a:	f997 3003 	ldrsb.w	r3, [r7, #3]
90002c2e:	2b00      	cmp	r3, #0
90002c30:	da0f      	bge.n	90002c52 <HAL_PCD_EP_SetStall+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
90002c32:	78fb      	ldrb	r3, [r7, #3]
90002c34:	f003 020f 	and.w	r2, r3, #15
90002c38:	4613      	mov	r3, r2
90002c3a:	00db      	lsls	r3, r3, #3
90002c3c:	4413      	add	r3, r2
90002c3e:	009b      	lsls	r3, r3, #2
90002c40:	3310      	adds	r3, #16
90002c42:	687a      	ldr	r2, [r7, #4]
90002c44:	4413      	add	r3, r2
90002c46:	3304      	adds	r3, #4
90002c48:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
90002c4a:	68fb      	ldr	r3, [r7, #12]
90002c4c:	2201      	movs	r2, #1
90002c4e:	705a      	strb	r2, [r3, #1]
90002c50:	e00d      	b.n	90002c6e <HAL_PCD_EP_SetStall+0x62>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
90002c52:	78fa      	ldrb	r2, [r7, #3]
90002c54:	4613      	mov	r3, r2
90002c56:	00db      	lsls	r3, r3, #3
90002c58:	4413      	add	r3, r2
90002c5a:	009b      	lsls	r3, r3, #2
90002c5c:	f503 7314 	add.w	r3, r3, #592	@ 0x250
90002c60:	687a      	ldr	r2, [r7, #4]
90002c62:	4413      	add	r3, r2
90002c64:	3304      	adds	r3, #4
90002c66:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
90002c68:	68fb      	ldr	r3, [r7, #12]
90002c6a:	2200      	movs	r2, #0
90002c6c:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 1U;
90002c6e:	68fb      	ldr	r3, [r7, #12]
90002c70:	2201      	movs	r2, #1
90002c72:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
90002c74:	78fb      	ldrb	r3, [r7, #3]
90002c76:	f003 030f 	and.w	r3, r3, #15
90002c7a:	b2da      	uxtb	r2, r3
90002c7c:	68fb      	ldr	r3, [r7, #12]
90002c7e:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
90002c80:	687b      	ldr	r3, [r7, #4]
90002c82:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
90002c86:	2b01      	cmp	r3, #1
90002c88:	d101      	bne.n	90002c8e <HAL_PCD_EP_SetStall+0x82>
90002c8a:	2302      	movs	r3, #2
90002c8c:	e01d      	b.n	90002cca <HAL_PCD_EP_SetStall+0xbe>
90002c8e:	687b      	ldr	r3, [r7, #4]
90002c90:	2201      	movs	r2, #1
90002c92:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  (void)USB_EPSetStall(hpcd->Instance, ep);
90002c96:	687b      	ldr	r3, [r7, #4]
90002c98:	681b      	ldr	r3, [r3, #0]
90002c9a:	68f9      	ldr	r1, [r7, #12]
90002c9c:	4618      	mov	r0, r3
90002c9e:	f006 ffc6 	bl	90009c2e <USB_EPSetStall>

  if ((ep_addr & EP_ADDR_MSK) == 0U)
90002ca2:	78fb      	ldrb	r3, [r7, #3]
90002ca4:	f003 030f 	and.w	r3, r3, #15
90002ca8:	2b00      	cmp	r3, #0
90002caa:	d109      	bne.n	90002cc0 <HAL_PCD_EP_SetStall+0xb4>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
90002cac:	687b      	ldr	r3, [r7, #4]
90002cae:	6818      	ldr	r0, [r3, #0]
90002cb0:	687b      	ldr	r3, [r7, #4]
90002cb2:	7999      	ldrb	r1, [r3, #6]
90002cb4:	687b      	ldr	r3, [r7, #4]
90002cb6:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
90002cba:	461a      	mov	r2, r3
90002cbc:	f007 fa4e 	bl	9000a15c <USB_EP0_OutStart>
  }

  __HAL_UNLOCK(hpcd);
90002cc0:	687b      	ldr	r3, [r7, #4]
90002cc2:	2200      	movs	r2, #0
90002cc4:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
90002cc8:	2300      	movs	r3, #0
}
90002cca:	4618      	mov	r0, r3
90002ccc:	3710      	adds	r7, #16
90002cce:	46bd      	mov	sp, r7
90002cd0:	bd80      	pop	{r7, pc}

90002cd2 <HAL_PCD_EP_ClrStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
90002cd2:	b580      	push	{r7, lr}
90002cd4:	b084      	sub	sp, #16
90002cd6:	af00      	add	r7, sp, #0
90002cd8:	6078      	str	r0, [r7, #4]
90002cda:	460b      	mov	r3, r1
90002cdc:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
90002cde:	78fb      	ldrb	r3, [r7, #3]
90002ce0:	f003 030f 	and.w	r3, r3, #15
90002ce4:	687a      	ldr	r2, [r7, #4]
90002ce6:	7912      	ldrb	r2, [r2, #4]
90002ce8:	4293      	cmp	r3, r2
90002cea:	d901      	bls.n	90002cf0 <HAL_PCD_EP_ClrStall+0x1e>
  {
    return HAL_ERROR;
90002cec:	2301      	movs	r3, #1
90002cee:	e042      	b.n	90002d76 <HAL_PCD_EP_ClrStall+0xa4>
  }

  if ((0x80U & ep_addr) == 0x80U)
90002cf0:	f997 3003 	ldrsb.w	r3, [r7, #3]
90002cf4:	2b00      	cmp	r3, #0
90002cf6:	da0f      	bge.n	90002d18 <HAL_PCD_EP_ClrStall+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
90002cf8:	78fb      	ldrb	r3, [r7, #3]
90002cfa:	f003 020f 	and.w	r2, r3, #15
90002cfe:	4613      	mov	r3, r2
90002d00:	00db      	lsls	r3, r3, #3
90002d02:	4413      	add	r3, r2
90002d04:	009b      	lsls	r3, r3, #2
90002d06:	3310      	adds	r3, #16
90002d08:	687a      	ldr	r2, [r7, #4]
90002d0a:	4413      	add	r3, r2
90002d0c:	3304      	adds	r3, #4
90002d0e:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
90002d10:	68fb      	ldr	r3, [r7, #12]
90002d12:	2201      	movs	r2, #1
90002d14:	705a      	strb	r2, [r3, #1]
90002d16:	e00f      	b.n	90002d38 <HAL_PCD_EP_ClrStall+0x66>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
90002d18:	78fb      	ldrb	r3, [r7, #3]
90002d1a:	f003 020f 	and.w	r2, r3, #15
90002d1e:	4613      	mov	r3, r2
90002d20:	00db      	lsls	r3, r3, #3
90002d22:	4413      	add	r3, r2
90002d24:	009b      	lsls	r3, r3, #2
90002d26:	f503 7314 	add.w	r3, r3, #592	@ 0x250
90002d2a:	687a      	ldr	r2, [r7, #4]
90002d2c:	4413      	add	r3, r2
90002d2e:	3304      	adds	r3, #4
90002d30:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
90002d32:	68fb      	ldr	r3, [r7, #12]
90002d34:	2200      	movs	r2, #0
90002d36:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 0U;
90002d38:	68fb      	ldr	r3, [r7, #12]
90002d3a:	2200      	movs	r2, #0
90002d3c:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
90002d3e:	78fb      	ldrb	r3, [r7, #3]
90002d40:	f003 030f 	and.w	r3, r3, #15
90002d44:	b2da      	uxtb	r2, r3
90002d46:	68fb      	ldr	r3, [r7, #12]
90002d48:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
90002d4a:	687b      	ldr	r3, [r7, #4]
90002d4c:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
90002d50:	2b01      	cmp	r3, #1
90002d52:	d101      	bne.n	90002d58 <HAL_PCD_EP_ClrStall+0x86>
90002d54:	2302      	movs	r3, #2
90002d56:	e00e      	b.n	90002d76 <HAL_PCD_EP_ClrStall+0xa4>
90002d58:	687b      	ldr	r3, [r7, #4]
90002d5a:	2201      	movs	r2, #1
90002d5c:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_EPClearStall(hpcd->Instance, ep);
90002d60:	687b      	ldr	r3, [r7, #4]
90002d62:	681b      	ldr	r3, [r3, #0]
90002d64:	68f9      	ldr	r1, [r7, #12]
90002d66:	4618      	mov	r0, r3
90002d68:	f006 ffcf 	bl	90009d0a <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
90002d6c:	687b      	ldr	r3, [r7, #4]
90002d6e:	2200      	movs	r2, #0
90002d70:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
90002d74:	2300      	movs	r3, #0
}
90002d76:	4618      	mov	r0, r3
90002d78:	3710      	adds	r7, #16
90002d7a:	46bd      	mov	sp, r7
90002d7c:	bd80      	pop	{r7, pc}

90002d7e <HAL_PCD_EP_Abort>:
   * @param  hpcd PCD handle
   * @param  ep_addr endpoint address
   * @retval HAL status
   */
HAL_StatusTypeDef HAL_PCD_EP_Abort(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
90002d7e:	b580      	push	{r7, lr}
90002d80:	b084      	sub	sp, #16
90002d82:	af00      	add	r7, sp, #0
90002d84:	6078      	str	r0, [r7, #4]
90002d86:	460b      	mov	r3, r1
90002d88:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef ret;
  PCD_EPTypeDef *ep;

  if ((0x80U & ep_addr) == 0x80U)
90002d8a:	f997 3003 	ldrsb.w	r3, [r7, #3]
90002d8e:	2b00      	cmp	r3, #0
90002d90:	da0c      	bge.n	90002dac <HAL_PCD_EP_Abort+0x2e>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
90002d92:	78fb      	ldrb	r3, [r7, #3]
90002d94:	f003 020f 	and.w	r2, r3, #15
90002d98:	4613      	mov	r3, r2
90002d9a:	00db      	lsls	r3, r3, #3
90002d9c:	4413      	add	r3, r2
90002d9e:	009b      	lsls	r3, r3, #2
90002da0:	3310      	adds	r3, #16
90002da2:	687a      	ldr	r2, [r7, #4]
90002da4:	4413      	add	r3, r2
90002da6:	3304      	adds	r3, #4
90002da8:	60fb      	str	r3, [r7, #12]
90002daa:	e00c      	b.n	90002dc6 <HAL_PCD_EP_Abort+0x48>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
90002dac:	78fb      	ldrb	r3, [r7, #3]
90002dae:	f003 020f 	and.w	r2, r3, #15
90002db2:	4613      	mov	r3, r2
90002db4:	00db      	lsls	r3, r3, #3
90002db6:	4413      	add	r3, r2
90002db8:	009b      	lsls	r3, r3, #2
90002dba:	f503 7314 	add.w	r3, r3, #592	@ 0x250
90002dbe:	687a      	ldr	r2, [r7, #4]
90002dc0:	4413      	add	r3, r2
90002dc2:	3304      	adds	r3, #4
90002dc4:	60fb      	str	r3, [r7, #12]
  }

  /* Stop Xfer */
  ret = USB_EPStopXfer(hpcd->Instance, ep);
90002dc6:	687b      	ldr	r3, [r7, #4]
90002dc8:	681b      	ldr	r3, [r3, #0]
90002dca:	68f9      	ldr	r1, [r7, #12]
90002dcc:	4618      	mov	r0, r3
90002dce:	f006 fe31 	bl	90009a34 <USB_EPStopXfer>
90002dd2:	4603      	mov	r3, r0
90002dd4:	72fb      	strb	r3, [r7, #11]

  return ret;
90002dd6:	7afb      	ldrb	r3, [r7, #11]
}
90002dd8:	4618      	mov	r0, r3
90002dda:	3710      	adds	r7, #16
90002ddc:	46bd      	mov	sp, r7
90002dde:	bd80      	pop	{r7, pc}

90002de0 <HAL_PCD_EP_Flush>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
90002de0:	b580      	push	{r7, lr}
90002de2:	b082      	sub	sp, #8
90002de4:	af00      	add	r7, sp, #0
90002de6:	6078      	str	r0, [r7, #4]
90002de8:	460b      	mov	r3, r1
90002dea:	70fb      	strb	r3, [r7, #3]
  __HAL_LOCK(hpcd);
90002dec:	687b      	ldr	r3, [r7, #4]
90002dee:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
90002df2:	2b01      	cmp	r3, #1
90002df4:	d101      	bne.n	90002dfa <HAL_PCD_EP_Flush+0x1a>
90002df6:	2302      	movs	r3, #2
90002df8:	e01b      	b.n	90002e32 <HAL_PCD_EP_Flush+0x52>
90002dfa:	687b      	ldr	r3, [r7, #4]
90002dfc:	2201      	movs	r2, #1
90002dfe:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  if ((ep_addr & 0x80U) == 0x80U)
90002e02:	f997 3003 	ldrsb.w	r3, [r7, #3]
90002e06:	2b00      	cmp	r3, #0
90002e08:	da09      	bge.n	90002e1e <HAL_PCD_EP_Flush+0x3e>
  {
    (void)USB_FlushTxFifo(hpcd->Instance, (uint32_t)ep_addr & EP_ADDR_MSK);
90002e0a:	687b      	ldr	r3, [r7, #4]
90002e0c:	681a      	ldr	r2, [r3, #0]
90002e0e:	78fb      	ldrb	r3, [r7, #3]
90002e10:	f003 030f 	and.w	r3, r3, #15
90002e14:	4619      	mov	r1, r3
90002e16:	4610      	mov	r0, r2
90002e18:	f006 f966 	bl	900090e8 <USB_FlushTxFifo>
90002e1c:	e004      	b.n	90002e28 <HAL_PCD_EP_Flush+0x48>
  }
  else
  {
    (void)USB_FlushRxFifo(hpcd->Instance);
90002e1e:	687b      	ldr	r3, [r7, #4]
90002e20:	681b      	ldr	r3, [r3, #0]
90002e22:	4618      	mov	r0, r3
90002e24:	f006 f992 	bl	9000914c <USB_FlushRxFifo>
  }

  __HAL_UNLOCK(hpcd);
90002e28:	687b      	ldr	r3, [r7, #4]
90002e2a:	2200      	movs	r2, #0
90002e2c:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
90002e30:	2300      	movs	r3, #0
}
90002e32:	4618      	mov	r0, r3
90002e34:	3708      	adds	r7, #8
90002e36:	46bd      	mov	sp, r7
90002e38:	bd80      	pop	{r7, pc}

90002e3a <PCD_WriteEmptyTxFifo>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
90002e3a:	b580      	push	{r7, lr}
90002e3c:	b08a      	sub	sp, #40	@ 0x28
90002e3e:	af02      	add	r7, sp, #8
90002e40:	6078      	str	r0, [r7, #4]
90002e42:	6039      	str	r1, [r7, #0]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
90002e44:	687b      	ldr	r3, [r7, #4]
90002e46:	681b      	ldr	r3, [r3, #0]
90002e48:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
90002e4a:	697b      	ldr	r3, [r7, #20]
90002e4c:	613b      	str	r3, [r7, #16]
  USB_OTG_EPTypeDef *ep;
  uint32_t len;
  uint32_t len32b;
  uint32_t fifoemptymsk;

  ep = &hpcd->IN_ep[epnum];
90002e4e:	683a      	ldr	r2, [r7, #0]
90002e50:	4613      	mov	r3, r2
90002e52:	00db      	lsls	r3, r3, #3
90002e54:	4413      	add	r3, r2
90002e56:	009b      	lsls	r3, r3, #2
90002e58:	3310      	adds	r3, #16
90002e5a:	687a      	ldr	r2, [r7, #4]
90002e5c:	4413      	add	r3, r2
90002e5e:	3304      	adds	r3, #4
90002e60:	60fb      	str	r3, [r7, #12]

  if (ep->xfer_count > ep->xfer_len)
90002e62:	68fb      	ldr	r3, [r7, #12]
90002e64:	695a      	ldr	r2, [r3, #20]
90002e66:	68fb      	ldr	r3, [r7, #12]
90002e68:	691b      	ldr	r3, [r3, #16]
90002e6a:	429a      	cmp	r2, r3
90002e6c:	d901      	bls.n	90002e72 <PCD_WriteEmptyTxFifo+0x38>
  {
    return HAL_ERROR;
90002e6e:	2301      	movs	r3, #1
90002e70:	e06b      	b.n	90002f4a <PCD_WriteEmptyTxFifo+0x110>
  }

  len = ep->xfer_len - ep->xfer_count;
90002e72:	68fb      	ldr	r3, [r7, #12]
90002e74:	691a      	ldr	r2, [r3, #16]
90002e76:	68fb      	ldr	r3, [r7, #12]
90002e78:	695b      	ldr	r3, [r3, #20]
90002e7a:	1ad3      	subs	r3, r2, r3
90002e7c:	61fb      	str	r3, [r7, #28]

  if (len > ep->maxpacket)
90002e7e:	68fb      	ldr	r3, [r7, #12]
90002e80:	689b      	ldr	r3, [r3, #8]
90002e82:	69fa      	ldr	r2, [r7, #28]
90002e84:	429a      	cmp	r2, r3
90002e86:	d902      	bls.n	90002e8e <PCD_WriteEmptyTxFifo+0x54>
  {
    len = ep->maxpacket;
90002e88:	68fb      	ldr	r3, [r7, #12]
90002e8a:	689b      	ldr	r3, [r3, #8]
90002e8c:	61fb      	str	r3, [r7, #28]
  }

  len32b = (len + 3U) / 4U;
90002e8e:	69fb      	ldr	r3, [r7, #28]
90002e90:	3303      	adds	r3, #3
90002e92:	089b      	lsrs	r3, r3, #2
90002e94:	61bb      	str	r3, [r7, #24]

  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
90002e96:	e02a      	b.n	90002eee <PCD_WriteEmptyTxFifo+0xb4>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
90002e98:	68fb      	ldr	r3, [r7, #12]
90002e9a:	691a      	ldr	r2, [r3, #16]
90002e9c:	68fb      	ldr	r3, [r7, #12]
90002e9e:	695b      	ldr	r3, [r3, #20]
90002ea0:	1ad3      	subs	r3, r2, r3
90002ea2:	61fb      	str	r3, [r7, #28]

    if (len > ep->maxpacket)
90002ea4:	68fb      	ldr	r3, [r7, #12]
90002ea6:	689b      	ldr	r3, [r3, #8]
90002ea8:	69fa      	ldr	r2, [r7, #28]
90002eaa:	429a      	cmp	r2, r3
90002eac:	d902      	bls.n	90002eb4 <PCD_WriteEmptyTxFifo+0x7a>
    {
      len = ep->maxpacket;
90002eae:	68fb      	ldr	r3, [r7, #12]
90002eb0:	689b      	ldr	r3, [r3, #8]
90002eb2:	61fb      	str	r3, [r7, #28]
    }
    len32b = (len + 3U) / 4U;
90002eb4:	69fb      	ldr	r3, [r7, #28]
90002eb6:	3303      	adds	r3, #3
90002eb8:	089b      	lsrs	r3, r3, #2
90002eba:	61bb      	str	r3, [r7, #24]

    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
90002ebc:	68fb      	ldr	r3, [r7, #12]
90002ebe:	68d9      	ldr	r1, [r3, #12]
90002ec0:	683b      	ldr	r3, [r7, #0]
90002ec2:	b2da      	uxtb	r2, r3
90002ec4:	69fb      	ldr	r3, [r7, #28]
90002ec6:	b298      	uxth	r0, r3
                          (uint8_t)hpcd->Init.dma_enable);
90002ec8:	687b      	ldr	r3, [r7, #4]
90002eca:	799b      	ldrb	r3, [r3, #6]
    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
90002ecc:	9300      	str	r3, [sp, #0]
90002ece:	4603      	mov	r3, r0
90002ed0:	6978      	ldr	r0, [r7, #20]
90002ed2:	f006 ff80 	bl	90009dd6 <USB_WritePacket>

    ep->xfer_buff  += len;
90002ed6:	68fb      	ldr	r3, [r7, #12]
90002ed8:	68da      	ldr	r2, [r3, #12]
90002eda:	69fb      	ldr	r3, [r7, #28]
90002edc:	441a      	add	r2, r3
90002ede:	68fb      	ldr	r3, [r7, #12]
90002ee0:	60da      	str	r2, [r3, #12]
    ep->xfer_count += len;
90002ee2:	68fb      	ldr	r3, [r7, #12]
90002ee4:	695a      	ldr	r2, [r3, #20]
90002ee6:	69fb      	ldr	r3, [r7, #28]
90002ee8:	441a      	add	r2, r3
90002eea:	68fb      	ldr	r3, [r7, #12]
90002eec:	615a      	str	r2, [r3, #20]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
90002eee:	683b      	ldr	r3, [r7, #0]
90002ef0:	015a      	lsls	r2, r3, #5
90002ef2:	693b      	ldr	r3, [r7, #16]
90002ef4:	4413      	add	r3, r2
90002ef6:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90002efa:	699b      	ldr	r3, [r3, #24]
90002efc:	b29b      	uxth	r3, r3
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
90002efe:	69ba      	ldr	r2, [r7, #24]
90002f00:	429a      	cmp	r2, r3
90002f02:	d809      	bhi.n	90002f18 <PCD_WriteEmptyTxFifo+0xde>
90002f04:	68fb      	ldr	r3, [r7, #12]
90002f06:	695a      	ldr	r2, [r3, #20]
90002f08:	68fb      	ldr	r3, [r7, #12]
90002f0a:	691b      	ldr	r3, [r3, #16]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
90002f0c:	429a      	cmp	r2, r3
90002f0e:	d203      	bcs.n	90002f18 <PCD_WriteEmptyTxFifo+0xde>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
90002f10:	68fb      	ldr	r3, [r7, #12]
90002f12:	691b      	ldr	r3, [r3, #16]
90002f14:	2b00      	cmp	r3, #0
90002f16:	d1bf      	bne.n	90002e98 <PCD_WriteEmptyTxFifo+0x5e>
  }

  if (ep->xfer_len <= ep->xfer_count)
90002f18:	68fb      	ldr	r3, [r7, #12]
90002f1a:	691a      	ldr	r2, [r3, #16]
90002f1c:	68fb      	ldr	r3, [r7, #12]
90002f1e:	695b      	ldr	r3, [r3, #20]
90002f20:	429a      	cmp	r2, r3
90002f22:	d811      	bhi.n	90002f48 <PCD_WriteEmptyTxFifo+0x10e>
  {
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
90002f24:	683b      	ldr	r3, [r7, #0]
90002f26:	f003 030f 	and.w	r3, r3, #15
90002f2a:	2201      	movs	r2, #1
90002f2c:	fa02 f303 	lsl.w	r3, r2, r3
90002f30:	60bb      	str	r3, [r7, #8]
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
90002f32:	693b      	ldr	r3, [r7, #16]
90002f34:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90002f38:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
90002f3a:	68bb      	ldr	r3, [r7, #8]
90002f3c:	43db      	mvns	r3, r3
90002f3e:	6939      	ldr	r1, [r7, #16]
90002f40:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
90002f44:	4013      	ands	r3, r2
90002f46:	634b      	str	r3, [r1, #52]	@ 0x34
  }

  return HAL_OK;
90002f48:	2300      	movs	r3, #0
}
90002f4a:	4618      	mov	r0, r3
90002f4c:	3720      	adds	r7, #32
90002f4e:	46bd      	mov	sp, r7
90002f50:	bd80      	pop	{r7, pc}
	...

90002f54 <PCD_EP_OutXfrComplete_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutXfrComplete_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
90002f54:	b580      	push	{r7, lr}
90002f56:	b088      	sub	sp, #32
90002f58:	af00      	add	r7, sp, #0
90002f5a:	6078      	str	r0, [r7, #4]
90002f5c:	6039      	str	r1, [r7, #0]
  USB_OTG_EPTypeDef *ep;
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
90002f5e:	687b      	ldr	r3, [r7, #4]
90002f60:	681b      	ldr	r3, [r3, #0]
90002f62:	61fb      	str	r3, [r7, #28]
  uint32_t USBx_BASE = (uint32_t)USBx;
90002f64:	69fb      	ldr	r3, [r7, #28]
90002f66:	61bb      	str	r3, [r7, #24]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
90002f68:	69fb      	ldr	r3, [r7, #28]
90002f6a:	333c      	adds	r3, #60	@ 0x3c
90002f6c:	3304      	adds	r3, #4
90002f6e:	681b      	ldr	r3, [r3, #0]
90002f70:	617b      	str	r3, [r7, #20]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
90002f72:	683b      	ldr	r3, [r7, #0]
90002f74:	015a      	lsls	r2, r3, #5
90002f76:	69bb      	ldr	r3, [r7, #24]
90002f78:	4413      	add	r3, r2
90002f7a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90002f7e:	689b      	ldr	r3, [r3, #8]
90002f80:	613b      	str	r3, [r7, #16]

  if (hpcd->Init.dma_enable == 1U)
90002f82:	687b      	ldr	r3, [r7, #4]
90002f84:	799b      	ldrb	r3, [r3, #6]
90002f86:	2b01      	cmp	r3, #1
90002f88:	d17b      	bne.n	90003082 <PCD_EP_OutXfrComplete_int+0x12e>
  {
    if ((DoepintReg & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) /* Class C */
90002f8a:	693b      	ldr	r3, [r7, #16]
90002f8c:	f003 0308 	and.w	r3, r3, #8
90002f90:	2b00      	cmp	r3, #0
90002f92:	d015      	beq.n	90002fc0 <PCD_EP_OutXfrComplete_int+0x6c>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
90002f94:	697b      	ldr	r3, [r7, #20]
90002f96:	4a61      	ldr	r2, [pc, #388]	@ (9000311c <PCD_EP_OutXfrComplete_int+0x1c8>)
90002f98:	4293      	cmp	r3, r2
90002f9a:	f240 80b9 	bls.w	90003110 <PCD_EP_OutXfrComplete_int+0x1bc>
          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
90002f9e:	693b      	ldr	r3, [r7, #16]
90002fa0:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
90002fa4:	2b00      	cmp	r3, #0
90002fa6:	f000 80b3 	beq.w	90003110 <PCD_EP_OutXfrComplete_int+0x1bc>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
90002faa:	683b      	ldr	r3, [r7, #0]
90002fac:	015a      	lsls	r2, r3, #5
90002fae:	69bb      	ldr	r3, [r7, #24]
90002fb0:	4413      	add	r3, r2
90002fb2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90002fb6:	461a      	mov	r2, r3
90002fb8:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
90002fbc:	6093      	str	r3, [r2, #8]
90002fbe:	e0a7      	b.n	90003110 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
    }
    else if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR) /* Class E */
90002fc0:	693b      	ldr	r3, [r7, #16]
90002fc2:	f003 0320 	and.w	r3, r3, #32
90002fc6:	2b00      	cmp	r3, #0
90002fc8:	d009      	beq.n	90002fde <PCD_EP_OutXfrComplete_int+0x8a>
    {
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
90002fca:	683b      	ldr	r3, [r7, #0]
90002fcc:	015a      	lsls	r2, r3, #5
90002fce:	69bb      	ldr	r3, [r7, #24]
90002fd0:	4413      	add	r3, r2
90002fd2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90002fd6:	461a      	mov	r2, r3
90002fd8:	2320      	movs	r3, #32
90002fda:	6093      	str	r3, [r2, #8]
90002fdc:	e098      	b.n	90003110 <PCD_EP_OutXfrComplete_int+0x1bc>
    }
    else if ((DoepintReg & (USB_OTG_DOEPINT_STUP | USB_OTG_DOEPINT_OTEPSPR)) == 0U)
90002fde:	693b      	ldr	r3, [r7, #16]
90002fe0:	f003 0328 	and.w	r3, r3, #40	@ 0x28
90002fe4:	2b00      	cmp	r3, #0
90002fe6:	f040 8093 	bne.w	90003110 <PCD_EP_OutXfrComplete_int+0x1bc>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
90002fea:	697b      	ldr	r3, [r7, #20]
90002fec:	4a4b      	ldr	r2, [pc, #300]	@ (9000311c <PCD_EP_OutXfrComplete_int+0x1c8>)
90002fee:	4293      	cmp	r3, r2
90002ff0:	d90f      	bls.n	90003012 <PCD_EP_OutXfrComplete_int+0xbe>
          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
90002ff2:	693b      	ldr	r3, [r7, #16]
90002ff4:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
90002ff8:	2b00      	cmp	r3, #0
90002ffa:	d00a      	beq.n	90003012 <PCD_EP_OutXfrComplete_int+0xbe>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
90002ffc:	683b      	ldr	r3, [r7, #0]
90002ffe:	015a      	lsls	r2, r3, #5
90003000:	69bb      	ldr	r3, [r7, #24]
90003002:	4413      	add	r3, r2
90003004:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90003008:	461a      	mov	r2, r3
9000300a:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
9000300e:	6093      	str	r3, [r2, #8]
90003010:	e07e      	b.n	90003110 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
      else
      {
        ep = &hpcd->OUT_ep[epnum];
90003012:	683a      	ldr	r2, [r7, #0]
90003014:	4613      	mov	r3, r2
90003016:	00db      	lsls	r3, r3, #3
90003018:	4413      	add	r3, r2
9000301a:	009b      	lsls	r3, r3, #2
9000301c:	f503 7314 	add.w	r3, r3, #592	@ 0x250
90003020:	687a      	ldr	r2, [r7, #4]
90003022:	4413      	add	r3, r2
90003024:	3304      	adds	r3, #4
90003026:	60fb      	str	r3, [r7, #12]

        /* out data packet received over EP */
        ep->xfer_count = ep->xfer_size - (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);
90003028:	68fb      	ldr	r3, [r7, #12]
9000302a:	6a1a      	ldr	r2, [r3, #32]
9000302c:	683b      	ldr	r3, [r7, #0]
9000302e:	0159      	lsls	r1, r3, #5
90003030:	69bb      	ldr	r3, [r7, #24]
90003032:	440b      	add	r3, r1
90003034:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90003038:	691b      	ldr	r3, [r3, #16]
9000303a:	f3c3 0312 	ubfx	r3, r3, #0, #19
9000303e:	1ad2      	subs	r2, r2, r3
90003040:	68fb      	ldr	r3, [r7, #12]
90003042:	615a      	str	r2, [r3, #20]

        if (epnum == 0U)
90003044:	683b      	ldr	r3, [r7, #0]
90003046:	2b00      	cmp	r3, #0
90003048:	d114      	bne.n	90003074 <PCD_EP_OutXfrComplete_int+0x120>
        {
          if (ep->xfer_len == 0U)
9000304a:	68fb      	ldr	r3, [r7, #12]
9000304c:	691b      	ldr	r3, [r3, #16]
9000304e:	2b00      	cmp	r3, #0
90003050:	d109      	bne.n	90003066 <PCD_EP_OutXfrComplete_int+0x112>
          {
            /* this is ZLP, so prepare EP0 for next setup */
            (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
90003052:	687b      	ldr	r3, [r7, #4]
90003054:	6818      	ldr	r0, [r3, #0]
90003056:	687b      	ldr	r3, [r7, #4]
90003058:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
9000305c:	461a      	mov	r2, r3
9000305e:	2101      	movs	r1, #1
90003060:	f007 f87c 	bl	9000a15c <USB_EP0_OutStart>
90003064:	e006      	b.n	90003074 <PCD_EP_OutXfrComplete_int+0x120>
          }
          else
          {
            ep->xfer_buff += ep->xfer_count;
90003066:	68fb      	ldr	r3, [r7, #12]
90003068:	68da      	ldr	r2, [r3, #12]
9000306a:	68fb      	ldr	r3, [r7, #12]
9000306c:	695b      	ldr	r3, [r3, #20]
9000306e:	441a      	add	r2, r3
90003070:	68fb      	ldr	r3, [r7, #12]
90003072:	60da      	str	r2, [r3, #12]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
90003074:	683b      	ldr	r3, [r7, #0]
90003076:	b2db      	uxtb	r3, r3
90003078:	4619      	mov	r1, r3
9000307a:	6878      	ldr	r0, [r7, #4]
9000307c:	f7fd fe8c 	bl	90000d98 <HAL_PCD_DataOutStageCallback>
90003080:	e046      	b.n	90003110 <PCD_EP_OutXfrComplete_int+0x1bc>
      /* ... */
    }
  }
  else
  {
    if (gSNPSiD == USB_OTG_CORE_ID_310A)
90003082:	697b      	ldr	r3, [r7, #20]
90003084:	4a26      	ldr	r2, [pc, #152]	@ (90003120 <PCD_EP_OutXfrComplete_int+0x1cc>)
90003086:	4293      	cmp	r3, r2
90003088:	d124      	bne.n	900030d4 <PCD_EP_OutXfrComplete_int+0x180>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
9000308a:	693b      	ldr	r3, [r7, #16]
9000308c:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
90003090:	2b00      	cmp	r3, #0
90003092:	d00a      	beq.n	900030aa <PCD_EP_OutXfrComplete_int+0x156>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
90003094:	683b      	ldr	r3, [r7, #0]
90003096:	015a      	lsls	r2, r3, #5
90003098:	69bb      	ldr	r3, [r7, #24]
9000309a:	4413      	add	r3, r2
9000309c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
900030a0:	461a      	mov	r2, r3
900030a2:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
900030a6:	6093      	str	r3, [r2, #8]
900030a8:	e032      	b.n	90003110 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
      else
      {
        if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
900030aa:	693b      	ldr	r3, [r7, #16]
900030ac:	f003 0320 	and.w	r3, r3, #32
900030b0:	2b00      	cmp	r3, #0
900030b2:	d008      	beq.n	900030c6 <PCD_EP_OutXfrComplete_int+0x172>
        {
          CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
900030b4:	683b      	ldr	r3, [r7, #0]
900030b6:	015a      	lsls	r2, r3, #5
900030b8:	69bb      	ldr	r3, [r7, #24]
900030ba:	4413      	add	r3, r2
900030bc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
900030c0:	461a      	mov	r2, r3
900030c2:	2320      	movs	r3, #32
900030c4:	6093      	str	r3, [r2, #8]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
900030c6:	683b      	ldr	r3, [r7, #0]
900030c8:	b2db      	uxtb	r3, r3
900030ca:	4619      	mov	r1, r3
900030cc:	6878      	ldr	r0, [r7, #4]
900030ce:	f7fd fe63 	bl	90000d98 <HAL_PCD_DataOutStageCallback>
900030d2:	e01d      	b.n	90003110 <PCD_EP_OutXfrComplete_int+0x1bc>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
    }
    else
    {
      if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
900030d4:	683b      	ldr	r3, [r7, #0]
900030d6:	2b00      	cmp	r3, #0
900030d8:	d114      	bne.n	90003104 <PCD_EP_OutXfrComplete_int+0x1b0>
900030da:	6879      	ldr	r1, [r7, #4]
900030dc:	683a      	ldr	r2, [r7, #0]
900030de:	4613      	mov	r3, r2
900030e0:	00db      	lsls	r3, r3, #3
900030e2:	4413      	add	r3, r2
900030e4:	009b      	lsls	r3, r3, #2
900030e6:	440b      	add	r3, r1
900030e8:	f503 7319 	add.w	r3, r3, #612	@ 0x264
900030ec:	681b      	ldr	r3, [r3, #0]
900030ee:	2b00      	cmp	r3, #0
900030f0:	d108      	bne.n	90003104 <PCD_EP_OutXfrComplete_int+0x1b0>
      {
        /* this is ZLP, so prepare EP0 for next setup */
        (void)USB_EP0_OutStart(hpcd->Instance, 0U, (uint8_t *)hpcd->Setup);
900030f2:	687b      	ldr	r3, [r7, #4]
900030f4:	6818      	ldr	r0, [r3, #0]
900030f6:	687b      	ldr	r3, [r7, #4]
900030f8:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
900030fc:	461a      	mov	r2, r3
900030fe:	2100      	movs	r1, #0
90003100:	f007 f82c 	bl	9000a15c <USB_EP0_OutStart>
      }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
      HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
90003104:	683b      	ldr	r3, [r7, #0]
90003106:	b2db      	uxtb	r3, r3
90003108:	4619      	mov	r1, r3
9000310a:	6878      	ldr	r0, [r7, #4]
9000310c:	f7fd fe44 	bl	90000d98 <HAL_PCD_DataOutStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
    }
  }

  return HAL_OK;
90003110:	2300      	movs	r3, #0
}
90003112:	4618      	mov	r0, r3
90003114:	3720      	adds	r7, #32
90003116:	46bd      	mov	sp, r7
90003118:	bd80      	pop	{r7, pc}
9000311a:	bf00      	nop
9000311c:	4f54300a 	.word	0x4f54300a
90003120:	4f54310a 	.word	0x4f54310a

90003124 <PCD_EP_OutSetupPacket_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
90003124:	b580      	push	{r7, lr}
90003126:	b086      	sub	sp, #24
90003128:	af00      	add	r7, sp, #0
9000312a:	6078      	str	r0, [r7, #4]
9000312c:	6039      	str	r1, [r7, #0]
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
9000312e:	687b      	ldr	r3, [r7, #4]
90003130:	681b      	ldr	r3, [r3, #0]
90003132:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
90003134:	697b      	ldr	r3, [r7, #20]
90003136:	613b      	str	r3, [r7, #16]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
90003138:	697b      	ldr	r3, [r7, #20]
9000313a:	333c      	adds	r3, #60	@ 0x3c
9000313c:	3304      	adds	r3, #4
9000313e:	681b      	ldr	r3, [r3, #0]
90003140:	60fb      	str	r3, [r7, #12]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
90003142:	683b      	ldr	r3, [r7, #0]
90003144:	015a      	lsls	r2, r3, #5
90003146:	693b      	ldr	r3, [r7, #16]
90003148:	4413      	add	r3, r2
9000314a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
9000314e:	689b      	ldr	r3, [r3, #8]
90003150:	60bb      	str	r3, [r7, #8]

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
90003152:	68fb      	ldr	r3, [r7, #12]
90003154:	4a15      	ldr	r2, [pc, #84]	@ (900031ac <PCD_EP_OutSetupPacket_int+0x88>)
90003156:	4293      	cmp	r3, r2
90003158:	d90e      	bls.n	90003178 <PCD_EP_OutSetupPacket_int+0x54>
      ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
9000315a:	68bb      	ldr	r3, [r7, #8]
9000315c:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
90003160:	2b00      	cmp	r3, #0
90003162:	d009      	beq.n	90003178 <PCD_EP_OutSetupPacket_int+0x54>
  {
    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
90003164:	683b      	ldr	r3, [r7, #0]
90003166:	015a      	lsls	r2, r3, #5
90003168:	693b      	ldr	r3, [r7, #16]
9000316a:	4413      	add	r3, r2
9000316c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90003170:	461a      	mov	r2, r3
90003172:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
90003176:	6093      	str	r3, [r2, #8]

  /* Inform the upper layer that a setup packet is available */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
  hpcd->SetupStageCallback(hpcd);
#else
  HAL_PCD_SetupStageCallback(hpcd);
90003178:	6878      	ldr	r0, [r7, #4]
9000317a:	f7fd fdfb 	bl	90000d74 <HAL_PCD_SetupStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
9000317e:	68fb      	ldr	r3, [r7, #12]
90003180:	4a0a      	ldr	r2, [pc, #40]	@ (900031ac <PCD_EP_OutSetupPacket_int+0x88>)
90003182:	4293      	cmp	r3, r2
90003184:	d90c      	bls.n	900031a0 <PCD_EP_OutSetupPacket_int+0x7c>
90003186:	687b      	ldr	r3, [r7, #4]
90003188:	799b      	ldrb	r3, [r3, #6]
9000318a:	2b01      	cmp	r3, #1
9000318c:	d108      	bne.n	900031a0 <PCD_EP_OutSetupPacket_int+0x7c>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
9000318e:	687b      	ldr	r3, [r7, #4]
90003190:	6818      	ldr	r0, [r3, #0]
90003192:	687b      	ldr	r3, [r7, #4]
90003194:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
90003198:	461a      	mov	r2, r3
9000319a:	2101      	movs	r1, #1
9000319c:	f006 ffde 	bl	9000a15c <USB_EP0_OutStart>
  }

  return HAL_OK;
900031a0:	2300      	movs	r3, #0
}
900031a2:	4618      	mov	r0, r3
900031a4:	3718      	adds	r7, #24
900031a6:	46bd      	mov	sp, r7
900031a8:	bd80      	pop	{r7, pc}
900031aa:	bf00      	nop
900031ac:	4f54300a 	.word	0x4f54300a

900031b0 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo The number of Tx fifo
  * @param  size Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
900031b0:	b480      	push	{r7}
900031b2:	b085      	sub	sp, #20
900031b4:	af00      	add	r7, sp, #0
900031b6:	6078      	str	r0, [r7, #4]
900031b8:	460b      	mov	r3, r1
900031ba:	70fb      	strb	r3, [r7, #3]
900031bc:	4613      	mov	r3, r2
900031be:	803b      	strh	r3, [r7, #0]
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */

  Tx_Offset = hpcd->Instance->GRXFSIZ;
900031c0:	687b      	ldr	r3, [r7, #4]
900031c2:	681b      	ldr	r3, [r3, #0]
900031c4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
900031c6:	60bb      	str	r3, [r7, #8]

  if (fifo == 0U)
900031c8:	78fb      	ldrb	r3, [r7, #3]
900031ca:	2b00      	cmp	r3, #0
900031cc:	d107      	bne.n	900031de <HAL_PCDEx_SetTxFiFo+0x2e>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
900031ce:	883b      	ldrh	r3, [r7, #0]
900031d0:	0419      	lsls	r1, r3, #16
900031d2:	687b      	ldr	r3, [r7, #4]
900031d4:	681b      	ldr	r3, [r3, #0]
900031d6:	68ba      	ldr	r2, [r7, #8]
900031d8:	430a      	orrs	r2, r1
900031da:	629a      	str	r2, [r3, #40]	@ 0x28
900031dc:	e028      	b.n	90003230 <HAL_PCDEx_SetTxFiFo+0x80>
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
900031de:	687b      	ldr	r3, [r7, #4]
900031e0:	681b      	ldr	r3, [r3, #0]
900031e2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
900031e4:	0c1b      	lsrs	r3, r3, #16
900031e6:	68ba      	ldr	r2, [r7, #8]
900031e8:	4413      	add	r3, r2
900031ea:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
900031ec:	2300      	movs	r3, #0
900031ee:	73fb      	strb	r3, [r7, #15]
900031f0:	e00d      	b.n	9000320e <HAL_PCDEx_SetTxFiFo+0x5e>
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
900031f2:	687b      	ldr	r3, [r7, #4]
900031f4:	681a      	ldr	r2, [r3, #0]
900031f6:	7bfb      	ldrb	r3, [r7, #15]
900031f8:	3340      	adds	r3, #64	@ 0x40
900031fa:	009b      	lsls	r3, r3, #2
900031fc:	4413      	add	r3, r2
900031fe:	685b      	ldr	r3, [r3, #4]
90003200:	0c1b      	lsrs	r3, r3, #16
90003202:	68ba      	ldr	r2, [r7, #8]
90003204:	4413      	add	r3, r2
90003206:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
90003208:	7bfb      	ldrb	r3, [r7, #15]
9000320a:	3301      	adds	r3, #1
9000320c:	73fb      	strb	r3, [r7, #15]
9000320e:	7bfa      	ldrb	r2, [r7, #15]
90003210:	78fb      	ldrb	r3, [r7, #3]
90003212:	3b01      	subs	r3, #1
90003214:	429a      	cmp	r2, r3
90003216:	d3ec      	bcc.n	900031f2 <HAL_PCDEx_SetTxFiFo+0x42>
    }

    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
90003218:	883b      	ldrh	r3, [r7, #0]
9000321a:	0418      	lsls	r0, r3, #16
9000321c:	687b      	ldr	r3, [r7, #4]
9000321e:	6819      	ldr	r1, [r3, #0]
90003220:	78fb      	ldrb	r3, [r7, #3]
90003222:	3b01      	subs	r3, #1
90003224:	68ba      	ldr	r2, [r7, #8]
90003226:	4302      	orrs	r2, r0
90003228:	3340      	adds	r3, #64	@ 0x40
9000322a:	009b      	lsls	r3, r3, #2
9000322c:	440b      	add	r3, r1
9000322e:	605a      	str	r2, [r3, #4]
  }

  return HAL_OK;
90003230:	2300      	movs	r3, #0
}
90003232:	4618      	mov	r0, r3
90003234:	3714      	adds	r7, #20
90003236:	46bd      	mov	sp, r7
90003238:	f85d 7b04 	ldr.w	r7, [sp], #4
9000323c:	4770      	bx	lr

9000323e <HAL_PCDEx_SetRxFiFo>:
  * @param  hpcd PCD handle
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
9000323e:	b480      	push	{r7}
90003240:	b083      	sub	sp, #12
90003242:	af00      	add	r7, sp, #0
90003244:	6078      	str	r0, [r7, #4]
90003246:	460b      	mov	r3, r1
90003248:	807b      	strh	r3, [r7, #2]
  hpcd->Instance->GRXFSIZ = size;
9000324a:	687b      	ldr	r3, [r7, #4]
9000324c:	681b      	ldr	r3, [r3, #0]
9000324e:	887a      	ldrh	r2, [r7, #2]
90003250:	625a      	str	r2, [r3, #36]	@ 0x24

  return HAL_OK;
90003252:	2300      	movs	r3, #0
}
90003254:	4618      	mov	r0, r3
90003256:	370c      	adds	r7, #12
90003258:	46bd      	mov	sp, r7
9000325a:	f85d 7b04 	ldr.w	r7, [sp], #4
9000325e:	4770      	bx	lr

90003260 <HAL_PCDEx_ActivateLPM>:
  * @brief  Activate LPM feature.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
90003260:	b480      	push	{r7}
90003262:	b085      	sub	sp, #20
90003264:	af00      	add	r7, sp, #0
90003266:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
90003268:	687b      	ldr	r3, [r7, #4]
9000326a:	681b      	ldr	r3, [r3, #0]
9000326c:	60fb      	str	r3, [r7, #12]

  hpcd->lpm_active = 1U;
9000326e:	687b      	ldr	r3, [r7, #4]
90003270:	2201      	movs	r2, #1
90003272:	f8c3 24d8 	str.w	r2, [r3, #1240]	@ 0x4d8
  hpcd->LPM_State = LPM_L0;
90003276:	687b      	ldr	r3, [r7, #4]
90003278:	2200      	movs	r2, #0
9000327a:	f883 24cc 	strb.w	r2, [r3, #1228]	@ 0x4cc
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
9000327e:	68fb      	ldr	r3, [r7, #12]
90003280:	699b      	ldr	r3, [r3, #24]
90003282:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
90003286:	68fb      	ldr	r3, [r7, #12]
90003288:	619a      	str	r2, [r3, #24]
  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
9000328a:	68fb      	ldr	r3, [r7, #12]
9000328c:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
9000328e:	4b05      	ldr	r3, [pc, #20]	@ (900032a4 <HAL_PCDEx_ActivateLPM+0x44>)
90003290:	4313      	orrs	r3, r2
90003292:	68fa      	ldr	r2, [r7, #12]
90003294:	6553      	str	r3, [r2, #84]	@ 0x54

  return HAL_OK;
90003296:	2300      	movs	r3, #0
}
90003298:	4618      	mov	r0, r3
9000329a:	3714      	adds	r7, #20
9000329c:	46bd      	mov	sp, r7
9000329e:	f85d 7b04 	ldr.w	r7, [sp], #4
900032a2:	4770      	bx	lr
900032a4:	10000003 	.word	0x10000003

900032a8 <HAL_PCDEx_LPM_Callback>:
  * @param  hpcd PCD handle
  * @param  msg LPM message
  * @retval HAL status
  */
__weak void HAL_PCDEx_LPM_Callback(PCD_HandleTypeDef *hpcd, PCD_LPM_MsgTypeDef msg)
{
900032a8:	b480      	push	{r7}
900032aa:	b083      	sub	sp, #12
900032ac:	af00      	add	r7, sp, #0
900032ae:	6078      	str	r0, [r7, #4]
900032b0:	460b      	mov	r3, r1
900032b2:	70fb      	strb	r3, [r7, #3]
  UNUSED(msg);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCDEx_LPM_Callback could be implemented in the user file
   */
}
900032b4:	bf00      	nop
900032b6:	370c      	adds	r7, #12
900032b8:	46bd      	mov	sp, r7
900032ba:	f85d 7b04 	ldr.w	r7, [sp], #4
900032be:	4770      	bx	lr

900032c0 <HAL_PWREx_EnableUSBVoltageDetector>:
/**
  * @brief Enable the USB voltage level detector.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_EnableUSBVoltageDetector(void)
{
900032c0:	b580      	push	{r7, lr}
900032c2:	b082      	sub	sp, #8
900032c4:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Enable the USB voltage detector */
  SET_BIT(PWR->CSR2, PWR_CSR2_USB33DEN);
900032c6:	4b0f      	ldr	r3, [pc, #60]	@ (90003304 <HAL_PWREx_EnableUSBVoltageDetector+0x44>)
900032c8:	68db      	ldr	r3, [r3, #12]
900032ca:	4a0e      	ldr	r2, [pc, #56]	@ (90003304 <HAL_PWREx_EnableUSBVoltageDetector+0x44>)
900032cc:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
900032d0:	60d3      	str	r3, [r2, #12]

  /* Get tick */
  tickstart = HAL_GetTick();
900032d2:	f7fe f9f7 	bl	900016c4 <HAL_GetTick>
900032d6:	6078      	str	r0, [r7, #4]

  /* Wait till the USB regulator ready flag is set */
  while ((PWR->CSR2 & PWR_CSR2_USB33RDY) == 0U)
900032d8:	e009      	b.n	900032ee <HAL_PWREx_EnableUSBVoltageDetector+0x2e>
  {
    if ((HAL_GetTick() - tickstart) > PWR_FLAG_SETTING_DELAY)
900032da:	f7fe f9f3 	bl	900016c4 <HAL_GetTick>
900032de:	4602      	mov	r2, r0
900032e0:	687b      	ldr	r3, [r7, #4]
900032e2:	1ad3      	subs	r3, r2, r3
900032e4:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
900032e8:	d901      	bls.n	900032ee <HAL_PWREx_EnableUSBVoltageDetector+0x2e>
    {
      return HAL_ERROR;
900032ea:	2301      	movs	r3, #1
900032ec:	e006      	b.n	900032fc <HAL_PWREx_EnableUSBVoltageDetector+0x3c>
  while ((PWR->CSR2 & PWR_CSR2_USB33RDY) == 0U)
900032ee:	4b05      	ldr	r3, [pc, #20]	@ (90003304 <HAL_PWREx_EnableUSBVoltageDetector+0x44>)
900032f0:	68db      	ldr	r3, [r3, #12]
900032f2:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
900032f6:	2b00      	cmp	r3, #0
900032f8:	d0ef      	beq.n	900032da <HAL_PWREx_EnableUSBVoltageDetector+0x1a>
    }
  }
  return HAL_OK;
900032fa:	2300      	movs	r3, #0
}
900032fc:	4618      	mov	r0, r3
900032fe:	3708      	adds	r7, #8
90003300:	46bd      	mov	sp, r7
90003302:	bd80      	pop	{r7, pc}
90003304:	58024800 	.word	0x58024800

90003308 <HAL_PWREx_EnableUSBHSregulator>:
/**
  * @brief Enable the USB HS regulator.
  * @retval None.
  */
void HAL_PWREx_EnableUSBHSregulator(void)
{
90003308:	b480      	push	{r7}
9000330a:	af00      	add	r7, sp, #0
  /* Enable the USB HS regulator */
  SET_BIT(PWR->CSR2, PWR_CSR2_USBHSREGEN);
9000330c:	4b05      	ldr	r3, [pc, #20]	@ (90003324 <HAL_PWREx_EnableUSBHSregulator+0x1c>)
9000330e:	68db      	ldr	r3, [r3, #12]
90003310:	4a04      	ldr	r2, [pc, #16]	@ (90003324 <HAL_PWREx_EnableUSBHSregulator+0x1c>)
90003312:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
90003316:	60d3      	str	r3, [r2, #12]
}
90003318:	bf00      	nop
9000331a:	46bd      	mov	sp, r7
9000331c:	f85d 7b04 	ldr.w	r7, [sp], #4
90003320:	4770      	bx	lr
90003322:	bf00      	nop
90003324:	58024800 	.word	0x58024800

90003328 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
90003328:	b480      	push	{r7}
9000332a:	b08b      	sub	sp, #44	@ 0x2c
9000332c:	af00      	add	r7, sp, #0
  uint32_t sysclockfreq;
  uint32_t prescaler;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
9000332e:	4baa      	ldr	r3, [pc, #680]	@ (900035d8 <HAL_RCC_GetSysClockFreq+0x2b0>)
90003330:	691b      	ldr	r3, [r3, #16]
90003332:	f003 0338 	and.w	r3, r3, #56	@ 0x38
90003336:	2b18      	cmp	r3, #24
90003338:	f200 8136 	bhi.w	900035a8 <HAL_RCC_GetSysClockFreq+0x280>
9000333c:	a201      	add	r2, pc, #4	@ (adr r2, 90003344 <HAL_RCC_GetSysClockFreq+0x1c>)
9000333e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90003342:	bf00      	nop
90003344:	900033a9 	.word	0x900033a9
90003348:	900035a9 	.word	0x900035a9
9000334c:	900035a9 	.word	0x900035a9
90003350:	900035a9 	.word	0x900035a9
90003354:	900035a9 	.word	0x900035a9
90003358:	900035a9 	.word	0x900035a9
9000335c:	900035a9 	.word	0x900035a9
90003360:	900035a9 	.word	0x900035a9
90003364:	900033cf 	.word	0x900033cf
90003368:	900035a9 	.word	0x900035a9
9000336c:	900035a9 	.word	0x900035a9
90003370:	900035a9 	.word	0x900035a9
90003374:	900035a9 	.word	0x900035a9
90003378:	900035a9 	.word	0x900035a9
9000337c:	900035a9 	.word	0x900035a9
90003380:	900035a9 	.word	0x900035a9
90003384:	900033d5 	.word	0x900033d5
90003388:	900035a9 	.word	0x900035a9
9000338c:	900035a9 	.word	0x900035a9
90003390:	900035a9 	.word	0x900035a9
90003394:	900035a9 	.word	0x900035a9
90003398:	900035a9 	.word	0x900035a9
9000339c:	900035a9 	.word	0x900035a9
900033a0:	900035a9 	.word	0x900035a9
900033a4:	900033db 	.word	0x900033db
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */

      if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
900033a8:	4b8b      	ldr	r3, [pc, #556]	@ (900035d8 <HAL_RCC_GetSysClockFreq+0x2b0>)
900033aa:	681b      	ldr	r3, [r3, #0]
900033ac:	f003 0320 	and.w	r3, r3, #32
900033b0:	2b00      	cmp	r3, #0
900033b2:	d009      	beq.n	900033c8 <HAL_RCC_GetSysClockFreq+0xa0>
      {
        sysclockfreq = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
900033b4:	4b88      	ldr	r3, [pc, #544]	@ (900035d8 <HAL_RCC_GetSysClockFreq+0x2b0>)
900033b6:	681b      	ldr	r3, [r3, #0]
900033b8:	08db      	lsrs	r3, r3, #3
900033ba:	f003 0303 	and.w	r3, r3, #3
900033be:	4a87      	ldr	r2, [pc, #540]	@ (900035dc <HAL_RCC_GetSysClockFreq+0x2b4>)
900033c0:	fa22 f303 	lsr.w	r3, r2, r3
900033c4:	623b      	str	r3, [r7, #32]
      {
        /* Can't retrieve HSIDIV value */
        sysclockfreq = 0U;
      }

      break;
900033c6:	e0f2      	b.n	900035ae <HAL_RCC_GetSysClockFreq+0x286>
        sysclockfreq = 0U;
900033c8:	2300      	movs	r3, #0
900033ca:	623b      	str	r3, [r7, #32]
      break;
900033cc:	e0ef      	b.n	900035ae <HAL_RCC_GetSysClockFreq+0x286>

    case RCC_SYSCLKSOURCE_STATUS_CSI:  /* CSI used as system clock  source */
      sysclockfreq = CSI_VALUE;
900033ce:	4b84      	ldr	r3, [pc, #528]	@ (900035e0 <HAL_RCC_GetSysClockFreq+0x2b8>)
900033d0:	623b      	str	r3, [r7, #32]
      break;
900033d2:	e0ec      	b.n	900035ae <HAL_RCC_GetSysClockFreq+0x286>

    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
      sysclockfreq = HSE_VALUE;
900033d4:	4b83      	ldr	r3, [pc, #524]	@ (900035e4 <HAL_RCC_GetSysClockFreq+0x2bc>)
900033d6:	623b      	str	r3, [r7, #32]
      break;
900033d8:	e0e9      	b.n	900035ae <HAL_RCC_GetSysClockFreq+0x286>
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL1 used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLR
      */
      pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
900033da:	4b7f      	ldr	r3, [pc, #508]	@ (900035d8 <HAL_RCC_GetSysClockFreq+0x2b0>)
900033dc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
900033de:	f003 0303 	and.w	r3, r3, #3
900033e2:	61fb      	str	r3, [r7, #28]
      pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos)  ;
900033e4:	4b7c      	ldr	r3, [pc, #496]	@ (900035d8 <HAL_RCC_GetSysClockFreq+0x2b0>)
900033e6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
900033e8:	091b      	lsrs	r3, r3, #4
900033ea:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
900033ee:	61bb      	str	r3, [r7, #24]
      pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) >> RCC_PLLCFGR_PLL1FRACEN_Pos);
900033f0:	4b79      	ldr	r3, [pc, #484]	@ (900035d8 <HAL_RCC_GetSysClockFreq+0x2b0>)
900033f2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900033f4:	f003 0301 	and.w	r3, r3, #1
900033f8:	617b      	str	r3, [r7, #20]
      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN) >> 3));
900033fa:	4b77      	ldr	r3, [pc, #476]	@ (900035d8 <HAL_RCC_GetSysClockFreq+0x2b0>)
900033fc:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
900033fe:	08db      	lsrs	r3, r3, #3
90003400:	f3c3 030c 	ubfx	r3, r3, #0, #13
90003404:	697a      	ldr	r2, [r7, #20]
90003406:	fb02 f303 	mul.w	r3, r2, r3
9000340a:	ee07 3a90 	vmov	s15, r3
9000340e:	eef8 7a67 	vcvt.f32.u32	s15, s15
90003412:	edc7 7a04 	vstr	s15, [r7, #16]

      if (pllm != 0U)
90003416:	69bb      	ldr	r3, [r7, #24]
90003418:	2b00      	cmp	r3, #0
9000341a:	f000 80c2 	beq.w	900035a2 <HAL_RCC_GetSysClockFreq+0x27a>
      {
        switch (pllsource)
9000341e:	69fb      	ldr	r3, [r7, #28]
90003420:	2b02      	cmp	r3, #2
90003422:	d064      	beq.n	900034ee <HAL_RCC_GetSysClockFreq+0x1c6>
90003424:	69fb      	ldr	r3, [r7, #28]
90003426:	2b02      	cmp	r3, #2
90003428:	f200 8083 	bhi.w	90003532 <HAL_RCC_GetSysClockFreq+0x20a>
9000342c:	69fb      	ldr	r3, [r7, #28]
9000342e:	2b00      	cmp	r3, #0
90003430:	d003      	beq.n	9000343a <HAL_RCC_GetSysClockFreq+0x112>
90003432:	69fb      	ldr	r3, [r7, #28]
90003434:	2b01      	cmp	r3, #1
90003436:	d038      	beq.n	900034aa <HAL_RCC_GetSysClockFreq+0x182>
90003438:	e07b      	b.n	90003532 <HAL_RCC_GetSysClockFreq+0x20a>
        {
          case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
9000343a:	4b67      	ldr	r3, [pc, #412]	@ (900035d8 <HAL_RCC_GetSysClockFreq+0x2b0>)
9000343c:	681b      	ldr	r3, [r3, #0]
9000343e:	f003 0320 	and.w	r3, r3, #32
90003442:	2b00      	cmp	r3, #0
90003444:	d02d      	beq.n	900034a2 <HAL_RCC_GetSysClockFreq+0x17a>
            {
              hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
90003446:	4b64      	ldr	r3, [pc, #400]	@ (900035d8 <HAL_RCC_GetSysClockFreq+0x2b0>)
90003448:	681b      	ldr	r3, [r3, #0]
9000344a:	08db      	lsrs	r3, r3, #3
9000344c:	f003 0303 	and.w	r3, r3, #3
90003450:	4a62      	ldr	r2, [pc, #392]	@ (900035dc <HAL_RCC_GetSysClockFreq+0x2b4>)
90003452:	fa22 f303 	lsr.w	r3, r2, r3
90003456:	60fb      	str	r3, [r7, #12]
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (fracn1 / (float_t)0x2000) + (float_t)1);
90003458:	68fb      	ldr	r3, [r7, #12]
9000345a:	ee07 3a90 	vmov	s15, r3
9000345e:	eef8 6a67 	vcvt.f32.u32	s13, s15
90003462:	69bb      	ldr	r3, [r7, #24]
90003464:	ee07 3a90 	vmov	s15, r3
90003468:	eef8 7a67 	vcvt.f32.u32	s15, s15
9000346c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
90003470:	4b59      	ldr	r3, [pc, #356]	@ (900035d8 <HAL_RCC_GetSysClockFreq+0x2b0>)
90003472:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
90003474:	f3c3 0308 	ubfx	r3, r3, #0, #9
90003478:	ee07 3a90 	vmov	s15, r3
9000347c:	eef8 6a67 	vcvt.f32.u32	s13, s15
90003480:	ed97 6a04 	vldr	s12, [r7, #16]
90003484:	eddf 5a58 	vldr	s11, [pc, #352]	@ 900035e8 <HAL_RCC_GetSysClockFreq+0x2c0>
90003488:	eec6 7a25 	vdiv.f32	s15, s12, s11
9000348c:	ee76 7aa7 	vadd.f32	s15, s13, s15
90003490:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
90003494:	ee77 7aa6 	vadd.f32	s15, s15, s13
90003498:	ee67 7a27 	vmul.f32	s15, s14, s15
9000349c:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
            else
            {
              /* Can't retrieve HSIDIV value */
              pllvco = (float_t)0;
            }
            break;
900034a0:	e069      	b.n	90003576 <HAL_RCC_GetSysClockFreq+0x24e>
              pllvco = (float_t)0;
900034a2:	f04f 0300 	mov.w	r3, #0
900034a6:	627b      	str	r3, [r7, #36]	@ 0x24
            break;
900034a8:	e065      	b.n	90003576 <HAL_RCC_GetSysClockFreq+0x24e>

          case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (fracn1 / (float_t)0x2000) + (float_t)1);
900034aa:	69bb      	ldr	r3, [r7, #24]
900034ac:	ee07 3a90 	vmov	s15, r3
900034b0:	eef8 7a67 	vcvt.f32.u32	s15, s15
900034b4:	eddf 6a4d 	vldr	s13, [pc, #308]	@ 900035ec <HAL_RCC_GetSysClockFreq+0x2c4>
900034b8:	ee86 7aa7 	vdiv.f32	s14, s13, s15
900034bc:	4b46      	ldr	r3, [pc, #280]	@ (900035d8 <HAL_RCC_GetSysClockFreq+0x2b0>)
900034be:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
900034c0:	f3c3 0308 	ubfx	r3, r3, #0, #9
900034c4:	ee07 3a90 	vmov	s15, r3
900034c8:	eef8 6a67 	vcvt.f32.u32	s13, s15
900034cc:	ed97 6a04 	vldr	s12, [r7, #16]
900034d0:	eddf 5a45 	vldr	s11, [pc, #276]	@ 900035e8 <HAL_RCC_GetSysClockFreq+0x2c0>
900034d4:	eec6 7a25 	vdiv.f32	s15, s12, s11
900034d8:	ee76 7aa7 	vadd.f32	s15, s13, s15
900034dc:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
900034e0:	ee77 7aa6 	vadd.f32	s15, s15, s13
900034e4:	ee67 7a27 	vmul.f32	s15, s14, s15
900034e8:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
            break;
900034ec:	e043      	b.n	90003576 <HAL_RCC_GetSysClockFreq+0x24e>

          case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
            pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (fracn1 / (float_t)0x2000) + (float_t)1);
900034ee:	69bb      	ldr	r3, [r7, #24]
900034f0:	ee07 3a90 	vmov	s15, r3
900034f4:	eef8 7a67 	vcvt.f32.u32	s15, s15
900034f8:	eddf 6a3d 	vldr	s13, [pc, #244]	@ 900035f0 <HAL_RCC_GetSysClockFreq+0x2c8>
900034fc:	ee86 7aa7 	vdiv.f32	s14, s13, s15
90003500:	4b35      	ldr	r3, [pc, #212]	@ (900035d8 <HAL_RCC_GetSysClockFreq+0x2b0>)
90003502:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
90003504:	f3c3 0308 	ubfx	r3, r3, #0, #9
90003508:	ee07 3a90 	vmov	s15, r3
9000350c:	eef8 6a67 	vcvt.f32.u32	s13, s15
90003510:	ed97 6a04 	vldr	s12, [r7, #16]
90003514:	eddf 5a34 	vldr	s11, [pc, #208]	@ 900035e8 <HAL_RCC_GetSysClockFreq+0x2c0>
90003518:	eec6 7a25 	vdiv.f32	s15, s12, s11
9000351c:	ee76 7aa7 	vadd.f32	s15, s13, s15
90003520:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
90003524:	ee77 7aa6 	vadd.f32	s15, s15, s13
90003528:	ee67 7a27 	vmul.f32	s15, s14, s15
9000352c:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
            break;
90003530:	e021      	b.n	90003576 <HAL_RCC_GetSysClockFreq+0x24e>

          default:
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (fracn1 / (float_t)0x2000) + (float_t)1);
90003532:	69bb      	ldr	r3, [r7, #24]
90003534:	ee07 3a90 	vmov	s15, r3
90003538:	eef8 7a67 	vcvt.f32.u32	s15, s15
9000353c:	eddf 6a2b 	vldr	s13, [pc, #172]	@ 900035ec <HAL_RCC_GetSysClockFreq+0x2c4>
90003540:	ee86 7aa7 	vdiv.f32	s14, s13, s15
90003544:	4b24      	ldr	r3, [pc, #144]	@ (900035d8 <HAL_RCC_GetSysClockFreq+0x2b0>)
90003546:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
90003548:	f3c3 0308 	ubfx	r3, r3, #0, #9
9000354c:	ee07 3a90 	vmov	s15, r3
90003550:	eef8 6a67 	vcvt.f32.u32	s13, s15
90003554:	ed97 6a04 	vldr	s12, [r7, #16]
90003558:	eddf 5a23 	vldr	s11, [pc, #140]	@ 900035e8 <HAL_RCC_GetSysClockFreq+0x2c0>
9000355c:	eec6 7a25 	vdiv.f32	s15, s12, s11
90003560:	ee76 7aa7 	vadd.f32	s15, s13, s15
90003564:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
90003568:	ee77 7aa6 	vadd.f32	s15, s15, s13
9000356c:	ee67 7a27 	vmul.f32	s15, s14, s15
90003570:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
            break;
90003574:	bf00      	nop
        }
        pllp = (((RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVP) >> RCC_PLL1DIVR1_DIVP_Pos) + 1U) ;
90003576:	4b18      	ldr	r3, [pc, #96]	@ (900035d8 <HAL_RCC_GetSysClockFreq+0x2b0>)
90003578:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
9000357a:	0a5b      	lsrs	r3, r3, #9
9000357c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
90003580:	3301      	adds	r3, #1
90003582:	60bb      	str	r3, [r7, #8]
        sysclockfreq = (uint32_t)(float_t)(pllvco / (float_t)pllp);
90003584:	68bb      	ldr	r3, [r7, #8]
90003586:	ee07 3a90 	vmov	s15, r3
9000358a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
9000358e:	edd7 6a09 	vldr	s13, [r7, #36]	@ 0x24
90003592:	eec6 7a87 	vdiv.f32	s15, s13, s14
90003596:	eefc 7ae7 	vcvt.u32.f32	s15, s15
9000359a:	ee17 3a90 	vmov	r3, s15
9000359e:	623b      	str	r3, [r7, #32]
      }
      else
      {
        sysclockfreq = 0U;
      }
      break;
900035a0:	e005      	b.n	900035ae <HAL_RCC_GetSysClockFreq+0x286>
        sysclockfreq = 0U;
900035a2:	2300      	movs	r3, #0
900035a4:	623b      	str	r3, [r7, #32]
      break;
900035a6:	e002      	b.n	900035ae <HAL_RCC_GetSysClockFreq+0x286>

    default:
      sysclockfreq = CSI_VALUE;
900035a8:	4b0d      	ldr	r3, [pc, #52]	@ (900035e0 <HAL_RCC_GetSysClockFreq+0x2b8>)
900035aa:	623b      	str	r3, [r7, #32]
      break;
900035ac:	bf00      	nop
  }

  prescaler = RCC->CDCFGR & RCC_CDCFGR_CPRE;
900035ae:	4b0a      	ldr	r3, [pc, #40]	@ (900035d8 <HAL_RCC_GetSysClockFreq+0x2b0>)
900035b0:	699b      	ldr	r3, [r3, #24]
900035b2:	f003 030f 	and.w	r3, r3, #15
900035b6:	607b      	str	r3, [r7, #4]
  if (prescaler >= 8U)
900035b8:	687b      	ldr	r3, [r7, #4]
900035ba:	2b07      	cmp	r3, #7
900035bc:	d905      	bls.n	900035ca <HAL_RCC_GetSysClockFreq+0x2a2>
  {
    sysclockfreq = sysclockfreq >> (prescaler - RCC_CDCFGR_CPRE_3 + 1U);
900035be:	687b      	ldr	r3, [r7, #4]
900035c0:	3b07      	subs	r3, #7
900035c2:	6a3a      	ldr	r2, [r7, #32]
900035c4:	fa22 f303 	lsr.w	r3, r2, r3
900035c8:	623b      	str	r3, [r7, #32]
  }

  return sysclockfreq;
900035ca:	6a3b      	ldr	r3, [r7, #32]
}
900035cc:	4618      	mov	r0, r3
900035ce:	372c      	adds	r7, #44	@ 0x2c
900035d0:	46bd      	mov	sp, r7
900035d2:	f85d 7b04 	ldr.w	r7, [sp], #4
900035d6:	4770      	bx	lr
900035d8:	58024400 	.word	0x58024400
900035dc:	03d09000 	.word	0x03d09000
900035e0:	003d0900 	.word	0x003d0900
900035e4:	016e3600 	.word	0x016e3600
900035e8:	46000000 	.word	0x46000000
900035ec:	4a742400 	.word	0x4a742400
900035f0:	4bb71b00 	.word	0x4bb71b00

900035f4 <HAL_RCC_GetHCLKFreq>:
/**
  * @brief  Return the HCLK frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
900035f4:	b580      	push	{r7, lr}
900035f6:	b084      	sub	sp, #16
900035f8:	af00      	add	r7, sp, #0
  uint32_t clock;
  uint32_t prescaler;
  const uint8_t AHBPrescTable[8] = {1U, 2U, 3U, 4U, 6U, 7U, 8U, 9U};
900035fa:	4a10      	ldr	r2, [pc, #64]	@ (9000363c <HAL_RCC_GetHCLKFreq+0x48>)
900035fc:	463b      	mov	r3, r7
900035fe:	e892 0003 	ldmia.w	r2, {r0, r1}
90003602:	e883 0003 	stmia.w	r3, {r0, r1}

  /* SysClk */
  clock = HAL_RCC_GetSysClockFreq();
90003606:	f7ff fe8f 	bl	90003328 <HAL_RCC_GetSysClockFreq>
9000360a:	60f8      	str	r0, [r7, #12]
  /* Bus matrix divider */
  prescaler = (RCC->BMCFGR & RCC_BMCFGR_BMPRE) >> RCC_BMCFGR_BMPRE_Pos;
9000360c:	4b0c      	ldr	r3, [pc, #48]	@ (90003640 <HAL_RCC_GetHCLKFreq+0x4c>)
9000360e:	69db      	ldr	r3, [r3, #28]
90003610:	f003 030f 	and.w	r3, r3, #15
90003614:	60bb      	str	r3, [r7, #8]
  if (prescaler >= 8U)
90003616:	68bb      	ldr	r3, [r7, #8]
90003618:	2b07      	cmp	r3, #7
9000361a:	d909      	bls.n	90003630 <HAL_RCC_GetHCLKFreq+0x3c>
  {
    clock = clock >> AHBPrescTable[prescaler - 8U];
9000361c:	68bb      	ldr	r3, [r7, #8]
9000361e:	3b08      	subs	r3, #8
90003620:	3310      	adds	r3, #16
90003622:	443b      	add	r3, r7
90003624:	f813 3c10 	ldrb.w	r3, [r3, #-16]
90003628:	461a      	mov	r2, r3
9000362a:	68fb      	ldr	r3, [r7, #12]
9000362c:	40d3      	lsrs	r3, r2
9000362e:	60fb      	str	r3, [r7, #12]
  }
  return (clock);
90003630:	68fb      	ldr	r3, [r7, #12]
}
90003632:	4618      	mov	r0, r3
90003634:	3710      	adds	r7, #16
90003636:	46bd      	mov	sp, r7
90003638:	bd80      	pop	{r7, pc}
9000363a:	bf00      	nop
9000363c:	9000dadc 	.word	0x9000dadc
90003640:	58024400 	.word	0x58024400

90003644 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
90003644:	b580      	push	{r7, lr}
90003646:	b082      	sub	sp, #8
90003648:	af00      	add	r7, sp, #0
  uint32_t clock;
  uint32_t prescaler;
  /* Get HCLK source and compute PCLK1 frequency ---------------------------*/
  clock = HAL_RCC_GetHCLKFreq();
9000364a:	f7ff ffd3 	bl	900035f4 <HAL_RCC_GetHCLKFreq>
9000364e:	6078      	str	r0, [r7, #4]
  /* APB1 prescaler */
  prescaler = (RCC->APBCFGR & RCC_APBCFGR_PPRE1) >> RCC_APBCFGR_PPRE1_Pos;
90003650:	4b09      	ldr	r3, [pc, #36]	@ (90003678 <HAL_RCC_GetPCLK1Freq+0x34>)
90003652:	6a1b      	ldr	r3, [r3, #32]
90003654:	f003 0307 	and.w	r3, r3, #7
90003658:	603b      	str	r3, [r7, #0]
  if (prescaler >= 4U)
9000365a:	683b      	ldr	r3, [r7, #0]
9000365c:	2b03      	cmp	r3, #3
9000365e:	d905      	bls.n	9000366c <HAL_RCC_GetPCLK1Freq+0x28>
  {
    clock = clock >> (prescaler - 3U);
90003660:	683b      	ldr	r3, [r7, #0]
90003662:	3b03      	subs	r3, #3
90003664:	687a      	ldr	r2, [r7, #4]
90003666:	fa22 f303 	lsr.w	r3, r2, r3
9000366a:	607b      	str	r3, [r7, #4]
  }
  return (clock);
9000366c:	687b      	ldr	r3, [r7, #4]
}
9000366e:	4618      	mov	r0, r3
90003670:	3708      	adds	r7, #8
90003672:	46bd      	mov	sp, r7
90003674:	bd80      	pop	{r7, pc}
90003676:	bf00      	nop
90003678:	58024400 	.word	0x58024400

9000367c <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
9000367c:	b580      	push	{r7, lr}
9000367e:	b082      	sub	sp, #8
90003680:	af00      	add	r7, sp, #0
  uint32_t clock;
  uint32_t prescaler;
  /* Get HCLK source and compute PCLK2 frequency ---------------------------*/
  clock = HAL_RCC_GetHCLKFreq();
90003682:	f7ff ffb7 	bl	900035f4 <HAL_RCC_GetHCLKFreq>
90003686:	6078      	str	r0, [r7, #4]
  /* APB2 prescaler */
  prescaler = (RCC->APBCFGR & RCC_APBCFGR_PPRE2) >> RCC_APBCFGR_PPRE2_Pos;
90003688:	4b09      	ldr	r3, [pc, #36]	@ (900036b0 <HAL_RCC_GetPCLK2Freq+0x34>)
9000368a:	6a1b      	ldr	r3, [r3, #32]
9000368c:	091b      	lsrs	r3, r3, #4
9000368e:	f003 0307 	and.w	r3, r3, #7
90003692:	603b      	str	r3, [r7, #0]
  if (prescaler >= 4U)
90003694:	683b      	ldr	r3, [r7, #0]
90003696:	2b03      	cmp	r3, #3
90003698:	d905      	bls.n	900036a6 <HAL_RCC_GetPCLK2Freq+0x2a>
  {
    clock = clock >> (prescaler - 3U);
9000369a:	683b      	ldr	r3, [r7, #0]
9000369c:	3b03      	subs	r3, #3
9000369e:	687a      	ldr	r2, [r7, #4]
900036a0:	fa22 f303 	lsr.w	r3, r2, r3
900036a4:	607b      	str	r3, [r7, #4]
  }
  return (clock);
900036a6:	687b      	ldr	r3, [r7, #4]
}
900036a8:	4618      	mov	r0, r3
900036aa:	3708      	adds	r7, #8
900036ac:	46bd      	mov	sp, r7
900036ae:	bd80      	pop	{r7, pc}
900036b0:	58024400 	.word	0x58024400

900036b4 <HAL_RCC_GetPCLK4Freq>:
  * @note   Each time PCLK4 changes, this function must be called to update the
  *         right PCLK4 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK4 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK4Freq(void)
{
900036b4:	b580      	push	{r7, lr}
900036b6:	b082      	sub	sp, #8
900036b8:	af00      	add	r7, sp, #0
  uint32_t clock;
  uint32_t prescaler;
  /* Get HCLK source and compute PCLK4 frequency ---------------------------*/
  clock = HAL_RCC_GetHCLKFreq();
900036ba:	f7ff ff9b 	bl	900035f4 <HAL_RCC_GetHCLKFreq>
900036be:	6078      	str	r0, [r7, #4]
  /* APB4 prescaler */
  prescaler = (RCC->APBCFGR & RCC_APBCFGR_PPRE4) >> RCC_APBCFGR_PPRE4_Pos;
900036c0:	4b09      	ldr	r3, [pc, #36]	@ (900036e8 <HAL_RCC_GetPCLK4Freq+0x34>)
900036c2:	6a1b      	ldr	r3, [r3, #32]
900036c4:	0a1b      	lsrs	r3, r3, #8
900036c6:	f003 0307 	and.w	r3, r3, #7
900036ca:	603b      	str	r3, [r7, #0]
  if (prescaler >= 4U)
900036cc:	683b      	ldr	r3, [r7, #0]
900036ce:	2b03      	cmp	r3, #3
900036d0:	d905      	bls.n	900036de <HAL_RCC_GetPCLK4Freq+0x2a>
  {
    clock = clock >> (prescaler - 3U);
900036d2:	683b      	ldr	r3, [r7, #0]
900036d4:	3b03      	subs	r3, #3
900036d6:	687a      	ldr	r2, [r7, #4]
900036d8:	fa22 f303 	lsr.w	r3, r2, r3
900036dc:	607b      	str	r3, [r7, #4]
  }
  return (clock);
900036de:	687b      	ldr	r3, [r7, #4]
}
900036e0:	4618      	mov	r0, r3
900036e2:	3708      	adds	r7, #8
900036e4:	46bd      	mov	sp, r7
900036e6:	bd80      	pop	{r7, pc}
900036e8:	58024400 	.word	0x58024400

900036ec <HAL_RCC_GetPLL1QFreq>:
/**
  * @brief  Return the PLL1Q frequency.
  * @retval PLL1Q frequency in Hz
  */
uint32_t HAL_RCC_GetPLL1QFreq(void)
{
900036ec:	b580      	push	{r7, lr}
900036ee:	b082      	sub	sp, #8
900036f0:	af00      	add	r7, sp, #0
  uint32_t pllq;

  /* PLL1Q divider */
  pllq = ((RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVQ) >> RCC_PLL1DIVR1_DIVQ_Pos) + 1U;
900036f2:	4b08      	ldr	r3, [pc, #32]	@ (90003714 <HAL_RCC_GetPLL1QFreq+0x28>)
900036f4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
900036f6:	0c1b      	lsrs	r3, r3, #16
900036f8:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
900036fc:	3301      	adds	r3, #1
900036fe:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL1Q one */
  return ((uint32_t)RCC_PLL1_GetVCOOutputFreq() / pllq);
90003700:	f000 f8d2 	bl	900038a8 <RCC_PLL1_GetVCOOutputFreq>
90003704:	4602      	mov	r2, r0
90003706:	687b      	ldr	r3, [r7, #4]
90003708:	fbb2 f3f3 	udiv	r3, r2, r3
}
9000370c:	4618      	mov	r0, r3
9000370e:	3708      	adds	r7, #8
90003710:	46bd      	mov	sp, r7
90003712:	bd80      	pop	{r7, pc}
90003714:	58024400 	.word	0x58024400

90003718 <HAL_RCC_GetPLL2PFreq>:
/**
  * @brief  Return the PLL2P frequency.
  * @retval PLL2P frequency in Hz
  */
uint32_t HAL_RCC_GetPLL2PFreq(void)
{
90003718:	b580      	push	{r7, lr}
9000371a:	b082      	sub	sp, #8
9000371c:	af00      	add	r7, sp, #0
  uint32_t pllp;

  /* PLL2P divider */
  pllp = ((RCC->PLL2DIVR1 & RCC_PLL2DIVR1_DIVP) >> RCC_PLL2DIVR1_DIVP_Pos) + 1U;
9000371e:	4b08      	ldr	r3, [pc, #32]	@ (90003740 <HAL_RCC_GetPLL2PFreq+0x28>)
90003720:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90003722:	0a5b      	lsrs	r3, r3, #9
90003724:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
90003728:	3301      	adds	r3, #1
9000372a:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL2P one */
  return ((uint32_t)RCC_PLL2_GetVCOOutputFreq() / pllp);
9000372c:	f000 f942 	bl	900039b4 <RCC_PLL2_GetVCOOutputFreq>
90003730:	4602      	mov	r2, r0
90003732:	687b      	ldr	r3, [r7, #4]
90003734:	fbb2 f3f3 	udiv	r3, r2, r3
}
90003738:	4618      	mov	r0, r3
9000373a:	3708      	adds	r7, #8
9000373c:	46bd      	mov	sp, r7
9000373e:	bd80      	pop	{r7, pc}
90003740:	58024400 	.word	0x58024400

90003744 <HAL_RCC_GetPLL2QFreq>:
/**
  * @brief  Return the PLL2Q frequency.
  * @retval PLL2Q frequency in Hz
  */
uint32_t HAL_RCC_GetPLL2QFreq(void)
{
90003744:	b580      	push	{r7, lr}
90003746:	b082      	sub	sp, #8
90003748:	af00      	add	r7, sp, #0
  uint32_t pllq;

  /* PLL2Q divider */
  pllq = ((RCC->PLL2DIVR1 & RCC_PLL2DIVR1_DIVQ) >> RCC_PLL2DIVR1_DIVQ_Pos) + 1U;
9000374a:	4b08      	ldr	r3, [pc, #32]	@ (9000376c <HAL_RCC_GetPLL2QFreq+0x28>)
9000374c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
9000374e:	0c1b      	lsrs	r3, r3, #16
90003750:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
90003754:	3301      	adds	r3, #1
90003756:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL2Q one */
  return ((uint32_t)RCC_PLL2_GetVCOOutputFreq() / pllq);
90003758:	f000 f92c 	bl	900039b4 <RCC_PLL2_GetVCOOutputFreq>
9000375c:	4602      	mov	r2, r0
9000375e:	687b      	ldr	r3, [r7, #4]
90003760:	fbb2 f3f3 	udiv	r3, r2, r3
}
90003764:	4618      	mov	r0, r3
90003766:	3708      	adds	r7, #8
90003768:	46bd      	mov	sp, r7
9000376a:	bd80      	pop	{r7, pc}
9000376c:	58024400 	.word	0x58024400

90003770 <HAL_RCC_GetPLL2RFreq>:
/**
  * @brief  Return the PLL2R frequency.
  * @retval PLL2R frequency in Hz
  */
uint32_t HAL_RCC_GetPLL2RFreq(void)
{
90003770:	b580      	push	{r7, lr}
90003772:	b082      	sub	sp, #8
90003774:	af00      	add	r7, sp, #0
  uint32_t pllr;

  /* PLL2R divider */
  pllr = ((RCC->PLL2DIVR1 & RCC_PLL2DIVR1_DIVR) >> RCC_PLL2DIVR1_DIVR_Pos) + 1U;
90003776:	4b08      	ldr	r3, [pc, #32]	@ (90003798 <HAL_RCC_GetPLL2RFreq+0x28>)
90003778:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
9000377a:	0e1b      	lsrs	r3, r3, #24
9000377c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
90003780:	3301      	adds	r3, #1
90003782:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL2R one */
  return ((uint32_t)RCC_PLL2_GetVCOOutputFreq() / pllr);
90003784:	f000 f916 	bl	900039b4 <RCC_PLL2_GetVCOOutputFreq>
90003788:	4602      	mov	r2, r0
9000378a:	687b      	ldr	r3, [r7, #4]
9000378c:	fbb2 f3f3 	udiv	r3, r2, r3
}
90003790:	4618      	mov	r0, r3
90003792:	3708      	adds	r7, #8
90003794:	46bd      	mov	sp, r7
90003796:	bd80      	pop	{r7, pc}
90003798:	58024400 	.word	0x58024400

9000379c <HAL_RCC_GetPLL2SFreq>:
/**
  * @brief  Return the PLL2S frequency.
  * @retval PLL2S frequency in Hz
  */
uint32_t HAL_RCC_GetPLL2SFreq(void)
{
9000379c:	b580      	push	{r7, lr}
9000379e:	b082      	sub	sp, #8
900037a0:	af00      	add	r7, sp, #0
  uint32_t plls;

  /* PLL2S divider */
  plls = ((RCC->PLL2DIVR2 & RCC_PLL2DIVR2_DIVS) >> RCC_PLL2DIVR2_DIVS_Pos) + 1U;
900037a2:	4b08      	ldr	r3, [pc, #32]	@ (900037c4 <HAL_RCC_GetPLL2SFreq+0x28>)
900037a4:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
900037a8:	f003 0307 	and.w	r3, r3, #7
900037ac:	3301      	adds	r3, #1
900037ae:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL2R one */
  return ((uint32_t)RCC_PLL2_GetVCOOutputFreq() / plls);
900037b0:	f000 f900 	bl	900039b4 <RCC_PLL2_GetVCOOutputFreq>
900037b4:	4602      	mov	r2, r0
900037b6:	687b      	ldr	r3, [r7, #4]
900037b8:	fbb2 f3f3 	udiv	r3, r2, r3
}
900037bc:	4618      	mov	r0, r3
900037be:	3708      	adds	r7, #8
900037c0:	46bd      	mov	sp, r7
900037c2:	bd80      	pop	{r7, pc}
900037c4:	58024400 	.word	0x58024400

900037c8 <HAL_RCC_GetPLL2TFreq>:
/**
  * @brief  Return the PLL2T frequency.
  * @retval PLL2T frequency in Hz
  */
uint32_t HAL_RCC_GetPLL2TFreq(void)
{
900037c8:	b580      	push	{r7, lr}
900037ca:	b082      	sub	sp, #8
900037cc:	af00      	add	r7, sp, #0
  uint32_t pllt;

  /* PLL2T divider */
  pllt = ((RCC->PLL2DIVR2 & RCC_PLL2DIVR2_DIVT) >> RCC_PLL2DIVR2_DIVT_Pos) + 1U;
900037ce:	4b09      	ldr	r3, [pc, #36]	@ (900037f4 <HAL_RCC_GetPLL2TFreq+0x2c>)
900037d0:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
900037d4:	0a1b      	lsrs	r3, r3, #8
900037d6:	f003 0307 	and.w	r3, r3, #7
900037da:	3301      	adds	r3, #1
900037dc:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL2T one */
  return ((uint32_t)RCC_PLL2_GetVCOOutputFreq() / pllt);
900037de:	f000 f8e9 	bl	900039b4 <RCC_PLL2_GetVCOOutputFreq>
900037e2:	4602      	mov	r2, r0
900037e4:	687b      	ldr	r3, [r7, #4]
900037e6:	fbb2 f3f3 	udiv	r3, r2, r3
}
900037ea:	4618      	mov	r0, r3
900037ec:	3708      	adds	r7, #8
900037ee:	46bd      	mov	sp, r7
900037f0:	bd80      	pop	{r7, pc}
900037f2:	bf00      	nop
900037f4:	58024400 	.word	0x58024400

900037f8 <HAL_RCC_GetPLL3PFreq>:
/**
  * @brief  Return the PLL3P frequency.
  * @retval PLL3P frequency in Hz
  */
uint32_t HAL_RCC_GetPLL3PFreq(void)
{
900037f8:	b580      	push	{r7, lr}
900037fa:	b082      	sub	sp, #8
900037fc:	af00      	add	r7, sp, #0
  uint32_t pllp;

  /* PLL3P divider */
  pllp = ((RCC->PLL3DIVR1 & RCC_PLL3DIVR1_DIVP) >> RCC_PLL3DIVR1_DIVP_Pos) + 1U;
900037fe:	4b08      	ldr	r3, [pc, #32]	@ (90003820 <HAL_RCC_GetPLL3PFreq+0x28>)
90003800:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
90003802:	0a5b      	lsrs	r3, r3, #9
90003804:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
90003808:	3301      	adds	r3, #1
9000380a:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL3P one */
  return ((uint32_t)RCC_PLL3_GetVCOOutputFreq() / pllp);
9000380c:	f000 f958 	bl	90003ac0 <RCC_PLL3_GetVCOOutputFreq>
90003810:	4602      	mov	r2, r0
90003812:	687b      	ldr	r3, [r7, #4]
90003814:	fbb2 f3f3 	udiv	r3, r2, r3
}
90003818:	4618      	mov	r0, r3
9000381a:	3708      	adds	r7, #8
9000381c:	46bd      	mov	sp, r7
9000381e:	bd80      	pop	{r7, pc}
90003820:	58024400 	.word	0x58024400

90003824 <HAL_RCC_GetPLL3QFreq>:
/**
  * @brief  Return the PLL3Q frequency.
  * @retval PLL3Q frequency in Hz
  */
uint32_t HAL_RCC_GetPLL3QFreq(void)
{
90003824:	b580      	push	{r7, lr}
90003826:	b082      	sub	sp, #8
90003828:	af00      	add	r7, sp, #0
  uint32_t pllq;

  /* PLL3Q divider */
  pllq = ((RCC->PLL3DIVR1 & RCC_PLL3DIVR1_DIVQ) >> RCC_PLL3DIVR1_DIVQ_Pos) + 1U;
9000382a:	4b08      	ldr	r3, [pc, #32]	@ (9000384c <HAL_RCC_GetPLL3QFreq+0x28>)
9000382c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
9000382e:	0c1b      	lsrs	r3, r3, #16
90003830:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
90003834:	3301      	adds	r3, #1
90003836:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL3Q one */
  return ((uint32_t)RCC_PLL3_GetVCOOutputFreq() / pllq);
90003838:	f000 f942 	bl	90003ac0 <RCC_PLL3_GetVCOOutputFreq>
9000383c:	4602      	mov	r2, r0
9000383e:	687b      	ldr	r3, [r7, #4]
90003840:	fbb2 f3f3 	udiv	r3, r2, r3
}
90003844:	4618      	mov	r0, r3
90003846:	3708      	adds	r7, #8
90003848:	46bd      	mov	sp, r7
9000384a:	bd80      	pop	{r7, pc}
9000384c:	58024400 	.word	0x58024400

90003850 <HAL_RCC_GetPLL3RFreq>:
/**
  * @brief  Return the PLL3R frequency.
  * @retval PLL3R frequency in Hz
  */
uint32_t HAL_RCC_GetPLL3RFreq(void)
{
90003850:	b580      	push	{r7, lr}
90003852:	b082      	sub	sp, #8
90003854:	af00      	add	r7, sp, #0
  uint32_t pllr;

  /* PLL3R divider */
  pllr = ((RCC->PLL3DIVR1 & RCC_PLL3DIVR1_DIVR) >> RCC_PLL3DIVR1_DIVR_Pos) + 1U;
90003856:	4b08      	ldr	r3, [pc, #32]	@ (90003878 <HAL_RCC_GetPLL3RFreq+0x28>)
90003858:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
9000385a:	0e1b      	lsrs	r3, r3, #24
9000385c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
90003860:	3301      	adds	r3, #1
90003862:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL3R one */
  return ((uint32_t)RCC_PLL3_GetVCOOutputFreq() / pllr);
90003864:	f000 f92c 	bl	90003ac0 <RCC_PLL3_GetVCOOutputFreq>
90003868:	4602      	mov	r2, r0
9000386a:	687b      	ldr	r3, [r7, #4]
9000386c:	fbb2 f3f3 	udiv	r3, r2, r3
}
90003870:	4618      	mov	r0, r3
90003872:	3708      	adds	r7, #8
90003874:	46bd      	mov	sp, r7
90003876:	bd80      	pop	{r7, pc}
90003878:	58024400 	.word	0x58024400

9000387c <HAL_RCC_GetPLL3SFreq>:
/**
  * @brief  Return the PLL3S frequency.
  * @retval PLL3S frequency in Hz
  */
uint32_t HAL_RCC_GetPLL3SFreq(void)
{
9000387c:	b580      	push	{r7, lr}
9000387e:	b082      	sub	sp, #8
90003880:	af00      	add	r7, sp, #0
  uint32_t plls;

  /* PLL3S divider */
  plls = ((RCC->PLL3DIVR2 & RCC_PLL3DIVR2_DIVS) >> RCC_PLL3DIVR2_DIVS_Pos) + 1U;
90003882:	4b08      	ldr	r3, [pc, #32]	@ (900038a4 <HAL_RCC_GetPLL3SFreq+0x28>)
90003884:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
90003888:	f003 0307 	and.w	r3, r3, #7
9000388c:	3301      	adds	r3, #1
9000388e:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL3S one */
  return ((uint32_t)RCC_PLL3_GetVCOOutputFreq() / plls);
90003890:	f000 f916 	bl	90003ac0 <RCC_PLL3_GetVCOOutputFreq>
90003894:	4602      	mov	r2, r0
90003896:	687b      	ldr	r3, [r7, #4]
90003898:	fbb2 f3f3 	udiv	r3, r2, r3
}
9000389c:	4618      	mov	r0, r3
9000389e:	3708      	adds	r7, #8
900038a0:	46bd      	mov	sp, r7
900038a2:	bd80      	pop	{r7, pc}
900038a4:	58024400 	.word	0x58024400

900038a8 <RCC_PLL1_GetVCOOutputFreq>:
/**
  * @brief  Compute PLL1 VCO output frequency
  * @retval Value of PLL1 VCO output frequency
  */
static uint32_t RCC_PLL1_GetVCOOutputFreq(void)
{
900038a8:	b480      	push	{r7}
900038aa:	b089      	sub	sp, #36	@ 0x24
900038ac:	af00      	add	r7, sp, #0
  uint32_t plln;
  uint32_t pllfracn;
  float_t frequency;

  /* Get PLL1 CKSELR and DIVR register values */
  tmpreg1 = RCC->PLLCKSELR;
900038ae:	4b3c      	ldr	r3, [pc, #240]	@ (900039a0 <RCC_PLL1_GetVCOOutputFreq+0xf8>)
900038b0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
900038b2:	617b      	str	r3, [r7, #20]
  tmpreg2 = RCC->PLL1DIVR1;
900038b4:	4b3a      	ldr	r3, [pc, #232]	@ (900039a0 <RCC_PLL1_GetVCOOutputFreq+0xf8>)
900038b6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
900038b8:	613b      	str	r3, [r7, #16]

  /* Retrieve PLL1 multiplication factor and divider */
  pllm = (tmpreg1 & RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos;
900038ba:	697b      	ldr	r3, [r7, #20]
900038bc:	091b      	lsrs	r3, r3, #4
900038be:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
900038c2:	60fb      	str	r3, [r7, #12]
  plln = (tmpreg2 & RCC_PLL1DIVR1_DIVN) + 1U;
900038c4:	693b      	ldr	r3, [r7, #16]
900038c6:	f3c3 0308 	ubfx	r3, r3, #0, #9
900038ca:	3301      	adds	r3, #1
900038cc:	60bb      	str	r3, [r7, #8]

  if (pllm == 0U)
900038ce:	68fb      	ldr	r3, [r7, #12]
900038d0:	2b00      	cmp	r3, #0
900038d2:	d101      	bne.n	900038d8 <RCC_PLL1_GetVCOOutputFreq+0x30>
  {
    /* Prescaler disabled */
    return 0U;
900038d4:	2300      	movs	r3, #0
900038d6:	e05c      	b.n	90003992 <RCC_PLL1_GetVCOOutputFreq+0xea>
  }

  /* Check if fractional part is enable */
  if ((RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) != 0U)
900038d8:	4b31      	ldr	r3, [pc, #196]	@ (900039a0 <RCC_PLL1_GetVCOOutputFreq+0xf8>)
900038da:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900038dc:	f003 0301 	and.w	r3, r3, #1
900038e0:	2b00      	cmp	r3, #0
900038e2:	d006      	beq.n	900038f2 <RCC_PLL1_GetVCOOutputFreq+0x4a>
  {
    pllfracn = (RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN) >> RCC_PLL1FRACR_FRACN_Pos;
900038e4:	4b2e      	ldr	r3, [pc, #184]	@ (900039a0 <RCC_PLL1_GetVCOOutputFreq+0xf8>)
900038e6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
900038e8:	08db      	lsrs	r3, r3, #3
900038ea:	f3c3 030c 	ubfx	r3, r3, #0, #13
900038ee:	61bb      	str	r3, [r7, #24]
900038f0:	e001      	b.n	900038f6 <RCC_PLL1_GetVCOOutputFreq+0x4e>
  }
  else
  {
    pllfracn = 0U;
900038f2:	2300      	movs	r3, #0
900038f4:	61bb      	str	r3, [r7, #24]
  }

  /* determine PLL source */
  switch (tmpreg1 & RCC_PLLCKSELR_PLLSRC)
900038f6:	697b      	ldr	r3, [r7, #20]
900038f8:	f003 0303 	and.w	r3, r3, #3
900038fc:	2b02      	cmp	r3, #2
900038fe:	d019      	beq.n	90003934 <RCC_PLL1_GetVCOOutputFreq+0x8c>
90003900:	2b02      	cmp	r3, #2
90003902:	d81d      	bhi.n	90003940 <RCC_PLL1_GetVCOOutputFreq+0x98>
90003904:	2b00      	cmp	r3, #0
90003906:	d002      	beq.n	9000390e <RCC_PLL1_GetVCOOutputFreq+0x66>
90003908:	2b01      	cmp	r3, #1
9000390a:	d016      	beq.n	9000393a <RCC_PLL1_GetVCOOutputFreq+0x92>
9000390c:	e018      	b.n	90003940 <RCC_PLL1_GetVCOOutputFreq+0x98>
  {
    /* HSI used as PLL1 clock source */
    case RCC_PLLSOURCE_HSI:
      if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
9000390e:	4b24      	ldr	r3, [pc, #144]	@ (900039a0 <RCC_PLL1_GetVCOOutputFreq+0xf8>)
90003910:	681b      	ldr	r3, [r3, #0]
90003912:	f003 0320 	and.w	r3, r3, #32
90003916:	2b00      	cmp	r3, #0
90003918:	d009      	beq.n	9000392e <RCC_PLL1_GetVCOOutputFreq+0x86>
      {
        pllsrc = HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV) >> RCC_CR_HSIDIV_Pos);
9000391a:	4b21      	ldr	r3, [pc, #132]	@ (900039a0 <RCC_PLL1_GetVCOOutputFreq+0xf8>)
9000391c:	681b      	ldr	r3, [r3, #0]
9000391e:	08db      	lsrs	r3, r3, #3
90003920:	f003 0303 	and.w	r3, r3, #3
90003924:	4a1f      	ldr	r2, [pc, #124]	@ (900039a4 <RCC_PLL1_GetVCOOutputFreq+0xfc>)
90003926:	fa22 f303 	lsr.w	r3, r2, r3
9000392a:	61fb      	str	r3, [r7, #28]
      else
      {
        /* Can't retrieve HSIDIV value */
        pllsrc = 0U;
      }
      break;
9000392c:	e00b      	b.n	90003946 <RCC_PLL1_GetVCOOutputFreq+0x9e>
        pllsrc = 0U;
9000392e:	2300      	movs	r3, #0
90003930:	61fb      	str	r3, [r7, #28]
      break;
90003932:	e008      	b.n	90003946 <RCC_PLL1_GetVCOOutputFreq+0x9e>

    /* HSE used as PLL1 clock source */
    case RCC_PLLSOURCE_HSE:
      pllsrc = HSE_VALUE;
90003934:	4b1c      	ldr	r3, [pc, #112]	@ (900039a8 <RCC_PLL1_GetVCOOutputFreq+0x100>)
90003936:	61fb      	str	r3, [r7, #28]
      break;
90003938:	e005      	b.n	90003946 <RCC_PLL1_GetVCOOutputFreq+0x9e>

    /* CSI used as PLL1 clock source */
    case RCC_PLLSOURCE_CSI:
      pllsrc = CSI_VALUE;
9000393a:	4b1c      	ldr	r3, [pc, #112]	@ (900039ac <RCC_PLL1_GetVCOOutputFreq+0x104>)
9000393c:	61fb      	str	r3, [r7, #28]
      break;
9000393e:	e002      	b.n	90003946 <RCC_PLL1_GetVCOOutputFreq+0x9e>

    default:
      pllsrc = 0U;
90003940:	2300      	movs	r3, #0
90003942:	61fb      	str	r3, [r7, #28]
      break;
90003944:	bf00      	nop
  }
  
  /* Compute VCO output frequency */
  frequency = ((float_t)pllsrc / (float_t)pllm) * ((float_t)plln + ((float_t)pllfracn / (float_t)0x2000U));
90003946:	69fb      	ldr	r3, [r7, #28]
90003948:	ee07 3a90 	vmov	s15, r3
9000394c:	eef8 6a67 	vcvt.f32.u32	s13, s15
90003950:	68fb      	ldr	r3, [r7, #12]
90003952:	ee07 3a90 	vmov	s15, r3
90003956:	eef8 7a67 	vcvt.f32.u32	s15, s15
9000395a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
9000395e:	68bb      	ldr	r3, [r7, #8]
90003960:	ee07 3a90 	vmov	s15, r3
90003964:	eef8 6a67 	vcvt.f32.u32	s13, s15
90003968:	69bb      	ldr	r3, [r7, #24]
9000396a:	ee07 3a90 	vmov	s15, r3
9000396e:	eeb8 6a67 	vcvt.f32.u32	s12, s15
90003972:	eddf 5a0f 	vldr	s11, [pc, #60]	@ 900039b0 <RCC_PLL1_GetVCOOutputFreq+0x108>
90003976:	eec6 7a25 	vdiv.f32	s15, s12, s11
9000397a:	ee76 7aa7 	vadd.f32	s15, s13, s15
9000397e:	ee67 7a27 	vmul.f32	s15, s14, s15
90003982:	edc7 7a01 	vstr	s15, [r7, #4]
  
  return (uint32_t)frequency;
90003986:	edd7 7a01 	vldr	s15, [r7, #4]
9000398a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
9000398e:	ee17 3a90 	vmov	r3, s15
}
90003992:	4618      	mov	r0, r3
90003994:	3724      	adds	r7, #36	@ 0x24
90003996:	46bd      	mov	sp, r7
90003998:	f85d 7b04 	ldr.w	r7, [sp], #4
9000399c:	4770      	bx	lr
9000399e:	bf00      	nop
900039a0:	58024400 	.word	0x58024400
900039a4:	03d09000 	.word	0x03d09000
900039a8:	016e3600 	.word	0x016e3600
900039ac:	003d0900 	.word	0x003d0900
900039b0:	46000000 	.word	0x46000000

900039b4 <RCC_PLL2_GetVCOOutputFreq>:
/**
  * @brief  Compute PLL2 VCO output frequency
  * @retval Value of PLL2 VCO output frequency
  */
static uint32_t RCC_PLL2_GetVCOOutputFreq(void)
{
900039b4:	b480      	push	{r7}
900039b6:	b089      	sub	sp, #36	@ 0x24
900039b8:	af00      	add	r7, sp, #0
  uint32_t plln;
  uint32_t pllfracn;
  float_t frequency;

  /* Get PLL2 CKSELR and DIVR register values */
  tmpreg1 = RCC->PLLCKSELR;
900039ba:	4b3c      	ldr	r3, [pc, #240]	@ (90003aac <RCC_PLL2_GetVCOOutputFreq+0xf8>)
900039bc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
900039be:	617b      	str	r3, [r7, #20]
  tmpreg2 = RCC->PLL2DIVR1;
900039c0:	4b3a      	ldr	r3, [pc, #232]	@ (90003aac <RCC_PLL2_GetVCOOutputFreq+0xf8>)
900039c2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
900039c4:	613b      	str	r3, [r7, #16]

  /* Retrieve PLL2 multiplication factor and divider */
  pllm = (tmpreg1 & RCC_PLLCKSELR_DIVM2) >> RCC_PLLCKSELR_DIVM2_Pos;
900039c6:	697b      	ldr	r3, [r7, #20]
900039c8:	0b1b      	lsrs	r3, r3, #12
900039ca:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
900039ce:	60fb      	str	r3, [r7, #12]
  plln = (tmpreg2 & RCC_PLL2DIVR1_DIVN) + 1U;
900039d0:	693b      	ldr	r3, [r7, #16]
900039d2:	f3c3 0308 	ubfx	r3, r3, #0, #9
900039d6:	3301      	adds	r3, #1
900039d8:	60bb      	str	r3, [r7, #8]

  if (pllm == 0U)
900039da:	68fb      	ldr	r3, [r7, #12]
900039dc:	2b00      	cmp	r3, #0
900039de:	d101      	bne.n	900039e4 <RCC_PLL2_GetVCOOutputFreq+0x30>
  {
    /* Prescaler disabled */
    return 0U;
900039e0:	2300      	movs	r3, #0
900039e2:	e05c      	b.n	90003a9e <RCC_PLL2_GetVCOOutputFreq+0xea>
  }

  /* Check if fractional part is enable */
  if ((RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) != 0U)
900039e4:	4b31      	ldr	r3, [pc, #196]	@ (90003aac <RCC_PLL2_GetVCOOutputFreq+0xf8>)
900039e6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900039e8:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
900039ec:	2b00      	cmp	r3, #0
900039ee:	d006      	beq.n	900039fe <RCC_PLL2_GetVCOOutputFreq+0x4a>
  {
    pllfracn = (RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN) >> RCC_PLL2FRACR_FRACN_Pos;
900039f0:	4b2e      	ldr	r3, [pc, #184]	@ (90003aac <RCC_PLL2_GetVCOOutputFreq+0xf8>)
900039f2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
900039f4:	08db      	lsrs	r3, r3, #3
900039f6:	f3c3 030c 	ubfx	r3, r3, #0, #13
900039fa:	61bb      	str	r3, [r7, #24]
900039fc:	e001      	b.n	90003a02 <RCC_PLL2_GetVCOOutputFreq+0x4e>
  }
  else
  {
    pllfracn = 0U;
900039fe:	2300      	movs	r3, #0
90003a00:	61bb      	str	r3, [r7, #24]
  }

  /* determine PLL source */
  switch (tmpreg1 & RCC_PLLCKSELR_PLLSRC)
90003a02:	697b      	ldr	r3, [r7, #20]
90003a04:	f003 0303 	and.w	r3, r3, #3
90003a08:	2b02      	cmp	r3, #2
90003a0a:	d019      	beq.n	90003a40 <RCC_PLL2_GetVCOOutputFreq+0x8c>
90003a0c:	2b02      	cmp	r3, #2
90003a0e:	d81d      	bhi.n	90003a4c <RCC_PLL2_GetVCOOutputFreq+0x98>
90003a10:	2b00      	cmp	r3, #0
90003a12:	d002      	beq.n	90003a1a <RCC_PLL2_GetVCOOutputFreq+0x66>
90003a14:	2b01      	cmp	r3, #1
90003a16:	d016      	beq.n	90003a46 <RCC_PLL2_GetVCOOutputFreq+0x92>
90003a18:	e018      	b.n	90003a4c <RCC_PLL2_GetVCOOutputFreq+0x98>
  {
    /* HSI used as PLL2 clock source */
    case RCC_PLLSOURCE_HSI:
      if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
90003a1a:	4b24      	ldr	r3, [pc, #144]	@ (90003aac <RCC_PLL2_GetVCOOutputFreq+0xf8>)
90003a1c:	681b      	ldr	r3, [r3, #0]
90003a1e:	f003 0320 	and.w	r3, r3, #32
90003a22:	2b00      	cmp	r3, #0
90003a24:	d009      	beq.n	90003a3a <RCC_PLL2_GetVCOOutputFreq+0x86>
      {
        pllsrc = HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV) >> RCC_CR_HSIDIV_Pos);
90003a26:	4b21      	ldr	r3, [pc, #132]	@ (90003aac <RCC_PLL2_GetVCOOutputFreq+0xf8>)
90003a28:	681b      	ldr	r3, [r3, #0]
90003a2a:	08db      	lsrs	r3, r3, #3
90003a2c:	f003 0303 	and.w	r3, r3, #3
90003a30:	4a1f      	ldr	r2, [pc, #124]	@ (90003ab0 <RCC_PLL2_GetVCOOutputFreq+0xfc>)
90003a32:	fa22 f303 	lsr.w	r3, r2, r3
90003a36:	61fb      	str	r3, [r7, #28]
      else
      {
        /* Can't retrieve HSIDIV value */
        pllsrc = 0U;
      }
      break;
90003a38:	e00b      	b.n	90003a52 <RCC_PLL2_GetVCOOutputFreq+0x9e>
        pllsrc = 0U;
90003a3a:	2300      	movs	r3, #0
90003a3c:	61fb      	str	r3, [r7, #28]
      break;
90003a3e:	e008      	b.n	90003a52 <RCC_PLL2_GetVCOOutputFreq+0x9e>

    /* HSE used as PLL2 clock source */
    case RCC_PLLSOURCE_HSE:
      pllsrc = HSE_VALUE;
90003a40:	4b1c      	ldr	r3, [pc, #112]	@ (90003ab4 <RCC_PLL2_GetVCOOutputFreq+0x100>)
90003a42:	61fb      	str	r3, [r7, #28]
      break;
90003a44:	e005      	b.n	90003a52 <RCC_PLL2_GetVCOOutputFreq+0x9e>

    /* CSI used as PLL2 clock source */
    case RCC_PLLSOURCE_CSI:
      pllsrc = CSI_VALUE;
90003a46:	4b1c      	ldr	r3, [pc, #112]	@ (90003ab8 <RCC_PLL2_GetVCOOutputFreq+0x104>)
90003a48:	61fb      	str	r3, [r7, #28]
      break;
90003a4a:	e002      	b.n	90003a52 <RCC_PLL2_GetVCOOutputFreq+0x9e>

    default:
      pllsrc = 0U;
90003a4c:	2300      	movs	r3, #0
90003a4e:	61fb      	str	r3, [r7, #28]
      break;
90003a50:	bf00      	nop
  }

  /* Compute VCO output frequency */
  frequency = ((float_t)pllsrc / (float_t)pllm) * ((float_t)plln + ((float_t)pllfracn / (float_t)0x2000U));
90003a52:	69fb      	ldr	r3, [r7, #28]
90003a54:	ee07 3a90 	vmov	s15, r3
90003a58:	eef8 6a67 	vcvt.f32.u32	s13, s15
90003a5c:	68fb      	ldr	r3, [r7, #12]
90003a5e:	ee07 3a90 	vmov	s15, r3
90003a62:	eef8 7a67 	vcvt.f32.u32	s15, s15
90003a66:	ee86 7aa7 	vdiv.f32	s14, s13, s15
90003a6a:	68bb      	ldr	r3, [r7, #8]
90003a6c:	ee07 3a90 	vmov	s15, r3
90003a70:	eef8 6a67 	vcvt.f32.u32	s13, s15
90003a74:	69bb      	ldr	r3, [r7, #24]
90003a76:	ee07 3a90 	vmov	s15, r3
90003a7a:	eeb8 6a67 	vcvt.f32.u32	s12, s15
90003a7e:	eddf 5a0f 	vldr	s11, [pc, #60]	@ 90003abc <RCC_PLL2_GetVCOOutputFreq+0x108>
90003a82:	eec6 7a25 	vdiv.f32	s15, s12, s11
90003a86:	ee76 7aa7 	vadd.f32	s15, s13, s15
90003a8a:	ee67 7a27 	vmul.f32	s15, s14, s15
90003a8e:	edc7 7a01 	vstr	s15, [r7, #4]
  
  return (uint32_t)frequency;
90003a92:	edd7 7a01 	vldr	s15, [r7, #4]
90003a96:	eefc 7ae7 	vcvt.u32.f32	s15, s15
90003a9a:	ee17 3a90 	vmov	r3, s15
}
90003a9e:	4618      	mov	r0, r3
90003aa0:	3724      	adds	r7, #36	@ 0x24
90003aa2:	46bd      	mov	sp, r7
90003aa4:	f85d 7b04 	ldr.w	r7, [sp], #4
90003aa8:	4770      	bx	lr
90003aaa:	bf00      	nop
90003aac:	58024400 	.word	0x58024400
90003ab0:	03d09000 	.word	0x03d09000
90003ab4:	016e3600 	.word	0x016e3600
90003ab8:	003d0900 	.word	0x003d0900
90003abc:	46000000 	.word	0x46000000

90003ac0 <RCC_PLL3_GetVCOOutputFreq>:
/**
  * @brief  Compute PLL3 VCO output frequency
  * @retval Value of PLL3 VCO output frequency
  */
static uint32_t RCC_PLL3_GetVCOOutputFreq(void)
{
90003ac0:	b480      	push	{r7}
90003ac2:	b089      	sub	sp, #36	@ 0x24
90003ac4:	af00      	add	r7, sp, #0
  uint32_t plln;
  uint32_t pllfracn;
  float_t frequency;

  /* Get PLL3 CKSELR and DIVR register values */
  tmpreg1 = RCC->PLLCKSELR;
90003ac6:	4b3c      	ldr	r3, [pc, #240]	@ (90003bb8 <RCC_PLL3_GetVCOOutputFreq+0xf8>)
90003ac8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
90003aca:	617b      	str	r3, [r7, #20]
  tmpreg2 = RCC->PLL3DIVR1;
90003acc:	4b3a      	ldr	r3, [pc, #232]	@ (90003bb8 <RCC_PLL3_GetVCOOutputFreq+0xf8>)
90003ace:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
90003ad0:	613b      	str	r3, [r7, #16]

  /* Retrieve PLL3 multiplication factor and divider */
  pllm = (tmpreg1 & RCC_PLLCKSELR_DIVM3) >> RCC_PLLCKSELR_DIVM3_Pos;
90003ad2:	697b      	ldr	r3, [r7, #20]
90003ad4:	0d1b      	lsrs	r3, r3, #20
90003ad6:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
90003ada:	60fb      	str	r3, [r7, #12]
  plln = (tmpreg2 & RCC_PLL3DIVR1_DIVN) + 1U;
90003adc:	693b      	ldr	r3, [r7, #16]
90003ade:	f3c3 0308 	ubfx	r3, r3, #0, #9
90003ae2:	3301      	adds	r3, #1
90003ae4:	60bb      	str	r3, [r7, #8]

  if (pllm == 0U)
90003ae6:	68fb      	ldr	r3, [r7, #12]
90003ae8:	2b00      	cmp	r3, #0
90003aea:	d101      	bne.n	90003af0 <RCC_PLL3_GetVCOOutputFreq+0x30>
  {
    /* Prescaler disabled */
    return 0U;
90003aec:	2300      	movs	r3, #0
90003aee:	e05c      	b.n	90003baa <RCC_PLL3_GetVCOOutputFreq+0xea>
  }

  /* Check if fractional part is enable */
  if ((RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) != 0U)
90003af0:	4b31      	ldr	r3, [pc, #196]	@ (90003bb8 <RCC_PLL3_GetVCOOutputFreq+0xf8>)
90003af2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90003af4:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
90003af8:	2b00      	cmp	r3, #0
90003afa:	d006      	beq.n	90003b0a <RCC_PLL3_GetVCOOutputFreq+0x4a>
  {
    pllfracn = (RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN) >> RCC_PLL3FRACR_FRACN_Pos;
90003afc:	4b2e      	ldr	r3, [pc, #184]	@ (90003bb8 <RCC_PLL3_GetVCOOutputFreq+0xf8>)
90003afe:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
90003b00:	08db      	lsrs	r3, r3, #3
90003b02:	f3c3 030c 	ubfx	r3, r3, #0, #13
90003b06:	61bb      	str	r3, [r7, #24]
90003b08:	e001      	b.n	90003b0e <RCC_PLL3_GetVCOOutputFreq+0x4e>
  }
  else
  {
    pllfracn = 0U;
90003b0a:	2300      	movs	r3, #0
90003b0c:	61bb      	str	r3, [r7, #24]
  }

  /* determine PLL source */
  switch (tmpreg1 & RCC_PLLCKSELR_PLLSRC)
90003b0e:	697b      	ldr	r3, [r7, #20]
90003b10:	f003 0303 	and.w	r3, r3, #3
90003b14:	2b02      	cmp	r3, #2
90003b16:	d019      	beq.n	90003b4c <RCC_PLL3_GetVCOOutputFreq+0x8c>
90003b18:	2b02      	cmp	r3, #2
90003b1a:	d81d      	bhi.n	90003b58 <RCC_PLL3_GetVCOOutputFreq+0x98>
90003b1c:	2b00      	cmp	r3, #0
90003b1e:	d002      	beq.n	90003b26 <RCC_PLL3_GetVCOOutputFreq+0x66>
90003b20:	2b01      	cmp	r3, #1
90003b22:	d016      	beq.n	90003b52 <RCC_PLL3_GetVCOOutputFreq+0x92>
90003b24:	e018      	b.n	90003b58 <RCC_PLL3_GetVCOOutputFreq+0x98>
  {
    /* HSI used as PLL3 clock source */
    case RCC_PLLSOURCE_HSI:
      if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
90003b26:	4b24      	ldr	r3, [pc, #144]	@ (90003bb8 <RCC_PLL3_GetVCOOutputFreq+0xf8>)
90003b28:	681b      	ldr	r3, [r3, #0]
90003b2a:	f003 0320 	and.w	r3, r3, #32
90003b2e:	2b00      	cmp	r3, #0
90003b30:	d009      	beq.n	90003b46 <RCC_PLL3_GetVCOOutputFreq+0x86>
      {
        pllsrc = HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV) >> RCC_CR_HSIDIV_Pos);
90003b32:	4b21      	ldr	r3, [pc, #132]	@ (90003bb8 <RCC_PLL3_GetVCOOutputFreq+0xf8>)
90003b34:	681b      	ldr	r3, [r3, #0]
90003b36:	08db      	lsrs	r3, r3, #3
90003b38:	f003 0303 	and.w	r3, r3, #3
90003b3c:	4a1f      	ldr	r2, [pc, #124]	@ (90003bbc <RCC_PLL3_GetVCOOutputFreq+0xfc>)
90003b3e:	fa22 f303 	lsr.w	r3, r2, r3
90003b42:	61fb      	str	r3, [r7, #28]
      else
      {
        /* Can't retrieve HSIDIV value */
        pllsrc = 0U;
      }
      break;
90003b44:	e00b      	b.n	90003b5e <RCC_PLL3_GetVCOOutputFreq+0x9e>
        pllsrc = 0U;
90003b46:	2300      	movs	r3, #0
90003b48:	61fb      	str	r3, [r7, #28]
      break;
90003b4a:	e008      	b.n	90003b5e <RCC_PLL3_GetVCOOutputFreq+0x9e>

    /* HSE used as PLL3 clock source */
    case RCC_PLLSOURCE_HSE:
      pllsrc = HSE_VALUE;
90003b4c:	4b1c      	ldr	r3, [pc, #112]	@ (90003bc0 <RCC_PLL3_GetVCOOutputFreq+0x100>)
90003b4e:	61fb      	str	r3, [r7, #28]
      break;
90003b50:	e005      	b.n	90003b5e <RCC_PLL3_GetVCOOutputFreq+0x9e>

    /* CSI used as PLL3 clock source */
    case RCC_PLLSOURCE_CSI:
      pllsrc = CSI_VALUE;
90003b52:	4b1c      	ldr	r3, [pc, #112]	@ (90003bc4 <RCC_PLL3_GetVCOOutputFreq+0x104>)
90003b54:	61fb      	str	r3, [r7, #28]
      break;
90003b56:	e002      	b.n	90003b5e <RCC_PLL3_GetVCOOutputFreq+0x9e>

    default:
      pllsrc = 0U;
90003b58:	2300      	movs	r3, #0
90003b5a:	61fb      	str	r3, [r7, #28]
      break;
90003b5c:	bf00      	nop
  }

  /* Compute VCO output frequency */
  frequency = ((float_t)pllsrc / (float_t)pllm) * ((float_t)plln + ((float_t)pllfracn / (float_t)0x2000U));
90003b5e:	69fb      	ldr	r3, [r7, #28]
90003b60:	ee07 3a90 	vmov	s15, r3
90003b64:	eef8 6a67 	vcvt.f32.u32	s13, s15
90003b68:	68fb      	ldr	r3, [r7, #12]
90003b6a:	ee07 3a90 	vmov	s15, r3
90003b6e:	eef8 7a67 	vcvt.f32.u32	s15, s15
90003b72:	ee86 7aa7 	vdiv.f32	s14, s13, s15
90003b76:	68bb      	ldr	r3, [r7, #8]
90003b78:	ee07 3a90 	vmov	s15, r3
90003b7c:	eef8 6a67 	vcvt.f32.u32	s13, s15
90003b80:	69bb      	ldr	r3, [r7, #24]
90003b82:	ee07 3a90 	vmov	s15, r3
90003b86:	eeb8 6a67 	vcvt.f32.u32	s12, s15
90003b8a:	eddf 5a0f 	vldr	s11, [pc, #60]	@ 90003bc8 <RCC_PLL3_GetVCOOutputFreq+0x108>
90003b8e:	eec6 7a25 	vdiv.f32	s15, s12, s11
90003b92:	ee76 7aa7 	vadd.f32	s15, s13, s15
90003b96:	ee67 7a27 	vmul.f32	s15, s14, s15
90003b9a:	edc7 7a01 	vstr	s15, [r7, #4]
  
  return (uint32_t)frequency;
90003b9e:	edd7 7a01 	vldr	s15, [r7, #4]
90003ba2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
90003ba6:	ee17 3a90 	vmov	r3, s15
}
90003baa:	4618      	mov	r0, r3
90003bac:	3724      	adds	r7, #36	@ 0x24
90003bae:	46bd      	mov	sp, r7
90003bb0:	f85d 7b04 	ldr.w	r7, [sp], #4
90003bb4:	4770      	bx	lr
90003bb6:	bf00      	nop
90003bb8:	58024400 	.word	0x58024400
90003bbc:	03d09000 	.word	0x03d09000
90003bc0:	016e3600 	.word	0x016e3600
90003bc4:	003d0900 	.word	0x003d0900
90003bc8:	46000000 	.word	0x46000000

90003bcc <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(const RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
90003bcc:	b580      	push	{r7, lr}
90003bce:	b086      	sub	sp, #24
90003bd0:	af00      	add	r7, sp, #0
90003bd2:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
90003bd4:	2300      	movs	r3, #0
90003bd6:	75fb      	strb	r3, [r7, #23]
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
90003bd8:	2300      	movs	r3, #0
90003bda:	75bb      	strb	r3, [r7, #22]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- RTC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
90003bdc:	687b      	ldr	r3, [r7, #4]
90003bde:	681b      	ldr	r3, [r3, #0]
90003be0:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
90003be4:	2b00      	cmp	r3, #0
90003be6:	f000 8081 	beq.w	90003cec <HAL_RCCEx_PeriphCLKConfig+0x120>
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* As the RTC clock source selection can be changed only if the Backup Domain is reset */
    /* reset the Backup domain only if the RTC Clock source selection is modified from default reset value */
    tmpreg = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
90003bea:	4b8c      	ldr	r3, [pc, #560]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003bec:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
90003bee:	f403 7340 	and.w	r3, r3, #768	@ 0x300
90003bf2:	613b      	str	r3, [r7, #16]

    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
90003bf4:	693b      	ldr	r3, [r7, #16]
90003bf6:	2b00      	cmp	r3, #0
90003bf8:	d029      	beq.n	90003c4e <HAL_RCCEx_PeriphCLKConfig+0x82>
90003bfa:	687b      	ldr	r3, [r7, #4]
90003bfc:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
90003bfe:	f403 7340 	and.w	r3, r3, #768	@ 0x300
90003c02:	693a      	ldr	r2, [r7, #16]
90003c04:	429a      	cmp	r2, r3
90003c06:	d022      	beq.n	90003c4e <HAL_RCCEx_PeriphCLKConfig+0x82>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
90003c08:	4b85      	ldr	r3, [pc, #532]	@ (90003e20 <HAL_RCCEx_PeriphCLKConfig+0x254>)
90003c0a:	681b      	ldr	r3, [r3, #0]
90003c0c:	4a84      	ldr	r2, [pc, #528]	@ (90003e20 <HAL_RCCEx_PeriphCLKConfig+0x254>)
90003c0e:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
90003c12:	6013      	str	r3, [r2, #0]

      /* Read back to check Backup domain enabled */
      if (READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
90003c14:	4b82      	ldr	r3, [pc, #520]	@ (90003e20 <HAL_RCCEx_PeriphCLKConfig+0x254>)
90003c16:	681b      	ldr	r3, [r3, #0]
90003c18:	f403 7380 	and.w	r3, r3, #256	@ 0x100
90003c1c:	2b00      	cmp	r3, #0
90003c1e:	d102      	bne.n	90003c26 <HAL_RCCEx_PeriphCLKConfig+0x5a>
      {
        ret = HAL_ERROR;
90003c20:	2301      	movs	r3, #1
90003c22:	75fb      	strb	r3, [r7, #23]
90003c24:	e013      	b.n	90003c4e <HAL_RCCEx_PeriphCLKConfig+0x82>
      }
      else
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        /* excepted the RTC clock source selection that will be changed */
        tmpreg = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
90003c26:	4b7d      	ldr	r3, [pc, #500]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003c28:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
90003c2a:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
90003c2e:	613b      	str	r3, [r7, #16]
        __HAL_RCC_BACKUPRESET_FORCE();
90003c30:	4b7a      	ldr	r3, [pc, #488]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003c32:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
90003c34:	4a79      	ldr	r2, [pc, #484]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003c36:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
90003c3a:	6713      	str	r3, [r2, #112]	@ 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
90003c3c:	4b77      	ldr	r3, [pc, #476]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003c3e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
90003c40:	4a76      	ldr	r2, [pc, #472]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003c42:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
90003c46:	6713      	str	r3, [r2, #112]	@ 0x70
        /* Restore the content of BDCR register */
        WRITE_REG(RCC->BDCR, tmpreg);
90003c48:	4a74      	ldr	r2, [pc, #464]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003c4a:	693b      	ldr	r3, [r7, #16]
90003c4c:	6713      	str	r3, [r2, #112]	@ 0x70
      }
    }

    if (ret == HAL_OK)
90003c4e:	7dfb      	ldrb	r3, [r7, #23]
90003c50:	2b00      	cmp	r3, #0
90003c52:	d149      	bne.n	90003ce8 <HAL_RCCEx_PeriphCLKConfig+0x11c>
    {
      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
90003c54:	687b      	ldr	r3, [r7, #4]
90003c56:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
90003c58:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
90003c5c:	d115      	bne.n	90003c8a <HAL_RCCEx_PeriphCLKConfig+0xbe>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
90003c5e:	f7fd fd31 	bl	900016c4 <HAL_GetTick>
90003c62:	60f8      	str	r0, [r7, #12]

        /* Wait till LSE is ready */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
90003c64:	e00b      	b.n	90003c7e <HAL_RCCEx_PeriphCLKConfig+0xb2>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
90003c66:	f7fd fd2d 	bl	900016c4 <HAL_GetTick>
90003c6a:	4602      	mov	r2, r0
90003c6c:	68fb      	ldr	r3, [r7, #12]
90003c6e:	1ad3      	subs	r3, r2, r3
90003c70:	f241 3288 	movw	r2, #5000	@ 0x1388
90003c74:	4293      	cmp	r3, r2
90003c76:	d902      	bls.n	90003c7e <HAL_RCCEx_PeriphCLKConfig+0xb2>
          {
            ret = HAL_TIMEOUT;
90003c78:	2303      	movs	r3, #3
90003c7a:	75fb      	strb	r3, [r7, #23]
            break;
90003c7c:	e005      	b.n	90003c8a <HAL_RCCEx_PeriphCLKConfig+0xbe>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
90003c7e:	4b67      	ldr	r3, [pc, #412]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003c80:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
90003c82:	f003 0302 	and.w	r3, r3, #2
90003c86:	2b00      	cmp	r3, #0
90003c88:	d0ed      	beq.n	90003c66 <HAL_RCCEx_PeriphCLKConfig+0x9a>
          }
        }
      }

      if (ret == HAL_OK)
90003c8a:	7dfb      	ldrb	r3, [r7, #23]
90003c8c:	2b00      	cmp	r3, #0
90003c8e:	d128      	bne.n	90003ce2 <HAL_RCCEx_PeriphCLKConfig+0x116>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
90003c90:	687b      	ldr	r3, [r7, #4]
90003c92:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
90003c94:	f403 337c 	and.w	r3, r3, #258048	@ 0x3f000
90003c98:	2b00      	cmp	r3, #0
90003c9a:	d00c      	beq.n	90003cb6 <HAL_RCCEx_PeriphCLKConfig+0xea>
90003c9c:	4b5f      	ldr	r3, [pc, #380]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003c9e:	691b      	ldr	r3, [r3, #16]
90003ca0:	f423 527c 	bic.w	r2, r3, #16128	@ 0x3f00
90003ca4:	687b      	ldr	r3, [r7, #4]
90003ca6:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
90003ca8:	0919      	lsrs	r1, r3, #4
90003caa:	4b5e      	ldr	r3, [pc, #376]	@ (90003e24 <HAL_RCCEx_PeriphCLKConfig+0x258>)
90003cac:	400b      	ands	r3, r1
90003cae:	495b      	ldr	r1, [pc, #364]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003cb0:	4313      	orrs	r3, r2
90003cb2:	610b      	str	r3, [r1, #16]
90003cb4:	e005      	b.n	90003cc2 <HAL_RCCEx_PeriphCLKConfig+0xf6>
90003cb6:	4b59      	ldr	r3, [pc, #356]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003cb8:	691b      	ldr	r3, [r3, #16]
90003cba:	4a58      	ldr	r2, [pc, #352]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003cbc:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
90003cc0:	6113      	str	r3, [r2, #16]
90003cc2:	4b56      	ldr	r3, [pc, #344]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003cc4:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
90003cc6:	687b      	ldr	r3, [r7, #4]
90003cc8:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
90003cca:	f403 7340 	and.w	r3, r3, #768	@ 0x300
90003cce:	4953      	ldr	r1, [pc, #332]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003cd0:	4313      	orrs	r3, r2
90003cd2:	670b      	str	r3, [r1, #112]	@ 0x70
        __HAL_RCC_RTC_ENABLE();
90003cd4:	4b51      	ldr	r3, [pc, #324]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003cd6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
90003cd8:	4a50      	ldr	r2, [pc, #320]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003cda:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
90003cde:	6713      	str	r3, [r2, #112]	@ 0x70
90003ce0:	e004      	b.n	90003cec <HAL_RCCEx_PeriphCLKConfig+0x120>
      }
      else
      {
        /* set overall return value */
        status = ret;
90003ce2:	7dfb      	ldrb	r3, [r7, #23]
90003ce4:	75bb      	strb	r3, [r7, #22]
90003ce6:	e001      	b.n	90003cec <HAL_RCCEx_PeriphCLKConfig+0x120>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
90003ce8:	7dfb      	ldrb	r3, [r7, #23]
90003cea:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- FMC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
90003cec:	687b      	ldr	r3, [r7, #4]
90003cee:	681b      	ldr	r3, [r3, #0]
90003cf0:	f003 0301 	and.w	r3, r3, #1
90003cf4:	2b00      	cmp	r3, #0
90003cf6:	d030      	beq.n	90003d5a <HAL_RCCEx_PeriphCLKConfig+0x18e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FMCCLKSOURCE(PeriphClkInit->FmcClockSelection));

    switch (PeriphClkInit->FmcClockSelection)
90003cf8:	687b      	ldr	r3, [r7, #4]
90003cfa:	685b      	ldr	r3, [r3, #4]
90003cfc:	2b03      	cmp	r3, #3
90003cfe:	d819      	bhi.n	90003d34 <HAL_RCCEx_PeriphCLKConfig+0x168>
90003d00:	a201      	add	r2, pc, #4	@ (adr r2, 90003d08 <HAL_RCCEx_PeriphCLKConfig+0x13c>)
90003d02:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90003d06:	bf00      	nop
90003d08:	90003d3b 	.word	0x90003d3b
90003d0c:	90003d19 	.word	0x90003d19
90003d10:	90003d27 	.word	0x90003d27
90003d14:	90003d3b 	.word	0x90003d3b
      case RCC_FMCCLKSOURCE_HCLK:   /* HCLK  clock selected as FMC kernel peripheral clock */
        break;

      case RCC_FMCCLKSOURCE_PLL1Q:  /* PLL1_Q is used as clock source for FMC kernel */
        /* Enable FMC kernel clock output generated form System PLL . */
        __HAL_RCC_PLL1CLKOUT_ENABLE(RCC_PLL_QCLK);
90003d18:	4b40      	ldr	r3, [pc, #256]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003d1a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90003d1c:	4a3f      	ldr	r2, [pc, #252]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003d1e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
90003d22:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* FMC kernel clock source configuration done later after clock selection check */
        break;
90003d24:	e00a      	b.n	90003d3c <HAL_RCCEx_PeriphCLKConfig+0x170>

      case RCC_FMCCLKSOURCE_PLL2R:  /* PLL2_R is used as clock source for FMC kernel */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_RCLK);
90003d26:	4b3d      	ldr	r3, [pc, #244]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003d28:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90003d2a:	4a3c      	ldr	r2, [pc, #240]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003d2c:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
90003d30:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* FMC kernel clock source configuration done later after clock selection check */
        break;
90003d32:	e003      	b.n	90003d3c <HAL_RCCEx_PeriphCLKConfig+0x170>
      case RCC_FMCCLKSOURCE_HSI:   /* HSI oscillator is used as clock source for FMC kernel */
        /* FMC kernel clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
90003d34:	2301      	movs	r3, #1
90003d36:	75fb      	strb	r3, [r7, #23]
        break;
90003d38:	e000      	b.n	90003d3c <HAL_RCCEx_PeriphCLKConfig+0x170>
        break;
90003d3a:	bf00      	nop
    }

    if (ret == HAL_OK)
90003d3c:	7dfb      	ldrb	r3, [r7, #23]
90003d3e:	2b00      	cmp	r3, #0
90003d40:	d109      	bne.n	90003d56 <HAL_RCCEx_PeriphCLKConfig+0x18a>
    {
      /* Set the source of FMC kernel clock*/
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
90003d42:	4b36      	ldr	r3, [pc, #216]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003d44:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90003d46:	f023 0203 	bic.w	r2, r3, #3
90003d4a:	687b      	ldr	r3, [r7, #4]
90003d4c:	685b      	ldr	r3, [r3, #4]
90003d4e:	4933      	ldr	r1, [pc, #204]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003d50:	4313      	orrs	r3, r2
90003d52:	64cb      	str	r3, [r1, #76]	@ 0x4c
90003d54:	e001      	b.n	90003d5a <HAL_RCCEx_PeriphCLKConfig+0x18e>
    }
    else
    {
      /* set overall return value */
      status = ret;
90003d56:	7dfb      	ldrb	r3, [r7, #23]
90003d58:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- XSPI1 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI1) == RCC_PERIPHCLK_XSPI1)
90003d5a:	687b      	ldr	r3, [r7, #4]
90003d5c:	681b      	ldr	r3, [r3, #0]
90003d5e:	f003 0302 	and.w	r3, r3, #2
90003d62:	2b00      	cmp	r3, #0
90003d64:	d02a      	beq.n	90003dbc <HAL_RCCEx_PeriphCLKConfig+0x1f0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI1CLKSOURCE(PeriphClkInit->Xspi1ClockSelection));

    switch (PeriphClkInit->Xspi1ClockSelection)
90003d66:	687b      	ldr	r3, [r7, #4]
90003d68:	689b      	ldr	r3, [r3, #8]
90003d6a:	2b20      	cmp	r3, #32
90003d6c:	d00c      	beq.n	90003d88 <HAL_RCCEx_PeriphCLKConfig+0x1bc>
90003d6e:	2b20      	cmp	r3, #32
90003d70:	d811      	bhi.n	90003d96 <HAL_RCCEx_PeriphCLKConfig+0x1ca>
90003d72:	2b00      	cmp	r3, #0
90003d74:	d012      	beq.n	90003d9c <HAL_RCCEx_PeriphCLKConfig+0x1d0>
90003d76:	2b10      	cmp	r3, #16
90003d78:	d10d      	bne.n	90003d96 <HAL_RCCEx_PeriphCLKConfig+0x1ca>
      case RCC_XSPI1CLKSOURCE_HCLK:   /* HCLK is used as clock source for Xspi1 */
        /* Nothing to do */
        break;

      case RCC_XSPI1CLKSOURCE_PLL2S:  /* PLL2_S is used as clock source for Xspi1 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_SCLK);
90003d7a:	4b28      	ldr	r3, [pc, #160]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003d7c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90003d7e:	4a27      	ldr	r2, [pc, #156]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003d80:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
90003d84:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* XSPI1 clock source configuration done later after clock selection check */
        break;
90003d86:	e00a      	b.n	90003d9e <HAL_RCCEx_PeriphCLKConfig+0x1d2>

      case RCC_XSPI1CLKSOURCE_PLL2T:  /* PLL2_T is used as clock source for Xspi1 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_TCLK);
90003d88:	4b24      	ldr	r3, [pc, #144]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003d8a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90003d8c:	4a23      	ldr	r2, [pc, #140]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003d8e:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
90003d92:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* XSPI1 clock source configuration done later after clock selection check */
        break;
90003d94:	e003      	b.n	90003d9e <HAL_RCCEx_PeriphCLKConfig+0x1d2>

      default:
        ret = HAL_ERROR;
90003d96:	2301      	movs	r3, #1
90003d98:	75fb      	strb	r3, [r7, #23]
        break;
90003d9a:	e000      	b.n	90003d9e <HAL_RCCEx_PeriphCLKConfig+0x1d2>
        break;
90003d9c:	bf00      	nop
    }

    if (ret == HAL_OK)
90003d9e:	7dfb      	ldrb	r3, [r7, #23]
90003da0:	2b00      	cmp	r3, #0
90003da2:	d109      	bne.n	90003db8 <HAL_RCCEx_PeriphCLKConfig+0x1ec>
    {
      /* Configure the XSPI1 clock source */
      __HAL_RCC_XSPI1_CONFIG(PeriphClkInit->Xspi1ClockSelection);
90003da4:	4b1d      	ldr	r3, [pc, #116]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003da6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90003da8:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
90003dac:	687b      	ldr	r3, [r7, #4]
90003dae:	689b      	ldr	r3, [r3, #8]
90003db0:	491a      	ldr	r1, [pc, #104]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003db2:	4313      	orrs	r3, r2
90003db4:	64cb      	str	r3, [r1, #76]	@ 0x4c
90003db6:	e001      	b.n	90003dbc <HAL_RCCEx_PeriphCLKConfig+0x1f0>
    }
    else
    {
      /* set overall return value */
      status = ret;
90003db8:	7dfb      	ldrb	r3, [r7, #23]
90003dba:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- XSPI2 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI2) == RCC_PERIPHCLK_XSPI2)
90003dbc:	687b      	ldr	r3, [r7, #4]
90003dbe:	681b      	ldr	r3, [r3, #0]
90003dc0:	f003 0304 	and.w	r3, r3, #4
90003dc4:	2b00      	cmp	r3, #0
90003dc6:	d031      	beq.n	90003e2c <HAL_RCCEx_PeriphCLKConfig+0x260>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI2CLKSOURCE(PeriphClkInit->Xspi2ClockSelection));

    switch (PeriphClkInit->Xspi2ClockSelection)
90003dc8:	687b      	ldr	r3, [r7, #4]
90003dca:	68db      	ldr	r3, [r3, #12]
90003dcc:	2b80      	cmp	r3, #128	@ 0x80
90003dce:	d00c      	beq.n	90003dea <HAL_RCCEx_PeriphCLKConfig+0x21e>
90003dd0:	2b80      	cmp	r3, #128	@ 0x80
90003dd2:	d811      	bhi.n	90003df8 <HAL_RCCEx_PeriphCLKConfig+0x22c>
90003dd4:	2b00      	cmp	r3, #0
90003dd6:	d012      	beq.n	90003dfe <HAL_RCCEx_PeriphCLKConfig+0x232>
90003dd8:	2b40      	cmp	r3, #64	@ 0x40
90003dda:	d10d      	bne.n	90003df8 <HAL_RCCEx_PeriphCLKConfig+0x22c>
      case RCC_XSPI2CLKSOURCE_HCLK:   /* HCLK is used as clock source for Xspi2 */
        /* Nothing to do */
        break;

      case RCC_XSPI2CLKSOURCE_PLL2S:  /* PLL2_S is used as clock source for Xspi2 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_SCLK);
90003ddc:	4b0f      	ldr	r3, [pc, #60]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003dde:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90003de0:	4a0e      	ldr	r2, [pc, #56]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003de2:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
90003de6:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* XSPI2 clock source configuration done later after clock selection check */
        break;
90003de8:	e00a      	b.n	90003e00 <HAL_RCCEx_PeriphCLKConfig+0x234>

      case RCC_XSPI2CLKSOURCE_PLL2T:  /* PLL2_T is used as clock source for Xspi2 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_TCLK);
90003dea:	4b0c      	ldr	r3, [pc, #48]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003dec:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90003dee:	4a0b      	ldr	r2, [pc, #44]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003df0:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
90003df4:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* XSPI2 clock source configuration done later after clock selection check */
        break;
90003df6:	e003      	b.n	90003e00 <HAL_RCCEx_PeriphCLKConfig+0x234>

      default:
        ret = HAL_ERROR;
90003df8:	2301      	movs	r3, #1
90003dfa:	75fb      	strb	r3, [r7, #23]
        break;
90003dfc:	e000      	b.n	90003e00 <HAL_RCCEx_PeriphCLKConfig+0x234>
        break;
90003dfe:	bf00      	nop
    }

    if (ret == HAL_OK)
90003e00:	7dfb      	ldrb	r3, [r7, #23]
90003e02:	2b00      	cmp	r3, #0
90003e04:	d110      	bne.n	90003e28 <HAL_RCCEx_PeriphCLKConfig+0x25c>
    {
      /* Configure the XSPI2 clock source */
      __HAL_RCC_XSPI2_CONFIG(PeriphClkInit->Xspi2ClockSelection);
90003e06:	4b05      	ldr	r3, [pc, #20]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003e08:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90003e0a:	f023 02c0 	bic.w	r2, r3, #192	@ 0xc0
90003e0e:	687b      	ldr	r3, [r7, #4]
90003e10:	68db      	ldr	r3, [r3, #12]
90003e12:	4902      	ldr	r1, [pc, #8]	@ (90003e1c <HAL_RCCEx_PeriphCLKConfig+0x250>)
90003e14:	4313      	orrs	r3, r2
90003e16:	64cb      	str	r3, [r1, #76]	@ 0x4c
90003e18:	e008      	b.n	90003e2c <HAL_RCCEx_PeriphCLKConfig+0x260>
90003e1a:	bf00      	nop
90003e1c:	58024400 	.word	0x58024400
90003e20:	58024800 	.word	0x58024800
90003e24:	0fffffcf 	.word	0x0fffffcf
    }
    else
    {
      /* set overall return value */
      status = ret;
90003e28:	7dfb      	ldrb	r3, [r7, #23]
90003e2a:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
90003e2c:	687b      	ldr	r3, [r7, #4]
90003e2e:	681b      	ldr	r3, [r3, #0]
90003e30:	f003 0308 	and.w	r3, r3, #8
90003e34:	2b00      	cmp	r3, #0
90003e36:	d008      	beq.n	90003e4a <HAL_RCCEx_PeriphCLKConfig+0x27e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CKPERCLKSOURCE(PeriphClkInit->CkperClockSelection));

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
90003e38:	4b93      	ldr	r3, [pc, #588]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003e3a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90003e3c:	f023 5240 	bic.w	r2, r3, #805306368	@ 0x30000000
90003e40:	687b      	ldr	r3, [r7, #4]
90003e42:	691b      	ldr	r3, [r3, #16]
90003e44:	4990      	ldr	r1, [pc, #576]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003e46:	4313      	orrs	r3, r2
90003e48:	64cb      	str	r3, [r1, #76]	@ 0x4c
  }

  /*------------------------------------- SDMMC12 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC12) == RCC_PERIPHCLK_SDMMC12)
90003e4a:	687b      	ldr	r3, [r7, #4]
90003e4c:	681b      	ldr	r3, [r3, #0]
90003e4e:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
90003e52:	2b00      	cmp	r3, #0
90003e54:	d026      	beq.n	90003ea4 <HAL_RCCEx_PeriphCLKConfig+0x2d8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC12CLKSOURCE(PeriphClkInit->Sdmmc12ClockSelection));

    switch (PeriphClkInit->Sdmmc12ClockSelection)
90003e56:	687b      	ldr	r3, [r7, #4]
90003e58:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
90003e5a:	2b00      	cmp	r3, #0
90003e5c:	d002      	beq.n	90003e64 <HAL_RCCEx_PeriphCLKConfig+0x298>
90003e5e:	2b04      	cmp	r3, #4
90003e60:	d007      	beq.n	90003e72 <HAL_RCCEx_PeriphCLKConfig+0x2a6>
90003e62:	e00d      	b.n	90003e80 <HAL_RCCEx_PeriphCLKConfig+0x2b4>
    {
      case RCC_SDMMC12CLKSOURCE_PLL2S:  /* PLL2_S is used as clock source for SDMMC12 kernel */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_SCLK);
90003e64:	4b88      	ldr	r3, [pc, #544]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003e66:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90003e68:	4a87      	ldr	r2, [pc, #540]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003e6a:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
90003e6e:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SDMMC12 kernel clock source configuration done later after clock selection check */
        break;
90003e70:	e009      	b.n	90003e86 <HAL_RCCEx_PeriphCLKConfig+0x2ba>

      case RCC_SDMMC12CLKSOURCE_PLL2T:  /* PLL2_T is used as clock source for SDMMC12 kernel */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_TCLK);
90003e72:	4b85      	ldr	r3, [pc, #532]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003e74:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90003e76:	4a84      	ldr	r2, [pc, #528]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003e78:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
90003e7c:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SDMMC12 kernel clock source configuration done later after clock selection check */
        break;
90003e7e:	e002      	b.n	90003e86 <HAL_RCCEx_PeriphCLKConfig+0x2ba>

      default:
        ret = HAL_ERROR;
90003e80:	2301      	movs	r3, #1
90003e82:	75fb      	strb	r3, [r7, #23]
        break;
90003e84:	bf00      	nop
    }

    if (ret == HAL_OK)
90003e86:	7dfb      	ldrb	r3, [r7, #23]
90003e88:	2b00      	cmp	r3, #0
90003e8a:	d109      	bne.n	90003ea0 <HAL_RCCEx_PeriphCLKConfig+0x2d4>
    {
      /* Set the source of SDMMC12 clock*/
      __HAL_RCC_SDMMC12_CONFIG(PeriphClkInit->Sdmmc12ClockSelection);
90003e8c:	4b7e      	ldr	r3, [pc, #504]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003e8e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90003e90:	f023 0204 	bic.w	r2, r3, #4
90003e94:	687b      	ldr	r3, [r7, #4]
90003e96:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
90003e98:	497b      	ldr	r1, [pc, #492]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003e9a:	4313      	orrs	r3, r2
90003e9c:	64cb      	str	r3, [r1, #76]	@ 0x4c
90003e9e:	e001      	b.n	90003ea4 <HAL_RCCEx_PeriphCLKConfig+0x2d8>
    }
    else
    {
      /* set overall return value */
      status = ret;
90003ea0:	7dfb      	ldrb	r3, [r7, #23]
90003ea2:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- ADC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
90003ea4:	687b      	ldr	r3, [r7, #4]
90003ea6:	681b      	ldr	r3, [r3, #0]
90003ea8:	f003 0310 	and.w	r3, r3, #16
90003eac:	2b00      	cmp	r3, #0
90003eae:	d02e      	beq.n	90003f0e <HAL_RCCEx_PeriphCLKConfig+0x342>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    switch (PeriphClkInit->AdcClockSelection)
90003eb0:	687b      	ldr	r3, [r7, #4]
90003eb2:	695b      	ldr	r3, [r3, #20]
90003eb4:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
90003eb8:	d019      	beq.n	90003eee <HAL_RCCEx_PeriphCLKConfig+0x322>
90003eba:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
90003ebe:	d813      	bhi.n	90003ee8 <HAL_RCCEx_PeriphCLKConfig+0x31c>
90003ec0:	2b00      	cmp	r3, #0
90003ec2:	d003      	beq.n	90003ecc <HAL_RCCEx_PeriphCLKConfig+0x300>
90003ec4:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
90003ec8:	d007      	beq.n	90003eda <HAL_RCCEx_PeriphCLKConfig+0x30e>
90003eca:	e00d      	b.n	90003ee8 <HAL_RCCEx_PeriphCLKConfig+0x31c>
    {

      case RCC_ADCCLKSOURCE_PLL2P: /* PLL2_P is used as clock source for ADC */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_PCLK);
90003ecc:	4b6e      	ldr	r3, [pc, #440]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003ece:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90003ed0:	4a6d      	ldr	r2, [pc, #436]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003ed2:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
90003ed6:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* ADC clock source configuration done later after clock selection check */
        break;
90003ed8:	e00a      	b.n	90003ef0 <HAL_RCCEx_PeriphCLKConfig+0x324>

      case RCC_ADCCLKSOURCE_PLL3R: /* PLL3_R is used as clock source for ADC */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_RCLK);
90003eda:	4b6b      	ldr	r3, [pc, #428]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003edc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90003ede:	4a6a      	ldr	r2, [pc, #424]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003ee0:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
90003ee4:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* ADC clock source configuration done later after clock selection check */
        break;
90003ee6:	e003      	b.n	90003ef0 <HAL_RCCEx_PeriphCLKConfig+0x324>
        /* HSI, HSE, or CSI oscillator is used as source of ADC clock */
        /* ADC clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
90003ee8:	2301      	movs	r3, #1
90003eea:	75fb      	strb	r3, [r7, #23]
        break;
90003eec:	e000      	b.n	90003ef0 <HAL_RCCEx_PeriphCLKConfig+0x324>
        break;
90003eee:	bf00      	nop
    }

    if (ret == HAL_OK)
90003ef0:	7dfb      	ldrb	r3, [r7, #23]
90003ef2:	2b00      	cmp	r3, #0
90003ef4:	d109      	bne.n	90003f0a <HAL_RCCEx_PeriphCLKConfig+0x33e>
    {
      /* Set the source of ADC clock*/
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
90003ef6:	4b64      	ldr	r3, [pc, #400]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003ef8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90003efa:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
90003efe:	687b      	ldr	r3, [r7, #4]
90003f00:	695b      	ldr	r3, [r3, #20]
90003f02:	4961      	ldr	r1, [pc, #388]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003f04:	4313      	orrs	r3, r2
90003f06:	64cb      	str	r3, [r1, #76]	@ 0x4c
90003f08:	e001      	b.n	90003f0e <HAL_RCCEx_PeriphCLKConfig+0x342>
    }
    else
    {
      /* set overall return value */
      status = ret;
90003f0a:	7dfb      	ldrb	r3, [r7, #23]
90003f0c:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- ADF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
90003f0e:	687b      	ldr	r3, [r7, #4]
90003f10:	681b      	ldr	r3, [r3, #0]
90003f12:	f003 0320 	and.w	r3, r3, #32
90003f16:	2b00      	cmp	r3, #0
90003f18:	d03f      	beq.n	90003f9a <HAL_RCCEx_PeriphCLKConfig+0x3ce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADF1CLKSOURCE(PeriphClkInit->Adf1ClockSelection));

    switch (PeriphClkInit->Adf1ClockSelection)
90003f1a:	687b      	ldr	r3, [r7, #4]
90003f1c:	699b      	ldr	r3, [r3, #24]
90003f1e:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
90003f22:	d02a      	beq.n	90003f7a <HAL_RCCEx_PeriphCLKConfig+0x3ae>
90003f24:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
90003f28:	d824      	bhi.n	90003f74 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
90003f2a:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
90003f2e:	d024      	beq.n	90003f7a <HAL_RCCEx_PeriphCLKConfig+0x3ae>
90003f30:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
90003f34:	d81e      	bhi.n	90003f74 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
90003f36:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
90003f3a:	d01e      	beq.n	90003f7a <HAL_RCCEx_PeriphCLKConfig+0x3ae>
90003f3c:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
90003f40:	d818      	bhi.n	90003f74 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
90003f42:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
90003f46:	d00e      	beq.n	90003f66 <HAL_RCCEx_PeriphCLKConfig+0x39a>
90003f48:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
90003f4c:	d812      	bhi.n	90003f74 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
90003f4e:	2b00      	cmp	r3, #0
90003f50:	d013      	beq.n	90003f7a <HAL_RCCEx_PeriphCLKConfig+0x3ae>
90003f52:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
90003f56:	d10d      	bne.n	90003f74 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
    {
      case RCC_ADF1CLKSOURCE_PLL2P:  /* PLL2_P is used as clock source for ADF1 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_PCLK);
90003f58:	4b4b      	ldr	r3, [pc, #300]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003f5a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90003f5c:	4a4a      	ldr	r2, [pc, #296]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003f5e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
90003f62:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* ADF1 clock source configuration done later after clock selection check */
        break;
90003f64:	e00a      	b.n	90003f7c <HAL_RCCEx_PeriphCLKConfig+0x3b0>

      case RCC_ADF1CLKSOURCE_PLL3P:  /* PLL3_P is used as clock source for ADF1 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_PCLK);
90003f66:	4b48      	ldr	r3, [pc, #288]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003f68:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90003f6a:	4a47      	ldr	r2, [pc, #284]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003f6c:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
90003f70:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* ADF1 clock source configuration done later after clock selection check */
        break;
90003f72:	e003      	b.n	90003f7c <HAL_RCCEx_PeriphCLKConfig+0x3b0>
      case RCC_ADF1CLKSOURCE_HSI:    /* HSI is used as clock source for ADF1 */
        /* ADF1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
90003f74:	2301      	movs	r3, #1
90003f76:	75fb      	strb	r3, [r7, #23]
        break;
90003f78:	e000      	b.n	90003f7c <HAL_RCCEx_PeriphCLKConfig+0x3b0>
        break;
90003f7a:	bf00      	nop
    }

    if (ret == HAL_OK)
90003f7c:	7dfb      	ldrb	r3, [r7, #23]
90003f7e:	2b00      	cmp	r3, #0
90003f80:	d109      	bne.n	90003f96 <HAL_RCCEx_PeriphCLKConfig+0x3ca>
    {
      /* Set the source of ADF1 clock*/
      __HAL_RCC_ADF1_CONFIG(PeriphClkInit->Adf1ClockSelection);
90003f82:	4b41      	ldr	r3, [pc, #260]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003f84:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90003f86:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
90003f8a:	687b      	ldr	r3, [r7, #4]
90003f8c:	699b      	ldr	r3, [r3, #24]
90003f8e:	493e      	ldr	r1, [pc, #248]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003f90:	4313      	orrs	r3, r2
90003f92:	64cb      	str	r3, [r1, #76]	@ 0x4c
90003f94:	e001      	b.n	90003f9a <HAL_RCCEx_PeriphCLKConfig+0x3ce>
    }
    else
    {
      /* set overall return value */
      status = ret;
90003f96:	7dfb      	ldrb	r3, [r7, #23]
90003f98:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------- CEC configuration ---------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
90003f9a:	687b      	ldr	r3, [r7, #4]
90003f9c:	681b      	ldr	r3, [r3, #0]
90003f9e:	f003 0340 	and.w	r3, r3, #64	@ 0x40
90003fa2:	2b00      	cmp	r3, #0
90003fa4:	d008      	beq.n	90003fb8 <HAL_RCCEx_PeriphCLKConfig+0x3ec>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
90003fa6:	4b38      	ldr	r3, [pc, #224]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003fa8:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
90003faa:	f023 5240 	bic.w	r2, r3, #805306368	@ 0x30000000
90003fae:	687b      	ldr	r3, [r7, #4]
90003fb0:	69db      	ldr	r3, [r3, #28]
90003fb2:	4935      	ldr	r1, [pc, #212]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003fb4:	4313      	orrs	r3, r2
90003fb6:	650b      	str	r3, [r1, #80]	@ 0x50
  }

  /*---------------------- ETH1 REF configuration --------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1REF) == RCC_PERIPHCLK_ETH1REF)
90003fb8:	687b      	ldr	r3, [r7, #4]
90003fba:	681b      	ldr	r3, [r3, #0]
90003fbc:	f003 0380 	and.w	r3, r3, #128	@ 0x80
90003fc0:	2b00      	cmp	r3, #0
90003fc2:	d008      	beq.n	90003fd6 <HAL_RCCEx_PeriphCLKConfig+0x40a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1REFCLKSOURCE(PeriphClkInit->Eth1RefClockSelection));

    /* Configure the ETH1 REF clock source */
    __HAL_RCC_ETH1REF_CONFIG(PeriphClkInit->Eth1RefClockSelection);
90003fc4:	4b30      	ldr	r3, [pc, #192]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003fc6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90003fc8:	f423 3240 	bic.w	r2, r3, #196608	@ 0x30000
90003fcc:	687b      	ldr	r3, [r7, #4]
90003fce:	6a1b      	ldr	r3, [r3, #32]
90003fd0:	492d      	ldr	r1, [pc, #180]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003fd2:	4313      	orrs	r3, r2
90003fd4:	64cb      	str	r3, [r1, #76]	@ 0x4c
  }

  /*---------------------- ETH1PHY configuration --------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PHY) == RCC_PERIPHCLK_ETH1PHY)
90003fd6:	687b      	ldr	r3, [r7, #4]
90003fd8:	681b      	ldr	r3, [r3, #0]
90003fda:	f403 7380 	and.w	r3, r3, #256	@ 0x100
90003fde:	2b00      	cmp	r3, #0
90003fe0:	d020      	beq.n	90004024 <HAL_RCCEx_PeriphCLKConfig+0x458>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PHYCLKSOURCE(PeriphClkInit->Eth1PhyClockSelection));

    switch (PeriphClkInit->Eth1PhyClockSelection)
90003fe2:	687b      	ldr	r3, [r7, #4]
90003fe4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
90003fe6:	2b00      	cmp	r3, #0
90003fe8:	d00c      	beq.n	90004004 <HAL_RCCEx_PeriphCLKConfig+0x438>
90003fea:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
90003fee:	d106      	bne.n	90003ffe <HAL_RCCEx_PeriphCLKConfig+0x432>
      case RCC_ETH1PHYCLKSOURCE_HSE:    /* HSE is used as clock source for ETH PHY */
        /* ETH PHY clock source configuration done later after clock selection check */
        break;

      case RCC_ETH1PHYCLKSOURCE_PLL3S:  /* PLL3_S is used as clock source for ETH PHY */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_SCLK);
90003ff0:	4b25      	ldr	r3, [pc, #148]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003ff2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90003ff4:	4a24      	ldr	r2, [pc, #144]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90003ff6:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
90003ffa:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* ETH PHY clock source configuration done later after clock selection check */
        break;
90003ffc:	e003      	b.n	90004006 <HAL_RCCEx_PeriphCLKConfig+0x43a>

      default:
        ret = HAL_ERROR;
90003ffe:	2301      	movs	r3, #1
90004000:	75fb      	strb	r3, [r7, #23]
        break;
90004002:	e000      	b.n	90004006 <HAL_RCCEx_PeriphCLKConfig+0x43a>
        break;
90004004:	bf00      	nop
    }

    if (ret == HAL_OK)
90004006:	7dfb      	ldrb	r3, [r7, #23]
90004008:	2b00      	cmp	r3, #0
9000400a:	d109      	bne.n	90004020 <HAL_RCCEx_PeriphCLKConfig+0x454>
    {
      /* Set the source of ETH PHY clock*/
      __HAL_RCC_ETH1PHY_CONFIG(PeriphClkInit->Eth1PhyClockSelection);
9000400c:	4b1e      	ldr	r3, [pc, #120]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
9000400e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90004010:	f423 2280 	bic.w	r2, r3, #262144	@ 0x40000
90004014:	687b      	ldr	r3, [r7, #4]
90004016:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
90004018:	491b      	ldr	r1, [pc, #108]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
9000401a:	4313      	orrs	r3, r2
9000401c:	64cb      	str	r3, [r1, #76]	@ 0x4c
9000401e:	e001      	b.n	90004024 <HAL_RCCEx_PeriphCLKConfig+0x458>
    }
    else
    {
      /* set overall return value */
      status = ret;
90004020:	7dfb      	ldrb	r3, [r7, #23]
90004022:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------- FDCAN configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
90004024:	687b      	ldr	r3, [r7, #4]
90004026:	681b      	ldr	r3, [r3, #0]
90004028:	f403 7300 	and.w	r3, r3, #512	@ 0x200
9000402c:	2b00      	cmp	r3, #0
9000402e:	d02f      	beq.n	90004090 <HAL_RCCEx_PeriphCLKConfig+0x4c4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));

    switch (PeriphClkInit->FdcanClockSelection)
90004030:	687b      	ldr	r3, [r7, #4]
90004032:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
90004034:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
90004038:	d00e      	beq.n	90004058 <HAL_RCCEx_PeriphCLKConfig+0x48c>
9000403a:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
9000403e:	d812      	bhi.n	90004066 <HAL_RCCEx_PeriphCLKConfig+0x49a>
90004040:	2b00      	cmp	r3, #0
90004042:	d013      	beq.n	9000406c <HAL_RCCEx_PeriphCLKConfig+0x4a0>
90004044:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
90004048:	d10d      	bne.n	90004066 <HAL_RCCEx_PeriphCLKConfig+0x49a>
    {
      case RCC_FDCANCLKSOURCE_PLL1Q: /* PLL1_Q is used as clock source for FDCAN kernel */
        /* Enable FDCAN Clock output generated form System PLL . */
        __HAL_RCC_PLL1CLKOUT_ENABLE(RCC_PLL_QCLK);
9000404a:	4b0f      	ldr	r3, [pc, #60]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
9000404c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000404e:	4a0e      	ldr	r2, [pc, #56]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90004050:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
90004054:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* FDCAN clock source configuration done later after clock selection check */
        break;
90004056:	e00a      	b.n	9000406e <HAL_RCCEx_PeriphCLKConfig+0x4a2>

      case RCC_FDCANCLKSOURCE_PLL2P: /* PLL2_P is used as clock source for FDCAN kernel */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_PCLK);
90004058:	4b0b      	ldr	r3, [pc, #44]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
9000405a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000405c:	4a0a      	ldr	r2, [pc, #40]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
9000405e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
90004062:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* FDCAN clock source configuration done later after clock selection check */
        break;
90004064:	e003      	b.n	9000406e <HAL_RCCEx_PeriphCLKConfig+0x4a2>
      case RCC_FDCANCLKSOURCE_HSE:   /* HSE is used as clock source for FDCAN kernel */
        /* FDCAN clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
90004066:	2301      	movs	r3, #1
90004068:	75fb      	strb	r3, [r7, #23]
        break;
9000406a:	e000      	b.n	9000406e <HAL_RCCEx_PeriphCLKConfig+0x4a2>
        break;
9000406c:	bf00      	nop
    }

    if (ret == HAL_OK)
9000406e:	7dfb      	ldrb	r3, [r7, #23]
90004070:	2b00      	cmp	r3, #0
90004072:	d10b      	bne.n	9000408c <HAL_RCCEx_PeriphCLKConfig+0x4c0>
    {
      /* Set the source of FDCAN clock*/
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
90004074:	4b04      	ldr	r3, [pc, #16]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90004076:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
90004078:	f423 0240 	bic.w	r2, r3, #12582912	@ 0xc00000
9000407c:	687b      	ldr	r3, [r7, #4]
9000407e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
90004080:	4901      	ldr	r1, [pc, #4]	@ (90004088 <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
90004082:	4313      	orrs	r3, r2
90004084:	650b      	str	r3, [r1, #80]	@ 0x50
90004086:	e003      	b.n	90004090 <HAL_RCCEx_PeriphCLKConfig+0x4c4>
90004088:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
9000408c:	7dfb      	ldrb	r3, [r7, #23]
9000408e:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------ I2C1/I3C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C1_I3C1) == RCC_PERIPHCLK_I2C1_I3C1)
90004090:	687b      	ldr	r3, [r7, #4]
90004092:	681b      	ldr	r3, [r3, #0]
90004094:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
90004098:	2b00      	cmp	r3, #0
9000409a:	d02c      	beq.n	900040f6 <HAL_RCCEx_PeriphCLKConfig+0x52a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1_I3C1CLKSOURCE(PeriphClkInit->I2c1_I3c1ClockSelection));

    switch (PeriphClkInit->I2c1_I3c1ClockSelection)
9000409c:	687b      	ldr	r3, [r7, #4]
9000409e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900040a0:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
900040a4:	d017      	beq.n	900040d6 <HAL_RCCEx_PeriphCLKConfig+0x50a>
900040a6:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
900040aa:	d811      	bhi.n	900040d0 <HAL_RCCEx_PeriphCLKConfig+0x504>
900040ac:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
900040b0:	d011      	beq.n	900040d6 <HAL_RCCEx_PeriphCLKConfig+0x50a>
900040b2:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
900040b6:	d80b      	bhi.n	900040d0 <HAL_RCCEx_PeriphCLKConfig+0x504>
900040b8:	2b00      	cmp	r3, #0
900040ba:	d00c      	beq.n	900040d6 <HAL_RCCEx_PeriphCLKConfig+0x50a>
900040bc:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
900040c0:	d106      	bne.n	900040d0 <HAL_RCCEx_PeriphCLKConfig+0x504>
    {
      case RCC_I2C1_I3C1CLKSOURCE_PLL3R:   /* PLL3_R is used as clock source for I2C1/I3C1*/
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_RCLK);
900040c2:	4b97      	ldr	r3, [pc, #604]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
900040c4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900040c6:	4a96      	ldr	r2, [pc, #600]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
900040c8:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
900040cc:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* I2C1/I3C1 clock source configuration done later after clock selection check */
        break;
900040ce:	e003      	b.n	900040d8 <HAL_RCCEx_PeriphCLKConfig+0x50c>
      case RCC_I2C1_I3C1CLKSOURCE_CSI:     /* CSI is used as clock source for I2C1/I3C1*/
        /* I2C1/I3C1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
900040d0:	2301      	movs	r3, #1
900040d2:	75fb      	strb	r3, [r7, #23]
        break;
900040d4:	e000      	b.n	900040d8 <HAL_RCCEx_PeriphCLKConfig+0x50c>
        break;
900040d6:	bf00      	nop
    }

    if (ret == HAL_OK)
900040d8:	7dfb      	ldrb	r3, [r7, #23]
900040da:	2b00      	cmp	r3, #0
900040dc:	d109      	bne.n	900040f2 <HAL_RCCEx_PeriphCLKConfig+0x526>
    {
      /* Set the source of I2C1/I3C1 clock*/
      __HAL_RCC_I2C1_I3C1_CONFIG(PeriphClkInit->I2c1_I3c1ClockSelection);
900040de:	4b90      	ldr	r3, [pc, #576]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
900040e0:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
900040e2:	f423 5240 	bic.w	r2, r3, #12288	@ 0x3000
900040e6:	687b      	ldr	r3, [r7, #4]
900040e8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900040ea:	498d      	ldr	r1, [pc, #564]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
900040ec:	4313      	orrs	r3, r2
900040ee:	650b      	str	r3, [r1, #80]	@ 0x50
900040f0:	e001      	b.n	900040f6 <HAL_RCCEx_PeriphCLKConfig+0x52a>
    }
    else
    {
      /* set overall return value */
      status = ret;
900040f2:	7dfb      	ldrb	r3, [r7, #23]
900040f4:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------ I2C2/I2C3 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C23) == RCC_PERIPHCLK_I2C23)
900040f6:	687b      	ldr	r3, [r7, #4]
900040f8:	681b      	ldr	r3, [r3, #0]
900040fa:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
900040fe:	2b00      	cmp	r3, #0
90004100:	d02c      	beq.n	9000415c <HAL_RCCEx_PeriphCLKConfig+0x590>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C23CLKSOURCE(PeriphClkInit->I2c23ClockSelection));

    switch (PeriphClkInit->I2c23ClockSelection)
90004102:	687b      	ldr	r3, [r7, #4]
90004104:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
90004106:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
9000410a:	d017      	beq.n	9000413c <HAL_RCCEx_PeriphCLKConfig+0x570>
9000410c:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
90004110:	d811      	bhi.n	90004136 <HAL_RCCEx_PeriphCLKConfig+0x56a>
90004112:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
90004116:	d011      	beq.n	9000413c <HAL_RCCEx_PeriphCLKConfig+0x570>
90004118:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
9000411c:	d80b      	bhi.n	90004136 <HAL_RCCEx_PeriphCLKConfig+0x56a>
9000411e:	2b00      	cmp	r3, #0
90004120:	d00c      	beq.n	9000413c <HAL_RCCEx_PeriphCLKConfig+0x570>
90004122:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
90004126:	d106      	bne.n	90004136 <HAL_RCCEx_PeriphCLKConfig+0x56a>
    {
      case RCC_I2C23CLKSOURCE_PLL3R:   /* PLL3_R is used as clock source for I2C2/I2C3 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_RCLK);
90004128:	4b7d      	ldr	r3, [pc, #500]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
9000412a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000412c:	4a7c      	ldr	r2, [pc, #496]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
9000412e:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
90004132:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* I2C2/I2C3 clock source configuration done later after clock selection check */
        break;
90004134:	e003      	b.n	9000413e <HAL_RCCEx_PeriphCLKConfig+0x572>
      case RCC_I2C23CLKSOURCE_CSI:     /* CSI is used as clock source for I2C2/I2C3 */
        /* I2C2/I2C3 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
90004136:	2301      	movs	r3, #1
90004138:	75fb      	strb	r3, [r7, #23]
        break;
9000413a:	e000      	b.n	9000413e <HAL_RCCEx_PeriphCLKConfig+0x572>
        break;
9000413c:	bf00      	nop
    }

    if (ret == HAL_OK)
9000413e:	7dfb      	ldrb	r3, [r7, #23]
90004140:	2b00      	cmp	r3, #0
90004142:	d109      	bne.n	90004158 <HAL_RCCEx_PeriphCLKConfig+0x58c>
    {
      /* Set the source of I2C2/I2C3 clock*/
      __HAL_RCC_I2C23_CONFIG(PeriphClkInit->I2c23ClockSelection);
90004144:	4b76      	ldr	r3, [pc, #472]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
90004146:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
90004148:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
9000414c:	687b      	ldr	r3, [r7, #4]
9000414e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
90004150:	4973      	ldr	r1, [pc, #460]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
90004152:	4313      	orrs	r3, r2
90004154:	650b      	str	r3, [r1, #80]	@ 0x50
90004156:	e001      	b.n	9000415c <HAL_RCCEx_PeriphCLKConfig+0x590>
    }
    else
    {
      /* set overall return value */
      status = ret;
90004158:	7dfb      	ldrb	r3, [r7, #23]
9000415a:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM1 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
9000415c:	687b      	ldr	r3, [r7, #4]
9000415e:	681b      	ldr	r3, [r3, #0]
90004160:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
90004164:	2b00      	cmp	r3, #0
90004166:	d045      	beq.n	900041f4 <HAL_RCCEx_PeriphCLKConfig+0x628>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    switch (PeriphClkInit->Lptim1ClockSelection)
90004168:	687b      	ldr	r3, [r7, #4]
9000416a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
9000416c:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
90004170:	d02a      	beq.n	900041c8 <HAL_RCCEx_PeriphCLKConfig+0x5fc>
90004172:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
90004176:	d824      	bhi.n	900041c2 <HAL_RCCEx_PeriphCLKConfig+0x5f6>
90004178:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
9000417c:	d026      	beq.n	900041cc <HAL_RCCEx_PeriphCLKConfig+0x600>
9000417e:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
90004182:	d81e      	bhi.n	900041c2 <HAL_RCCEx_PeriphCLKConfig+0x5f6>
90004184:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
90004188:	d022      	beq.n	900041d0 <HAL_RCCEx_PeriphCLKConfig+0x604>
9000418a:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
9000418e:	d818      	bhi.n	900041c2 <HAL_RCCEx_PeriphCLKConfig+0x5f6>
90004190:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
90004194:	d00e      	beq.n	900041b4 <HAL_RCCEx_PeriphCLKConfig+0x5e8>
90004196:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
9000419a:	d812      	bhi.n	900041c2 <HAL_RCCEx_PeriphCLKConfig+0x5f6>
9000419c:	2b00      	cmp	r3, #0
9000419e:	d019      	beq.n	900041d4 <HAL_RCCEx_PeriphCLKConfig+0x608>
900041a0:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
900041a4:	d10d      	bne.n	900041c2 <HAL_RCCEx_PeriphCLKConfig+0x5f6>
      case RCC_LPTIM1CLKSOURCE_PCLK1: /* PCLK1 as clock source for LPTIM1 */
        /* LPTIM1 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM1CLKSOURCE_PLL2P: /* PLL2_P is used as clock source for LPTIM1 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_PCLK);
900041a6:	4b5e      	ldr	r3, [pc, #376]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
900041a8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900041aa:	4a5d      	ldr	r2, [pc, #372]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
900041ac:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
900041b0:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* LPTIM1 clock source configuration done later after clock selection check */
        break;
900041b2:	e010      	b.n	900041d6 <HAL_RCCEx_PeriphCLKConfig+0x60a>

      case RCC_LPTIM1CLKSOURCE_PLL3R:  /* PLL3_R is used as clock source for LPTIM1 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_RCLK);
900041b4:	4b5a      	ldr	r3, [pc, #360]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
900041b6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900041b8:	4a59      	ldr	r2, [pc, #356]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
900041ba:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
900041be:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* LPTIM1 clock source configuration done later after clock selection check */
        break;
900041c0:	e009      	b.n	900041d6 <HAL_RCCEx_PeriphCLKConfig+0x60a>
        /* HSI, HSE, or CSI oscillator is used as clock source for LPTIM1 */
        /* LPTIM1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
900041c2:	2301      	movs	r3, #1
900041c4:	75fb      	strb	r3, [r7, #23]
        break;
900041c6:	e006      	b.n	900041d6 <HAL_RCCEx_PeriphCLKConfig+0x60a>
        break;
900041c8:	bf00      	nop
900041ca:	e004      	b.n	900041d6 <HAL_RCCEx_PeriphCLKConfig+0x60a>
        break;
900041cc:	bf00      	nop
900041ce:	e002      	b.n	900041d6 <HAL_RCCEx_PeriphCLKConfig+0x60a>
        break;
900041d0:	bf00      	nop
900041d2:	e000      	b.n	900041d6 <HAL_RCCEx_PeriphCLKConfig+0x60a>
        break;
900041d4:	bf00      	nop
    }

    if (ret == HAL_OK)
900041d6:	7dfb      	ldrb	r3, [r7, #23]
900041d8:	2b00      	cmp	r3, #0
900041da:	d109      	bne.n	900041f0 <HAL_RCCEx_PeriphCLKConfig+0x624>
    {
      /* Set the source of LPTIM1 clock*/
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
900041dc:	4b50      	ldr	r3, [pc, #320]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
900041de:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
900041e0:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
900041e4:	687b      	ldr	r3, [r7, #4]
900041e6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
900041e8:	494d      	ldr	r1, [pc, #308]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
900041ea:	4313      	orrs	r3, r2
900041ec:	650b      	str	r3, [r1, #80]	@ 0x50
900041ee:	e001      	b.n	900041f4 <HAL_RCCEx_PeriphCLKConfig+0x628>
    }
    else
    {
      /* set overall return value */
      status = ret;
900041f0:	7dfb      	ldrb	r3, [r7, #23]
900041f2:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM2/LPTIM3 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM23) == RCC_PERIPHCLK_LPTIM23)
900041f4:	687b      	ldr	r3, [r7, #4]
900041f6:	681b      	ldr	r3, [r3, #0]
900041f8:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
900041fc:	2b00      	cmp	r3, #0
900041fe:	d045      	beq.n	9000428c <HAL_RCCEx_PeriphCLKConfig+0x6c0>
  {
    switch (PeriphClkInit->Lptim23ClockSelection)
90004200:	687b      	ldr	r3, [r7, #4]
90004202:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90004204:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
90004208:	d02a      	beq.n	90004260 <HAL_RCCEx_PeriphCLKConfig+0x694>
9000420a:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
9000420e:	d824      	bhi.n	9000425a <HAL_RCCEx_PeriphCLKConfig+0x68e>
90004210:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
90004214:	d026      	beq.n	90004264 <HAL_RCCEx_PeriphCLKConfig+0x698>
90004216:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
9000421a:	d81e      	bhi.n	9000425a <HAL_RCCEx_PeriphCLKConfig+0x68e>
9000421c:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
90004220:	d022      	beq.n	90004268 <HAL_RCCEx_PeriphCLKConfig+0x69c>
90004222:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
90004226:	d818      	bhi.n	9000425a <HAL_RCCEx_PeriphCLKConfig+0x68e>
90004228:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
9000422c:	d00e      	beq.n	9000424c <HAL_RCCEx_PeriphCLKConfig+0x680>
9000422e:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
90004232:	d812      	bhi.n	9000425a <HAL_RCCEx_PeriphCLKConfig+0x68e>
90004234:	2b00      	cmp	r3, #0
90004236:	d019      	beq.n	9000426c <HAL_RCCEx_PeriphCLKConfig+0x6a0>
90004238:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
9000423c:	d10d      	bne.n	9000425a <HAL_RCCEx_PeriphCLKConfig+0x68e>
      case RCC_LPTIM23CLKSOURCE_PCLK4: /* PCLK4 as clock source for LPTIM2/LPTIM3 */
        /* LPTIM2/LPTIM3 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM23CLKSOURCE_PLL2P: /* PLL2_P is used as clock source for LPTIM2/LPTIM3 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_PCLK);
9000423e:	4b38      	ldr	r3, [pc, #224]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
90004240:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004242:	4a37      	ldr	r2, [pc, #220]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
90004244:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
90004248:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* LPTIM2/LPTIM3 clock source configuration done later after clock selection check */
        break;
9000424a:	e010      	b.n	9000426e <HAL_RCCEx_PeriphCLKConfig+0x6a2>

      case RCC_LPTIM23CLKSOURCE_PLL3R: /* PLL3_R is used as clock source for LPTIM2/LPTIM3 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_RCLK);
9000424c:	4b34      	ldr	r3, [pc, #208]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
9000424e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004250:	4a33      	ldr	r2, [pc, #204]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
90004252:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
90004256:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* LPTIM2/LPTIM3 clock source configuration done later after clock selection check */
        break;
90004258:	e009      	b.n	9000426e <HAL_RCCEx_PeriphCLKConfig+0x6a2>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM2 clock */
        /* LPTIM2/LPTIM3 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
9000425a:	2301      	movs	r3, #1
9000425c:	75fb      	strb	r3, [r7, #23]
        break;
9000425e:	e006      	b.n	9000426e <HAL_RCCEx_PeriphCLKConfig+0x6a2>
        break;
90004260:	bf00      	nop
90004262:	e004      	b.n	9000426e <HAL_RCCEx_PeriphCLKConfig+0x6a2>
        break;
90004264:	bf00      	nop
90004266:	e002      	b.n	9000426e <HAL_RCCEx_PeriphCLKConfig+0x6a2>
        break;
90004268:	bf00      	nop
9000426a:	e000      	b.n	9000426e <HAL_RCCEx_PeriphCLKConfig+0x6a2>
        break;
9000426c:	bf00      	nop
    }

    if (ret == HAL_OK)
9000426e:	7dfb      	ldrb	r3, [r7, #23]
90004270:	2b00      	cmp	r3, #0
90004272:	d109      	bne.n	90004288 <HAL_RCCEx_PeriphCLKConfig+0x6bc>
    {
      /* Set the source of LPTIM2/LPTIM3 clock*/
      __HAL_RCC_LPTIM23_CONFIG(PeriphClkInit->Lptim23ClockSelection);
90004274:	4b2a      	ldr	r3, [pc, #168]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
90004276:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
90004278:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
9000427c:	687b      	ldr	r3, [r7, #4]
9000427e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90004280:	4927      	ldr	r1, [pc, #156]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
90004282:	4313      	orrs	r3, r2
90004284:	658b      	str	r3, [r1, #88]	@ 0x58
90004286:	e001      	b.n	9000428c <HAL_RCCEx_PeriphCLKConfig+0x6c0>
    }
    else
    {
      /* set overall return value */
      status = ret;
90004288:	7dfb      	ldrb	r3, [r7, #23]
9000428a:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM4/LPTIM5 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM45) == RCC_PERIPHCLK_LPTIM45)
9000428c:	687b      	ldr	r3, [r7, #4]
9000428e:	681b      	ldr	r3, [r3, #0]
90004290:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
90004294:	2b00      	cmp	r3, #0
90004296:	d047      	beq.n	90004328 <HAL_RCCEx_PeriphCLKConfig+0x75c>
  {
    switch (PeriphClkInit->Lptim45ClockSelection)
90004298:	687b      	ldr	r3, [r7, #4]
9000429a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
9000429c:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
900042a0:	d02a      	beq.n	900042f8 <HAL_RCCEx_PeriphCLKConfig+0x72c>
900042a2:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
900042a6:	d824      	bhi.n	900042f2 <HAL_RCCEx_PeriphCLKConfig+0x726>
900042a8:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
900042ac:	d026      	beq.n	900042fc <HAL_RCCEx_PeriphCLKConfig+0x730>
900042ae:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
900042b2:	d81e      	bhi.n	900042f2 <HAL_RCCEx_PeriphCLKConfig+0x726>
900042b4:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
900042b8:	d022      	beq.n	90004300 <HAL_RCCEx_PeriphCLKConfig+0x734>
900042ba:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
900042be:	d818      	bhi.n	900042f2 <HAL_RCCEx_PeriphCLKConfig+0x726>
900042c0:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
900042c4:	d00e      	beq.n	900042e4 <HAL_RCCEx_PeriphCLKConfig+0x718>
900042c6:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
900042ca:	d812      	bhi.n	900042f2 <HAL_RCCEx_PeriphCLKConfig+0x726>
900042cc:	2b00      	cmp	r3, #0
900042ce:	d019      	beq.n	90004304 <HAL_RCCEx_PeriphCLKConfig+0x738>
900042d0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
900042d4:	d10d      	bne.n	900042f2 <HAL_RCCEx_PeriphCLKConfig+0x726>
      case RCC_LPTIM45CLKSOURCE_PCLK4:  /* PCLK4 as clock source for LPTIM4/LPTIM5 */
        /* LPTIM4/LPTIM5 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM45CLKSOURCE_PLL2P: /* PLL2 is used as clock source for LPTIM4/LPTIM5 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_PCLK);
900042d6:	4b12      	ldr	r3, [pc, #72]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
900042d8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900042da:	4a11      	ldr	r2, [pc, #68]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
900042dc:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
900042e0:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* LPTIM4/LPTIM5 clock source configuration done later after clock selection check */
        break;
900042e2:	e010      	b.n	90004306 <HAL_RCCEx_PeriphCLKConfig+0x73a>

      case RCC_LPTIM45CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for LPTIM4/LPTIM5 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_RCLK);
900042e4:	4b0e      	ldr	r3, [pc, #56]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
900042e6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900042e8:	4a0d      	ldr	r2, [pc, #52]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
900042ea:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
900042ee:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* LPTIM4/LPTIM5 clock source configuration done later after clock selection check */
        break;
900042f0:	e009      	b.n	90004306 <HAL_RCCEx_PeriphCLKConfig+0x73a>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM4/LPTIM5 clock */
        /* LPTIM4/LPTIM5 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
900042f2:	2301      	movs	r3, #1
900042f4:	75fb      	strb	r3, [r7, #23]
        break;
900042f6:	e006      	b.n	90004306 <HAL_RCCEx_PeriphCLKConfig+0x73a>
        break;
900042f8:	bf00      	nop
900042fa:	e004      	b.n	90004306 <HAL_RCCEx_PeriphCLKConfig+0x73a>
        break;
900042fc:	bf00      	nop
900042fe:	e002      	b.n	90004306 <HAL_RCCEx_PeriphCLKConfig+0x73a>
        break;
90004300:	bf00      	nop
90004302:	e000      	b.n	90004306 <HAL_RCCEx_PeriphCLKConfig+0x73a>
        break;
90004304:	bf00      	nop
    }

    if (ret == HAL_OK)
90004306:	7dfb      	ldrb	r3, [r7, #23]
90004308:	2b00      	cmp	r3, #0
9000430a:	d10b      	bne.n	90004324 <HAL_RCCEx_PeriphCLKConfig+0x758>
    {
      /* Set the source of LPTIM4/LPTIM5 clock */
      __HAL_RCC_LPTIM45_CONFIG(PeriphClkInit->Lptim45ClockSelection);
9000430c:	4b04      	ldr	r3, [pc, #16]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
9000430e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
90004310:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
90004314:	687b      	ldr	r3, [r7, #4]
90004316:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
90004318:	4901      	ldr	r1, [pc, #4]	@ (90004320 <HAL_RCCEx_PeriphCLKConfig+0x754>)
9000431a:	4313      	orrs	r3, r2
9000431c:	658b      	str	r3, [r1, #88]	@ 0x58
9000431e:	e003      	b.n	90004328 <HAL_RCCEx_PeriphCLKConfig+0x75c>
90004320:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
90004324:	7dfb      	ldrb	r3, [r7, #23]
90004326:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
90004328:	687b      	ldr	r3, [r7, #4]
9000432a:	681b      	ldr	r3, [r3, #0]
9000432c:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
90004330:	2b00      	cmp	r3, #0
90004332:	d034      	beq.n	9000439e <HAL_RCCEx_PeriphCLKConfig+0x7d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    switch (PeriphClkInit->Lpuart1ClockSelection)
90004334:	687b      	ldr	r3, [r7, #4]
90004336:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
90004338:	2b05      	cmp	r3, #5
9000433a:	d81d      	bhi.n	90004378 <HAL_RCCEx_PeriphCLKConfig+0x7ac>
9000433c:	a201      	add	r2, pc, #4	@ (adr r2, 90004344 <HAL_RCCEx_PeriphCLKConfig+0x778>)
9000433e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90004342:	bf00      	nop
90004344:	9000437f 	.word	0x9000437f
90004348:	9000435d 	.word	0x9000435d
9000434c:	9000436b 	.word	0x9000436b
90004350:	9000437f 	.word	0x9000437f
90004354:	9000437f 	.word	0x9000437f
90004358:	9000437f 	.word	0x9000437f
      case RCC_LPUART1CLKSOURCE_PCLK4: /* PCLK4 selected as clock source for LPUART1 */
        /* LPUART1 clock source configuration done later after clock selection check */
        break;

      case RCC_LPUART1CLKSOURCE_PLL2Q: /* PLL2_Q is used as clock source for LPUART1 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_QCLK);
9000435c:	4b91      	ldr	r3, [pc, #580]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
9000435e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004360:	4a90      	ldr	r2, [pc, #576]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
90004362:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
90004366:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* LPUART1 clock source configuration done later after clock selection check */
        break;
90004368:	e00a      	b.n	90004380 <HAL_RCCEx_PeriphCLKConfig+0x7b4>

      case RCC_LPUART1CLKSOURCE_PLL3Q: /* PLL3_Q is used as clock source for LPUART1 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_QCLK);
9000436a:	4b8e      	ldr	r3, [pc, #568]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
9000436c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000436e:	4a8d      	ldr	r2, [pc, #564]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
90004370:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
90004374:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* LPUART1 clock source configuration done later after clock selection check */
        break;
90004376:	e003      	b.n	90004380 <HAL_RCCEx_PeriphCLKConfig+0x7b4>
        /* LSE,  oscillator is used as source of LPUART1 clock */
        /* LPUART1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
90004378:	2301      	movs	r3, #1
9000437a:	75fb      	strb	r3, [r7, #23]
        break;
9000437c:	e000      	b.n	90004380 <HAL_RCCEx_PeriphCLKConfig+0x7b4>
        break;
9000437e:	bf00      	nop
    }

    if (ret == HAL_OK)
90004380:	7dfb      	ldrb	r3, [r7, #23]
90004382:	2b00      	cmp	r3, #0
90004384:	d109      	bne.n	9000439a <HAL_RCCEx_PeriphCLKConfig+0x7ce>
    {
      /* Set the source of LPUART1 clock */
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
90004386:	4b87      	ldr	r3, [pc, #540]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
90004388:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
9000438a:	f023 0207 	bic.w	r2, r3, #7
9000438e:	687b      	ldr	r3, [r7, #4]
90004390:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
90004392:	4984      	ldr	r1, [pc, #528]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
90004394:	4313      	orrs	r3, r2
90004396:	658b      	str	r3, [r1, #88]	@ 0x58
90004398:	e001      	b.n	9000439e <HAL_RCCEx_PeriphCLKConfig+0x7d2>
    }
    else
    {
      /* set overall return value */
      status = ret;
9000439a:	7dfb      	ldrb	r3, [r7, #23]
9000439c:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- LTDC Configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
9000439e:	687b      	ldr	r3, [r7, #4]
900043a0:	681b      	ldr	r3, [r3, #0]
900043a2:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
900043a6:	2b00      	cmp	r3, #0
900043a8:	d005      	beq.n	900043b6 <HAL_RCCEx_PeriphCLKConfig+0x7ea>
  {
    /* LTDC internally connected to PLL3_R output clock */
    __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_RCLK);
900043aa:	4b7e      	ldr	r3, [pc, #504]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
900043ac:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900043ae:	4a7d      	ldr	r2, [pc, #500]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
900043b0:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
900043b4:	62d3      	str	r3, [r2, #44]	@ 0x2c
  }

  /*---------------------------- PSSI configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PSSI) == RCC_PERIPHCLK_PSSI)
900043b6:	687b      	ldr	r3, [r7, #4]
900043b8:	681b      	ldr	r3, [r3, #0]
900043ba:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
900043be:	2b00      	cmp	r3, #0
900043c0:	d021      	beq.n	90004406 <HAL_RCCEx_PeriphCLKConfig+0x83a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_PSSICLKSOURCE(PeriphClkInit->PssiClockSelection));

    switch (PeriphClkInit->PssiClockSelection)
900043c2:	687b      	ldr	r3, [r7, #4]
900043c4:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
900043c6:	2b00      	cmp	r3, #0
900043c8:	d003      	beq.n	900043d2 <HAL_RCCEx_PeriphCLKConfig+0x806>
900043ca:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
900043ce:	d00a      	beq.n	900043e6 <HAL_RCCEx_PeriphCLKConfig+0x81a>
900043d0:	e006      	b.n	900043e0 <HAL_RCCEx_PeriphCLKConfig+0x814>
    {
      case RCC_PSSICLKSOURCE_PLL3R:  /* PLL3_R is used as clock source for PSSI */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_RCLK);
900043d2:	4b74      	ldr	r3, [pc, #464]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
900043d4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900043d6:	4a73      	ldr	r2, [pc, #460]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
900043d8:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
900043dc:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* PSSI clock source configuration done later after clock selection check */
        break;
900043de:	e003      	b.n	900043e8 <HAL_RCCEx_PeriphCLKConfig+0x81c>
        /* HSI, HSE, or CSI oscillator is used as source of PSSI clock */
        /* PSSI clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
900043e0:	2301      	movs	r3, #1
900043e2:	75fb      	strb	r3, [r7, #23]
        break;
900043e4:	e000      	b.n	900043e8 <HAL_RCCEx_PeriphCLKConfig+0x81c>
        break;
900043e6:	bf00      	nop
    }

    if (ret == HAL_OK)
900043e8:	7dfb      	ldrb	r3, [r7, #23]
900043ea:	2b00      	cmp	r3, #0
900043ec:	d109      	bne.n	90004402 <HAL_RCCEx_PeriphCLKConfig+0x836>
    {
      /* Set the source of PSSI clock*/
      __HAL_RCC_PSSI_CONFIG(PeriphClkInit->PssiClockSelection);
900043ee:	4b6d      	ldr	r3, [pc, #436]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
900043f0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
900043f2:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
900043f6:	687b      	ldr	r3, [r7, #4]
900043f8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
900043fa:	496a      	ldr	r1, [pc, #424]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
900043fc:	4313      	orrs	r3, r2
900043fe:	64cb      	str	r3, [r1, #76]	@ 0x4c
90004400:	e001      	b.n	90004406 <HAL_RCCEx_PeriphCLKConfig+0x83a>
    }
    else
    {
      /* set overall return value */
      status = ret;
90004402:	7dfb      	ldrb	r3, [r7, #23]
90004404:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SAI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
90004406:	687b      	ldr	r3, [r7, #4]
90004408:	681b      	ldr	r3, [r3, #0]
9000440a:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
9000440e:	2b00      	cmp	r3, #0
90004410:	d043      	beq.n	9000449a <HAL_RCCEx_PeriphCLKConfig+0x8ce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    switch (PeriphClkInit->Sai1ClockSelection)
90004412:	687b      	ldr	r3, [r7, #4]
90004414:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90004416:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
9000441a:	d02c      	beq.n	90004476 <HAL_RCCEx_PeriphCLKConfig+0x8aa>
9000441c:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
90004420:	d826      	bhi.n	90004470 <HAL_RCCEx_PeriphCLKConfig+0x8a4>
90004422:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
90004426:	d028      	beq.n	9000447a <HAL_RCCEx_PeriphCLKConfig+0x8ae>
90004428:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
9000442c:	d820      	bhi.n	90004470 <HAL_RCCEx_PeriphCLKConfig+0x8a4>
9000442e:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
90004432:	d016      	beq.n	90004462 <HAL_RCCEx_PeriphCLKConfig+0x896>
90004434:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
90004438:	d81a      	bhi.n	90004470 <HAL_RCCEx_PeriphCLKConfig+0x8a4>
9000443a:	2b00      	cmp	r3, #0
9000443c:	d003      	beq.n	90004446 <HAL_RCCEx_PeriphCLKConfig+0x87a>
9000443e:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
90004442:	d007      	beq.n	90004454 <HAL_RCCEx_PeriphCLKConfig+0x888>
90004444:	e014      	b.n	90004470 <HAL_RCCEx_PeriphCLKConfig+0x8a4>
    {
      case RCC_SAI1CLKSOURCE_PLL1Q:  /* PLL1_Q is used as clock source for SAI1 */
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLL1CLKOUT_ENABLE(RCC_PLL_QCLK);
90004446:	4b57      	ldr	r3, [pc, #348]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
90004448:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000444a:	4a56      	ldr	r2, [pc, #344]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
9000444c:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
90004450:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SAI1 clock source configuration done later after clock selection check */
        break;
90004452:	e013      	b.n	9000447c <HAL_RCCEx_PeriphCLKConfig+0x8b0>

      case RCC_SAI1CLKSOURCE_PLL2P:  /* PLL2_P is used as clock source for SAI1 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_PCLK);
90004454:	4b53      	ldr	r3, [pc, #332]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
90004456:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004458:	4a52      	ldr	r2, [pc, #328]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
9000445a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
9000445e:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SAI1 clock source configuration done later after clock selection check */
        break;
90004460:	e00c      	b.n	9000447c <HAL_RCCEx_PeriphCLKConfig+0x8b0>

      case RCC_SAI1CLKSOURCE_PLL3P:  /* PLL3_P is used as clock source for SAI1 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_PCLK);
90004462:	4b50      	ldr	r3, [pc, #320]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
90004464:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004466:	4a4f      	ldr	r2, [pc, #316]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
90004468:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
9000446c:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SAI1 clock source configuration done later after clock selection check */
        break;
9000446e:	e005      	b.n	9000447c <HAL_RCCEx_PeriphCLKConfig+0x8b0>
        /* HSI, HSE, or CSI oscillator is used as source of SAI1 clock */
        /* SAI1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
90004470:	2301      	movs	r3, #1
90004472:	75fb      	strb	r3, [r7, #23]
        break;
90004474:	e002      	b.n	9000447c <HAL_RCCEx_PeriphCLKConfig+0x8b0>
        break;
90004476:	bf00      	nop
90004478:	e000      	b.n	9000447c <HAL_RCCEx_PeriphCLKConfig+0x8b0>
        break;
9000447a:	bf00      	nop
    }

    if (ret == HAL_OK)
9000447c:	7dfb      	ldrb	r3, [r7, #23]
9000447e:	2b00      	cmp	r3, #0
90004480:	d109      	bne.n	90004496 <HAL_RCCEx_PeriphCLKConfig+0x8ca>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
90004482:	4b48      	ldr	r3, [pc, #288]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
90004484:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
90004486:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
9000448a:	687b      	ldr	r3, [r7, #4]
9000448c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
9000448e:	4945      	ldr	r1, [pc, #276]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
90004490:	4313      	orrs	r3, r2
90004492:	654b      	str	r3, [r1, #84]	@ 0x54
90004494:	e001      	b.n	9000449a <HAL_RCCEx_PeriphCLKConfig+0x8ce>
    }
    else
    {
      /* set overall return value */
      status = ret;
90004496:	7dfb      	ldrb	r3, [r7, #23]
90004498:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SAI2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2)
9000449a:	687b      	ldr	r3, [r7, #4]
9000449c:	681b      	ldr	r3, [r3, #0]
9000449e:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
900044a2:	2b00      	cmp	r3, #0
900044a4:	d04b      	beq.n	9000453e <HAL_RCCEx_PeriphCLKConfig+0x972>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    switch (PeriphClkInit->Sai2ClockSelection)
900044a6:	687b      	ldr	r3, [r7, #4]
900044a8:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
900044aa:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
900044ae:	d032      	beq.n	90004516 <HAL_RCCEx_PeriphCLKConfig+0x94a>
900044b0:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
900044b4:	d82c      	bhi.n	90004510 <HAL_RCCEx_PeriphCLKConfig+0x944>
900044b6:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
900044ba:	d02e      	beq.n	9000451a <HAL_RCCEx_PeriphCLKConfig+0x94e>
900044bc:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
900044c0:	d826      	bhi.n	90004510 <HAL_RCCEx_PeriphCLKConfig+0x944>
900044c2:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
900044c6:	d02a      	beq.n	9000451e <HAL_RCCEx_PeriphCLKConfig+0x952>
900044c8:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
900044cc:	d820      	bhi.n	90004510 <HAL_RCCEx_PeriphCLKConfig+0x944>
900044ce:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
900044d2:	d016      	beq.n	90004502 <HAL_RCCEx_PeriphCLKConfig+0x936>
900044d4:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
900044d8:	d81a      	bhi.n	90004510 <HAL_RCCEx_PeriphCLKConfig+0x944>
900044da:	2b00      	cmp	r3, #0
900044dc:	d003      	beq.n	900044e6 <HAL_RCCEx_PeriphCLKConfig+0x91a>
900044de:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
900044e2:	d007      	beq.n	900044f4 <HAL_RCCEx_PeriphCLKConfig+0x928>
900044e4:	e014      	b.n	90004510 <HAL_RCCEx_PeriphCLKConfig+0x944>
    {
      case RCC_SAI2CLKSOURCE_PLL1Q:  /* PLL1_Q is used as clock source for SAI2 */
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLL1CLKOUT_ENABLE(RCC_PLL_QCLK);
900044e6:	4b2f      	ldr	r3, [pc, #188]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
900044e8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900044ea:	4a2e      	ldr	r2, [pc, #184]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
900044ec:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
900044f0:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SAI2 clock source configuration done later after clock selection check */
        break;
900044f2:	e015      	b.n	90004520 <HAL_RCCEx_PeriphCLKConfig+0x954>

      case RCC_SAI2CLKSOURCE_PLL2P:  /* PLL2_P is used as clock source for SAI2 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_PCLK);
900044f4:	4b2b      	ldr	r3, [pc, #172]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
900044f6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900044f8:	4a2a      	ldr	r2, [pc, #168]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
900044fa:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
900044fe:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SAI2 clock source configuration done later after clock selection check */
        break;
90004500:	e00e      	b.n	90004520 <HAL_RCCEx_PeriphCLKConfig+0x954>

      case RCC_SAI2CLKSOURCE_PLL3P:  /* PLL3_P is used as clock source for SAI2 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_PCLK);
90004502:	4b28      	ldr	r3, [pc, #160]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
90004504:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004506:	4a27      	ldr	r2, [pc, #156]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
90004508:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
9000450c:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SAI2 clock source configuration done later after clock selection check */
        break;
9000450e:	e007      	b.n	90004520 <HAL_RCCEx_PeriphCLKConfig+0x954>
      case RCC_SAI2CLKSOURCE_SPDIF: /* SPDIF clock is used as source of SAI2 clock */
        /* SAI2 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
90004510:	2301      	movs	r3, #1
90004512:	75fb      	strb	r3, [r7, #23]
        break;
90004514:	e004      	b.n	90004520 <HAL_RCCEx_PeriphCLKConfig+0x954>
        break;
90004516:	bf00      	nop
90004518:	e002      	b.n	90004520 <HAL_RCCEx_PeriphCLKConfig+0x954>
        break;
9000451a:	bf00      	nop
9000451c:	e000      	b.n	90004520 <HAL_RCCEx_PeriphCLKConfig+0x954>
        break;
9000451e:	bf00      	nop
    }

    if (ret == HAL_OK)
90004520:	7dfb      	ldrb	r3, [r7, #23]
90004522:	2b00      	cmp	r3, #0
90004524:	d109      	bne.n	9000453a <HAL_RCCEx_PeriphCLKConfig+0x96e>
    {
      /* Set the source of SAI2 clock*/
      __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
90004526:	4b1f      	ldr	r3, [pc, #124]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
90004528:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
9000452a:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
9000452e:	687b      	ldr	r3, [r7, #4]
90004530:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
90004532:	491c      	ldr	r1, [pc, #112]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
90004534:	4313      	orrs	r3, r2
90004536:	654b      	str	r3, [r1, #84]	@ 0x54
90004538:	e001      	b.n	9000453e <HAL_RCCEx_PeriphCLKConfig+0x972>
    }
    else
    {
      /* set overall return value */
      status = ret;
9000453a:	7dfb      	ldrb	r3, [r7, #23]
9000453c:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPDIFRX configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
9000453e:	687b      	ldr	r3, [r7, #4]
90004540:	681b      	ldr	r3, [r3, #0]
90004542:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
90004546:	2b00      	cmp	r3, #0
90004548:	d03e      	beq.n	900045c8 <HAL_RCCEx_PeriphCLKConfig+0x9fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPDIFRXCLKSOURCE(PeriphClkInit->SpdifrxClockSelection));

    switch (PeriphClkInit->SpdifrxClockSelection)
9000454a:	687b      	ldr	r3, [r7, #4]
9000454c:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
9000454e:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
90004552:	d029      	beq.n	900045a8 <HAL_RCCEx_PeriphCLKConfig+0x9dc>
90004554:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
90004558:	d820      	bhi.n	9000459c <HAL_RCCEx_PeriphCLKConfig+0x9d0>
9000455a:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
9000455e:	d016      	beq.n	9000458e <HAL_RCCEx_PeriphCLKConfig+0x9c2>
90004560:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
90004564:	d81a      	bhi.n	9000459c <HAL_RCCEx_PeriphCLKConfig+0x9d0>
90004566:	2b00      	cmp	r3, #0
90004568:	d003      	beq.n	90004572 <HAL_RCCEx_PeriphCLKConfig+0x9a6>
9000456a:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
9000456e:	d007      	beq.n	90004580 <HAL_RCCEx_PeriphCLKConfig+0x9b4>
90004570:	e014      	b.n	9000459c <HAL_RCCEx_PeriphCLKConfig+0x9d0>
    {
      case RCC_SPDIFRXCLKSOURCE_PLL1Q: /* PLL1_Q is used as clock source for SPDIFRX */
        /* Enable PLL1Q Clock output generated form System PLL . */
        __HAL_RCC_PLL1CLKOUT_ENABLE(RCC_PLL_QCLK);
90004572:	4b0c      	ldr	r3, [pc, #48]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
90004574:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004576:	4a0b      	ldr	r2, [pc, #44]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
90004578:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
9000457c:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
9000457e:	e014      	b.n	900045aa <HAL_RCCEx_PeriphCLKConfig+0x9de>

      case RCC_SPDIFRXCLKSOURCE_PLL2R: /* PLL2_R is used as clock source for SPDIFRX */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_RCLK);
90004580:	4b08      	ldr	r3, [pc, #32]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
90004582:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004584:	4a07      	ldr	r2, [pc, #28]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
90004586:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
9000458a:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
9000458c:	e00d      	b.n	900045aa <HAL_RCCEx_PeriphCLKConfig+0x9de>

      case RCC_SPDIFRXCLKSOURCE_PLL3R:  /* PLL3_R is used as clock source for SPDIFRX */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_RCLK);
9000458e:	4b05      	ldr	r3, [pc, #20]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
90004590:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004592:	4a04      	ldr	r2, [pc, #16]	@ (900045a4 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
90004594:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
90004598:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
9000459a:	e006      	b.n	900045aa <HAL_RCCEx_PeriphCLKConfig+0x9de>
        /* Internal OSC clock is used as source of SPDIFRX clock*/
        /* SPDIFRX clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
9000459c:	2301      	movs	r3, #1
9000459e:	75fb      	strb	r3, [r7, #23]
        break;
900045a0:	e003      	b.n	900045aa <HAL_RCCEx_PeriphCLKConfig+0x9de>
900045a2:	bf00      	nop
900045a4:	58024400 	.word	0x58024400
        break;
900045a8:	bf00      	nop
    }

    if (ret == HAL_OK)
900045aa:	7dfb      	ldrb	r3, [r7, #23]
900045ac:	2b00      	cmp	r3, #0
900045ae:	d109      	bne.n	900045c4 <HAL_RCCEx_PeriphCLKConfig+0x9f8>
    {
      /* Set the source of SPDIFRX clock */
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
900045b0:	4b8e      	ldr	r3, [pc, #568]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
900045b2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
900045b4:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
900045b8:	687b      	ldr	r3, [r7, #4]
900045ba:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
900045bc:	498b      	ldr	r1, [pc, #556]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
900045be:	4313      	orrs	r3, r2
900045c0:	650b      	str	r3, [r1, #80]	@ 0x50
900045c2:	e001      	b.n	900045c8 <HAL_RCCEx_PeriphCLKConfig+0x9fc>
    }
    else
    {
      /* set overall return value */
      status = ret;
900045c4:	7dfb      	ldrb	r3, [r7, #23]
900045c6:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
900045c8:	687b      	ldr	r3, [r7, #4]
900045ca:	681b      	ldr	r3, [r3, #0]
900045cc:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
900045d0:	2b00      	cmp	r3, #0
900045d2:	d043      	beq.n	9000465c <HAL_RCCEx_PeriphCLKConfig+0xa90>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI1CLKSOURCE(PeriphClkInit->Spi1ClockSelection));

    switch (PeriphClkInit->Spi1ClockSelection)
900045d4:	687b      	ldr	r3, [r7, #4]
900045d6:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
900045d8:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
900045dc:	d02c      	beq.n	90004638 <HAL_RCCEx_PeriphCLKConfig+0xa6c>
900045de:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
900045e2:	d826      	bhi.n	90004632 <HAL_RCCEx_PeriphCLKConfig+0xa66>
900045e4:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
900045e8:	d028      	beq.n	9000463c <HAL_RCCEx_PeriphCLKConfig+0xa70>
900045ea:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
900045ee:	d820      	bhi.n	90004632 <HAL_RCCEx_PeriphCLKConfig+0xa66>
900045f0:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
900045f4:	d016      	beq.n	90004624 <HAL_RCCEx_PeriphCLKConfig+0xa58>
900045f6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
900045fa:	d81a      	bhi.n	90004632 <HAL_RCCEx_PeriphCLKConfig+0xa66>
900045fc:	2b00      	cmp	r3, #0
900045fe:	d003      	beq.n	90004608 <HAL_RCCEx_PeriphCLKConfig+0xa3c>
90004600:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
90004604:	d007      	beq.n	90004616 <HAL_RCCEx_PeriphCLKConfig+0xa4a>
90004606:	e014      	b.n	90004632 <HAL_RCCEx_PeriphCLKConfig+0xa66>
    {
      case RCC_SPI1CLKSOURCE_PLL1Q:  /* PLL1_Q is used as clock source for SPI1 */
        /* Enable SPI Clock output generated form System PLL . */
        __HAL_RCC_PLL1CLKOUT_ENABLE(RCC_PLL_QCLK);
90004608:	4b78      	ldr	r3, [pc, #480]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
9000460a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000460c:	4a77      	ldr	r2, [pc, #476]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
9000460e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
90004612:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPI1 clock source configuration done later after clock selection check */
        break;
90004614:	e013      	b.n	9000463e <HAL_RCCEx_PeriphCLKConfig+0xa72>

      case RCC_SPI1CLKSOURCE_PLL2P:  /* PLL2_P is used as clock source for SPI1 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_PCLK);
90004616:	4b75      	ldr	r3, [pc, #468]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
90004618:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000461a:	4a74      	ldr	r2, [pc, #464]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
9000461c:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
90004620:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPI1 clock source configuration done later after clock selection check */
        break;
90004622:	e00c      	b.n	9000463e <HAL_RCCEx_PeriphCLKConfig+0xa72>

      case RCC_SPI1CLKSOURCE_PLL3P:  /* PLL3_P is used as clock source for SPI1 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_PCLK);
90004624:	4b71      	ldr	r3, [pc, #452]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
90004626:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004628:	4a70      	ldr	r2, [pc, #448]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
9000462a:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
9000462e:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPI1 clock source configuration done later after clock selection check */
        break;
90004630:	e005      	b.n	9000463e <HAL_RCCEx_PeriphCLKConfig+0xa72>
      case RCC_SPI1CLKSOURCE_CLKP:  /* HSI, HSE, or CSI oscillator is used as source of SPI1 clock */
        /* SPI1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
90004632:	2301      	movs	r3, #1
90004634:	75fb      	strb	r3, [r7, #23]
        break;
90004636:	e002      	b.n	9000463e <HAL_RCCEx_PeriphCLKConfig+0xa72>
        break;
90004638:	bf00      	nop
9000463a:	e000      	b.n	9000463e <HAL_RCCEx_PeriphCLKConfig+0xa72>
        break;
9000463c:	bf00      	nop
    }

    if (ret == HAL_OK)
9000463e:	7dfb      	ldrb	r3, [r7, #23]
90004640:	2b00      	cmp	r3, #0
90004642:	d109      	bne.n	90004658 <HAL_RCCEx_PeriphCLKConfig+0xa8c>
    {
      /* Set the source of SPI1 clock*/
      __HAL_RCC_SPI1_CONFIG(PeriphClkInit->Spi1ClockSelection);
90004644:	4b69      	ldr	r3, [pc, #420]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
90004646:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
90004648:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
9000464c:	687b      	ldr	r3, [r7, #4]
9000464e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
90004650:	4966      	ldr	r1, [pc, #408]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
90004652:	4313      	orrs	r3, r2
90004654:	654b      	str	r3, [r1, #84]	@ 0x54
90004656:	e001      	b.n	9000465c <HAL_RCCEx_PeriphCLKConfig+0xa90>
    }
    else
    {
      /* set overall return value */
      status = ret;
90004658:	7dfb      	ldrb	r3, [r7, #23]
9000465a:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI2/SPI3 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI23) == RCC_PERIPHCLK_SPI23)
9000465c:	687b      	ldr	r3, [r7, #4]
9000465e:	681b      	ldr	r3, [r3, #0]
90004660:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
90004664:	2b00      	cmp	r3, #0
90004666:	d03c      	beq.n	900046e2 <HAL_RCCEx_PeriphCLKConfig+0xb16>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI23CLKSOURCE(PeriphClkInit->Spi23ClockSelection));

    switch (PeriphClkInit->Spi23ClockSelection)
90004668:	687b      	ldr	r3, [r7, #4]
9000466a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
9000466c:	2b40      	cmp	r3, #64	@ 0x40
9000466e:	d026      	beq.n	900046be <HAL_RCCEx_PeriphCLKConfig+0xaf2>
90004670:	2b40      	cmp	r3, #64	@ 0x40
90004672:	d821      	bhi.n	900046b8 <HAL_RCCEx_PeriphCLKConfig+0xaec>
90004674:	2b30      	cmp	r3, #48	@ 0x30
90004676:	d024      	beq.n	900046c2 <HAL_RCCEx_PeriphCLKConfig+0xaf6>
90004678:	2b30      	cmp	r3, #48	@ 0x30
9000467a:	d81d      	bhi.n	900046b8 <HAL_RCCEx_PeriphCLKConfig+0xaec>
9000467c:	2b20      	cmp	r3, #32
9000467e:	d014      	beq.n	900046aa <HAL_RCCEx_PeriphCLKConfig+0xade>
90004680:	2b20      	cmp	r3, #32
90004682:	d819      	bhi.n	900046b8 <HAL_RCCEx_PeriphCLKConfig+0xaec>
90004684:	2b00      	cmp	r3, #0
90004686:	d002      	beq.n	9000468e <HAL_RCCEx_PeriphCLKConfig+0xac2>
90004688:	2b10      	cmp	r3, #16
9000468a:	d007      	beq.n	9000469c <HAL_RCCEx_PeriphCLKConfig+0xad0>
9000468c:	e014      	b.n	900046b8 <HAL_RCCEx_PeriphCLKConfig+0xaec>
    {
      case RCC_SPI23CLKSOURCE_PLL1Q:  /* PLL1_Q is used as clock source for SPI2/SPI3 */
        /* Enable SPI Clock output generated form System PLL . */
        __HAL_RCC_PLL1CLKOUT_ENABLE(RCC_PLL_QCLK);
9000468e:	4b57      	ldr	r3, [pc, #348]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
90004690:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004692:	4a56      	ldr	r2, [pc, #344]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
90004694:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
90004698:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPI2/SPI3 clock source configuration done later after clock selection check */
        break;
9000469a:	e013      	b.n	900046c4 <HAL_RCCEx_PeriphCLKConfig+0xaf8>

      case RCC_SPI23CLKSOURCE_PLL2P:  /* PLL2_P is used as clock source for SPI2/SPI3 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_PCLK);
9000469c:	4b53      	ldr	r3, [pc, #332]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
9000469e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900046a0:	4a52      	ldr	r2, [pc, #328]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
900046a2:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
900046a6:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPI2/SPI3 clock source configuration done later after clock selection check */
        break;
900046a8:	e00c      	b.n	900046c4 <HAL_RCCEx_PeriphCLKConfig+0xaf8>

      case RCC_SPI23CLKSOURCE_PLL3P:  /* PLL3_P is used as clock source for SPI2/SPI3 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_PCLK);
900046aa:	4b50      	ldr	r3, [pc, #320]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
900046ac:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900046ae:	4a4f      	ldr	r2, [pc, #316]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
900046b0:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
900046b4:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPI2/SPI3 clock source configuration done later after clock selection check */
        break;
900046b6:	e005      	b.n	900046c4 <HAL_RCCEx_PeriphCLKConfig+0xaf8>
      case RCC_SPI23CLKSOURCE_CLKP:  /* HSI, HSE, or CSI oscillator is used as source of SPI2/SPI3 clock */
        /* SPI2/SPI3 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
900046b8:	2301      	movs	r3, #1
900046ba:	75fb      	strb	r3, [r7, #23]
        break;
900046bc:	e002      	b.n	900046c4 <HAL_RCCEx_PeriphCLKConfig+0xaf8>
        break;
900046be:	bf00      	nop
900046c0:	e000      	b.n	900046c4 <HAL_RCCEx_PeriphCLKConfig+0xaf8>
        break;
900046c2:	bf00      	nop
    }

    if (ret == HAL_OK)
900046c4:	7dfb      	ldrb	r3, [r7, #23]
900046c6:	2b00      	cmp	r3, #0
900046c8:	d109      	bne.n	900046de <HAL_RCCEx_PeriphCLKConfig+0xb12>
    {
      /* Set the source of SPI2/SPI3 clock*/
      __HAL_RCC_SPI23_CONFIG(PeriphClkInit->Spi23ClockSelection);
900046ca:	4b48      	ldr	r3, [pc, #288]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
900046cc:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
900046ce:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
900046d2:	687b      	ldr	r3, [r7, #4]
900046d4:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
900046d6:	4945      	ldr	r1, [pc, #276]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
900046d8:	4313      	orrs	r3, r2
900046da:	650b      	str	r3, [r1, #80]	@ 0x50
900046dc:	e001      	b.n	900046e2 <HAL_RCCEx_PeriphCLKConfig+0xb16>
    }
    else
    {
      /* set overall return value */
      status = ret;
900046de:	7dfb      	ldrb	r3, [r7, #23]
900046e0:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI4/5 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
900046e2:	687b      	ldr	r3, [r7, #4]
900046e4:	681b      	ldr	r3, [r3, #0]
900046e6:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
900046ea:	2b00      	cmp	r3, #0
900046ec:	d03c      	beq.n	90004768 <HAL_RCCEx_PeriphCLKConfig+0xb9c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI45CLKSOURCE(PeriphClkInit->Spi45ClockSelection));

    switch (PeriphClkInit->Spi45ClockSelection)
900046ee:	687b      	ldr	r3, [r7, #4]
900046f0:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
900046f2:	2b50      	cmp	r3, #80	@ 0x50
900046f4:	d022      	beq.n	9000473c <HAL_RCCEx_PeriphCLKConfig+0xb70>
900046f6:	2b50      	cmp	r3, #80	@ 0x50
900046f8:	d81d      	bhi.n	90004736 <HAL_RCCEx_PeriphCLKConfig+0xb6a>
900046fa:	2b40      	cmp	r3, #64	@ 0x40
900046fc:	d020      	beq.n	90004740 <HAL_RCCEx_PeriphCLKConfig+0xb74>
900046fe:	2b40      	cmp	r3, #64	@ 0x40
90004700:	d819      	bhi.n	90004736 <HAL_RCCEx_PeriphCLKConfig+0xb6a>
90004702:	2b30      	cmp	r3, #48	@ 0x30
90004704:	d01e      	beq.n	90004744 <HAL_RCCEx_PeriphCLKConfig+0xb78>
90004706:	2b30      	cmp	r3, #48	@ 0x30
90004708:	d815      	bhi.n	90004736 <HAL_RCCEx_PeriphCLKConfig+0xb6a>
9000470a:	2b20      	cmp	r3, #32
9000470c:	d00c      	beq.n	90004728 <HAL_RCCEx_PeriphCLKConfig+0xb5c>
9000470e:	2b20      	cmp	r3, #32
90004710:	d811      	bhi.n	90004736 <HAL_RCCEx_PeriphCLKConfig+0xb6a>
90004712:	2b00      	cmp	r3, #0
90004714:	d018      	beq.n	90004748 <HAL_RCCEx_PeriphCLKConfig+0xb7c>
90004716:	2b10      	cmp	r3, #16
90004718:	d10d      	bne.n	90004736 <HAL_RCCEx_PeriphCLKConfig+0xb6a>
      case RCC_SPI45CLKSOURCE_PCLK2:  /* PCLK2 as clock source for SPI4/SPI5 */
        /* SPI4/SPI5 clock source configuration done later after clock selection check */
        break;

      case RCC_SPI45CLKSOURCE_PLL2Q:  /* PLL2_Q is used as clock source for SPI4/SPI5 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_QCLK);
9000471a:	4b34      	ldr	r3, [pc, #208]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
9000471c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000471e:	4a33      	ldr	r2, [pc, #204]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
90004720:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
90004724:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPI4/SPI5 clock source configuration done later after clock selection check */
        break;
90004726:	e010      	b.n	9000474a <HAL_RCCEx_PeriphCLKConfig+0xb7e>

      case RCC_SPI45CLKSOURCE_PLL3Q:  /* PLL3_Q is used as clock source for SPI4/SPI5 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_QCLK);
90004728:	4b30      	ldr	r3, [pc, #192]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
9000472a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000472c:	4a2f      	ldr	r2, [pc, #188]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
9000472e:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
90004732:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPI4/SPI5 clock source configuration done later after clock selection check */
        break;
90004734:	e009      	b.n	9000474a <HAL_RCCEx_PeriphCLKConfig+0xb7e>
      case RCC_SPI45CLKSOURCE_HSE: /* HSE oscillator clock is used as source of SPI4/SPI5 */
        /* SPI4/SPI5 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
90004736:	2301      	movs	r3, #1
90004738:	75fb      	strb	r3, [r7, #23]
        break;
9000473a:	e006      	b.n	9000474a <HAL_RCCEx_PeriphCLKConfig+0xb7e>
        break;
9000473c:	bf00      	nop
9000473e:	e004      	b.n	9000474a <HAL_RCCEx_PeriphCLKConfig+0xb7e>
        break;
90004740:	bf00      	nop
90004742:	e002      	b.n	9000474a <HAL_RCCEx_PeriphCLKConfig+0xb7e>
        break;
90004744:	bf00      	nop
90004746:	e000      	b.n	9000474a <HAL_RCCEx_PeriphCLKConfig+0xb7e>
        break;
90004748:	bf00      	nop
    }

    if (ret == HAL_OK)
9000474a:	7dfb      	ldrb	r3, [r7, #23]
9000474c:	2b00      	cmp	r3, #0
9000474e:	d109      	bne.n	90004764 <HAL_RCCEx_PeriphCLKConfig+0xb98>
    {
      /* Set the source of SPI4/SPI5 clock */
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
90004750:	4b26      	ldr	r3, [pc, #152]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
90004752:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
90004754:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
90004758:	687b      	ldr	r3, [r7, #4]
9000475a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
9000475c:	4923      	ldr	r1, [pc, #140]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
9000475e:	4313      	orrs	r3, r2
90004760:	654b      	str	r3, [r1, #84]	@ 0x54
90004762:	e001      	b.n	90004768 <HAL_RCCEx_PeriphCLKConfig+0xb9c>
    }
    else
    {
      /* set overall return value */
      status = ret;
90004764:	7dfb      	ldrb	r3, [r7, #23]
90004766:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
90004768:	687b      	ldr	r3, [r7, #4]
9000476a:	681b      	ldr	r3, [r3, #0]
9000476c:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
90004770:	2b00      	cmp	r3, #0
90004772:	d03f      	beq.n	900047f4 <HAL_RCCEx_PeriphCLKConfig+0xc28>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI6CLKSOURCE(PeriphClkInit->Spi6ClockSelection));

    switch (PeriphClkInit->Spi6ClockSelection)
90004774:	687b      	ldr	r3, [r7, #4]
90004776:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
90004778:	2b50      	cmp	r3, #80	@ 0x50
9000477a:	d022      	beq.n	900047c2 <HAL_RCCEx_PeriphCLKConfig+0xbf6>
9000477c:	2b50      	cmp	r3, #80	@ 0x50
9000477e:	d81d      	bhi.n	900047bc <HAL_RCCEx_PeriphCLKConfig+0xbf0>
90004780:	2b40      	cmp	r3, #64	@ 0x40
90004782:	d020      	beq.n	900047c6 <HAL_RCCEx_PeriphCLKConfig+0xbfa>
90004784:	2b40      	cmp	r3, #64	@ 0x40
90004786:	d819      	bhi.n	900047bc <HAL_RCCEx_PeriphCLKConfig+0xbf0>
90004788:	2b30      	cmp	r3, #48	@ 0x30
9000478a:	d01e      	beq.n	900047ca <HAL_RCCEx_PeriphCLKConfig+0xbfe>
9000478c:	2b30      	cmp	r3, #48	@ 0x30
9000478e:	d815      	bhi.n	900047bc <HAL_RCCEx_PeriphCLKConfig+0xbf0>
90004790:	2b20      	cmp	r3, #32
90004792:	d00c      	beq.n	900047ae <HAL_RCCEx_PeriphCLKConfig+0xbe2>
90004794:	2b20      	cmp	r3, #32
90004796:	d811      	bhi.n	900047bc <HAL_RCCEx_PeriphCLKConfig+0xbf0>
90004798:	2b00      	cmp	r3, #0
9000479a:	d018      	beq.n	900047ce <HAL_RCCEx_PeriphCLKConfig+0xc02>
9000479c:	2b10      	cmp	r3, #16
9000479e:	d10d      	bne.n	900047bc <HAL_RCCEx_PeriphCLKConfig+0xbf0>
      case RCC_SPI6CLKSOURCE_PCLK4: /* PCLK4 as clock source for SPI6 */
        /* SPI6 clock source configuration done later after clock selection check */
        break;

      case RCC_SPI6CLKSOURCE_PLL2Q:  /* PLL2_Q is used as clock source for SPI6 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_QCLK);
900047a0:	4b12      	ldr	r3, [pc, #72]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
900047a2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900047a4:	4a11      	ldr	r2, [pc, #68]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
900047a6:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
900047aa:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPI6 clock source configuration done later after clock selection check */
        break;
900047ac:	e010      	b.n	900047d0 <HAL_RCCEx_PeriphCLKConfig+0xc04>

      case RCC_SPI6CLKSOURCE_PLL3Q:  /* PLL3_Q is used as clock source for SPI6 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_QCLK);
900047ae:	4b0f      	ldr	r3, [pc, #60]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
900047b0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900047b2:	4a0e      	ldr	r2, [pc, #56]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
900047b4:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
900047b8:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPI6 clock source configuration done later after clock selection check */
        break;
900047ba:	e009      	b.n	900047d0 <HAL_RCCEx_PeriphCLKConfig+0xc04>
      case RCC_SPI6CLKSOURCE_HSE: /* HSE oscillator is used as source for SPI6 */
        /* SPI6 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
900047bc:	2301      	movs	r3, #1
900047be:	75fb      	strb	r3, [r7, #23]
        break;
900047c0:	e006      	b.n	900047d0 <HAL_RCCEx_PeriphCLKConfig+0xc04>
        break;
900047c2:	bf00      	nop
900047c4:	e004      	b.n	900047d0 <HAL_RCCEx_PeriphCLKConfig+0xc04>
        break;
900047c6:	bf00      	nop
900047c8:	e002      	b.n	900047d0 <HAL_RCCEx_PeriphCLKConfig+0xc04>
        break;
900047ca:	bf00      	nop
900047cc:	e000      	b.n	900047d0 <HAL_RCCEx_PeriphCLKConfig+0xc04>
        break;
900047ce:	bf00      	nop
    }

    if (ret == HAL_OK)
900047d0:	7dfb      	ldrb	r3, [r7, #23]
900047d2:	2b00      	cmp	r3, #0
900047d4:	d10c      	bne.n	900047f0 <HAL_RCCEx_PeriphCLKConfig+0xc24>
    {
      /* Set the source of SPI6 clock*/
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
900047d6:	4b05      	ldr	r3, [pc, #20]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
900047d8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
900047da:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
900047de:	687b      	ldr	r3, [r7, #4]
900047e0:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
900047e2:	4902      	ldr	r1, [pc, #8]	@ (900047ec <HAL_RCCEx_PeriphCLKConfig+0xc20>)
900047e4:	4313      	orrs	r3, r2
900047e6:	658b      	str	r3, [r1, #88]	@ 0x58
900047e8:	e004      	b.n	900047f4 <HAL_RCCEx_PeriphCLKConfig+0xc28>
900047ea:	bf00      	nop
900047ec:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
900047f0:	7dfb      	ldrb	r3, [r7, #23]
900047f2:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- USART1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
900047f4:	687b      	ldr	r3, [r7, #4]
900047f6:	681b      	ldr	r3, [r3, #0]
900047f8:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
900047fc:	2b00      	cmp	r3, #0
900047fe:	d034      	beq.n	9000486a <HAL_RCCEx_PeriphCLKConfig+0xc9e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    switch (PeriphClkInit->Usart1ClockSelection)
90004800:	687b      	ldr	r3, [r7, #4]
90004802:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
90004804:	2b05      	cmp	r3, #5
90004806:	d81d      	bhi.n	90004844 <HAL_RCCEx_PeriphCLKConfig+0xc78>
90004808:	a201      	add	r2, pc, #4	@ (adr r2, 90004810 <HAL_RCCEx_PeriphCLKConfig+0xc44>)
9000480a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
9000480e:	bf00      	nop
90004810:	9000484b 	.word	0x9000484b
90004814:	90004829 	.word	0x90004829
90004818:	90004837 	.word	0x90004837
9000481c:	9000484b 	.word	0x9000484b
90004820:	9000484b 	.word	0x9000484b
90004824:	9000484b 	.word	0x9000484b
      case RCC_USART1CLKSOURCE_PCLK2: /* PCLK2 as clock source for USART1 */
        /* USART1 clock source configuration done later after clock selection check */
        break;

      case RCC_USART1CLKSOURCE_PLL2Q: /* PLL2_Q is used as clock source for USART1 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_QCLK);
90004828:	4b69      	ldr	r3, [pc, #420]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
9000482a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000482c:	4a68      	ldr	r2, [pc, #416]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
9000482e:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
90004832:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* USART1 clock source configuration done later after clock selection check */
        break;
90004834:	e00a      	b.n	9000484c <HAL_RCCEx_PeriphCLKConfig+0xc80>

      case RCC_USART1CLKSOURCE_PLL3Q: /* PLL3_Q is used as clock source for USART1 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_QCLK);
90004836:	4b66      	ldr	r3, [pc, #408]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
90004838:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000483a:	4a65      	ldr	r2, [pc, #404]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
9000483c:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
90004840:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* USART1 clock source configuration done later after clock selection check */
        break;
90004842:	e003      	b.n	9000484c <HAL_RCCEx_PeriphCLKConfig+0xc80>
      case RCC_USART1CLKSOURCE_LSE: /* LSE oscillator is used as source for USART1 */
        /* USART1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
90004844:	2301      	movs	r3, #1
90004846:	75fb      	strb	r3, [r7, #23]
        break;
90004848:	e000      	b.n	9000484c <HAL_RCCEx_PeriphCLKConfig+0xc80>
        break;
9000484a:	bf00      	nop
    }

    if (ret == HAL_OK)
9000484c:	7dfb      	ldrb	r3, [r7, #23]
9000484e:	2b00      	cmp	r3, #0
90004850:	d109      	bne.n	90004866 <HAL_RCCEx_PeriphCLKConfig+0xc9a>
    {
      /* Set the source of USART1 clock */
      __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
90004852:	4b5f      	ldr	r3, [pc, #380]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
90004854:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
90004856:	f023 0207 	bic.w	r2, r3, #7
9000485a:	687b      	ldr	r3, [r7, #4]
9000485c:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
9000485e:	495c      	ldr	r1, [pc, #368]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
90004860:	4313      	orrs	r3, r2
90004862:	654b      	str	r3, [r1, #84]	@ 0x54
90004864:	e001      	b.n	9000486a <HAL_RCCEx_PeriphCLKConfig+0xc9e>
    }
    else
    {
      /* set overall return value */
      status = ret;
90004866:	7dfb      	ldrb	r3, [r7, #23]
90004868:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------- USART2/USART3/UART4/UART5/UART7/UART8 Configuration --------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
9000486a:	687b      	ldr	r3, [r7, #4]
9000486c:	681b      	ldr	r3, [r3, #0]
9000486e:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
90004872:	2b00      	cmp	r3, #0
90004874:	d033      	beq.n	900048de <HAL_RCCEx_PeriphCLKConfig+0xd12>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART234578CLKSOURCE(PeriphClkInit->Usart234578ClockSelection));

    switch (PeriphClkInit->Usart234578ClockSelection)
90004876:	687b      	ldr	r3, [r7, #4]
90004878:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
9000487a:	2b05      	cmp	r3, #5
9000487c:	d81c      	bhi.n	900048b8 <HAL_RCCEx_PeriphCLKConfig+0xcec>
9000487e:	a201      	add	r2, pc, #4	@ (adr r2, 90004884 <HAL_RCCEx_PeriphCLKConfig+0xcb8>)
90004880:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90004884:	900048bf 	.word	0x900048bf
90004888:	9000489d 	.word	0x9000489d
9000488c:	900048ab 	.word	0x900048ab
90004890:	900048bf 	.word	0x900048bf
90004894:	900048bf 	.word	0x900048bf
90004898:	900048bf 	.word	0x900048bf
      case RCC_USART234578CLKSOURCE_PCLK1: /* PCLK1 as clock source for USART2/USART3/UART4/UART5/UART7/UART8 */
        /* USART2/USART3/UART4/UART5/UART7/UART8 clock source configuration done later after clock selection check */
        break;

      case RCC_USART234578CLKSOURCE_PLL2Q: /* PLL2_Q is used as clock source for USART2/USART3/UART4/UART5/UART7/UART8 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_QCLK);
9000489c:	4b4c      	ldr	r3, [pc, #304]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
9000489e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900048a0:	4a4b      	ldr	r2, [pc, #300]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
900048a2:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
900048a6:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* USART2/USART3/UART4/UART5/UART7/UART8 clock source configuration done later after clock selection check */
        break;
900048a8:	e00a      	b.n	900048c0 <HAL_RCCEx_PeriphCLKConfig+0xcf4>

      case RCC_USART234578CLKSOURCE_PLL3Q: /* PLL3_Q is used as clock source for USART2/USART3/UART4/UART5/UART7/UART8 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_QCLK);
900048aa:	4b49      	ldr	r3, [pc, #292]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
900048ac:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900048ae:	4a48      	ldr	r2, [pc, #288]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
900048b0:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
900048b4:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* USART2/USART3/UART4/UART5/UART7/UART8 clock source configuration done later after clock selection check */
        break;
900048b6:	e003      	b.n	900048c0 <HAL_RCCEx_PeriphCLKConfig+0xcf4>
        /* LSE,  oscillator is used as source of USART2/USART3/UART4/UART5/UART7/UART8 clock */
        /* USART2/USART3/UART4/UART5/UART7/UART8 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
900048b8:	2301      	movs	r3, #1
900048ba:	75fb      	strb	r3, [r7, #23]
        break;
900048bc:	e000      	b.n	900048c0 <HAL_RCCEx_PeriphCLKConfig+0xcf4>
        break;
900048be:	bf00      	nop
    }

    if (ret == HAL_OK)
900048c0:	7dfb      	ldrb	r3, [r7, #23]
900048c2:	2b00      	cmp	r3, #0
900048c4:	d109      	bne.n	900048da <HAL_RCCEx_PeriphCLKConfig+0xd0e>
    {
      /* Set the source of USART2/USART3/UART4/UART5/UART7/UART8 clock */
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
900048c6:	4b42      	ldr	r3, [pc, #264]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
900048c8:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
900048ca:	f023 0207 	bic.w	r2, r3, #7
900048ce:	687b      	ldr	r3, [r7, #4]
900048d0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
900048d2:	493f      	ldr	r1, [pc, #252]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
900048d4:	4313      	orrs	r3, r2
900048d6:	650b      	str	r3, [r1, #80]	@ 0x50
900048d8:	e001      	b.n	900048de <HAL_RCCEx_PeriphCLKConfig+0xd12>
    }
    else
    {
      /* set overall return value */
      status = ret;
900048da:	7dfb      	ldrb	r3, [r7, #23]
900048dc:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------ USBPHYC Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHYC) == RCC_PERIPHCLK_USBPHYC)
900048de:	687b      	ldr	r3, [r7, #4]
900048e0:	681b      	ldr	r3, [r3, #0]
900048e2:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
900048e6:	2b00      	cmp	r3, #0
900048e8:	d027      	beq.n	9000493a <HAL_RCCEx_PeriphCLKConfig+0xd6e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHYCCLKSOURCE(PeriphClkInit->UsbPhycClockSelection));

    switch (PeriphClkInit->UsbPhycClockSelection)
900048ea:	687b      	ldr	r3, [r7, #4]
900048ec:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
900048ee:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
900048f2:	d008      	beq.n	90004906 <HAL_RCCEx_PeriphCLKConfig+0xd3a>
900048f4:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
900048f8:	d80c      	bhi.n	90004914 <HAL_RCCEx_PeriphCLKConfig+0xd48>
900048fa:	2b00      	cmp	r3, #0
900048fc:	d00d      	beq.n	9000491a <HAL_RCCEx_PeriphCLKConfig+0xd4e>
900048fe:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
90004902:	d00a      	beq.n	9000491a <HAL_RCCEx_PeriphCLKConfig+0xd4e>
90004904:	e006      	b.n	90004914 <HAL_RCCEx_PeriphCLKConfig+0xd48>
    {
      case RCC_USBPHYCCLKSOURCE_PLL3Q: /* PLL3_Q is used as clock source for USBPHYC */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_QCLK);
90004906:	4b32      	ldr	r3, [pc, #200]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
90004908:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000490a:	4a31      	ldr	r2, [pc, #196]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
9000490c:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
90004910:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* USBPHYC clock source configuration done later after clock selection check */
        break;
90004912:	e003      	b.n	9000491c <HAL_RCCEx_PeriphCLKConfig+0xd50>
      case RCC_USBPHYCCLKSOURCE_HSE_DIV2: /* HSE divided by 2 is used as clock source for USBPHYC */
        /* USBPHYC clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
90004914:	2301      	movs	r3, #1
90004916:	75fb      	strb	r3, [r7, #23]
        break;
90004918:	e000      	b.n	9000491c <HAL_RCCEx_PeriphCLKConfig+0xd50>
        break;
9000491a:	bf00      	nop
    }

    if (ret == HAL_OK)
9000491c:	7dfb      	ldrb	r3, [r7, #23]
9000491e:	2b00      	cmp	r3, #0
90004920:	d109      	bne.n	90004936 <HAL_RCCEx_PeriphCLKConfig+0xd6a>
    {
      /* Set the source of USBPHYC clock*/
      __HAL_RCC_USBPHYC_CONFIG(PeriphClkInit->UsbPhycClockSelection);
90004922:	4b2b      	ldr	r3, [pc, #172]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
90004924:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90004926:	f423 5240 	bic.w	r2, r3, #12288	@ 0x3000
9000492a:	687b      	ldr	r3, [r7, #4]
9000492c:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
9000492e:	4928      	ldr	r1, [pc, #160]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
90004930:	4313      	orrs	r3, r2
90004932:	64cb      	str	r3, [r1, #76]	@ 0x4c
90004934:	e001      	b.n	9000493a <HAL_RCCEx_PeriphCLKConfig+0xd6e>
    }
    else
    {
      /* set overall return value */
      status = ret;
90004936:	7dfb      	ldrb	r3, [r7, #23]
90004938:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------ USBOTGFS Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGFS) == RCC_PERIPHCLK_USBOTGFS)
9000493a:	687b      	ldr	r3, [r7, #4]
9000493c:	681b      	ldr	r3, [r3, #0]
9000493e:	2b00      	cmp	r3, #0
90004940:	da2c      	bge.n	9000499c <HAL_RCCEx_PeriphCLKConfig+0xdd0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGFSCLKSOURCE(PeriphClkInit->UsbOtgFsClockSelection));

    switch (PeriphClkInit->UsbOtgFsClockSelection)
90004942:	687b      	ldr	r3, [r7, #4]
90004944:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
90004946:	f5b3 4f40 	cmp.w	r3, #49152	@ 0xc000
9000494a:	d017      	beq.n	9000497c <HAL_RCCEx_PeriphCLKConfig+0xdb0>
9000494c:	f5b3 4f40 	cmp.w	r3, #49152	@ 0xc000
90004950:	d811      	bhi.n	90004976 <HAL_RCCEx_PeriphCLKConfig+0xdaa>
90004952:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
90004956:	d011      	beq.n	9000497c <HAL_RCCEx_PeriphCLKConfig+0xdb0>
90004958:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
9000495c:	d80b      	bhi.n	90004976 <HAL_RCCEx_PeriphCLKConfig+0xdaa>
9000495e:	2b00      	cmp	r3, #0
90004960:	d00c      	beq.n	9000497c <HAL_RCCEx_PeriphCLKConfig+0xdb0>
90004962:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
90004966:	d106      	bne.n	90004976 <HAL_RCCEx_PeriphCLKConfig+0xdaa>
    {
      case RCC_USBOTGFSCLKSOURCE_PLL3Q: /* PLL3_Q is used as clock source for USB OTG FS */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_QCLK);
90004968:	4b19      	ldr	r3, [pc, #100]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
9000496a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000496c:	4a18      	ldr	r2, [pc, #96]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
9000496e:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
90004972:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* USB OTG FS clock source configuration done later after clock selection check */
        break;
90004974:	e003      	b.n	9000497e <HAL_RCCEx_PeriphCLKConfig+0xdb2>
      case RCC_USBOTGFSCLKSOURCE_CLK48: /* USBPHYC CLK48 is used as clock source for USB OTG FS */
        /* USB OTG FS clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
90004976:	2301      	movs	r3, #1
90004978:	75fb      	strb	r3, [r7, #23]
        break;
9000497a:	e000      	b.n	9000497e <HAL_RCCEx_PeriphCLKConfig+0xdb2>
        break;
9000497c:	bf00      	nop
    }

    if (ret == HAL_OK)
9000497e:	7dfb      	ldrb	r3, [r7, #23]
90004980:	2b00      	cmp	r3, #0
90004982:	d109      	bne.n	90004998 <HAL_RCCEx_PeriphCLKConfig+0xdcc>
    {
      /* Set the source of USBPHYC clock*/
      __HAL_RCC_USBOTGFS_CONFIG(PeriphClkInit->UsbOtgFsClockSelection);
90004984:	4b12      	ldr	r3, [pc, #72]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
90004986:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90004988:	f423 4240 	bic.w	r2, r3, #49152	@ 0xc000
9000498c:	687b      	ldr	r3, [r7, #4]
9000498e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
90004990:	490f      	ldr	r1, [pc, #60]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
90004992:	4313      	orrs	r3, r2
90004994:	64cb      	str	r3, [r1, #76]	@ 0x4c
90004996:	e001      	b.n	9000499c <HAL_RCCEx_PeriphCLKConfig+0xdd0>
    }
    else
    {
      /* set overall return value */
      status = ret;
90004998:	7dfb      	ldrb	r3, [r7, #23]
9000499a:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
9000499c:	687b      	ldr	r3, [r7, #4]
9000499e:	681b      	ldr	r3, [r3, #0]
900049a0:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
900049a4:	2b00      	cmp	r3, #0
900049a6:	d009      	beq.n	900049bc <HAL_RCCEx_PeriphCLKConfig+0xdf0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER_CONFIG(PeriphClkInit->TIMPresSelection);
900049a8:	4b09      	ldr	r3, [pc, #36]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
900049aa:	691b      	ldr	r3, [r3, #16]
900049ac:	f423 4200 	bic.w	r2, r3, #32768	@ 0x8000
900049b0:	687b      	ldr	r3, [r7, #4]
900049b2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
900049b6:	4906      	ldr	r1, [pc, #24]	@ (900049d0 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
900049b8:	4313      	orrs	r3, r2
900049ba:	610b      	str	r3, [r1, #16]
  }

  if (status == HAL_OK)
900049bc:	7dbb      	ldrb	r3, [r7, #22]
900049be:	2b00      	cmp	r3, #0
900049c0:	d101      	bne.n	900049c6 <HAL_RCCEx_PeriphCLKConfig+0xdfa>
  {
    return HAL_OK;
900049c2:	2300      	movs	r3, #0
900049c4:	e000      	b.n	900049c8 <HAL_RCCEx_PeriphCLKConfig+0xdfc>
  }
  return HAL_ERROR;
900049c6:	2301      	movs	r3, #1
}
900049c8:	4618      	mov	r0, r3
900049ca:	3718      	adds	r7, #24
900049cc:	46bd      	mov	sp, r7
900049ce:	bd80      	pop	{r7, pc}
900049d0:	58024400 	.word	0x58024400

900049d4 <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg RCC_PERIPHCLK_USART234578 : USART2/3/5/7/8 peripheral clock
  *            @arg RCC_PERIPHCLK_USBOTGFS    : USBOTGFS peripheral clock
  * @retval Frequency in KHz
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
900049d4:	b580      	push	{r7, lr}
900049d6:	b086      	sub	sp, #24
900049d8:	af00      	add	r7, sp, #0
900049da:	6078      	str	r0, [r7, #4]
  uint32_t frequency = 0; /* Set to 0 for returned value if no source clock */
900049dc:	2300      	movs	r3, #0
900049de:	617b      	str	r3, [r7, #20]
  uint32_t clocksource;
  uint32_t ethclocksource;
  uint32_t prescaler;

  switch (PeriphClk)
900049e0:	687b      	ldr	r3, [r7, #4]
900049e2:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
900049e6:	f001 82db 	beq.w	90005fa0 <HAL_RCCEx_GetPeriphCLKFreq+0x15cc>
900049ea:	687b      	ldr	r3, [r7, #4]
900049ec:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
900049f0:	f201 8326 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
900049f4:	687b      	ldr	r3, [r7, #4]
900049f6:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
900049fa:	f001 8298 	beq.w	90005f2e <HAL_RCCEx_GetPeriphCLKFreq+0x155a>
900049fe:	687b      	ldr	r3, [r7, #4]
90004a00:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
90004a04:	f201 831c 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004a08:	687b      	ldr	r3, [r7, #4]
90004a0a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
90004a0e:	f001 822a 	beq.w	90005e66 <HAL_RCCEx_GetPeriphCLKFreq+0x1492>
90004a12:	687b      	ldr	r3, [r7, #4]
90004a14:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
90004a18:	f201 8312 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004a1c:	687b      	ldr	r3, [r7, #4]
90004a1e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
90004a22:	f001 81bb 	beq.w	90005d9c <HAL_RCCEx_GetPeriphCLKFreq+0x13c8>
90004a26:	687b      	ldr	r3, [r7, #4]
90004a28:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
90004a2c:	f201 8308 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004a30:	687b      	ldr	r3, [r7, #4]
90004a32:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
90004a36:	f001 8139 	beq.w	90005cac <HAL_RCCEx_GetPeriphCLKFreq+0x12d8>
90004a3a:	687b      	ldr	r3, [r7, #4]
90004a3c:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
90004a40:	f201 82fe 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004a44:	687b      	ldr	r3, [r7, #4]
90004a46:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
90004a4a:	f001 80bf 	beq.w	90005bcc <HAL_RCCEx_GetPeriphCLKFreq+0x11f8>
90004a4e:	687b      	ldr	r3, [r7, #4]
90004a50:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
90004a54:	f201 82f4 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004a58:	687b      	ldr	r3, [r7, #4]
90004a5a:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
90004a5e:	f001 8069 	beq.w	90005b34 <HAL_RCCEx_GetPeriphCLKFreq+0x1160>
90004a62:	687b      	ldr	r3, [r7, #4]
90004a64:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
90004a68:	f201 82ea 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004a6c:	687b      	ldr	r3, [r7, #4]
90004a6e:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
90004a72:	f001 8007 	beq.w	90005a84 <HAL_RCCEx_GetPeriphCLKFreq+0x10b0>
90004a76:	687b      	ldr	r3, [r7, #4]
90004a78:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
90004a7c:	f201 82e0 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004a80:	687b      	ldr	r3, [r7, #4]
90004a82:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
90004a86:	f000 87a2 	beq.w	900059ce <HAL_RCCEx_GetPeriphCLKFreq+0xffa>
90004a8a:	687b      	ldr	r3, [r7, #4]
90004a8c:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
90004a90:	f201 82d6 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004a94:	687b      	ldr	r3, [r7, #4]
90004a96:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
90004a9a:	f000 877a 	beq.w	90005992 <HAL_RCCEx_GetPeriphCLKFreq+0xfbe>
90004a9e:	687b      	ldr	r3, [r7, #4]
90004aa0:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
90004aa4:	f201 82cc 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004aa8:	687b      	ldr	r3, [r7, #4]
90004aaa:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
90004aae:	f000 8713 	beq.w	900058d8 <HAL_RCCEx_GetPeriphCLKFreq+0xf04>
90004ab2:	687b      	ldr	r3, [r7, #4]
90004ab4:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
90004ab8:	f201 82c2 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004abc:	687b      	ldr	r3, [r7, #4]
90004abe:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
90004ac2:	f000 86ad 	beq.w	90005820 <HAL_RCCEx_GetPeriphCLKFreq+0xe4c>
90004ac6:	687b      	ldr	r3, [r7, #4]
90004ac8:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
90004acc:	f201 82b8 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004ad0:	687b      	ldr	r3, [r7, #4]
90004ad2:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
90004ad6:	f000 8644 	beq.w	90005762 <HAL_RCCEx_GetPeriphCLKFreq+0xd8e>
90004ada:	687b      	ldr	r3, [r7, #4]
90004adc:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
90004ae0:	f201 82ae 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004ae4:	687b      	ldr	r3, [r7, #4]
90004ae6:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
90004aea:	f000 861c 	beq.w	90005726 <HAL_RCCEx_GetPeriphCLKFreq+0xd52>
90004aee:	687b      	ldr	r3, [r7, #4]
90004af0:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
90004af4:	f201 82a4 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004af8:	687b      	ldr	r3, [r7, #4]
90004afa:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
90004afe:	f000 8606 	beq.w	9000570e <HAL_RCCEx_GetPeriphCLKFreq+0xd3a>
90004b02:	687b      	ldr	r3, [r7, #4]
90004b04:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
90004b08:	f201 829a 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004b0c:	687b      	ldr	r3, [r7, #4]
90004b0e:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
90004b12:	f000 8592 	beq.w	9000563a <HAL_RCCEx_GetPeriphCLKFreq+0xc66>
90004b16:	687b      	ldr	r3, [r7, #4]
90004b18:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
90004b1c:	f201 8290 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004b20:	687b      	ldr	r3, [r7, #4]
90004b22:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
90004b26:	f000 8519 	beq.w	9000555c <HAL_RCCEx_GetPeriphCLKFreq+0xb88>
90004b2a:	687b      	ldr	r3, [r7, #4]
90004b2c:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
90004b30:	f201 8286 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004b34:	687b      	ldr	r3, [r7, #4]
90004b36:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
90004b3a:	f000 84a3 	beq.w	90005484 <HAL_RCCEx_GetPeriphCLKFreq+0xab0>
90004b3e:	687b      	ldr	r3, [r7, #4]
90004b40:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
90004b44:	f201 827c 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004b48:	687b      	ldr	r3, [r7, #4]
90004b4a:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
90004b4e:	f000 842d 	beq.w	900053ac <HAL_RCCEx_GetPeriphCLKFreq+0x9d8>
90004b52:	687b      	ldr	r3, [r7, #4]
90004b54:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
90004b58:	f201 8272 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004b5c:	687b      	ldr	r3, [r7, #4]
90004b5e:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
90004b62:	f000 83c5 	beq.w	900052f0 <HAL_RCCEx_GetPeriphCLKFreq+0x91c>
90004b66:	687b      	ldr	r3, [r7, #4]
90004b68:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
90004b6c:	f201 8268 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004b70:	687b      	ldr	r3, [r7, #4]
90004b72:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
90004b76:	f000 8365 	beq.w	90005244 <HAL_RCCEx_GetPeriphCLKFreq+0x870>
90004b7a:	687b      	ldr	r3, [r7, #4]
90004b7c:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
90004b80:	f201 825e 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004b84:	687b      	ldr	r3, [r7, #4]
90004b86:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
90004b8a:	f000 831d 	beq.w	900051c8 <HAL_RCCEx_GetPeriphCLKFreq+0x7f4>
90004b8e:	687b      	ldr	r3, [r7, #4]
90004b90:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
90004b94:	f201 8254 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004b98:	687b      	ldr	r3, [r7, #4]
90004b9a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
90004b9e:	f000 82ed 	beq.w	9000517c <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>
90004ba2:	687b      	ldr	r3, [r7, #4]
90004ba4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
90004ba8:	f201 824a 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004bac:	687b      	ldr	r3, [r7, #4]
90004bae:	2b80      	cmp	r3, #128	@ 0x80
90004bb0:	f000 8291 	beq.w	900050d6 <HAL_RCCEx_GetPeriphCLKFreq+0x702>
90004bb4:	687b      	ldr	r3, [r7, #4]
90004bb6:	2b80      	cmp	r3, #128	@ 0x80
90004bb8:	f201 8242 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004bbc:	687b      	ldr	r3, [r7, #4]
90004bbe:	2b20      	cmp	r3, #32
90004bc0:	d84c      	bhi.n	90004c5c <HAL_RCCEx_GetPeriphCLKFreq+0x288>
90004bc2:	687b      	ldr	r3, [r7, #4]
90004bc4:	2b00      	cmp	r3, #0
90004bc6:	f001 823b 	beq.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004bca:	687b      	ldr	r3, [r7, #4]
90004bcc:	3b01      	subs	r3, #1
90004bce:	2b1f      	cmp	r3, #31
90004bd0:	f201 8236 	bhi.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
90004bd4:	a201      	add	r2, pc, #4	@ (adr r2, 90004bdc <HAL_RCCEx_GetPeriphCLKFreq+0x208>)
90004bd6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90004bda:	bf00      	nop
90004bdc:	90004c69 	.word	0x90004c69
90004be0:	90004d37 	.word	0x90004d37
90004be4:	90006041 	.word	0x90006041
90004be8:	90004dc7 	.word	0x90004dc7
90004bec:	90006041 	.word	0x90006041
90004bf0:	90006041 	.word	0x90006041
90004bf4:	90006041 	.word	0x90006041
90004bf8:	90004e5f 	.word	0x90004e5f
90004bfc:	90006041 	.word	0x90006041
90004c00:	90006041 	.word	0x90006041
90004c04:	90006041 	.word	0x90006041
90004c08:	90006041 	.word	0x90006041
90004c0c:	90006041 	.word	0x90006041
90004c10:	90006041 	.word	0x90006041
90004c14:	90006041 	.word	0x90006041
90004c18:	90004f01 	.word	0x90004f01
90004c1c:	90006041 	.word	0x90006041
90004c20:	90006041 	.word	0x90006041
90004c24:	90006041 	.word	0x90006041
90004c28:	90006041 	.word	0x90006041
90004c2c:	90006041 	.word	0x90006041
90004c30:	90006041 	.word	0x90006041
90004c34:	90006041 	.word	0x90006041
90004c38:	90006041 	.word	0x90006041
90004c3c:	90006041 	.word	0x90006041
90004c40:	90006041 	.word	0x90006041
90004c44:	90006041 	.word	0x90006041
90004c48:	90006041 	.word	0x90006041
90004c4c:	90006041 	.word	0x90006041
90004c50:	90006041 	.word	0x90006041
90004c54:	90006041 	.word	0x90006041
90004c58:	90004f6d 	.word	0x90004f6d
90004c5c:	687b      	ldr	r3, [r7, #4]
90004c5e:	2b40      	cmp	r3, #64	@ 0x40
90004c60:	f000 81fb 	beq.w	9000505a <HAL_RCCEx_GetPeriphCLKFreq+0x686>
      }
      break;

    default:
      /* Nothing to do, frequency is by default set to 0 */
      break;
90004c64:	f001 b9ec 	b.w	90006040 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
      clocksource = __HAL_RCC_GET_FMC_SOURCE();
90004c68:	4ba1      	ldr	r3, [pc, #644]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004c6a:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
90004c6e:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
90004c72:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
90004c76:	d004      	beq.n	90004c82 <HAL_RCCEx_GetPeriphCLKFreq+0x2ae>
90004c78:	4b9d      	ldr	r3, [pc, #628]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004c7a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90004c7c:	f003 0303 	and.w	r3, r3, #3
90004c80:	e001      	b.n	90004c86 <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
90004c82:	f44f 43a0 	mov.w	r3, #20480	@ 0x5000
90004c86:	613b      	str	r3, [r7, #16]
      switch (clocksource)
90004c88:	693b      	ldr	r3, [r7, #16]
90004c8a:	2b03      	cmp	r3, #3
90004c8c:	d80e      	bhi.n	90004cac <HAL_RCCEx_GetPeriphCLKFreq+0x2d8>
90004c8e:	693b      	ldr	r3, [r7, #16]
90004c90:	2b03      	cmp	r3, #3
90004c92:	d844      	bhi.n	90004d1e <HAL_RCCEx_GetPeriphCLKFreq+0x34a>
90004c94:	a201      	add	r2, pc, #4	@ (adr r2, 90004c9c <HAL_RCCEx_GetPeriphCLKFreq+0x2c8>)
90004c96:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90004c9a:	bf00      	nop
90004c9c:	90004cb7 	.word	0x90004cb7
90004ca0:	90004cbf 	.word	0x90004cbf
90004ca4:	90004cd3 	.word	0x90004cd3
90004ca8:	90004ce7 	.word	0x90004ce7
90004cac:	693b      	ldr	r3, [r7, #16]
90004cae:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
90004cb2:	d02e      	beq.n	90004d12 <HAL_RCCEx_GetPeriphCLKFreq+0x33e>
          break;
90004cb4:	e033      	b.n	90004d1e <HAL_RCCEx_GetPeriphCLKFreq+0x34a>
          frequency = HAL_RCC_GetHCLKFreq();
90004cb6:	f7fe fc9d 	bl	900035f4 <HAL_RCC_GetHCLKFreq>
90004cba:	6178      	str	r0, [r7, #20]
          break;
90004cbc:	e039      	b.n	90004d32 <HAL_RCCEx_GetPeriphCLKFreq+0x35e>
          if (__HAL_RCC_GET_PLL1CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
90004cbe:	4b8c      	ldr	r3, [pc, #560]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004cc0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004cc2:	f003 0340 	and.w	r3, r3, #64	@ 0x40
90004cc6:	2b00      	cmp	r3, #0
90004cc8:	d02c      	beq.n	90004d24 <HAL_RCCEx_GetPeriphCLKFreq+0x350>
            frequency = HAL_RCC_GetPLL1QFreq();
90004cca:	f7fe fd0f 	bl	900036ec <HAL_RCC_GetPLL1QFreq>
90004cce:	6178      	str	r0, [r7, #20]
          break;
90004cd0:	e028      	b.n	90004d24 <HAL_RCCEx_GetPeriphCLKFreq+0x350>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
90004cd2:	4b87      	ldr	r3, [pc, #540]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004cd4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004cd6:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
90004cda:	2b00      	cmp	r3, #0
90004cdc:	d025      	beq.n	90004d2a <HAL_RCCEx_GetPeriphCLKFreq+0x356>
            frequency = HAL_RCC_GetPLL2RFreq();
90004cde:	f7fe fd47 	bl	90003770 <HAL_RCC_GetPLL2RFreq>
90004ce2:	6178      	str	r0, [r7, #20]
          break;
90004ce4:	e021      	b.n	90004d2a <HAL_RCCEx_GetPeriphCLKFreq+0x356>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
90004ce6:	4b82      	ldr	r3, [pc, #520]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004ce8:	681b      	ldr	r3, [r3, #0]
90004cea:	f003 0304 	and.w	r3, r3, #4
90004cee:	2b00      	cmp	r3, #0
90004cf0:	d01e      	beq.n	90004d30 <HAL_RCCEx_GetPeriphCLKFreq+0x35c>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
90004cf2:	4b7f      	ldr	r3, [pc, #508]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004cf4:	681b      	ldr	r3, [r3, #0]
90004cf6:	f003 0320 	and.w	r3, r3, #32
90004cfa:	2b00      	cmp	r3, #0
90004cfc:	d018      	beq.n	90004d30 <HAL_RCCEx_GetPeriphCLKFreq+0x35c>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
90004cfe:	4b7c      	ldr	r3, [pc, #496]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004d00:	681b      	ldr	r3, [r3, #0]
90004d02:	08db      	lsrs	r3, r3, #3
90004d04:	f003 0303 	and.w	r3, r3, #3
90004d08:	4a7a      	ldr	r2, [pc, #488]	@ (90004ef4 <HAL_RCCEx_GetPeriphCLKFreq+0x520>)
90004d0a:	fa22 f303 	lsr.w	r3, r2, r3
90004d0e:	617b      	str	r3, [r7, #20]
          break;
90004d10:	e00e      	b.n	90004d30 <HAL_RCCEx_GetPeriphCLKFreq+0x35c>
          frequency = (HAL_RCC_GetHCLKFreq() / 4U);
90004d12:	f7fe fc6f 	bl	900035f4 <HAL_RCC_GetHCLKFreq>
90004d16:	4603      	mov	r3, r0
90004d18:	089b      	lsrs	r3, r3, #2
90004d1a:	617b      	str	r3, [r7, #20]
          break;
90004d1c:	e009      	b.n	90004d32 <HAL_RCCEx_GetPeriphCLKFreq+0x35e>
          break;
90004d1e:	bf00      	nop
90004d20:	f001 b993 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90004d24:	bf00      	nop
90004d26:	f001 b990 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90004d2a:	bf00      	nop
90004d2c:	f001 b98d 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90004d30:	bf00      	nop
      break;
90004d32:	f001 b98a 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_XSPI1_SOURCE();
90004d36:	4b6e      	ldr	r3, [pc, #440]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004d38:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
90004d3c:	f003 0370 	and.w	r3, r3, #112	@ 0x70
90004d40:	2b40      	cmp	r3, #64	@ 0x40
90004d42:	d004      	beq.n	90004d4e <HAL_RCCEx_GetPeriphCLKFreq+0x37a>
90004d44:	4b6a      	ldr	r3, [pc, #424]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004d46:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90004d48:	f003 0330 	and.w	r3, r3, #48	@ 0x30
90004d4c:	e000      	b.n	90004d50 <HAL_RCCEx_GetPeriphCLKFreq+0x37c>
90004d4e:	2340      	movs	r3, #64	@ 0x40
90004d50:	613b      	str	r3, [r7, #16]
      switch (clocksource)
90004d52:	693b      	ldr	r3, [r7, #16]
90004d54:	2b40      	cmp	r3, #64	@ 0x40
90004d56:	d027      	beq.n	90004da8 <HAL_RCCEx_GetPeriphCLKFreq+0x3d4>
90004d58:	693b      	ldr	r3, [r7, #16]
90004d5a:	2b40      	cmp	r3, #64	@ 0x40
90004d5c:	d82a      	bhi.n	90004db4 <HAL_RCCEx_GetPeriphCLKFreq+0x3e0>
90004d5e:	693b      	ldr	r3, [r7, #16]
90004d60:	2b20      	cmp	r3, #32
90004d62:	d017      	beq.n	90004d94 <HAL_RCCEx_GetPeriphCLKFreq+0x3c0>
90004d64:	693b      	ldr	r3, [r7, #16]
90004d66:	2b20      	cmp	r3, #32
90004d68:	d824      	bhi.n	90004db4 <HAL_RCCEx_GetPeriphCLKFreq+0x3e0>
90004d6a:	693b      	ldr	r3, [r7, #16]
90004d6c:	2b00      	cmp	r3, #0
90004d6e:	d003      	beq.n	90004d78 <HAL_RCCEx_GetPeriphCLKFreq+0x3a4>
90004d70:	693b      	ldr	r3, [r7, #16]
90004d72:	2b10      	cmp	r3, #16
90004d74:	d004      	beq.n	90004d80 <HAL_RCCEx_GetPeriphCLKFreq+0x3ac>
          break;
90004d76:	e01d      	b.n	90004db4 <HAL_RCCEx_GetPeriphCLKFreq+0x3e0>
          frequency = HAL_RCC_GetHCLKFreq();
90004d78:	f7fe fc3c 	bl	900035f4 <HAL_RCC_GetHCLKFreq>
90004d7c:	6178      	str	r0, [r7, #20]
          break;
90004d7e:	e020      	b.n	90004dc2 <HAL_RCCEx_GetPeriphCLKFreq+0x3ee>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_SCLK) != 0U)
90004d80:	4b5b      	ldr	r3, [pc, #364]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004d82:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004d84:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
90004d88:	2b00      	cmp	r3, #0
90004d8a:	d016      	beq.n	90004dba <HAL_RCCEx_GetPeriphCLKFreq+0x3e6>
            frequency = HAL_RCC_GetPLL2SFreq();
90004d8c:	f7fe fd06 	bl	9000379c <HAL_RCC_GetPLL2SFreq>
90004d90:	6178      	str	r0, [r7, #20]
          break;
90004d92:	e012      	b.n	90004dba <HAL_RCCEx_GetPeriphCLKFreq+0x3e6>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_TCLK) != 0U)
90004d94:	4b56      	ldr	r3, [pc, #344]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004d96:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004d98:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
90004d9c:	2b00      	cmp	r3, #0
90004d9e:	d00f      	beq.n	90004dc0 <HAL_RCCEx_GetPeriphCLKFreq+0x3ec>
            frequency = HAL_RCC_GetPLL2TFreq();
90004da0:	f7fe fd12 	bl	900037c8 <HAL_RCC_GetPLL2TFreq>
90004da4:	6178      	str	r0, [r7, #20]
          break;
90004da6:	e00b      	b.n	90004dc0 <HAL_RCCEx_GetPeriphCLKFreq+0x3ec>
          frequency = (HAL_RCC_GetHCLKFreq() / 4U);
90004da8:	f7fe fc24 	bl	900035f4 <HAL_RCC_GetHCLKFreq>
90004dac:	4603      	mov	r3, r0
90004dae:	089b      	lsrs	r3, r3, #2
90004db0:	617b      	str	r3, [r7, #20]
          break;
90004db2:	e006      	b.n	90004dc2 <HAL_RCCEx_GetPeriphCLKFreq+0x3ee>
          break;
90004db4:	bf00      	nop
90004db6:	f001 b948 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90004dba:	bf00      	nop
90004dbc:	f001 b945 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90004dc0:	bf00      	nop
      break;
90004dc2:	f001 b942 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_XSPI2_SOURCE();
90004dc6:	4b4a      	ldr	r3, [pc, #296]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004dc8:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
90004dcc:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
90004dd0:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
90004dd4:	d004      	beq.n	90004de0 <HAL_RCCEx_GetPeriphCLKFreq+0x40c>
90004dd6:	4b46      	ldr	r3, [pc, #280]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004dd8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90004dda:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
90004dde:	e001      	b.n	90004de4 <HAL_RCCEx_GetPeriphCLKFreq+0x410>
90004de0:	f44f 6380 	mov.w	r3, #1024	@ 0x400
90004de4:	613b      	str	r3, [r7, #16]
      switch (clocksource)
90004de6:	693b      	ldr	r3, [r7, #16]
90004de8:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
90004dec:	d028      	beq.n	90004e40 <HAL_RCCEx_GetPeriphCLKFreq+0x46c>
90004dee:	693b      	ldr	r3, [r7, #16]
90004df0:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
90004df4:	d82a      	bhi.n	90004e4c <HAL_RCCEx_GetPeriphCLKFreq+0x478>
90004df6:	693b      	ldr	r3, [r7, #16]
90004df8:	2b80      	cmp	r3, #128	@ 0x80
90004dfa:	d017      	beq.n	90004e2c <HAL_RCCEx_GetPeriphCLKFreq+0x458>
90004dfc:	693b      	ldr	r3, [r7, #16]
90004dfe:	2b80      	cmp	r3, #128	@ 0x80
90004e00:	d824      	bhi.n	90004e4c <HAL_RCCEx_GetPeriphCLKFreq+0x478>
90004e02:	693b      	ldr	r3, [r7, #16]
90004e04:	2b00      	cmp	r3, #0
90004e06:	d003      	beq.n	90004e10 <HAL_RCCEx_GetPeriphCLKFreq+0x43c>
90004e08:	693b      	ldr	r3, [r7, #16]
90004e0a:	2b40      	cmp	r3, #64	@ 0x40
90004e0c:	d004      	beq.n	90004e18 <HAL_RCCEx_GetPeriphCLKFreq+0x444>
          break;
90004e0e:	e01d      	b.n	90004e4c <HAL_RCCEx_GetPeriphCLKFreq+0x478>
          frequency = HAL_RCC_GetHCLKFreq();
90004e10:	f7fe fbf0 	bl	900035f4 <HAL_RCC_GetHCLKFreq>
90004e14:	6178      	str	r0, [r7, #20]
          break;
90004e16:	e020      	b.n	90004e5a <HAL_RCCEx_GetPeriphCLKFreq+0x486>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_SCLK) != 0U)
90004e18:	4b35      	ldr	r3, [pc, #212]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004e1a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004e1c:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
90004e20:	2b00      	cmp	r3, #0
90004e22:	d016      	beq.n	90004e52 <HAL_RCCEx_GetPeriphCLKFreq+0x47e>
            frequency = HAL_RCC_GetPLL2SFreq();
90004e24:	f7fe fcba 	bl	9000379c <HAL_RCC_GetPLL2SFreq>
90004e28:	6178      	str	r0, [r7, #20]
          break;
90004e2a:	e012      	b.n	90004e52 <HAL_RCCEx_GetPeriphCLKFreq+0x47e>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_TCLK) != 0U)
90004e2c:	4b30      	ldr	r3, [pc, #192]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004e2e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004e30:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
90004e34:	2b00      	cmp	r3, #0
90004e36:	d00f      	beq.n	90004e58 <HAL_RCCEx_GetPeriphCLKFreq+0x484>
            frequency = HAL_RCC_GetPLL2TFreq();
90004e38:	f7fe fcc6 	bl	900037c8 <HAL_RCC_GetPLL2TFreq>
90004e3c:	6178      	str	r0, [r7, #20]
          break;
90004e3e:	e00b      	b.n	90004e58 <HAL_RCCEx_GetPeriphCLKFreq+0x484>
          frequency = (HAL_RCC_GetHCLKFreq() / 4U);
90004e40:	f7fe fbd8 	bl	900035f4 <HAL_RCC_GetHCLKFreq>
90004e44:	4603      	mov	r3, r0
90004e46:	089b      	lsrs	r3, r3, #2
90004e48:	617b      	str	r3, [r7, #20]
          break;
90004e4a:	e006      	b.n	90004e5a <HAL_RCCEx_GetPeriphCLKFreq+0x486>
          break;
90004e4c:	bf00      	nop
90004e4e:	f001 b8fc 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90004e52:	bf00      	nop
90004e54:	f001 b8f9 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90004e58:	bf00      	nop
      break;
90004e5a:	f001 b8f6 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_CLKP_SOURCE();
90004e5e:	4b24      	ldr	r3, [pc, #144]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004e60:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90004e62:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
90004e66:	613b      	str	r3, [r7, #16]
      switch (clocksource)
90004e68:	693b      	ldr	r3, [r7, #16]
90004e6a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
90004e6e:	d02a      	beq.n	90004ec6 <HAL_RCCEx_GetPeriphCLKFreq+0x4f2>
90004e70:	693b      	ldr	r3, [r7, #16]
90004e72:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
90004e76:	d82f      	bhi.n	90004ed8 <HAL_RCCEx_GetPeriphCLKFreq+0x504>
90004e78:	693b      	ldr	r3, [r7, #16]
90004e7a:	2b00      	cmp	r3, #0
90004e7c:	d004      	beq.n	90004e88 <HAL_RCCEx_GetPeriphCLKFreq+0x4b4>
90004e7e:	693b      	ldr	r3, [r7, #16]
90004e80:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
90004e84:	d016      	beq.n	90004eb4 <HAL_RCCEx_GetPeriphCLKFreq+0x4e0>
          break;
90004e86:	e027      	b.n	90004ed8 <HAL_RCCEx_GetPeriphCLKFreq+0x504>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
90004e88:	4b19      	ldr	r3, [pc, #100]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004e8a:	681b      	ldr	r3, [r3, #0]
90004e8c:	f003 0304 	and.w	r3, r3, #4
90004e90:	2b00      	cmp	r3, #0
90004e92:	d024      	beq.n	90004ede <HAL_RCCEx_GetPeriphCLKFreq+0x50a>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
90004e94:	4b16      	ldr	r3, [pc, #88]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004e96:	681b      	ldr	r3, [r3, #0]
90004e98:	f003 0320 	and.w	r3, r3, #32
90004e9c:	2b00      	cmp	r3, #0
90004e9e:	d01e      	beq.n	90004ede <HAL_RCCEx_GetPeriphCLKFreq+0x50a>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
90004ea0:	4b13      	ldr	r3, [pc, #76]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004ea2:	681b      	ldr	r3, [r3, #0]
90004ea4:	08db      	lsrs	r3, r3, #3
90004ea6:	f003 0303 	and.w	r3, r3, #3
90004eaa:	4a12      	ldr	r2, [pc, #72]	@ (90004ef4 <HAL_RCCEx_GetPeriphCLKFreq+0x520>)
90004eac:	fa22 f303 	lsr.w	r3, r2, r3
90004eb0:	617b      	str	r3, [r7, #20]
          break;
90004eb2:	e014      	b.n	90004ede <HAL_RCCEx_GetPeriphCLKFreq+0x50a>
          if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
90004eb4:	4b0e      	ldr	r3, [pc, #56]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004eb6:	681b      	ldr	r3, [r3, #0]
90004eb8:	f403 7380 	and.w	r3, r3, #256	@ 0x100
90004ebc:	2b00      	cmp	r3, #0
90004ebe:	d011      	beq.n	90004ee4 <HAL_RCCEx_GetPeriphCLKFreq+0x510>
            frequency = CSI_VALUE;
90004ec0:	4b0d      	ldr	r3, [pc, #52]	@ (90004ef8 <HAL_RCCEx_GetPeriphCLKFreq+0x524>)
90004ec2:	617b      	str	r3, [r7, #20]
          break;
90004ec4:	e00e      	b.n	90004ee4 <HAL_RCCEx_GetPeriphCLKFreq+0x510>
          if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
90004ec6:	4b0a      	ldr	r3, [pc, #40]	@ (90004ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
90004ec8:	681b      	ldr	r3, [r3, #0]
90004eca:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
90004ece:	2b00      	cmp	r3, #0
90004ed0:	d00b      	beq.n	90004eea <HAL_RCCEx_GetPeriphCLKFreq+0x516>
            frequency = HSE_VALUE;
90004ed2:	4b0a      	ldr	r3, [pc, #40]	@ (90004efc <HAL_RCCEx_GetPeriphCLKFreq+0x528>)
90004ed4:	617b      	str	r3, [r7, #20]
          break;
90004ed6:	e008      	b.n	90004eea <HAL_RCCEx_GetPeriphCLKFreq+0x516>
          break;
90004ed8:	bf00      	nop
90004eda:	f001 b8b6 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90004ede:	bf00      	nop
90004ee0:	f001 b8b3 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90004ee4:	bf00      	nop
90004ee6:	f001 b8b0 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90004eea:	bf00      	nop
      break;
90004eec:	f001 b8ad 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
90004ef0:	58024400 	.word	0x58024400
90004ef4:	03d09000 	.word	0x03d09000
90004ef8:	003d0900 	.word	0x003d0900
90004efc:	016e3600 	.word	0x016e3600
      clocksource = __HAL_RCC_GET_ADC_SOURCE();
90004f00:	4b9a      	ldr	r3, [pc, #616]	@ (9000516c <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
90004f02:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90004f04:	f003 7340 	and.w	r3, r3, #50331648	@ 0x3000000
90004f08:	613b      	str	r3, [r7, #16]
      switch (clocksource)
90004f0a:	693b      	ldr	r3, [r7, #16]
90004f0c:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
90004f10:	d01f      	beq.n	90004f52 <HAL_RCCEx_GetPeriphCLKFreq+0x57e>
90004f12:	693b      	ldr	r3, [r7, #16]
90004f14:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
90004f18:	d81f      	bhi.n	90004f5a <HAL_RCCEx_GetPeriphCLKFreq+0x586>
90004f1a:	693b      	ldr	r3, [r7, #16]
90004f1c:	2b00      	cmp	r3, #0
90004f1e:	d004      	beq.n	90004f2a <HAL_RCCEx_GetPeriphCLKFreq+0x556>
90004f20:	693b      	ldr	r3, [r7, #16]
90004f22:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
90004f26:	d00a      	beq.n	90004f3e <HAL_RCCEx_GetPeriphCLKFreq+0x56a>
          break;
90004f28:	e017      	b.n	90004f5a <HAL_RCCEx_GetPeriphCLKFreq+0x586>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
90004f2a:	4b90      	ldr	r3, [pc, #576]	@ (9000516c <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
90004f2c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004f2e:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
90004f32:	2b00      	cmp	r3, #0
90004f34:	d014      	beq.n	90004f60 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>
            frequency = HAL_RCC_GetPLL2PFreq();
90004f36:	f7fe fbef 	bl	90003718 <HAL_RCC_GetPLL2PFreq>
90004f3a:	6178      	str	r0, [r7, #20]
          break;
90004f3c:	e010      	b.n	90004f60 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
90004f3e:	4b8b      	ldr	r3, [pc, #556]	@ (9000516c <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
90004f40:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004f42:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
90004f46:	2b00      	cmp	r3, #0
90004f48:	d00d      	beq.n	90004f66 <HAL_RCCEx_GetPeriphCLKFreq+0x592>
            frequency = HAL_RCC_GetPLL3RFreq();
90004f4a:	f7fe fc81 	bl	90003850 <HAL_RCC_GetPLL3RFreq>
90004f4e:	6178      	str	r0, [r7, #20]
          break;
90004f50:	e009      	b.n	90004f66 <HAL_RCCEx_GetPeriphCLKFreq+0x592>
          frequency = RCC_GetCLKPFreq();
90004f52:	f001 f87f 	bl	90006054 <RCC_GetCLKPFreq>
90004f56:	6178      	str	r0, [r7, #20]
          break;
90004f58:	e006      	b.n	90004f68 <HAL_RCCEx_GetPeriphCLKFreq+0x594>
          break;
90004f5a:	bf00      	nop
90004f5c:	f001 b875 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90004f60:	bf00      	nop
90004f62:	f001 b872 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90004f66:	bf00      	nop
      break;
90004f68:	f001 b86f 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_ADF1_SOURCE();
90004f6c:	4b7f      	ldr	r3, [pc, #508]	@ (9000516c <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
90004f6e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90004f70:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
90004f74:	613b      	str	r3, [r7, #16]
      switch (clocksource)
90004f76:	693b      	ldr	r3, [r7, #16]
90004f78:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
90004f7c:	d048      	beq.n	90005010 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>
90004f7e:	693b      	ldr	r3, [r7, #16]
90004f80:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
90004f84:	d85a      	bhi.n	9000503c <HAL_RCCEx_GetPeriphCLKFreq+0x668>
90004f86:	693b      	ldr	r3, [r7, #16]
90004f88:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
90004f8c:	d037      	beq.n	90004ffe <HAL_RCCEx_GetPeriphCLKFreq+0x62a>
90004f8e:	693b      	ldr	r3, [r7, #16]
90004f90:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
90004f94:	d852      	bhi.n	9000503c <HAL_RCCEx_GetPeriphCLKFreq+0x668>
90004f96:	693b      	ldr	r3, [r7, #16]
90004f98:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
90004f9c:	d02b      	beq.n	90004ff6 <HAL_RCCEx_GetPeriphCLKFreq+0x622>
90004f9e:	693b      	ldr	r3, [r7, #16]
90004fa0:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
90004fa4:	d84a      	bhi.n	9000503c <HAL_RCCEx_GetPeriphCLKFreq+0x668>
90004fa6:	693b      	ldr	r3, [r7, #16]
90004fa8:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
90004fac:	d019      	beq.n	90004fe2 <HAL_RCCEx_GetPeriphCLKFreq+0x60e>
90004fae:	693b      	ldr	r3, [r7, #16]
90004fb0:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
90004fb4:	d842      	bhi.n	9000503c <HAL_RCCEx_GetPeriphCLKFreq+0x668>
90004fb6:	693b      	ldr	r3, [r7, #16]
90004fb8:	2b00      	cmp	r3, #0
90004fba:	d004      	beq.n	90004fc6 <HAL_RCCEx_GetPeriphCLKFreq+0x5f2>
90004fbc:	693b      	ldr	r3, [r7, #16]
90004fbe:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
90004fc2:	d004      	beq.n	90004fce <HAL_RCCEx_GetPeriphCLKFreq+0x5fa>
          break;
90004fc4:	e03a      	b.n	9000503c <HAL_RCCEx_GetPeriphCLKFreq+0x668>
          frequency = HAL_RCC_GetHCLKFreq();
90004fc6:	f7fe fb15 	bl	900035f4 <HAL_RCC_GetHCLKFreq>
90004fca:	6178      	str	r0, [r7, #20]
          break;
90004fcc:	e043      	b.n	90005056 <HAL_RCCEx_GetPeriphCLKFreq+0x682>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
90004fce:	4b67      	ldr	r3, [pc, #412]	@ (9000516c <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
90004fd0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004fd2:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
90004fd6:	2b00      	cmp	r3, #0
90004fd8:	d033      	beq.n	90005042 <HAL_RCCEx_GetPeriphCLKFreq+0x66e>
            frequency = HAL_RCC_GetPLL2PFreq();
90004fda:	f7fe fb9d 	bl	90003718 <HAL_RCC_GetPLL2PFreq>
90004fde:	6178      	str	r0, [r7, #20]
          break;
90004fe0:	e02f      	b.n	90005042 <HAL_RCCEx_GetPeriphCLKFreq+0x66e>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
90004fe2:	4b62      	ldr	r3, [pc, #392]	@ (9000516c <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
90004fe4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90004fe6:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
90004fea:	2b00      	cmp	r3, #0
90004fec:	d02c      	beq.n	90005048 <HAL_RCCEx_GetPeriphCLKFreq+0x674>
            frequency = HAL_RCC_GetPLL3PFreq();
90004fee:	f7fe fc03 	bl	900037f8 <HAL_RCC_GetPLL3PFreq>
90004ff2:	6178      	str	r0, [r7, #20]
          break;
90004ff4:	e028      	b.n	90005048 <HAL_RCCEx_GetPeriphCLKFreq+0x674>
          frequency = EXTERNAL_CLOCK_VALUE;
90004ff6:	f64b 3380 	movw	r3, #48000	@ 0xbb80
90004ffa:	617b      	str	r3, [r7, #20]
          break;
90004ffc:	e02b      	b.n	90005056 <HAL_RCCEx_GetPeriphCLKFreq+0x682>
          if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
90004ffe:	4b5b      	ldr	r3, [pc, #364]	@ (9000516c <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
90005000:	681b      	ldr	r3, [r3, #0]
90005002:	f403 7380 	and.w	r3, r3, #256	@ 0x100
90005006:	2b00      	cmp	r3, #0
90005008:	d021      	beq.n	9000504e <HAL_RCCEx_GetPeriphCLKFreq+0x67a>
            frequency = CSI_VALUE;
9000500a:	4b59      	ldr	r3, [pc, #356]	@ (90005170 <HAL_RCCEx_GetPeriphCLKFreq+0x79c>)
9000500c:	617b      	str	r3, [r7, #20]
          break;
9000500e:	e01e      	b.n	9000504e <HAL_RCCEx_GetPeriphCLKFreq+0x67a>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
90005010:	4b56      	ldr	r3, [pc, #344]	@ (9000516c <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
90005012:	681b      	ldr	r3, [r3, #0]
90005014:	f003 0304 	and.w	r3, r3, #4
90005018:	2b00      	cmp	r3, #0
9000501a:	d01b      	beq.n	90005054 <HAL_RCCEx_GetPeriphCLKFreq+0x680>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
9000501c:	4b53      	ldr	r3, [pc, #332]	@ (9000516c <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
9000501e:	681b      	ldr	r3, [r3, #0]
90005020:	f003 0320 	and.w	r3, r3, #32
90005024:	2b00      	cmp	r3, #0
90005026:	d015      	beq.n	90005054 <HAL_RCCEx_GetPeriphCLKFreq+0x680>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
90005028:	4b50      	ldr	r3, [pc, #320]	@ (9000516c <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
9000502a:	681b      	ldr	r3, [r3, #0]
9000502c:	08db      	lsrs	r3, r3, #3
9000502e:	f003 0303 	and.w	r3, r3, #3
90005032:	4a50      	ldr	r2, [pc, #320]	@ (90005174 <HAL_RCCEx_GetPeriphCLKFreq+0x7a0>)
90005034:	fa22 f303 	lsr.w	r3, r2, r3
90005038:	617b      	str	r3, [r7, #20]
          break;
9000503a:	e00b      	b.n	90005054 <HAL_RCCEx_GetPeriphCLKFreq+0x680>
          break;
9000503c:	bf00      	nop
9000503e:	f001 b804 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005042:	bf00      	nop
90005044:	f001 b801 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005048:	bf00      	nop
9000504a:	f000 bffe 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
9000504e:	bf00      	nop
90005050:	f000 bffb 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005054:	bf00      	nop
      break;
90005056:	f000 bff8 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_CEC_SOURCE();
9000505a:	4b44      	ldr	r3, [pc, #272]	@ (9000516c <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
9000505c:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
9000505e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
90005062:	613b      	str	r3, [r7, #16]
      switch (clocksource)
90005064:	693b      	ldr	r3, [r7, #16]
90005066:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
9000506a:	d01f      	beq.n	900050ac <HAL_RCCEx_GetPeriphCLKFreq+0x6d8>
9000506c:	693b      	ldr	r3, [r7, #16]
9000506e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
90005072:	d824      	bhi.n	900050be <HAL_RCCEx_GetPeriphCLKFreq+0x6ea>
90005074:	693b      	ldr	r3, [r7, #16]
90005076:	2b00      	cmp	r3, #0
90005078:	d004      	beq.n	90005084 <HAL_RCCEx_GetPeriphCLKFreq+0x6b0>
9000507a:	693b      	ldr	r3, [r7, #16]
9000507c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
90005080:	d00a      	beq.n	90005098 <HAL_RCCEx_GetPeriphCLKFreq+0x6c4>
          break;
90005082:	e01c      	b.n	900050be <HAL_RCCEx_GetPeriphCLKFreq+0x6ea>
          if (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
90005084:	4b39      	ldr	r3, [pc, #228]	@ (9000516c <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
90005086:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
90005088:	f003 0302 	and.w	r3, r3, #2
9000508c:	2b00      	cmp	r3, #0
9000508e:	d019      	beq.n	900050c4 <HAL_RCCEx_GetPeriphCLKFreq+0x6f0>
            frequency = LSE_VALUE;
90005090:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
90005094:	617b      	str	r3, [r7, #20]
          break;
90005096:	e015      	b.n	900050c4 <HAL_RCCEx_GetPeriphCLKFreq+0x6f0>
          if (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
90005098:	4b34      	ldr	r3, [pc, #208]	@ (9000516c <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
9000509a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
9000509c:	f003 0302 	and.w	r3, r3, #2
900050a0:	2b00      	cmp	r3, #0
900050a2:	d012      	beq.n	900050ca <HAL_RCCEx_GetPeriphCLKFreq+0x6f6>
            frequency = LSI_VALUE;
900050a4:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
900050a8:	617b      	str	r3, [r7, #20]
          break;
900050aa:	e00e      	b.n	900050ca <HAL_RCCEx_GetPeriphCLKFreq+0x6f6>
          if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
900050ac:	4b2f      	ldr	r3, [pc, #188]	@ (9000516c <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
900050ae:	681b      	ldr	r3, [r3, #0]
900050b0:	f403 7380 	and.w	r3, r3, #256	@ 0x100
900050b4:	2b00      	cmp	r3, #0
900050b6:	d00b      	beq.n	900050d0 <HAL_RCCEx_GetPeriphCLKFreq+0x6fc>
            frequency = CSI_VALUE;
900050b8:	4b2d      	ldr	r3, [pc, #180]	@ (90005170 <HAL_RCCEx_GetPeriphCLKFreq+0x79c>)
900050ba:	617b      	str	r3, [r7, #20]
          break;
900050bc:	e008      	b.n	900050d0 <HAL_RCCEx_GetPeriphCLKFreq+0x6fc>
          break;
900050be:	bf00      	nop
900050c0:	f000 bfc3 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
900050c4:	bf00      	nop
900050c6:	f000 bfc0 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
900050ca:	bf00      	nop
900050cc:	f000 bfbd 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
900050d0:	bf00      	nop
      break;
900050d2:	f000 bfba 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_ETH1REF_SOURCE();
900050d6:	4b25      	ldr	r3, [pc, #148]	@ (9000516c <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
900050d8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
900050da:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
900050de:	613b      	str	r3, [r7, #16]
      switch (clocksource)
900050e0:	693b      	ldr	r3, [r7, #16]
900050e2:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
900050e6:	d014      	beq.n	90005112 <HAL_RCCEx_GetPeriphCLKFreq+0x73e>
900050e8:	693b      	ldr	r3, [r7, #16]
900050ea:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
900050ee:	d834      	bhi.n	9000515a <HAL_RCCEx_GetPeriphCLKFreq+0x786>
900050f0:	693b      	ldr	r3, [r7, #16]
900050f2:	2b00      	cmp	r3, #0
900050f4:	d034      	beq.n	90005160 <HAL_RCCEx_GetPeriphCLKFreq+0x78c>
900050f6:	693b      	ldr	r3, [r7, #16]
900050f8:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
900050fc:	d000      	beq.n	90005100 <HAL_RCCEx_GetPeriphCLKFreq+0x72c>
          break;
900050fe:	e02c      	b.n	9000515a <HAL_RCCEx_GetPeriphCLKFreq+0x786>
          if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
90005100:	4b1a      	ldr	r3, [pc, #104]	@ (9000516c <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
90005102:	681b      	ldr	r3, [r3, #0]
90005104:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
90005108:	2b00      	cmp	r3, #0
9000510a:	d02c      	beq.n	90005166 <HAL_RCCEx_GetPeriphCLKFreq+0x792>
            frequency = HSE_VALUE;
9000510c:	4b1a      	ldr	r3, [pc, #104]	@ (90005178 <HAL_RCCEx_GetPeriphCLKFreq+0x7a4>)
9000510e:	617b      	str	r3, [r7, #20]
          break;
90005110:	e029      	b.n	90005166 <HAL_RCCEx_GetPeriphCLKFreq+0x792>
          ethclocksource = __HAL_RCC_GET_ETH1PHY_SOURCE();
90005112:	4b16      	ldr	r3, [pc, #88]	@ (9000516c <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
90005114:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90005116:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
9000511a:	60bb      	str	r3, [r7, #8]
          switch (ethclocksource)
9000511c:	68bb      	ldr	r3, [r7, #8]
9000511e:	2b00      	cmp	r3, #0
90005120:	d004      	beq.n	9000512c <HAL_RCCEx_GetPeriphCLKFreq+0x758>
90005122:	68bb      	ldr	r3, [r7, #8]
90005124:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
90005128:	d009      	beq.n	9000513e <HAL_RCCEx_GetPeriphCLKFreq+0x76a>
              break;
9000512a:	e015      	b.n	90005158 <HAL_RCCEx_GetPeriphCLKFreq+0x784>
              if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
9000512c:	4b0f      	ldr	r3, [pc, #60]	@ (9000516c <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
9000512e:	681b      	ldr	r3, [r3, #0]
90005130:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
90005134:	2b00      	cmp	r3, #0
90005136:	d00c      	beq.n	90005152 <HAL_RCCEx_GetPeriphCLKFreq+0x77e>
                frequency = HSE_VALUE;
90005138:	4b0f      	ldr	r3, [pc, #60]	@ (90005178 <HAL_RCCEx_GetPeriphCLKFreq+0x7a4>)
9000513a:	617b      	str	r3, [r7, #20]
              break;
9000513c:	e009      	b.n	90005152 <HAL_RCCEx_GetPeriphCLKFreq+0x77e>
              if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_SCLK) != 0U)
9000513e:	4b0b      	ldr	r3, [pc, #44]	@ (9000516c <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
90005140:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005142:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
90005146:	2b00      	cmp	r3, #0
90005148:	d005      	beq.n	90005156 <HAL_RCCEx_GetPeriphCLKFreq+0x782>
                frequency = HAL_RCC_GetPLL3SFreq();
9000514a:	f7fe fb97 	bl	9000387c <HAL_RCC_GetPLL3SFreq>
9000514e:	6178      	str	r0, [r7, #20]
              break;
90005150:	e001      	b.n	90005156 <HAL_RCCEx_GetPeriphCLKFreq+0x782>
              break;
90005152:	bf00      	nop
90005154:	e008      	b.n	90005168 <HAL_RCCEx_GetPeriphCLKFreq+0x794>
              break;
90005156:	bf00      	nop
          break;
90005158:	e006      	b.n	90005168 <HAL_RCCEx_GetPeriphCLKFreq+0x794>
          break;
9000515a:	bf00      	nop
9000515c:	f000 bf75 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005160:	bf00      	nop
90005162:	f000 bf72 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005166:	bf00      	nop
      break;
90005168:	f000 bf6f 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
9000516c:	58024400 	.word	0x58024400
90005170:	003d0900 	.word	0x003d0900
90005174:	03d09000 	.word	0x03d09000
90005178:	016e3600 	.word	0x016e3600
      clocksource = __HAL_RCC_GET_ETH1PHY_SOURCE();
9000517c:	4b87      	ldr	r3, [pc, #540]	@ (9000539c <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
9000517e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90005180:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
90005184:	613b      	str	r3, [r7, #16]
      switch (clocksource)
90005186:	693b      	ldr	r3, [r7, #16]
90005188:	2b00      	cmp	r3, #0
9000518a:	d004      	beq.n	90005196 <HAL_RCCEx_GetPeriphCLKFreq+0x7c2>
9000518c:	693b      	ldr	r3, [r7, #16]
9000518e:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
90005192:	d009      	beq.n	900051a8 <HAL_RCCEx_GetPeriphCLKFreq+0x7d4>
          break;
90005194:	e016      	b.n	900051c4 <HAL_RCCEx_GetPeriphCLKFreq+0x7f0>
          if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
90005196:	4b81      	ldr	r3, [pc, #516]	@ (9000539c <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
90005198:	681b      	ldr	r3, [r3, #0]
9000519a:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
9000519e:	2b00      	cmp	r3, #0
900051a0:	d00c      	beq.n	900051bc <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
            frequency = HSE_VALUE;
900051a2:	4b7f      	ldr	r3, [pc, #508]	@ (900053a0 <HAL_RCCEx_GetPeriphCLKFreq+0x9cc>)
900051a4:	617b      	str	r3, [r7, #20]
          break;
900051a6:	e009      	b.n	900051bc <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_SCLK) != 0U)
900051a8:	4b7c      	ldr	r3, [pc, #496]	@ (9000539c <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
900051aa:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900051ac:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
900051b0:	2b00      	cmp	r3, #0
900051b2:	d006      	beq.n	900051c2 <HAL_RCCEx_GetPeriphCLKFreq+0x7ee>
            frequency = HAL_RCC_GetPLL3SFreq();
900051b4:	f7fe fb62 	bl	9000387c <HAL_RCC_GetPLL3SFreq>
900051b8:	6178      	str	r0, [r7, #20]
          break;
900051ba:	e002      	b.n	900051c2 <HAL_RCCEx_GetPeriphCLKFreq+0x7ee>
          break;
900051bc:	bf00      	nop
900051be:	f000 bf44 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
900051c2:	bf00      	nop
      break;
900051c4:	f000 bf41 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_FDCAN_SOURCE();
900051c8:	4b74      	ldr	r3, [pc, #464]	@ (9000539c <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
900051ca:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
900051cc:	f403 0340 	and.w	r3, r3, #12582912	@ 0xc00000
900051d0:	613b      	str	r3, [r7, #16]
      switch (clocksource)
900051d2:	693b      	ldr	r3, [r7, #16]
900051d4:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
900051d8:	d01e      	beq.n	90005218 <HAL_RCCEx_GetPeriphCLKFreq+0x844>
900051da:	693b      	ldr	r3, [r7, #16]
900051dc:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
900051e0:	d824      	bhi.n	9000522c <HAL_RCCEx_GetPeriphCLKFreq+0x858>
900051e2:	693b      	ldr	r3, [r7, #16]
900051e4:	2b00      	cmp	r3, #0
900051e6:	d004      	beq.n	900051f2 <HAL_RCCEx_GetPeriphCLKFreq+0x81e>
900051e8:	693b      	ldr	r3, [r7, #16]
900051ea:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
900051ee:	d009      	beq.n	90005204 <HAL_RCCEx_GetPeriphCLKFreq+0x830>
          break;
900051f0:	e01c      	b.n	9000522c <HAL_RCCEx_GetPeriphCLKFreq+0x858>
          if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
900051f2:	4b6a      	ldr	r3, [pc, #424]	@ (9000539c <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
900051f4:	681b      	ldr	r3, [r3, #0]
900051f6:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
900051fa:	2b00      	cmp	r3, #0
900051fc:	d019      	beq.n	90005232 <HAL_RCCEx_GetPeriphCLKFreq+0x85e>
            frequency = HSE_VALUE;
900051fe:	4b68      	ldr	r3, [pc, #416]	@ (900053a0 <HAL_RCCEx_GetPeriphCLKFreq+0x9cc>)
90005200:	617b      	str	r3, [r7, #20]
          break;
90005202:	e016      	b.n	90005232 <HAL_RCCEx_GetPeriphCLKFreq+0x85e>
          if (__HAL_RCC_GET_PLL1CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
90005204:	4b65      	ldr	r3, [pc, #404]	@ (9000539c <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
90005206:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005208:	f003 0340 	and.w	r3, r3, #64	@ 0x40
9000520c:	2b00      	cmp	r3, #0
9000520e:	d013      	beq.n	90005238 <HAL_RCCEx_GetPeriphCLKFreq+0x864>
            frequency = HAL_RCC_GetPLL1QFreq();
90005210:	f7fe fa6c 	bl	900036ec <HAL_RCC_GetPLL1QFreq>
90005214:	6178      	str	r0, [r7, #20]
          break;
90005216:	e00f      	b.n	90005238 <HAL_RCCEx_GetPeriphCLKFreq+0x864>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
90005218:	4b60      	ldr	r3, [pc, #384]	@ (9000539c <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
9000521a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000521c:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
90005220:	2b00      	cmp	r3, #0
90005222:	d00c      	beq.n	9000523e <HAL_RCCEx_GetPeriphCLKFreq+0x86a>
            frequency = HAL_RCC_GetPLL2PFreq();
90005224:	f7fe fa78 	bl	90003718 <HAL_RCC_GetPLL2PFreq>
90005228:	6178      	str	r0, [r7, #20]
          break;
9000522a:	e008      	b.n	9000523e <HAL_RCCEx_GetPeriphCLKFreq+0x86a>
          break;
9000522c:	bf00      	nop
9000522e:	f000 bf0c 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005232:	bf00      	nop
90005234:	f000 bf09 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005238:	bf00      	nop
9000523a:	f000 bf06 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
9000523e:	bf00      	nop
      break;
90005240:	f000 bf03 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_I2C23_SOURCE();
90005244:	4b55      	ldr	r3, [pc, #340]	@ (9000539c <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
90005246:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
90005248:	f403 7340 	and.w	r3, r3, #768	@ 0x300
9000524c:	613b      	str	r3, [r7, #16]
      switch (clocksource)
9000524e:	693b      	ldr	r3, [r7, #16]
90005250:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
90005254:	d037      	beq.n	900052c6 <HAL_RCCEx_GetPeriphCLKFreq+0x8f2>
90005256:	693b      	ldr	r3, [r7, #16]
90005258:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
9000525c:	d83c      	bhi.n	900052d8 <HAL_RCCEx_GetPeriphCLKFreq+0x904>
9000525e:	693b      	ldr	r3, [r7, #16]
90005260:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
90005264:	d019      	beq.n	9000529a <HAL_RCCEx_GetPeriphCLKFreq+0x8c6>
90005266:	693b      	ldr	r3, [r7, #16]
90005268:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
9000526c:	d834      	bhi.n	900052d8 <HAL_RCCEx_GetPeriphCLKFreq+0x904>
9000526e:	693b      	ldr	r3, [r7, #16]
90005270:	2b00      	cmp	r3, #0
90005272:	d004      	beq.n	9000527e <HAL_RCCEx_GetPeriphCLKFreq+0x8aa>
90005274:	693b      	ldr	r3, [r7, #16]
90005276:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
9000527a:	d004      	beq.n	90005286 <HAL_RCCEx_GetPeriphCLKFreq+0x8b2>
          break;
9000527c:	e02c      	b.n	900052d8 <HAL_RCCEx_GetPeriphCLKFreq+0x904>
          frequency = HAL_RCC_GetPCLK1Freq();
9000527e:	f7fe f9e1 	bl	90003644 <HAL_RCC_GetPCLK1Freq>
90005282:	6178      	str	r0, [r7, #20]
          break;
90005284:	e032      	b.n	900052ec <HAL_RCCEx_GetPeriphCLKFreq+0x918>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
90005286:	4b45      	ldr	r3, [pc, #276]	@ (9000539c <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
90005288:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000528a:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
9000528e:	2b00      	cmp	r3, #0
90005290:	d025      	beq.n	900052de <HAL_RCCEx_GetPeriphCLKFreq+0x90a>
            frequency = HAL_RCC_GetPLL3RFreq();
90005292:	f7fe fadd 	bl	90003850 <HAL_RCC_GetPLL3RFreq>
90005296:	6178      	str	r0, [r7, #20]
          break;
90005298:	e021      	b.n	900052de <HAL_RCCEx_GetPeriphCLKFreq+0x90a>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
9000529a:	4b40      	ldr	r3, [pc, #256]	@ (9000539c <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
9000529c:	681b      	ldr	r3, [r3, #0]
9000529e:	f003 0304 	and.w	r3, r3, #4
900052a2:	2b00      	cmp	r3, #0
900052a4:	d01e      	beq.n	900052e4 <HAL_RCCEx_GetPeriphCLKFreq+0x910>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
900052a6:	4b3d      	ldr	r3, [pc, #244]	@ (9000539c <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
900052a8:	681b      	ldr	r3, [r3, #0]
900052aa:	f003 0320 	and.w	r3, r3, #32
900052ae:	2b00      	cmp	r3, #0
900052b0:	d018      	beq.n	900052e4 <HAL_RCCEx_GetPeriphCLKFreq+0x910>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
900052b2:	4b3a      	ldr	r3, [pc, #232]	@ (9000539c <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
900052b4:	681b      	ldr	r3, [r3, #0]
900052b6:	08db      	lsrs	r3, r3, #3
900052b8:	f003 0303 	and.w	r3, r3, #3
900052bc:	4a39      	ldr	r2, [pc, #228]	@ (900053a4 <HAL_RCCEx_GetPeriphCLKFreq+0x9d0>)
900052be:	fa22 f303 	lsr.w	r3, r2, r3
900052c2:	617b      	str	r3, [r7, #20]
          break;
900052c4:	e00e      	b.n	900052e4 <HAL_RCCEx_GetPeriphCLKFreq+0x910>
          if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
900052c6:	4b35      	ldr	r3, [pc, #212]	@ (9000539c <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
900052c8:	681b      	ldr	r3, [r3, #0]
900052ca:	f403 7380 	and.w	r3, r3, #256	@ 0x100
900052ce:	2b00      	cmp	r3, #0
900052d0:	d00b      	beq.n	900052ea <HAL_RCCEx_GetPeriphCLKFreq+0x916>
            frequency = CSI_VALUE;
900052d2:	4b35      	ldr	r3, [pc, #212]	@ (900053a8 <HAL_RCCEx_GetPeriphCLKFreq+0x9d4>)
900052d4:	617b      	str	r3, [r7, #20]
          break;
900052d6:	e008      	b.n	900052ea <HAL_RCCEx_GetPeriphCLKFreq+0x916>
          break;
900052d8:	bf00      	nop
900052da:	f000 beb6 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
900052de:	bf00      	nop
900052e0:	f000 beb3 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
900052e4:	bf00      	nop
900052e6:	f000 beb0 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
900052ea:	bf00      	nop
      break;
900052ec:	f000 bead 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_I2C1_I3C1_SOURCE();
900052f0:	4b2a      	ldr	r3, [pc, #168]	@ (9000539c <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
900052f2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
900052f4:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
900052f8:	613b      	str	r3, [r7, #16]
      switch (clocksource)
900052fa:	693b      	ldr	r3, [r7, #16]
900052fc:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
90005300:	d037      	beq.n	90005372 <HAL_RCCEx_GetPeriphCLKFreq+0x99e>
90005302:	693b      	ldr	r3, [r7, #16]
90005304:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
90005308:	d83c      	bhi.n	90005384 <HAL_RCCEx_GetPeriphCLKFreq+0x9b0>
9000530a:	693b      	ldr	r3, [r7, #16]
9000530c:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
90005310:	d019      	beq.n	90005346 <HAL_RCCEx_GetPeriphCLKFreq+0x972>
90005312:	693b      	ldr	r3, [r7, #16]
90005314:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
90005318:	d834      	bhi.n	90005384 <HAL_RCCEx_GetPeriphCLKFreq+0x9b0>
9000531a:	693b      	ldr	r3, [r7, #16]
9000531c:	2b00      	cmp	r3, #0
9000531e:	d004      	beq.n	9000532a <HAL_RCCEx_GetPeriphCLKFreq+0x956>
90005320:	693b      	ldr	r3, [r7, #16]
90005322:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
90005326:	d004      	beq.n	90005332 <HAL_RCCEx_GetPeriphCLKFreq+0x95e>
          break;
90005328:	e02c      	b.n	90005384 <HAL_RCCEx_GetPeriphCLKFreq+0x9b0>
          frequency = HAL_RCC_GetPCLK1Freq();
9000532a:	f7fe f98b 	bl	90003644 <HAL_RCC_GetPCLK1Freq>
9000532e:	6178      	str	r0, [r7, #20]
          break;
90005330:	e032      	b.n	90005398 <HAL_RCCEx_GetPeriphCLKFreq+0x9c4>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
90005332:	4b1a      	ldr	r3, [pc, #104]	@ (9000539c <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
90005334:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005336:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
9000533a:	2b00      	cmp	r3, #0
9000533c:	d025      	beq.n	9000538a <HAL_RCCEx_GetPeriphCLKFreq+0x9b6>
            frequency = HAL_RCC_GetPLL3RFreq();
9000533e:	f7fe fa87 	bl	90003850 <HAL_RCC_GetPLL3RFreq>
90005342:	6178      	str	r0, [r7, #20]
          break;
90005344:	e021      	b.n	9000538a <HAL_RCCEx_GetPeriphCLKFreq+0x9b6>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
90005346:	4b15      	ldr	r3, [pc, #84]	@ (9000539c <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
90005348:	681b      	ldr	r3, [r3, #0]
9000534a:	f003 0304 	and.w	r3, r3, #4
9000534e:	2b00      	cmp	r3, #0
90005350:	d01e      	beq.n	90005390 <HAL_RCCEx_GetPeriphCLKFreq+0x9bc>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
90005352:	4b12      	ldr	r3, [pc, #72]	@ (9000539c <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
90005354:	681b      	ldr	r3, [r3, #0]
90005356:	f003 0320 	and.w	r3, r3, #32
9000535a:	2b00      	cmp	r3, #0
9000535c:	d018      	beq.n	90005390 <HAL_RCCEx_GetPeriphCLKFreq+0x9bc>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
9000535e:	4b0f      	ldr	r3, [pc, #60]	@ (9000539c <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
90005360:	681b      	ldr	r3, [r3, #0]
90005362:	08db      	lsrs	r3, r3, #3
90005364:	f003 0303 	and.w	r3, r3, #3
90005368:	4a0e      	ldr	r2, [pc, #56]	@ (900053a4 <HAL_RCCEx_GetPeriphCLKFreq+0x9d0>)
9000536a:	fa22 f303 	lsr.w	r3, r2, r3
9000536e:	617b      	str	r3, [r7, #20]
          break;
90005370:	e00e      	b.n	90005390 <HAL_RCCEx_GetPeriphCLKFreq+0x9bc>
          if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
90005372:	4b0a      	ldr	r3, [pc, #40]	@ (9000539c <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
90005374:	681b      	ldr	r3, [r3, #0]
90005376:	f403 7380 	and.w	r3, r3, #256	@ 0x100
9000537a:	2b00      	cmp	r3, #0
9000537c:	d00b      	beq.n	90005396 <HAL_RCCEx_GetPeriphCLKFreq+0x9c2>
            frequency = CSI_VALUE;
9000537e:	4b0a      	ldr	r3, [pc, #40]	@ (900053a8 <HAL_RCCEx_GetPeriphCLKFreq+0x9d4>)
90005380:	617b      	str	r3, [r7, #20]
          break;
90005382:	e008      	b.n	90005396 <HAL_RCCEx_GetPeriphCLKFreq+0x9c2>
          break;
90005384:	bf00      	nop
90005386:	f000 be60 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
9000538a:	bf00      	nop
9000538c:	f000 be5d 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005390:	bf00      	nop
90005392:	f000 be5a 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005396:	bf00      	nop
      break;
90005398:	f000 be57 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
9000539c:	58024400 	.word	0x58024400
900053a0:	016e3600 	.word	0x016e3600
900053a4:	03d09000 	.word	0x03d09000
900053a8:	003d0900 	.word	0x003d0900
      clocksource = __HAL_RCC_GET_LPTIM1_SOURCE();
900053ac:	4ba0      	ldr	r3, [pc, #640]	@ (90005630 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
900053ae:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
900053b0:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
900053b4:	613b      	str	r3, [r7, #16]
      switch (clocksource)
900053b6:	693b      	ldr	r3, [r7, #16]
900053b8:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
900053bc:	d04f      	beq.n	9000545e <HAL_RCCEx_GetPeriphCLKFreq+0xa8a>
900053be:	693b      	ldr	r3, [r7, #16]
900053c0:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
900053c4:	d84f      	bhi.n	90005466 <HAL_RCCEx_GetPeriphCLKFreq+0xa92>
900053c6:	693b      	ldr	r3, [r7, #16]
900053c8:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
900053cc:	d03d      	beq.n	9000544a <HAL_RCCEx_GetPeriphCLKFreq+0xa76>
900053ce:	693b      	ldr	r3, [r7, #16]
900053d0:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
900053d4:	d847      	bhi.n	90005466 <HAL_RCCEx_GetPeriphCLKFreq+0xa92>
900053d6:	693b      	ldr	r3, [r7, #16]
900053d8:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
900053dc:	d02b      	beq.n	90005436 <HAL_RCCEx_GetPeriphCLKFreq+0xa62>
900053de:	693b      	ldr	r3, [r7, #16]
900053e0:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
900053e4:	d83f      	bhi.n	90005466 <HAL_RCCEx_GetPeriphCLKFreq+0xa92>
900053e6:	693b      	ldr	r3, [r7, #16]
900053e8:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
900053ec:	d019      	beq.n	90005422 <HAL_RCCEx_GetPeriphCLKFreq+0xa4e>
900053ee:	693b      	ldr	r3, [r7, #16]
900053f0:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
900053f4:	d837      	bhi.n	90005466 <HAL_RCCEx_GetPeriphCLKFreq+0xa92>
900053f6:	693b      	ldr	r3, [r7, #16]
900053f8:	2b00      	cmp	r3, #0
900053fa:	d004      	beq.n	90005406 <HAL_RCCEx_GetPeriphCLKFreq+0xa32>
900053fc:	693b      	ldr	r3, [r7, #16]
900053fe:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
90005402:	d004      	beq.n	9000540e <HAL_RCCEx_GetPeriphCLKFreq+0xa3a>
          break;
90005404:	e02f      	b.n	90005466 <HAL_RCCEx_GetPeriphCLKFreq+0xa92>
          frequency = HAL_RCC_GetPCLK1Freq();
90005406:	f7fe f91d 	bl	90003644 <HAL_RCC_GetPCLK1Freq>
9000540a:	6178      	str	r0, [r7, #20]
          break;
9000540c:	e038      	b.n	90005480 <HAL_RCCEx_GetPeriphCLKFreq+0xaac>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
9000540e:	4b88      	ldr	r3, [pc, #544]	@ (90005630 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
90005410:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005412:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
90005416:	2b00      	cmp	r3, #0
90005418:	d028      	beq.n	9000546c <HAL_RCCEx_GetPeriphCLKFreq+0xa98>
            frequency = HAL_RCC_GetPLL2PFreq();
9000541a:	f7fe f97d 	bl	90003718 <HAL_RCC_GetPLL2PFreq>
9000541e:	6178      	str	r0, [r7, #20]
          break;
90005420:	e024      	b.n	9000546c <HAL_RCCEx_GetPeriphCLKFreq+0xa98>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
90005422:	4b83      	ldr	r3, [pc, #524]	@ (90005630 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
90005424:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005426:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
9000542a:	2b00      	cmp	r3, #0
9000542c:	d021      	beq.n	90005472 <HAL_RCCEx_GetPeriphCLKFreq+0xa9e>
            frequency = HAL_RCC_GetPLL3RFreq();
9000542e:	f7fe fa0f 	bl	90003850 <HAL_RCC_GetPLL3RFreq>
90005432:	6178      	str	r0, [r7, #20]
          break;
90005434:	e01d      	b.n	90005472 <HAL_RCCEx_GetPeriphCLKFreq+0xa9e>
          if (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
90005436:	4b7e      	ldr	r3, [pc, #504]	@ (90005630 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
90005438:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
9000543a:	f003 0302 	and.w	r3, r3, #2
9000543e:	2b00      	cmp	r3, #0
90005440:	d01a      	beq.n	90005478 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>
            frequency = LSE_VALUE;
90005442:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
90005446:	617b      	str	r3, [r7, #20]
          break;
90005448:	e016      	b.n	90005478 <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>
          if (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
9000544a:	4b79      	ldr	r3, [pc, #484]	@ (90005630 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
9000544c:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
9000544e:	f003 0302 	and.w	r3, r3, #2
90005452:	2b00      	cmp	r3, #0
90005454:	d013      	beq.n	9000547e <HAL_RCCEx_GetPeriphCLKFreq+0xaaa>
            frequency = LSI_VALUE;
90005456:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
9000545a:	617b      	str	r3, [r7, #20]
          break;
9000545c:	e00f      	b.n	9000547e <HAL_RCCEx_GetPeriphCLKFreq+0xaaa>
          frequency = RCC_GetCLKPFreq();
9000545e:	f000 fdf9 	bl	90006054 <RCC_GetCLKPFreq>
90005462:	6178      	str	r0, [r7, #20]
          break;
90005464:	e00c      	b.n	90005480 <HAL_RCCEx_GetPeriphCLKFreq+0xaac>
          break;
90005466:	bf00      	nop
90005468:	f000 bdef 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
9000546c:	bf00      	nop
9000546e:	f000 bdec 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005472:	bf00      	nop
90005474:	f000 bde9 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005478:	bf00      	nop
9000547a:	f000 bde6 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
9000547e:	bf00      	nop
      break;
90005480:	f000 bde3 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_LPTIM23_SOURCE();
90005484:	4b6a      	ldr	r3, [pc, #424]	@ (90005630 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
90005486:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
90005488:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
9000548c:	613b      	str	r3, [r7, #16]
      switch (clocksource)
9000548e:	693b      	ldr	r3, [r7, #16]
90005490:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
90005494:	d04f      	beq.n	90005536 <HAL_RCCEx_GetPeriphCLKFreq+0xb62>
90005496:	693b      	ldr	r3, [r7, #16]
90005498:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
9000549c:	d84f      	bhi.n	9000553e <HAL_RCCEx_GetPeriphCLKFreq+0xb6a>
9000549e:	693b      	ldr	r3, [r7, #16]
900054a0:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
900054a4:	d03d      	beq.n	90005522 <HAL_RCCEx_GetPeriphCLKFreq+0xb4e>
900054a6:	693b      	ldr	r3, [r7, #16]
900054a8:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
900054ac:	d847      	bhi.n	9000553e <HAL_RCCEx_GetPeriphCLKFreq+0xb6a>
900054ae:	693b      	ldr	r3, [r7, #16]
900054b0:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
900054b4:	d02b      	beq.n	9000550e <HAL_RCCEx_GetPeriphCLKFreq+0xb3a>
900054b6:	693b      	ldr	r3, [r7, #16]
900054b8:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
900054bc:	d83f      	bhi.n	9000553e <HAL_RCCEx_GetPeriphCLKFreq+0xb6a>
900054be:	693b      	ldr	r3, [r7, #16]
900054c0:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
900054c4:	d019      	beq.n	900054fa <HAL_RCCEx_GetPeriphCLKFreq+0xb26>
900054c6:	693b      	ldr	r3, [r7, #16]
900054c8:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
900054cc:	d837      	bhi.n	9000553e <HAL_RCCEx_GetPeriphCLKFreq+0xb6a>
900054ce:	693b      	ldr	r3, [r7, #16]
900054d0:	2b00      	cmp	r3, #0
900054d2:	d004      	beq.n	900054de <HAL_RCCEx_GetPeriphCLKFreq+0xb0a>
900054d4:	693b      	ldr	r3, [r7, #16]
900054d6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
900054da:	d004      	beq.n	900054e6 <HAL_RCCEx_GetPeriphCLKFreq+0xb12>
          break;
900054dc:	e02f      	b.n	9000553e <HAL_RCCEx_GetPeriphCLKFreq+0xb6a>
          frequency = HAL_RCC_GetPCLK4Freq();
900054de:	f7fe f8e9 	bl	900036b4 <HAL_RCC_GetPCLK4Freq>
900054e2:	6178      	str	r0, [r7, #20]
          break;
900054e4:	e038      	b.n	90005558 <HAL_RCCEx_GetPeriphCLKFreq+0xb84>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
900054e6:	4b52      	ldr	r3, [pc, #328]	@ (90005630 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
900054e8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900054ea:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
900054ee:	2b00      	cmp	r3, #0
900054f0:	d028      	beq.n	90005544 <HAL_RCCEx_GetPeriphCLKFreq+0xb70>
            frequency = HAL_RCC_GetPLL2PFreq();
900054f2:	f7fe f911 	bl	90003718 <HAL_RCC_GetPLL2PFreq>
900054f6:	6178      	str	r0, [r7, #20]
          break;
900054f8:	e024      	b.n	90005544 <HAL_RCCEx_GetPeriphCLKFreq+0xb70>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
900054fa:	4b4d      	ldr	r3, [pc, #308]	@ (90005630 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
900054fc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900054fe:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
90005502:	2b00      	cmp	r3, #0
90005504:	d021      	beq.n	9000554a <HAL_RCCEx_GetPeriphCLKFreq+0xb76>
            frequency = HAL_RCC_GetPLL3RFreq();
90005506:	f7fe f9a3 	bl	90003850 <HAL_RCC_GetPLL3RFreq>
9000550a:	6178      	str	r0, [r7, #20]
          break;
9000550c:	e01d      	b.n	9000554a <HAL_RCCEx_GetPeriphCLKFreq+0xb76>
          if (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
9000550e:	4b48      	ldr	r3, [pc, #288]	@ (90005630 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
90005510:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
90005512:	f003 0302 	and.w	r3, r3, #2
90005516:	2b00      	cmp	r3, #0
90005518:	d01a      	beq.n	90005550 <HAL_RCCEx_GetPeriphCLKFreq+0xb7c>
            frequency = LSE_VALUE;
9000551a:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
9000551e:	617b      	str	r3, [r7, #20]
          break;
90005520:	e016      	b.n	90005550 <HAL_RCCEx_GetPeriphCLKFreq+0xb7c>
          if (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
90005522:	4b43      	ldr	r3, [pc, #268]	@ (90005630 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
90005524:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
90005526:	f003 0302 	and.w	r3, r3, #2
9000552a:	2b00      	cmp	r3, #0
9000552c:	d013      	beq.n	90005556 <HAL_RCCEx_GetPeriphCLKFreq+0xb82>
            frequency = LSI_VALUE;
9000552e:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
90005532:	617b      	str	r3, [r7, #20]
          break;
90005534:	e00f      	b.n	90005556 <HAL_RCCEx_GetPeriphCLKFreq+0xb82>
          frequency = RCC_GetCLKPFreq();
90005536:	f000 fd8d 	bl	90006054 <RCC_GetCLKPFreq>
9000553a:	6178      	str	r0, [r7, #20]
          break;
9000553c:	e00c      	b.n	90005558 <HAL_RCCEx_GetPeriphCLKFreq+0xb84>
          break;
9000553e:	bf00      	nop
90005540:	f000 bd83 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005544:	bf00      	nop
90005546:	f000 bd80 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
9000554a:	bf00      	nop
9000554c:	f000 bd7d 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005550:	bf00      	nop
90005552:	f000 bd7a 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005556:	bf00      	nop
      break;
90005558:	f000 bd77 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_LPTIM45_SOURCE();
9000555c:	4b34      	ldr	r3, [pc, #208]	@ (90005630 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
9000555e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
90005560:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
90005564:	613b      	str	r3, [r7, #16]
      switch (clocksource)
90005566:	693b      	ldr	r3, [r7, #16]
90005568:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
9000556c:	d04f      	beq.n	9000560e <HAL_RCCEx_GetPeriphCLKFreq+0xc3a>
9000556e:	693b      	ldr	r3, [r7, #16]
90005570:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
90005574:	d84f      	bhi.n	90005616 <HAL_RCCEx_GetPeriphCLKFreq+0xc42>
90005576:	693b      	ldr	r3, [r7, #16]
90005578:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
9000557c:	d03d      	beq.n	900055fa <HAL_RCCEx_GetPeriphCLKFreq+0xc26>
9000557e:	693b      	ldr	r3, [r7, #16]
90005580:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
90005584:	d847      	bhi.n	90005616 <HAL_RCCEx_GetPeriphCLKFreq+0xc42>
90005586:	693b      	ldr	r3, [r7, #16]
90005588:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
9000558c:	d02b      	beq.n	900055e6 <HAL_RCCEx_GetPeriphCLKFreq+0xc12>
9000558e:	693b      	ldr	r3, [r7, #16]
90005590:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
90005594:	d83f      	bhi.n	90005616 <HAL_RCCEx_GetPeriphCLKFreq+0xc42>
90005596:	693b      	ldr	r3, [r7, #16]
90005598:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
9000559c:	d019      	beq.n	900055d2 <HAL_RCCEx_GetPeriphCLKFreq+0xbfe>
9000559e:	693b      	ldr	r3, [r7, #16]
900055a0:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
900055a4:	d837      	bhi.n	90005616 <HAL_RCCEx_GetPeriphCLKFreq+0xc42>
900055a6:	693b      	ldr	r3, [r7, #16]
900055a8:	2b00      	cmp	r3, #0
900055aa:	d004      	beq.n	900055b6 <HAL_RCCEx_GetPeriphCLKFreq+0xbe2>
900055ac:	693b      	ldr	r3, [r7, #16]
900055ae:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
900055b2:	d004      	beq.n	900055be <HAL_RCCEx_GetPeriphCLKFreq+0xbea>
          break;
900055b4:	e02f      	b.n	90005616 <HAL_RCCEx_GetPeriphCLKFreq+0xc42>
          frequency = HAL_RCC_GetPCLK4Freq();
900055b6:	f7fe f87d 	bl	900036b4 <HAL_RCC_GetPCLK4Freq>
900055ba:	6178      	str	r0, [r7, #20]
          break;
900055bc:	e03b      	b.n	90005636 <HAL_RCCEx_GetPeriphCLKFreq+0xc62>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
900055be:	4b1c      	ldr	r3, [pc, #112]	@ (90005630 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
900055c0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900055c2:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
900055c6:	2b00      	cmp	r3, #0
900055c8:	d028      	beq.n	9000561c <HAL_RCCEx_GetPeriphCLKFreq+0xc48>
            frequency = HAL_RCC_GetPLL2PFreq();
900055ca:	f7fe f8a5 	bl	90003718 <HAL_RCC_GetPLL2PFreq>
900055ce:	6178      	str	r0, [r7, #20]
          break;
900055d0:	e024      	b.n	9000561c <HAL_RCCEx_GetPeriphCLKFreq+0xc48>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
900055d2:	4b17      	ldr	r3, [pc, #92]	@ (90005630 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
900055d4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900055d6:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
900055da:	2b00      	cmp	r3, #0
900055dc:	d021      	beq.n	90005622 <HAL_RCCEx_GetPeriphCLKFreq+0xc4e>
            frequency = HAL_RCC_GetPLL3RFreq();
900055de:	f7fe f937 	bl	90003850 <HAL_RCC_GetPLL3RFreq>
900055e2:	6178      	str	r0, [r7, #20]
          break;
900055e4:	e01d      	b.n	90005622 <HAL_RCCEx_GetPeriphCLKFreq+0xc4e>
          if (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
900055e6:	4b12      	ldr	r3, [pc, #72]	@ (90005630 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
900055e8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
900055ea:	f003 0302 	and.w	r3, r3, #2
900055ee:	2b00      	cmp	r3, #0
900055f0:	d01a      	beq.n	90005628 <HAL_RCCEx_GetPeriphCLKFreq+0xc54>
            frequency = LSE_VALUE;
900055f2:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
900055f6:	617b      	str	r3, [r7, #20]
          break;
900055f8:	e016      	b.n	90005628 <HAL_RCCEx_GetPeriphCLKFreq+0xc54>
          if (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
900055fa:	4b0d      	ldr	r3, [pc, #52]	@ (90005630 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
900055fc:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
900055fe:	f003 0302 	and.w	r3, r3, #2
90005602:	2b00      	cmp	r3, #0
90005604:	d016      	beq.n	90005634 <HAL_RCCEx_GetPeriphCLKFreq+0xc60>
            frequency = LSI_VALUE;
90005606:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
9000560a:	617b      	str	r3, [r7, #20]
          break;
9000560c:	e012      	b.n	90005634 <HAL_RCCEx_GetPeriphCLKFreq+0xc60>
          frequency = RCC_GetCLKPFreq();
9000560e:	f000 fd21 	bl	90006054 <RCC_GetCLKPFreq>
90005612:	6178      	str	r0, [r7, #20]
          break;
90005614:	e00f      	b.n	90005636 <HAL_RCCEx_GetPeriphCLKFreq+0xc62>
          break;
90005616:	bf00      	nop
90005618:	f000 bd17 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
9000561c:	bf00      	nop
9000561e:	f000 bd14 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005622:	bf00      	nop
90005624:	f000 bd11 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005628:	bf00      	nop
9000562a:	f000 bd0e 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
9000562e:	bf00      	nop
90005630:	58024400 	.word	0x58024400
          break;
90005634:	bf00      	nop
      break;
90005636:	f000 bd08 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_LPUART1_SOURCE();
9000563a:	4ba3      	ldr	r3, [pc, #652]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
9000563c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
9000563e:	f003 0307 	and.w	r3, r3, #7
90005642:	613b      	str	r3, [r7, #16]
      switch (clocksource)
90005644:	693b      	ldr	r3, [r7, #16]
90005646:	2b05      	cmp	r3, #5
90005648:	d84f      	bhi.n	900056ea <HAL_RCCEx_GetPeriphCLKFreq+0xd16>
9000564a:	a201      	add	r2, pc, #4	@ (adr r2, 90005650 <HAL_RCCEx_GetPeriphCLKFreq+0xc7c>)
9000564c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90005650:	90005669 	.word	0x90005669
90005654:	90005671 	.word	0x90005671
90005658:	90005685 	.word	0x90005685
9000565c:	90005699 	.word	0x90005699
90005660:	900056c5 	.word	0x900056c5
90005664:	900056d7 	.word	0x900056d7
          frequency = HAL_RCC_GetPCLK4Freq();
90005668:	f7fe f824 	bl	900036b4 <HAL_RCC_GetPCLK4Freq>
9000566c:	6178      	str	r0, [r7, #20]
          break;
9000566e:	e04c      	b.n	9000570a <HAL_RCCEx_GetPeriphCLKFreq+0xd36>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
90005670:	4b95      	ldr	r3, [pc, #596]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
90005672:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005674:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
90005678:	2b00      	cmp	r3, #0
9000567a:	d039      	beq.n	900056f0 <HAL_RCCEx_GetPeriphCLKFreq+0xd1c>
            frequency = HAL_RCC_GetPLL2QFreq();
9000567c:	f7fe f862 	bl	90003744 <HAL_RCC_GetPLL2QFreq>
90005680:	6178      	str	r0, [r7, #20]
          break;
90005682:	e035      	b.n	900056f0 <HAL_RCCEx_GetPeriphCLKFreq+0xd1c>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
90005684:	4b90      	ldr	r3, [pc, #576]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
90005686:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005688:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
9000568c:	2b00      	cmp	r3, #0
9000568e:	d032      	beq.n	900056f6 <HAL_RCCEx_GetPeriphCLKFreq+0xd22>
            frequency = HAL_RCC_GetPLL3QFreq();
90005690:	f7fe f8c8 	bl	90003824 <HAL_RCC_GetPLL3QFreq>
90005694:	6178      	str	r0, [r7, #20]
          break;
90005696:	e02e      	b.n	900056f6 <HAL_RCCEx_GetPeriphCLKFreq+0xd22>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
90005698:	4b8b      	ldr	r3, [pc, #556]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
9000569a:	681b      	ldr	r3, [r3, #0]
9000569c:	f003 0304 	and.w	r3, r3, #4
900056a0:	2b00      	cmp	r3, #0
900056a2:	d02b      	beq.n	900056fc <HAL_RCCEx_GetPeriphCLKFreq+0xd28>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
900056a4:	4b88      	ldr	r3, [pc, #544]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
900056a6:	681b      	ldr	r3, [r3, #0]
900056a8:	f003 0320 	and.w	r3, r3, #32
900056ac:	2b00      	cmp	r3, #0
900056ae:	d025      	beq.n	900056fc <HAL_RCCEx_GetPeriphCLKFreq+0xd28>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
900056b0:	4b85      	ldr	r3, [pc, #532]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
900056b2:	681b      	ldr	r3, [r3, #0]
900056b4:	08db      	lsrs	r3, r3, #3
900056b6:	f003 0303 	and.w	r3, r3, #3
900056ba:	4a84      	ldr	r2, [pc, #528]	@ (900058cc <HAL_RCCEx_GetPeriphCLKFreq+0xef8>)
900056bc:	fa22 f303 	lsr.w	r3, r2, r3
900056c0:	617b      	str	r3, [r7, #20]
          break;
900056c2:	e01b      	b.n	900056fc <HAL_RCCEx_GetPeriphCLKFreq+0xd28>
          if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
900056c4:	4b80      	ldr	r3, [pc, #512]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
900056c6:	681b      	ldr	r3, [r3, #0]
900056c8:	f403 7380 	and.w	r3, r3, #256	@ 0x100
900056cc:	2b00      	cmp	r3, #0
900056ce:	d018      	beq.n	90005702 <HAL_RCCEx_GetPeriphCLKFreq+0xd2e>
            frequency = CSI_VALUE;
900056d0:	4b7f      	ldr	r3, [pc, #508]	@ (900058d0 <HAL_RCCEx_GetPeriphCLKFreq+0xefc>)
900056d2:	617b      	str	r3, [r7, #20]
          break;
900056d4:	e015      	b.n	90005702 <HAL_RCCEx_GetPeriphCLKFreq+0xd2e>
          if (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
900056d6:	4b7c      	ldr	r3, [pc, #496]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
900056d8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
900056da:	f003 0302 	and.w	r3, r3, #2
900056de:	2b00      	cmp	r3, #0
900056e0:	d012      	beq.n	90005708 <HAL_RCCEx_GetPeriphCLKFreq+0xd34>
            frequency = LSE_VALUE;
900056e2:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
900056e6:	617b      	str	r3, [r7, #20]
          break;
900056e8:	e00e      	b.n	90005708 <HAL_RCCEx_GetPeriphCLKFreq+0xd34>
          break;
900056ea:	bf00      	nop
900056ec:	f000 bcad 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
900056f0:	bf00      	nop
900056f2:	f000 bcaa 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
900056f6:	bf00      	nop
900056f8:	f000 bca7 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
900056fc:	bf00      	nop
900056fe:	f000 bca4 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005702:	bf00      	nop
90005704:	f000 bca1 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005708:	bf00      	nop
      break;
9000570a:	f000 bc9e 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
9000570e:	4b6e      	ldr	r3, [pc, #440]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
90005710:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005712:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
90005716:	2b00      	cmp	r3, #0
90005718:	f000 8494 	beq.w	90006044 <HAL_RCCEx_GetPeriphCLKFreq+0x1670>
        frequency = HAL_RCC_GetPLL3RFreq();
9000571c:	f7fe f898 	bl	90003850 <HAL_RCC_GetPLL3RFreq>
90005720:	6178      	str	r0, [r7, #20]
      break;
90005722:	f000 bc8f 	b.w	90006044 <HAL_RCCEx_GetPeriphCLKFreq+0x1670>
      clocksource = __HAL_RCC_GET_PSSI_SOURCE();
90005726:	4b68      	ldr	r3, [pc, #416]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
90005728:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
9000572a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
9000572e:	613b      	str	r3, [r7, #16]
      switch (clocksource)
90005730:	693b      	ldr	r3, [r7, #16]
90005732:	2b00      	cmp	r3, #0
90005734:	d004      	beq.n	90005740 <HAL_RCCEx_GetPeriphCLKFreq+0xd6c>
90005736:	693b      	ldr	r3, [r7, #16]
90005738:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
9000573c:	d00a      	beq.n	90005754 <HAL_RCCEx_GetPeriphCLKFreq+0xd80>
          break;
9000573e:	e00e      	b.n	9000575e <HAL_RCCEx_GetPeriphCLKFreq+0xd8a>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
90005740:	4b61      	ldr	r3, [pc, #388]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
90005742:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005744:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
90005748:	2b00      	cmp	r3, #0
9000574a:	d007      	beq.n	9000575c <HAL_RCCEx_GetPeriphCLKFreq+0xd88>
            frequency = HAL_RCC_GetPLL3RFreq();
9000574c:	f7fe f880 	bl	90003850 <HAL_RCC_GetPLL3RFreq>
90005750:	6178      	str	r0, [r7, #20]
          break;
90005752:	e003      	b.n	9000575c <HAL_RCCEx_GetPeriphCLKFreq+0xd88>
          frequency = RCC_GetCLKPFreq();
90005754:	f000 fc7e 	bl	90006054 <RCC_GetCLKPFreq>
90005758:	6178      	str	r0, [r7, #20]
          break;
9000575a:	e000      	b.n	9000575e <HAL_RCCEx_GetPeriphCLKFreq+0xd8a>
          break;
9000575c:	bf00      	nop
      break;
9000575e:	f000 bc74 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_RTC_SOURCE();
90005762:	4b59      	ldr	r3, [pc, #356]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
90005764:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
90005766:	f403 7340 	and.w	r3, r3, #768	@ 0x300
9000576a:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
9000576e:	d107      	bne.n	90005780 <HAL_RCCEx_GetPeriphCLKFreq+0xdac>
90005770:	4b55      	ldr	r3, [pc, #340]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
90005772:	691b      	ldr	r3, [r3, #16]
90005774:	011b      	lsls	r3, r3, #4
90005776:	f403 337c 	and.w	r3, r3, #258048	@ 0x3f000
9000577a:	f443 7340 	orr.w	r3, r3, #768	@ 0x300
9000577e:	e003      	b.n	90005788 <HAL_RCCEx_GetPeriphCLKFreq+0xdb4>
90005780:	4b51      	ldr	r3, [pc, #324]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
90005782:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
90005784:	f403 7340 	and.w	r3, r3, #768	@ 0x300
90005788:	613b      	str	r3, [r7, #16]
      switch (clocksource)
9000578a:	693b      	ldr	r3, [r7, #16]
9000578c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
90005790:	d014      	beq.n	900057bc <HAL_RCCEx_GetPeriphCLKFreq+0xde8>
90005792:	693b      	ldr	r3, [r7, #16]
90005794:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
90005798:	d81a      	bhi.n	900057d0 <HAL_RCCEx_GetPeriphCLKFreq+0xdfc>
9000579a:	693b      	ldr	r3, [r7, #16]
9000579c:	2b00      	cmp	r3, #0
9000579e:	d033      	beq.n	90005808 <HAL_RCCEx_GetPeriphCLKFreq+0xe34>
900057a0:	693b      	ldr	r3, [r7, #16]
900057a2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
900057a6:	d113      	bne.n	900057d0 <HAL_RCCEx_GetPeriphCLKFreq+0xdfc>
          if (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
900057a8:	4b47      	ldr	r3, [pc, #284]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
900057aa:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
900057ac:	f003 0302 	and.w	r3, r3, #2
900057b0:	2b00      	cmp	r3, #0
900057b2:	d02c      	beq.n	9000580e <HAL_RCCEx_GetPeriphCLKFreq+0xe3a>
            frequency = LSE_VALUE;
900057b4:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
900057b8:	617b      	str	r3, [r7, #20]
          break;
900057ba:	e028      	b.n	9000580e <HAL_RCCEx_GetPeriphCLKFreq+0xe3a>
          if (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
900057bc:	4b42      	ldr	r3, [pc, #264]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
900057be:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
900057c0:	f003 0302 	and.w	r3, r3, #2
900057c4:	2b00      	cmp	r3, #0
900057c6:	d025      	beq.n	90005814 <HAL_RCCEx_GetPeriphCLKFreq+0xe40>
            frequency = LSI_VALUE;
900057c8:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
900057cc:	617b      	str	r3, [r7, #20]
          break;
900057ce:	e021      	b.n	90005814 <HAL_RCCEx_GetPeriphCLKFreq+0xe40>
          if (READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL) == RCC_BDCR_RTCSEL) /*!< HSE is the clock source for RTC */
900057d0:	4b3d      	ldr	r3, [pc, #244]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
900057d2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
900057d4:	f403 7340 	and.w	r3, r3, #768	@ 0x300
900057d8:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
900057dc:	d11d      	bne.n	9000581a <HAL_RCCEx_GetPeriphCLKFreq+0xe46>
            if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
900057de:	4b3a      	ldr	r3, [pc, #232]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
900057e0:	681b      	ldr	r3, [r3, #0]
900057e2:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
900057e6:	2b00      	cmp	r3, #0
900057e8:	d017      	beq.n	9000581a <HAL_RCCEx_GetPeriphCLKFreq+0xe46>
              prescaler = READ_BIT(RCC->CFGR, RCC_CFGR_RTCPRE) >> RCC_CFGR_RTCPRE_Pos;
900057ea:	4b37      	ldr	r3, [pc, #220]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
900057ec:	691b      	ldr	r3, [r3, #16]
900057ee:	0a1b      	lsrs	r3, r3, #8
900057f0:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
900057f4:	60fb      	str	r3, [r7, #12]
              if (prescaler > 1U)
900057f6:	68fb      	ldr	r3, [r7, #12]
900057f8:	2b01      	cmp	r3, #1
900057fa:	d90e      	bls.n	9000581a <HAL_RCCEx_GetPeriphCLKFreq+0xe46>
                frequency = HSE_VALUE / prescaler;
900057fc:	4a35      	ldr	r2, [pc, #212]	@ (900058d4 <HAL_RCCEx_GetPeriphCLKFreq+0xf00>)
900057fe:	68fb      	ldr	r3, [r7, #12]
90005800:	fbb2 f3f3 	udiv	r3, r2, r3
90005804:	617b      	str	r3, [r7, #20]
          break;
90005806:	e008      	b.n	9000581a <HAL_RCCEx_GetPeriphCLKFreq+0xe46>
          break;
90005808:	bf00      	nop
9000580a:	f000 bc1e 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
9000580e:	bf00      	nop
90005810:	f000 bc1b 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005814:	bf00      	nop
90005816:	f000 bc18 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
9000581a:	bf00      	nop
      break;
9000581c:	f000 bc15 	b.w	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_SAI1_SOURCE();
90005820:	4b29      	ldr	r3, [pc, #164]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
90005822:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
90005824:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
90005828:	613b      	str	r3, [r7, #16]
      switch (clocksource)
9000582a:	693b      	ldr	r3, [r7, #16]
9000582c:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
90005830:	d039      	beq.n	900058a6 <HAL_RCCEx_GetPeriphCLKFreq+0xed2>
90005832:	693b      	ldr	r3, [r7, #16]
90005834:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
90005838:	d83d      	bhi.n	900058b6 <HAL_RCCEx_GetPeriphCLKFreq+0xee2>
9000583a:	693b      	ldr	r3, [r7, #16]
9000583c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
90005840:	d035      	beq.n	900058ae <HAL_RCCEx_GetPeriphCLKFreq+0xeda>
90005842:	693b      	ldr	r3, [r7, #16]
90005844:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
90005848:	d835      	bhi.n	900058b6 <HAL_RCCEx_GetPeriphCLKFreq+0xee2>
9000584a:	693b      	ldr	r3, [r7, #16]
9000584c:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
90005850:	d01f      	beq.n	90005892 <HAL_RCCEx_GetPeriphCLKFreq+0xebe>
90005852:	693b      	ldr	r3, [r7, #16]
90005854:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
90005858:	d82d      	bhi.n	900058b6 <HAL_RCCEx_GetPeriphCLKFreq+0xee2>
9000585a:	693b      	ldr	r3, [r7, #16]
9000585c:	2b00      	cmp	r3, #0
9000585e:	d004      	beq.n	9000586a <HAL_RCCEx_GetPeriphCLKFreq+0xe96>
90005860:	693b      	ldr	r3, [r7, #16]
90005862:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
90005866:	d00a      	beq.n	9000587e <HAL_RCCEx_GetPeriphCLKFreq+0xeaa>
          break;
90005868:	e025      	b.n	900058b6 <HAL_RCCEx_GetPeriphCLKFreq+0xee2>
          if (__HAL_RCC_GET_PLL1CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
9000586a:	4b17      	ldr	r3, [pc, #92]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
9000586c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000586e:	f003 0340 	and.w	r3, r3, #64	@ 0x40
90005872:	2b00      	cmp	r3, #0
90005874:	d021      	beq.n	900058ba <HAL_RCCEx_GetPeriphCLKFreq+0xee6>
            frequency = HAL_RCC_GetPLL1QFreq();
90005876:	f7fd ff39 	bl	900036ec <HAL_RCC_GetPLL1QFreq>
9000587a:	6178      	str	r0, [r7, #20]
          break;
9000587c:	e01d      	b.n	900058ba <HAL_RCCEx_GetPeriphCLKFreq+0xee6>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
9000587e:	4b12      	ldr	r3, [pc, #72]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
90005880:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005882:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
90005886:	2b00      	cmp	r3, #0
90005888:	d019      	beq.n	900058be <HAL_RCCEx_GetPeriphCLKFreq+0xeea>
            frequency = HAL_RCC_GetPLL2PFreq();
9000588a:	f7fd ff45 	bl	90003718 <HAL_RCC_GetPLL2PFreq>
9000588e:	6178      	str	r0, [r7, #20]
          break;
90005890:	e015      	b.n	900058be <HAL_RCCEx_GetPeriphCLKFreq+0xeea>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
90005892:	4b0d      	ldr	r3, [pc, #52]	@ (900058c8 <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
90005894:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005896:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
9000589a:	2b00      	cmp	r3, #0
9000589c:	d011      	beq.n	900058c2 <HAL_RCCEx_GetPeriphCLKFreq+0xeee>
            frequency = HAL_RCC_GetPLL3PFreq();
9000589e:	f7fd ffab 	bl	900037f8 <HAL_RCC_GetPLL3PFreq>
900058a2:	6178      	str	r0, [r7, #20]
          break;
900058a4:	e00d      	b.n	900058c2 <HAL_RCCEx_GetPeriphCLKFreq+0xeee>
          frequency = RCC_GetCLKPFreq();
900058a6:	f000 fbd5 	bl	90006054 <RCC_GetCLKPFreq>
900058aa:	6178      	str	r0, [r7, #20]
          break;
900058ac:	e00a      	b.n	900058c4 <HAL_RCCEx_GetPeriphCLKFreq+0xef0>
          frequency = EXTERNAL_CLOCK_VALUE;
900058ae:	f64b 3380 	movw	r3, #48000	@ 0xbb80
900058b2:	617b      	str	r3, [r7, #20]
          break;
900058b4:	e006      	b.n	900058c4 <HAL_RCCEx_GetPeriphCLKFreq+0xef0>
          break;
900058b6:	bf00      	nop
900058b8:	e3c7      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
900058ba:	bf00      	nop
900058bc:	e3c5      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
900058be:	bf00      	nop
900058c0:	e3c3      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
900058c2:	bf00      	nop
      break;
900058c4:	e3c1      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
900058c6:	bf00      	nop
900058c8:	58024400 	.word	0x58024400
900058cc:	03d09000 	.word	0x03d09000
900058d0:	003d0900 	.word	0x003d0900
900058d4:	016e3600 	.word	0x016e3600
      clocksource = __HAL_RCC_GET_SAI2_SOURCE();
900058d8:	4b94      	ldr	r3, [pc, #592]	@ (90005b2c <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
900058da:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
900058dc:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
900058e0:	613b      	str	r3, [r7, #16]
      switch (clocksource)
900058e2:	693b      	ldr	r3, [r7, #16]
900058e4:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
900058e8:	d049      	beq.n	9000597e <HAL_RCCEx_GetPeriphCLKFreq+0xfaa>
900058ea:	693b      	ldr	r3, [r7, #16]
900058ec:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
900058f0:	d847      	bhi.n	90005982 <HAL_RCCEx_GetPeriphCLKFreq+0xfae>
900058f2:	693b      	ldr	r3, [r7, #16]
900058f4:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
900058f8:	d039      	beq.n	9000596e <HAL_RCCEx_GetPeriphCLKFreq+0xf9a>
900058fa:	693b      	ldr	r3, [r7, #16]
900058fc:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
90005900:	d83f      	bhi.n	90005982 <HAL_RCCEx_GetPeriphCLKFreq+0xfae>
90005902:	693b      	ldr	r3, [r7, #16]
90005904:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
90005908:	d035      	beq.n	90005976 <HAL_RCCEx_GetPeriphCLKFreq+0xfa2>
9000590a:	693b      	ldr	r3, [r7, #16]
9000590c:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
90005910:	d837      	bhi.n	90005982 <HAL_RCCEx_GetPeriphCLKFreq+0xfae>
90005912:	693b      	ldr	r3, [r7, #16]
90005914:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
90005918:	d01f      	beq.n	9000595a <HAL_RCCEx_GetPeriphCLKFreq+0xf86>
9000591a:	693b      	ldr	r3, [r7, #16]
9000591c:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
90005920:	d82f      	bhi.n	90005982 <HAL_RCCEx_GetPeriphCLKFreq+0xfae>
90005922:	693b      	ldr	r3, [r7, #16]
90005924:	2b00      	cmp	r3, #0
90005926:	d004      	beq.n	90005932 <HAL_RCCEx_GetPeriphCLKFreq+0xf5e>
90005928:	693b      	ldr	r3, [r7, #16]
9000592a:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
9000592e:	d00a      	beq.n	90005946 <HAL_RCCEx_GetPeriphCLKFreq+0xf72>
          break;
90005930:	e027      	b.n	90005982 <HAL_RCCEx_GetPeriphCLKFreq+0xfae>
          if (__HAL_RCC_GET_PLL1CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
90005932:	4b7e      	ldr	r3, [pc, #504]	@ (90005b2c <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
90005934:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005936:	f003 0340 	and.w	r3, r3, #64	@ 0x40
9000593a:	2b00      	cmp	r3, #0
9000593c:	d023      	beq.n	90005986 <HAL_RCCEx_GetPeriphCLKFreq+0xfb2>
            frequency = HAL_RCC_GetPLL1QFreq();
9000593e:	f7fd fed5 	bl	900036ec <HAL_RCC_GetPLL1QFreq>
90005942:	6178      	str	r0, [r7, #20]
          break;
90005944:	e01f      	b.n	90005986 <HAL_RCCEx_GetPeriphCLKFreq+0xfb2>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
90005946:	4b79      	ldr	r3, [pc, #484]	@ (90005b2c <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
90005948:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000594a:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
9000594e:	2b00      	cmp	r3, #0
90005950:	d01b      	beq.n	9000598a <HAL_RCCEx_GetPeriphCLKFreq+0xfb6>
            frequency = HAL_RCC_GetPLL2PFreq();
90005952:	f7fd fee1 	bl	90003718 <HAL_RCC_GetPLL2PFreq>
90005956:	6178      	str	r0, [r7, #20]
          break;
90005958:	e017      	b.n	9000598a <HAL_RCCEx_GetPeriphCLKFreq+0xfb6>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
9000595a:	4b74      	ldr	r3, [pc, #464]	@ (90005b2c <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
9000595c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000595e:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
90005962:	2b00      	cmp	r3, #0
90005964:	d013      	beq.n	9000598e <HAL_RCCEx_GetPeriphCLKFreq+0xfba>
            frequency = HAL_RCC_GetPLL3PFreq();
90005966:	f7fd ff47 	bl	900037f8 <HAL_RCC_GetPLL3PFreq>
9000596a:	6178      	str	r0, [r7, #20]
          break;
9000596c:	e00f      	b.n	9000598e <HAL_RCCEx_GetPeriphCLKFreq+0xfba>
          frequency = RCC_GetCLKPFreq();
9000596e:	f000 fb71 	bl	90006054 <RCC_GetCLKPFreq>
90005972:	6178      	str	r0, [r7, #20]
          break;
90005974:	e00c      	b.n	90005990 <HAL_RCCEx_GetPeriphCLKFreq+0xfbc>
          frequency = EXTERNAL_CLOCK_VALUE;
90005976:	f64b 3380 	movw	r3, #48000	@ 0xbb80
9000597a:	617b      	str	r3, [r7, #20]
          break;
9000597c:	e008      	b.n	90005990 <HAL_RCCEx_GetPeriphCLKFreq+0xfbc>
          break;
9000597e:	bf00      	nop
90005980:	e363      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005982:	bf00      	nop
90005984:	e361      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005986:	bf00      	nop
90005988:	e35f      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
9000598a:	bf00      	nop
9000598c:	e35d      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
9000598e:	bf00      	nop
      break;
90005990:	e35b      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_SDMMC12_SOURCE();
90005992:	4b66      	ldr	r3, [pc, #408]	@ (90005b2c <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
90005994:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90005996:	f003 0304 	and.w	r3, r3, #4
9000599a:	613b      	str	r3, [r7, #16]
      if (clocksource ==
9000599c:	693b      	ldr	r3, [r7, #16]
9000599e:	2b00      	cmp	r3, #0
900059a0:	d10a      	bne.n	900059b8 <HAL_RCCEx_GetPeriphCLKFreq+0xfe4>
        if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_SCLK) != 0U)
900059a2:	4b62      	ldr	r3, [pc, #392]	@ (90005b2c <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
900059a4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900059a6:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
900059aa:	2b00      	cmp	r3, #0
900059ac:	f000 834c 	beq.w	90006048 <HAL_RCCEx_GetPeriphCLKFreq+0x1674>
          frequency = HAL_RCC_GetPLL2SFreq();
900059b0:	f7fd fef4 	bl	9000379c <HAL_RCC_GetPLL2SFreq>
900059b4:	6178      	str	r0, [r7, #20]
      break;
900059b6:	e347      	b.n	90006048 <HAL_RCCEx_GetPeriphCLKFreq+0x1674>
        if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_TCLK) != 0U)
900059b8:	4b5c      	ldr	r3, [pc, #368]	@ (90005b2c <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
900059ba:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900059bc:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
900059c0:	2b00      	cmp	r3, #0
900059c2:	f000 8341 	beq.w	90006048 <HAL_RCCEx_GetPeriphCLKFreq+0x1674>
          frequency = HAL_RCC_GetPLL2TFreq();
900059c6:	f7fd feff 	bl	900037c8 <HAL_RCC_GetPLL2TFreq>
900059ca:	6178      	str	r0, [r7, #20]
      break;
900059cc:	e33c      	b.n	90006048 <HAL_RCCEx_GetPeriphCLKFreq+0x1674>
      clocksource = __HAL_RCC_GET_SPDIFRX_SOURCE();
900059ce:	4b57      	ldr	r3, [pc, #348]	@ (90005b2c <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
900059d0:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
900059d2:	f003 7340 	and.w	r3, r3, #50331648	@ 0x3000000
900059d6:	613b      	str	r3, [r7, #16]
      switch (clocksource)
900059d8:	693b      	ldr	r3, [r7, #16]
900059da:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
900059de:	d031      	beq.n	90005a44 <HAL_RCCEx_GetPeriphCLKFreq+0x1070>
900059e0:	693b      	ldr	r3, [r7, #16]
900059e2:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
900059e6:	d843      	bhi.n	90005a70 <HAL_RCCEx_GetPeriphCLKFreq+0x109c>
900059e8:	693b      	ldr	r3, [r7, #16]
900059ea:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
900059ee:	d01f      	beq.n	90005a30 <HAL_RCCEx_GetPeriphCLKFreq+0x105c>
900059f0:	693b      	ldr	r3, [r7, #16]
900059f2:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
900059f6:	d83b      	bhi.n	90005a70 <HAL_RCCEx_GetPeriphCLKFreq+0x109c>
900059f8:	693b      	ldr	r3, [r7, #16]
900059fa:	2b00      	cmp	r3, #0
900059fc:	d004      	beq.n	90005a08 <HAL_RCCEx_GetPeriphCLKFreq+0x1034>
900059fe:	693b      	ldr	r3, [r7, #16]
90005a00:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
90005a04:	d00a      	beq.n	90005a1c <HAL_RCCEx_GetPeriphCLKFreq+0x1048>
          break;
90005a06:	e033      	b.n	90005a70 <HAL_RCCEx_GetPeriphCLKFreq+0x109c>
          if (__HAL_RCC_GET_PLL1CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
90005a08:	4b48      	ldr	r3, [pc, #288]	@ (90005b2c <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
90005a0a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005a0c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
90005a10:	2b00      	cmp	r3, #0
90005a12:	d02f      	beq.n	90005a74 <HAL_RCCEx_GetPeriphCLKFreq+0x10a0>
            frequency = HAL_RCC_GetPLL1QFreq();
90005a14:	f7fd fe6a 	bl	900036ec <HAL_RCC_GetPLL1QFreq>
90005a18:	6178      	str	r0, [r7, #20]
          break;
90005a1a:	e02b      	b.n	90005a74 <HAL_RCCEx_GetPeriphCLKFreq+0x10a0>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
90005a1c:	4b43      	ldr	r3, [pc, #268]	@ (90005b2c <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
90005a1e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005a20:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
90005a24:	2b00      	cmp	r3, #0
90005a26:	d027      	beq.n	90005a78 <HAL_RCCEx_GetPeriphCLKFreq+0x10a4>
            frequency = HAL_RCC_GetPLL2RFreq();
90005a28:	f7fd fea2 	bl	90003770 <HAL_RCC_GetPLL2RFreq>
90005a2c:	6178      	str	r0, [r7, #20]
          break;
90005a2e:	e023      	b.n	90005a78 <HAL_RCCEx_GetPeriphCLKFreq+0x10a4>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
90005a30:	4b3e      	ldr	r3, [pc, #248]	@ (90005b2c <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
90005a32:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005a34:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
90005a38:	2b00      	cmp	r3, #0
90005a3a:	d01f      	beq.n	90005a7c <HAL_RCCEx_GetPeriphCLKFreq+0x10a8>
            frequency = HAL_RCC_GetPLL3RFreq();
90005a3c:	f7fd ff08 	bl	90003850 <HAL_RCC_GetPLL3RFreq>
90005a40:	6178      	str	r0, [r7, #20]
          break;
90005a42:	e01b      	b.n	90005a7c <HAL_RCCEx_GetPeriphCLKFreq+0x10a8>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
90005a44:	4b39      	ldr	r3, [pc, #228]	@ (90005b2c <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
90005a46:	681b      	ldr	r3, [r3, #0]
90005a48:	f003 0304 	and.w	r3, r3, #4
90005a4c:	2b00      	cmp	r3, #0
90005a4e:	d017      	beq.n	90005a80 <HAL_RCCEx_GetPeriphCLKFreq+0x10ac>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
90005a50:	4b36      	ldr	r3, [pc, #216]	@ (90005b2c <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
90005a52:	681b      	ldr	r3, [r3, #0]
90005a54:	f003 0320 	and.w	r3, r3, #32
90005a58:	2b00      	cmp	r3, #0
90005a5a:	d011      	beq.n	90005a80 <HAL_RCCEx_GetPeriphCLKFreq+0x10ac>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
90005a5c:	4b33      	ldr	r3, [pc, #204]	@ (90005b2c <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
90005a5e:	681b      	ldr	r3, [r3, #0]
90005a60:	08db      	lsrs	r3, r3, #3
90005a62:	f003 0303 	and.w	r3, r3, #3
90005a66:	4a32      	ldr	r2, [pc, #200]	@ (90005b30 <HAL_RCCEx_GetPeriphCLKFreq+0x115c>)
90005a68:	fa22 f303 	lsr.w	r3, r2, r3
90005a6c:	617b      	str	r3, [r7, #20]
          break;
90005a6e:	e007      	b.n	90005a80 <HAL_RCCEx_GetPeriphCLKFreq+0x10ac>
          break;
90005a70:	bf00      	nop
90005a72:	e2ea      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005a74:	bf00      	nop
90005a76:	e2e8      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005a78:	bf00      	nop
90005a7a:	e2e6      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005a7c:	bf00      	nop
90005a7e:	e2e4      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005a80:	bf00      	nop
      break;
90005a82:	e2e2      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_SPI1_SOURCE();
90005a84:	4b29      	ldr	r3, [pc, #164]	@ (90005b2c <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
90005a86:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
90005a88:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
90005a8c:	613b      	str	r3, [r7, #16]
      switch (clocksource)
90005a8e:	693b      	ldr	r3, [r7, #16]
90005a90:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
90005a94:	d039      	beq.n	90005b0a <HAL_RCCEx_GetPeriphCLKFreq+0x1136>
90005a96:	693b      	ldr	r3, [r7, #16]
90005a98:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
90005a9c:	d83d      	bhi.n	90005b1a <HAL_RCCEx_GetPeriphCLKFreq+0x1146>
90005a9e:	693b      	ldr	r3, [r7, #16]
90005aa0:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
90005aa4:	d035      	beq.n	90005b12 <HAL_RCCEx_GetPeriphCLKFreq+0x113e>
90005aa6:	693b      	ldr	r3, [r7, #16]
90005aa8:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
90005aac:	d835      	bhi.n	90005b1a <HAL_RCCEx_GetPeriphCLKFreq+0x1146>
90005aae:	693b      	ldr	r3, [r7, #16]
90005ab0:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
90005ab4:	d01f      	beq.n	90005af6 <HAL_RCCEx_GetPeriphCLKFreq+0x1122>
90005ab6:	693b      	ldr	r3, [r7, #16]
90005ab8:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
90005abc:	d82d      	bhi.n	90005b1a <HAL_RCCEx_GetPeriphCLKFreq+0x1146>
90005abe:	693b      	ldr	r3, [r7, #16]
90005ac0:	2b00      	cmp	r3, #0
90005ac2:	d004      	beq.n	90005ace <HAL_RCCEx_GetPeriphCLKFreq+0x10fa>
90005ac4:	693b      	ldr	r3, [r7, #16]
90005ac6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
90005aca:	d00a      	beq.n	90005ae2 <HAL_RCCEx_GetPeriphCLKFreq+0x110e>
          break;
90005acc:	e025      	b.n	90005b1a <HAL_RCCEx_GetPeriphCLKFreq+0x1146>
          if (__HAL_RCC_GET_PLL1CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
90005ace:	4b17      	ldr	r3, [pc, #92]	@ (90005b2c <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
90005ad0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005ad2:	f003 0340 	and.w	r3, r3, #64	@ 0x40
90005ad6:	2b00      	cmp	r3, #0
90005ad8:	d021      	beq.n	90005b1e <HAL_RCCEx_GetPeriphCLKFreq+0x114a>
            frequency = HAL_RCC_GetPLL1QFreq();
90005ada:	f7fd fe07 	bl	900036ec <HAL_RCC_GetPLL1QFreq>
90005ade:	6178      	str	r0, [r7, #20]
          break;
90005ae0:	e01d      	b.n	90005b1e <HAL_RCCEx_GetPeriphCLKFreq+0x114a>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
90005ae2:	4b12      	ldr	r3, [pc, #72]	@ (90005b2c <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
90005ae4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005ae6:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
90005aea:	2b00      	cmp	r3, #0
90005aec:	d019      	beq.n	90005b22 <HAL_RCCEx_GetPeriphCLKFreq+0x114e>
            frequency = HAL_RCC_GetPLL2PFreq();
90005aee:	f7fd fe13 	bl	90003718 <HAL_RCC_GetPLL2PFreq>
90005af2:	6178      	str	r0, [r7, #20]
          break;
90005af4:	e015      	b.n	90005b22 <HAL_RCCEx_GetPeriphCLKFreq+0x114e>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
90005af6:	4b0d      	ldr	r3, [pc, #52]	@ (90005b2c <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
90005af8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005afa:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
90005afe:	2b00      	cmp	r3, #0
90005b00:	d011      	beq.n	90005b26 <HAL_RCCEx_GetPeriphCLKFreq+0x1152>
            frequency = HAL_RCC_GetPLL3PFreq();
90005b02:	f7fd fe79 	bl	900037f8 <HAL_RCC_GetPLL3PFreq>
90005b06:	6178      	str	r0, [r7, #20]
          break;
90005b08:	e00d      	b.n	90005b26 <HAL_RCCEx_GetPeriphCLKFreq+0x1152>
          frequency = RCC_GetCLKPFreq();
90005b0a:	f000 faa3 	bl	90006054 <RCC_GetCLKPFreq>
90005b0e:	6178      	str	r0, [r7, #20]
          break;
90005b10:	e00a      	b.n	90005b28 <HAL_RCCEx_GetPeriphCLKFreq+0x1154>
          frequency = EXTERNAL_CLOCK_VALUE;
90005b12:	f64b 3380 	movw	r3, #48000	@ 0xbb80
90005b16:	617b      	str	r3, [r7, #20]
          break;
90005b18:	e006      	b.n	90005b28 <HAL_RCCEx_GetPeriphCLKFreq+0x1154>
          break;
90005b1a:	bf00      	nop
90005b1c:	e295      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005b1e:	bf00      	nop
90005b20:	e293      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005b22:	bf00      	nop
90005b24:	e291      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005b26:	bf00      	nop
      break;
90005b28:	e28f      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
90005b2a:	bf00      	nop
90005b2c:	58024400 	.word	0x58024400
90005b30:	03d09000 	.word	0x03d09000
      clocksource = __HAL_RCC_GET_SPI23_SOURCE();
90005b34:	4b92      	ldr	r3, [pc, #584]	@ (90005d80 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
90005b36:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
90005b38:	f003 0370 	and.w	r3, r3, #112	@ 0x70
90005b3c:	613b      	str	r3, [r7, #16]
      switch (clocksource)
90005b3e:	693b      	ldr	r3, [r7, #16]
90005b40:	2b40      	cmp	r3, #64	@ 0x40
90005b42:	d033      	beq.n	90005bac <HAL_RCCEx_GetPeriphCLKFreq+0x11d8>
90005b44:	693b      	ldr	r3, [r7, #16]
90005b46:	2b40      	cmp	r3, #64	@ 0x40
90005b48:	d838      	bhi.n	90005bbc <HAL_RCCEx_GetPeriphCLKFreq+0x11e8>
90005b4a:	693b      	ldr	r3, [r7, #16]
90005b4c:	2b30      	cmp	r3, #48	@ 0x30
90005b4e:	d031      	beq.n	90005bb4 <HAL_RCCEx_GetPeriphCLKFreq+0x11e0>
90005b50:	693b      	ldr	r3, [r7, #16]
90005b52:	2b30      	cmp	r3, #48	@ 0x30
90005b54:	d832      	bhi.n	90005bbc <HAL_RCCEx_GetPeriphCLKFreq+0x11e8>
90005b56:	693b      	ldr	r3, [r7, #16]
90005b58:	2b20      	cmp	r3, #32
90005b5a:	d01d      	beq.n	90005b98 <HAL_RCCEx_GetPeriphCLKFreq+0x11c4>
90005b5c:	693b      	ldr	r3, [r7, #16]
90005b5e:	2b20      	cmp	r3, #32
90005b60:	d82c      	bhi.n	90005bbc <HAL_RCCEx_GetPeriphCLKFreq+0x11e8>
90005b62:	693b      	ldr	r3, [r7, #16]
90005b64:	2b00      	cmp	r3, #0
90005b66:	d003      	beq.n	90005b70 <HAL_RCCEx_GetPeriphCLKFreq+0x119c>
90005b68:	693b      	ldr	r3, [r7, #16]
90005b6a:	2b10      	cmp	r3, #16
90005b6c:	d00a      	beq.n	90005b84 <HAL_RCCEx_GetPeriphCLKFreq+0x11b0>
          break;
90005b6e:	e025      	b.n	90005bbc <HAL_RCCEx_GetPeriphCLKFreq+0x11e8>
          if (__HAL_RCC_GET_PLL1CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
90005b70:	4b83      	ldr	r3, [pc, #524]	@ (90005d80 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
90005b72:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005b74:	f003 0340 	and.w	r3, r3, #64	@ 0x40
90005b78:	2b00      	cmp	r3, #0
90005b7a:	d021      	beq.n	90005bc0 <HAL_RCCEx_GetPeriphCLKFreq+0x11ec>
            frequency = HAL_RCC_GetPLL1QFreq();
90005b7c:	f7fd fdb6 	bl	900036ec <HAL_RCC_GetPLL1QFreq>
90005b80:	6178      	str	r0, [r7, #20]
          break;
90005b82:	e01d      	b.n	90005bc0 <HAL_RCCEx_GetPeriphCLKFreq+0x11ec>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
90005b84:	4b7e      	ldr	r3, [pc, #504]	@ (90005d80 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
90005b86:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005b88:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
90005b8c:	2b00      	cmp	r3, #0
90005b8e:	d019      	beq.n	90005bc4 <HAL_RCCEx_GetPeriphCLKFreq+0x11f0>
            frequency = HAL_RCC_GetPLL2PFreq();
90005b90:	f7fd fdc2 	bl	90003718 <HAL_RCC_GetPLL2PFreq>
90005b94:	6178      	str	r0, [r7, #20]
          break;
90005b96:	e015      	b.n	90005bc4 <HAL_RCCEx_GetPeriphCLKFreq+0x11f0>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
90005b98:	4b79      	ldr	r3, [pc, #484]	@ (90005d80 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
90005b9a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005b9c:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
90005ba0:	2b00      	cmp	r3, #0
90005ba2:	d011      	beq.n	90005bc8 <HAL_RCCEx_GetPeriphCLKFreq+0x11f4>
            frequency = HAL_RCC_GetPLL3PFreq();
90005ba4:	f7fd fe28 	bl	900037f8 <HAL_RCC_GetPLL3PFreq>
90005ba8:	6178      	str	r0, [r7, #20]
          break;
90005baa:	e00d      	b.n	90005bc8 <HAL_RCCEx_GetPeriphCLKFreq+0x11f4>
          frequency = RCC_GetCLKPFreq();
90005bac:	f000 fa52 	bl	90006054 <RCC_GetCLKPFreq>
90005bb0:	6178      	str	r0, [r7, #20]
          break;
90005bb2:	e00a      	b.n	90005bca <HAL_RCCEx_GetPeriphCLKFreq+0x11f6>
          frequency = EXTERNAL_CLOCK_VALUE;
90005bb4:	f64b 3380 	movw	r3, #48000	@ 0xbb80
90005bb8:	617b      	str	r3, [r7, #20]
          break;
90005bba:	e006      	b.n	90005bca <HAL_RCCEx_GetPeriphCLKFreq+0x11f6>
          break;
90005bbc:	bf00      	nop
90005bbe:	e244      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005bc0:	bf00      	nop
90005bc2:	e242      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005bc4:	bf00      	nop
90005bc6:	e240      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005bc8:	bf00      	nop
      break;
90005bca:	e23e      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_SPI45_SOURCE();
90005bcc:	4b6c      	ldr	r3, [pc, #432]	@ (90005d80 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
90005bce:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
90005bd0:	f003 0370 	and.w	r3, r3, #112	@ 0x70
90005bd4:	613b      	str	r3, [r7, #16]
      switch (clocksource)
90005bd6:	693b      	ldr	r3, [r7, #16]
90005bd8:	2b50      	cmp	r3, #80	@ 0x50
90005bda:	d052      	beq.n	90005c82 <HAL_RCCEx_GetPeriphCLKFreq+0x12ae>
90005bdc:	693b      	ldr	r3, [r7, #16]
90005bde:	2b50      	cmp	r3, #80	@ 0x50
90005be0:	d858      	bhi.n	90005c94 <HAL_RCCEx_GetPeriphCLKFreq+0x12c0>
90005be2:	693b      	ldr	r3, [r7, #16]
90005be4:	2b40      	cmp	r3, #64	@ 0x40
90005be6:	d043      	beq.n	90005c70 <HAL_RCCEx_GetPeriphCLKFreq+0x129c>
90005be8:	693b      	ldr	r3, [r7, #16]
90005bea:	2b40      	cmp	r3, #64	@ 0x40
90005bec:	d852      	bhi.n	90005c94 <HAL_RCCEx_GetPeriphCLKFreq+0x12c0>
90005bee:	693b      	ldr	r3, [r7, #16]
90005bf0:	2b30      	cmp	r3, #48	@ 0x30
90005bf2:	d027      	beq.n	90005c44 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>
90005bf4:	693b      	ldr	r3, [r7, #16]
90005bf6:	2b30      	cmp	r3, #48	@ 0x30
90005bf8:	d84c      	bhi.n	90005c94 <HAL_RCCEx_GetPeriphCLKFreq+0x12c0>
90005bfa:	693b      	ldr	r3, [r7, #16]
90005bfc:	2b20      	cmp	r3, #32
90005bfe:	d017      	beq.n	90005c30 <HAL_RCCEx_GetPeriphCLKFreq+0x125c>
90005c00:	693b      	ldr	r3, [r7, #16]
90005c02:	2b20      	cmp	r3, #32
90005c04:	d846      	bhi.n	90005c94 <HAL_RCCEx_GetPeriphCLKFreq+0x12c0>
90005c06:	693b      	ldr	r3, [r7, #16]
90005c08:	2b00      	cmp	r3, #0
90005c0a:	d003      	beq.n	90005c14 <HAL_RCCEx_GetPeriphCLKFreq+0x1240>
90005c0c:	693b      	ldr	r3, [r7, #16]
90005c0e:	2b10      	cmp	r3, #16
90005c10:	d004      	beq.n	90005c1c <HAL_RCCEx_GetPeriphCLKFreq+0x1248>
          break;
90005c12:	e03f      	b.n	90005c94 <HAL_RCCEx_GetPeriphCLKFreq+0x12c0>
          frequency = HAL_RCC_GetPCLK2Freq();
90005c14:	f7fd fd32 	bl	9000367c <HAL_RCC_GetPCLK2Freq>
90005c18:	6178      	str	r0, [r7, #20]
          break;
90005c1a:	e046      	b.n	90005caa <HAL_RCCEx_GetPeriphCLKFreq+0x12d6>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
90005c1c:	4b58      	ldr	r3, [pc, #352]	@ (90005d80 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
90005c1e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005c20:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
90005c24:	2b00      	cmp	r3, #0
90005c26:	d037      	beq.n	90005c98 <HAL_RCCEx_GetPeriphCLKFreq+0x12c4>
            frequency = HAL_RCC_GetPLL2QFreq();
90005c28:	f7fd fd8c 	bl	90003744 <HAL_RCC_GetPLL2QFreq>
90005c2c:	6178      	str	r0, [r7, #20]
          break;
90005c2e:	e033      	b.n	90005c98 <HAL_RCCEx_GetPeriphCLKFreq+0x12c4>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
90005c30:	4b53      	ldr	r3, [pc, #332]	@ (90005d80 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
90005c32:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005c34:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
90005c38:	2b00      	cmp	r3, #0
90005c3a:	d02f      	beq.n	90005c9c <HAL_RCCEx_GetPeriphCLKFreq+0x12c8>
            frequency = HAL_RCC_GetPLL3QFreq();
90005c3c:	f7fd fdf2 	bl	90003824 <HAL_RCC_GetPLL3QFreq>
90005c40:	6178      	str	r0, [r7, #20]
          break;
90005c42:	e02b      	b.n	90005c9c <HAL_RCCEx_GetPeriphCLKFreq+0x12c8>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
90005c44:	4b4e      	ldr	r3, [pc, #312]	@ (90005d80 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
90005c46:	681b      	ldr	r3, [r3, #0]
90005c48:	f003 0304 	and.w	r3, r3, #4
90005c4c:	2b00      	cmp	r3, #0
90005c4e:	d027      	beq.n	90005ca0 <HAL_RCCEx_GetPeriphCLKFreq+0x12cc>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
90005c50:	4b4b      	ldr	r3, [pc, #300]	@ (90005d80 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
90005c52:	681b      	ldr	r3, [r3, #0]
90005c54:	f003 0320 	and.w	r3, r3, #32
90005c58:	2b00      	cmp	r3, #0
90005c5a:	d021      	beq.n	90005ca0 <HAL_RCCEx_GetPeriphCLKFreq+0x12cc>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
90005c5c:	4b48      	ldr	r3, [pc, #288]	@ (90005d80 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
90005c5e:	681b      	ldr	r3, [r3, #0]
90005c60:	08db      	lsrs	r3, r3, #3
90005c62:	f003 0303 	and.w	r3, r3, #3
90005c66:	4a47      	ldr	r2, [pc, #284]	@ (90005d84 <HAL_RCCEx_GetPeriphCLKFreq+0x13b0>)
90005c68:	fa22 f303 	lsr.w	r3, r2, r3
90005c6c:	617b      	str	r3, [r7, #20]
          break;
90005c6e:	e017      	b.n	90005ca0 <HAL_RCCEx_GetPeriphCLKFreq+0x12cc>
          if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
90005c70:	4b43      	ldr	r3, [pc, #268]	@ (90005d80 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
90005c72:	681b      	ldr	r3, [r3, #0]
90005c74:	f403 7380 	and.w	r3, r3, #256	@ 0x100
90005c78:	2b00      	cmp	r3, #0
90005c7a:	d013      	beq.n	90005ca4 <HAL_RCCEx_GetPeriphCLKFreq+0x12d0>
            frequency = CSI_VALUE;
90005c7c:	4b42      	ldr	r3, [pc, #264]	@ (90005d88 <HAL_RCCEx_GetPeriphCLKFreq+0x13b4>)
90005c7e:	617b      	str	r3, [r7, #20]
          break;
90005c80:	e010      	b.n	90005ca4 <HAL_RCCEx_GetPeriphCLKFreq+0x12d0>
          if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
90005c82:	4b3f      	ldr	r3, [pc, #252]	@ (90005d80 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
90005c84:	681b      	ldr	r3, [r3, #0]
90005c86:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
90005c8a:	2b00      	cmp	r3, #0
90005c8c:	d00c      	beq.n	90005ca8 <HAL_RCCEx_GetPeriphCLKFreq+0x12d4>
            frequency = HSE_VALUE;
90005c8e:	4b3f      	ldr	r3, [pc, #252]	@ (90005d8c <HAL_RCCEx_GetPeriphCLKFreq+0x13b8>)
90005c90:	617b      	str	r3, [r7, #20]
          break;
90005c92:	e009      	b.n	90005ca8 <HAL_RCCEx_GetPeriphCLKFreq+0x12d4>
          break;
90005c94:	bf00      	nop
90005c96:	e1d8      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005c98:	bf00      	nop
90005c9a:	e1d6      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005c9c:	bf00      	nop
90005c9e:	e1d4      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005ca0:	bf00      	nop
90005ca2:	e1d2      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005ca4:	bf00      	nop
90005ca6:	e1d0      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005ca8:	bf00      	nop
      break;
90005caa:	e1ce      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_SPI6_SOURCE();
90005cac:	4b34      	ldr	r3, [pc, #208]	@ (90005d80 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
90005cae:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
90005cb0:	f003 0370 	and.w	r3, r3, #112	@ 0x70
90005cb4:	613b      	str	r3, [r7, #16]
      switch (clocksource)
90005cb6:	693b      	ldr	r3, [r7, #16]
90005cb8:	2b50      	cmp	r3, #80	@ 0x50
90005cba:	d052      	beq.n	90005d62 <HAL_RCCEx_GetPeriphCLKFreq+0x138e>
90005cbc:	693b      	ldr	r3, [r7, #16]
90005cbe:	2b50      	cmp	r3, #80	@ 0x50
90005cc0:	d858      	bhi.n	90005d74 <HAL_RCCEx_GetPeriphCLKFreq+0x13a0>
90005cc2:	693b      	ldr	r3, [r7, #16]
90005cc4:	2b40      	cmp	r3, #64	@ 0x40
90005cc6:	d043      	beq.n	90005d50 <HAL_RCCEx_GetPeriphCLKFreq+0x137c>
90005cc8:	693b      	ldr	r3, [r7, #16]
90005cca:	2b40      	cmp	r3, #64	@ 0x40
90005ccc:	d852      	bhi.n	90005d74 <HAL_RCCEx_GetPeriphCLKFreq+0x13a0>
90005cce:	693b      	ldr	r3, [r7, #16]
90005cd0:	2b30      	cmp	r3, #48	@ 0x30
90005cd2:	d027      	beq.n	90005d24 <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
90005cd4:	693b      	ldr	r3, [r7, #16]
90005cd6:	2b30      	cmp	r3, #48	@ 0x30
90005cd8:	d84c      	bhi.n	90005d74 <HAL_RCCEx_GetPeriphCLKFreq+0x13a0>
90005cda:	693b      	ldr	r3, [r7, #16]
90005cdc:	2b20      	cmp	r3, #32
90005cde:	d017      	beq.n	90005d10 <HAL_RCCEx_GetPeriphCLKFreq+0x133c>
90005ce0:	693b      	ldr	r3, [r7, #16]
90005ce2:	2b20      	cmp	r3, #32
90005ce4:	d846      	bhi.n	90005d74 <HAL_RCCEx_GetPeriphCLKFreq+0x13a0>
90005ce6:	693b      	ldr	r3, [r7, #16]
90005ce8:	2b00      	cmp	r3, #0
90005cea:	d003      	beq.n	90005cf4 <HAL_RCCEx_GetPeriphCLKFreq+0x1320>
90005cec:	693b      	ldr	r3, [r7, #16]
90005cee:	2b10      	cmp	r3, #16
90005cf0:	d004      	beq.n	90005cfc <HAL_RCCEx_GetPeriphCLKFreq+0x1328>
          break;
90005cf2:	e03f      	b.n	90005d74 <HAL_RCCEx_GetPeriphCLKFreq+0x13a0>
          frequency = HAL_RCC_GetPCLK4Freq();
90005cf4:	f7fd fcde 	bl	900036b4 <HAL_RCC_GetPCLK4Freq>
90005cf8:	6178      	str	r0, [r7, #20]
          break;
90005cfa:	e04e      	b.n	90005d9a <HAL_RCCEx_GetPeriphCLKFreq+0x13c6>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
90005cfc:	4b20      	ldr	r3, [pc, #128]	@ (90005d80 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
90005cfe:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005d00:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
90005d04:	2b00      	cmp	r3, #0
90005d06:	d037      	beq.n	90005d78 <HAL_RCCEx_GetPeriphCLKFreq+0x13a4>
            frequency = HAL_RCC_GetPLL2QFreq();
90005d08:	f7fd fd1c 	bl	90003744 <HAL_RCC_GetPLL2QFreq>
90005d0c:	6178      	str	r0, [r7, #20]
          break;
90005d0e:	e033      	b.n	90005d78 <HAL_RCCEx_GetPeriphCLKFreq+0x13a4>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
90005d10:	4b1b      	ldr	r3, [pc, #108]	@ (90005d80 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
90005d12:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005d14:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
90005d18:	2b00      	cmp	r3, #0
90005d1a:	d02f      	beq.n	90005d7c <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
            frequency = HAL_RCC_GetPLL3QFreq();
90005d1c:	f7fd fd82 	bl	90003824 <HAL_RCC_GetPLL3QFreq>
90005d20:	6178      	str	r0, [r7, #20]
          break;
90005d22:	e02b      	b.n	90005d7c <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
90005d24:	4b16      	ldr	r3, [pc, #88]	@ (90005d80 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
90005d26:	681b      	ldr	r3, [r3, #0]
90005d28:	f003 0304 	and.w	r3, r3, #4
90005d2c:	2b00      	cmp	r3, #0
90005d2e:	d02f      	beq.n	90005d90 <HAL_RCCEx_GetPeriphCLKFreq+0x13bc>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
90005d30:	4b13      	ldr	r3, [pc, #76]	@ (90005d80 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
90005d32:	681b      	ldr	r3, [r3, #0]
90005d34:	f003 0320 	and.w	r3, r3, #32
90005d38:	2b00      	cmp	r3, #0
90005d3a:	d029      	beq.n	90005d90 <HAL_RCCEx_GetPeriphCLKFreq+0x13bc>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
90005d3c:	4b10      	ldr	r3, [pc, #64]	@ (90005d80 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
90005d3e:	681b      	ldr	r3, [r3, #0]
90005d40:	08db      	lsrs	r3, r3, #3
90005d42:	f003 0303 	and.w	r3, r3, #3
90005d46:	4a0f      	ldr	r2, [pc, #60]	@ (90005d84 <HAL_RCCEx_GetPeriphCLKFreq+0x13b0>)
90005d48:	fa22 f303 	lsr.w	r3, r2, r3
90005d4c:	617b      	str	r3, [r7, #20]
          break;
90005d4e:	e01f      	b.n	90005d90 <HAL_RCCEx_GetPeriphCLKFreq+0x13bc>
          if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
90005d50:	4b0b      	ldr	r3, [pc, #44]	@ (90005d80 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
90005d52:	681b      	ldr	r3, [r3, #0]
90005d54:	f403 7380 	and.w	r3, r3, #256	@ 0x100
90005d58:	2b00      	cmp	r3, #0
90005d5a:	d01b      	beq.n	90005d94 <HAL_RCCEx_GetPeriphCLKFreq+0x13c0>
            frequency = CSI_VALUE;
90005d5c:	4b0a      	ldr	r3, [pc, #40]	@ (90005d88 <HAL_RCCEx_GetPeriphCLKFreq+0x13b4>)
90005d5e:	617b      	str	r3, [r7, #20]
          break;
90005d60:	e018      	b.n	90005d94 <HAL_RCCEx_GetPeriphCLKFreq+0x13c0>
          if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
90005d62:	4b07      	ldr	r3, [pc, #28]	@ (90005d80 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
90005d64:	681b      	ldr	r3, [r3, #0]
90005d66:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
90005d6a:	2b00      	cmp	r3, #0
90005d6c:	d014      	beq.n	90005d98 <HAL_RCCEx_GetPeriphCLKFreq+0x13c4>
            frequency = HSE_VALUE;
90005d6e:	4b07      	ldr	r3, [pc, #28]	@ (90005d8c <HAL_RCCEx_GetPeriphCLKFreq+0x13b8>)
90005d70:	617b      	str	r3, [r7, #20]
          break;
90005d72:	e011      	b.n	90005d98 <HAL_RCCEx_GetPeriphCLKFreq+0x13c4>
          break;
90005d74:	bf00      	nop
90005d76:	e168      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005d78:	bf00      	nop
90005d7a:	e166      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005d7c:	bf00      	nop
90005d7e:	e164      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
90005d80:	58024400 	.word	0x58024400
90005d84:	03d09000 	.word	0x03d09000
90005d88:	003d0900 	.word	0x003d0900
90005d8c:	016e3600 	.word	0x016e3600
          break;
90005d90:	bf00      	nop
90005d92:	e15a      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005d94:	bf00      	nop
90005d96:	e158      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005d98:	bf00      	nop
      break;
90005d9a:	e156      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_USART1_SOURCE();
90005d9c:	4b9e      	ldr	r3, [pc, #632]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005d9e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
90005da0:	f003 0307 	and.w	r3, r3, #7
90005da4:	613b      	str	r3, [r7, #16]
      switch (clocksource)
90005da6:	693b      	ldr	r3, [r7, #16]
90005da8:	2b05      	cmp	r3, #5
90005daa:	d850      	bhi.n	90005e4e <HAL_RCCEx_GetPeriphCLKFreq+0x147a>
90005dac:	a201      	add	r2, pc, #4	@ (adr r2, 90005db4 <HAL_RCCEx_GetPeriphCLKFreq+0x13e0>)
90005dae:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90005db2:	bf00      	nop
90005db4:	90005dcd 	.word	0x90005dcd
90005db8:	90005dd5 	.word	0x90005dd5
90005dbc:	90005de9 	.word	0x90005de9
90005dc0:	90005dfd 	.word	0x90005dfd
90005dc4:	90005e29 	.word	0x90005e29
90005dc8:	90005e3b 	.word	0x90005e3b
          frequency = HAL_RCC_GetPCLK2Freq();
90005dcc:	f7fd fc56 	bl	9000367c <HAL_RCC_GetPCLK2Freq>
90005dd0:	6178      	str	r0, [r7, #20]
          break;
90005dd2:	e047      	b.n	90005e64 <HAL_RCCEx_GetPeriphCLKFreq+0x1490>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
90005dd4:	4b90      	ldr	r3, [pc, #576]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005dd6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005dd8:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
90005ddc:	2b00      	cmp	r3, #0
90005dde:	d038      	beq.n	90005e52 <HAL_RCCEx_GetPeriphCLKFreq+0x147e>
            frequency = HAL_RCC_GetPLL2QFreq();
90005de0:	f7fd fcb0 	bl	90003744 <HAL_RCC_GetPLL2QFreq>
90005de4:	6178      	str	r0, [r7, #20]
          break;
90005de6:	e034      	b.n	90005e52 <HAL_RCCEx_GetPeriphCLKFreq+0x147e>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
90005de8:	4b8b      	ldr	r3, [pc, #556]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005dea:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005dec:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
90005df0:	2b00      	cmp	r3, #0
90005df2:	d030      	beq.n	90005e56 <HAL_RCCEx_GetPeriphCLKFreq+0x1482>
            frequency = HAL_RCC_GetPLL3QFreq();
90005df4:	f7fd fd16 	bl	90003824 <HAL_RCC_GetPLL3QFreq>
90005df8:	6178      	str	r0, [r7, #20]
          break;
90005dfa:	e02c      	b.n	90005e56 <HAL_RCCEx_GetPeriphCLKFreq+0x1482>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
90005dfc:	4b86      	ldr	r3, [pc, #536]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005dfe:	681b      	ldr	r3, [r3, #0]
90005e00:	f003 0304 	and.w	r3, r3, #4
90005e04:	2b00      	cmp	r3, #0
90005e06:	d028      	beq.n	90005e5a <HAL_RCCEx_GetPeriphCLKFreq+0x1486>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
90005e08:	4b83      	ldr	r3, [pc, #524]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005e0a:	681b      	ldr	r3, [r3, #0]
90005e0c:	f003 0320 	and.w	r3, r3, #32
90005e10:	2b00      	cmp	r3, #0
90005e12:	d022      	beq.n	90005e5a <HAL_RCCEx_GetPeriphCLKFreq+0x1486>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
90005e14:	4b80      	ldr	r3, [pc, #512]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005e16:	681b      	ldr	r3, [r3, #0]
90005e18:	08db      	lsrs	r3, r3, #3
90005e1a:	f003 0303 	and.w	r3, r3, #3
90005e1e:	4a7f      	ldr	r2, [pc, #508]	@ (9000601c <HAL_RCCEx_GetPeriphCLKFreq+0x1648>)
90005e20:	fa22 f303 	lsr.w	r3, r2, r3
90005e24:	617b      	str	r3, [r7, #20]
          break;
90005e26:	e018      	b.n	90005e5a <HAL_RCCEx_GetPeriphCLKFreq+0x1486>
          if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
90005e28:	4b7b      	ldr	r3, [pc, #492]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005e2a:	681b      	ldr	r3, [r3, #0]
90005e2c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
90005e30:	2b00      	cmp	r3, #0
90005e32:	d014      	beq.n	90005e5e <HAL_RCCEx_GetPeriphCLKFreq+0x148a>
            frequency = CSI_VALUE;
90005e34:	4b7a      	ldr	r3, [pc, #488]	@ (90006020 <HAL_RCCEx_GetPeriphCLKFreq+0x164c>)
90005e36:	617b      	str	r3, [r7, #20]
          break;
90005e38:	e011      	b.n	90005e5e <HAL_RCCEx_GetPeriphCLKFreq+0x148a>
          if (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
90005e3a:	4b77      	ldr	r3, [pc, #476]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005e3c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
90005e3e:	f003 0302 	and.w	r3, r3, #2
90005e42:	2b00      	cmp	r3, #0
90005e44:	d00d      	beq.n	90005e62 <HAL_RCCEx_GetPeriphCLKFreq+0x148e>
            frequency = LSE_VALUE;
90005e46:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
90005e4a:	617b      	str	r3, [r7, #20]
          break;
90005e4c:	e009      	b.n	90005e62 <HAL_RCCEx_GetPeriphCLKFreq+0x148e>
          break;
90005e4e:	bf00      	nop
90005e50:	e0fb      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005e52:	bf00      	nop
90005e54:	e0f9      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005e56:	bf00      	nop
90005e58:	e0f7      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005e5a:	bf00      	nop
90005e5c:	e0f5      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005e5e:	bf00      	nop
90005e60:	e0f3      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005e62:	bf00      	nop
      break;
90005e64:	e0f1      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_USART234578_SOURCE();
90005e66:	4b6c      	ldr	r3, [pc, #432]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005e68:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
90005e6a:	f003 0307 	and.w	r3, r3, #7
90005e6e:	613b      	str	r3, [r7, #16]
      switch (clocksource)
90005e70:	693b      	ldr	r3, [r7, #16]
90005e72:	2b05      	cmp	r3, #5
90005e74:	d84f      	bhi.n	90005f16 <HAL_RCCEx_GetPeriphCLKFreq+0x1542>
90005e76:	a201      	add	r2, pc, #4	@ (adr r2, 90005e7c <HAL_RCCEx_GetPeriphCLKFreq+0x14a8>)
90005e78:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90005e7c:	90005e95 	.word	0x90005e95
90005e80:	90005e9d 	.word	0x90005e9d
90005e84:	90005eb1 	.word	0x90005eb1
90005e88:	90005ec5 	.word	0x90005ec5
90005e8c:	90005ef1 	.word	0x90005ef1
90005e90:	90005f03 	.word	0x90005f03
          frequency = HAL_RCC_GetPCLK1Freq();
90005e94:	f7fd fbd6 	bl	90003644 <HAL_RCC_GetPCLK1Freq>
90005e98:	6178      	str	r0, [r7, #20]
          break;
90005e9a:	e047      	b.n	90005f2c <HAL_RCCEx_GetPeriphCLKFreq+0x1558>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
90005e9c:	4b5e      	ldr	r3, [pc, #376]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005e9e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005ea0:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
90005ea4:	2b00      	cmp	r3, #0
90005ea6:	d038      	beq.n	90005f1a <HAL_RCCEx_GetPeriphCLKFreq+0x1546>
            frequency = HAL_RCC_GetPLL2QFreq();
90005ea8:	f7fd fc4c 	bl	90003744 <HAL_RCC_GetPLL2QFreq>
90005eac:	6178      	str	r0, [r7, #20]
          break;
90005eae:	e034      	b.n	90005f1a <HAL_RCCEx_GetPeriphCLKFreq+0x1546>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
90005eb0:	4b59      	ldr	r3, [pc, #356]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005eb2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005eb4:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
90005eb8:	2b00      	cmp	r3, #0
90005eba:	d030      	beq.n	90005f1e <HAL_RCCEx_GetPeriphCLKFreq+0x154a>
            frequency = HAL_RCC_GetPLL3QFreq();
90005ebc:	f7fd fcb2 	bl	90003824 <HAL_RCC_GetPLL3QFreq>
90005ec0:	6178      	str	r0, [r7, #20]
          break;
90005ec2:	e02c      	b.n	90005f1e <HAL_RCCEx_GetPeriphCLKFreq+0x154a>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
90005ec4:	4b54      	ldr	r3, [pc, #336]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005ec6:	681b      	ldr	r3, [r3, #0]
90005ec8:	f003 0304 	and.w	r3, r3, #4
90005ecc:	2b00      	cmp	r3, #0
90005ece:	d028      	beq.n	90005f22 <HAL_RCCEx_GetPeriphCLKFreq+0x154e>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
90005ed0:	4b51      	ldr	r3, [pc, #324]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005ed2:	681b      	ldr	r3, [r3, #0]
90005ed4:	f003 0320 	and.w	r3, r3, #32
90005ed8:	2b00      	cmp	r3, #0
90005eda:	d022      	beq.n	90005f22 <HAL_RCCEx_GetPeriphCLKFreq+0x154e>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
90005edc:	4b4e      	ldr	r3, [pc, #312]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005ede:	681b      	ldr	r3, [r3, #0]
90005ee0:	08db      	lsrs	r3, r3, #3
90005ee2:	f003 0303 	and.w	r3, r3, #3
90005ee6:	4a4d      	ldr	r2, [pc, #308]	@ (9000601c <HAL_RCCEx_GetPeriphCLKFreq+0x1648>)
90005ee8:	fa22 f303 	lsr.w	r3, r2, r3
90005eec:	617b      	str	r3, [r7, #20]
          break;
90005eee:	e018      	b.n	90005f22 <HAL_RCCEx_GetPeriphCLKFreq+0x154e>
          if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
90005ef0:	4b49      	ldr	r3, [pc, #292]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005ef2:	681b      	ldr	r3, [r3, #0]
90005ef4:	f403 7380 	and.w	r3, r3, #256	@ 0x100
90005ef8:	2b00      	cmp	r3, #0
90005efa:	d014      	beq.n	90005f26 <HAL_RCCEx_GetPeriphCLKFreq+0x1552>
            frequency = CSI_VALUE;
90005efc:	4b48      	ldr	r3, [pc, #288]	@ (90006020 <HAL_RCCEx_GetPeriphCLKFreq+0x164c>)
90005efe:	617b      	str	r3, [r7, #20]
          break;
90005f00:	e011      	b.n	90005f26 <HAL_RCCEx_GetPeriphCLKFreq+0x1552>
          if (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
90005f02:	4b45      	ldr	r3, [pc, #276]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005f04:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
90005f06:	f003 0302 	and.w	r3, r3, #2
90005f0a:	2b00      	cmp	r3, #0
90005f0c:	d00d      	beq.n	90005f2a <HAL_RCCEx_GetPeriphCLKFreq+0x1556>
            frequency = LSE_VALUE;
90005f0e:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
90005f12:	617b      	str	r3, [r7, #20]
          break;
90005f14:	e009      	b.n	90005f2a <HAL_RCCEx_GetPeriphCLKFreq+0x1556>
          break;
90005f16:	bf00      	nop
90005f18:	e097      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005f1a:	bf00      	nop
90005f1c:	e095      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005f1e:	bf00      	nop
90005f20:	e093      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005f22:	bf00      	nop
90005f24:	e091      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005f26:	bf00      	nop
90005f28:	e08f      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005f2a:	bf00      	nop
      break;
90005f2c:	e08d      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_USBPHYC_SOURCE();
90005f2e:	4b3a      	ldr	r3, [pc, #232]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005f30:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90005f32:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
90005f36:	613b      	str	r3, [r7, #16]
      switch (clocksource)
90005f38:	693b      	ldr	r3, [r7, #16]
90005f3a:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
90005f3e:	d01d      	beq.n	90005f7c <HAL_RCCEx_GetPeriphCLKFreq+0x15a8>
90005f40:	693b      	ldr	r3, [r7, #16]
90005f42:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
90005f46:	d823      	bhi.n	90005f90 <HAL_RCCEx_GetPeriphCLKFreq+0x15bc>
90005f48:	693b      	ldr	r3, [r7, #16]
90005f4a:	2b00      	cmp	r3, #0
90005f4c:	d004      	beq.n	90005f58 <HAL_RCCEx_GetPeriphCLKFreq+0x1584>
90005f4e:	693b      	ldr	r3, [r7, #16]
90005f50:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
90005f54:	d009      	beq.n	90005f6a <HAL_RCCEx_GetPeriphCLKFreq+0x1596>
          break;
90005f56:	e01b      	b.n	90005f90 <HAL_RCCEx_GetPeriphCLKFreq+0x15bc>
          if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
90005f58:	4b2f      	ldr	r3, [pc, #188]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005f5a:	681b      	ldr	r3, [r3, #0]
90005f5c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
90005f60:	2b00      	cmp	r3, #0
90005f62:	d017      	beq.n	90005f94 <HAL_RCCEx_GetPeriphCLKFreq+0x15c0>
            frequency = HSE_VALUE;
90005f64:	4b2f      	ldr	r3, [pc, #188]	@ (90006024 <HAL_RCCEx_GetPeriphCLKFreq+0x1650>)
90005f66:	617b      	str	r3, [r7, #20]
          break;
90005f68:	e014      	b.n	90005f94 <HAL_RCCEx_GetPeriphCLKFreq+0x15c0>
          if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
90005f6a:	4b2b      	ldr	r3, [pc, #172]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005f6c:	681b      	ldr	r3, [r3, #0]
90005f6e:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
90005f72:	2b00      	cmp	r3, #0
90005f74:	d010      	beq.n	90005f98 <HAL_RCCEx_GetPeriphCLKFreq+0x15c4>
            frequency = (HSE_VALUE >> 1UL);
90005f76:	4b2c      	ldr	r3, [pc, #176]	@ (90006028 <HAL_RCCEx_GetPeriphCLKFreq+0x1654>)
90005f78:	617b      	str	r3, [r7, #20]
          break;
90005f7a:	e00d      	b.n	90005f98 <HAL_RCCEx_GetPeriphCLKFreq+0x15c4>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
90005f7c:	4b26      	ldr	r3, [pc, #152]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005f7e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005f80:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
90005f84:	2b00      	cmp	r3, #0
90005f86:	d009      	beq.n	90005f9c <HAL_RCCEx_GetPeriphCLKFreq+0x15c8>
            frequency = HAL_RCC_GetPLL3QFreq();
90005f88:	f7fd fc4c 	bl	90003824 <HAL_RCC_GetPLL3QFreq>
90005f8c:	6178      	str	r0, [r7, #20]
          break;
90005f8e:	e005      	b.n	90005f9c <HAL_RCCEx_GetPeriphCLKFreq+0x15c8>
          break;
90005f90:	bf00      	nop
90005f92:	e05a      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005f94:	bf00      	nop
90005f96:	e058      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005f98:	bf00      	nop
90005f9a:	e056      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90005f9c:	bf00      	nop
      break;
90005f9e:	e054      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_USBOTGFS_SOURCE();
90005fa0:	4b1d      	ldr	r3, [pc, #116]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005fa2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90005fa4:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
90005fa8:	613b      	str	r3, [r7, #16]
      switch (clocksource)
90005faa:	693b      	ldr	r3, [r7, #16]
90005fac:	f5b3 4f40 	cmp.w	r3, #49152	@ 0xc000
90005fb0:	d02f      	beq.n	90006012 <HAL_RCCEx_GetPeriphCLKFreq+0x163e>
90005fb2:	693b      	ldr	r3, [r7, #16]
90005fb4:	f5b3 4f40 	cmp.w	r3, #49152	@ 0xc000
90005fb8:	d83a      	bhi.n	90006030 <HAL_RCCEx_GetPeriphCLKFreq+0x165c>
90005fba:	693b      	ldr	r3, [r7, #16]
90005fbc:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
90005fc0:	d01e      	beq.n	90006000 <HAL_RCCEx_GetPeriphCLKFreq+0x162c>
90005fc2:	693b      	ldr	r3, [r7, #16]
90005fc4:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
90005fc8:	d832      	bhi.n	90006030 <HAL_RCCEx_GetPeriphCLKFreq+0x165c>
90005fca:	693b      	ldr	r3, [r7, #16]
90005fcc:	2b00      	cmp	r3, #0
90005fce:	d004      	beq.n	90005fda <HAL_RCCEx_GetPeriphCLKFreq+0x1606>
90005fd0:	693b      	ldr	r3, [r7, #16]
90005fd2:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
90005fd6:	d009      	beq.n	90005fec <HAL_RCCEx_GetPeriphCLKFreq+0x1618>
          break;
90005fd8:	e02a      	b.n	90006030 <HAL_RCCEx_GetPeriphCLKFreq+0x165c>
          if (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) != 0U)
90005fda:	4b0f      	ldr	r3, [pc, #60]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005fdc:	681b      	ldr	r3, [r3, #0]
90005fde:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
90005fe2:	2b00      	cmp	r3, #0
90005fe4:	d026      	beq.n	90006034 <HAL_RCCEx_GetPeriphCLKFreq+0x1660>
            frequency = HSI48_VALUE;
90005fe6:	4b11      	ldr	r3, [pc, #68]	@ (9000602c <HAL_RCCEx_GetPeriphCLKFreq+0x1658>)
90005fe8:	617b      	str	r3, [r7, #20]
          break;
90005fea:	e023      	b.n	90006034 <HAL_RCCEx_GetPeriphCLKFreq+0x1660>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
90005fec:	4b0a      	ldr	r3, [pc, #40]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90005fee:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
90005ff0:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
90005ff4:	2b00      	cmp	r3, #0
90005ff6:	d01f      	beq.n	90006038 <HAL_RCCEx_GetPeriphCLKFreq+0x1664>
            frequency = HAL_RCC_GetPLL3QFreq();
90005ff8:	f7fd fc14 	bl	90003824 <HAL_RCC_GetPLL3QFreq>
90005ffc:	6178      	str	r0, [r7, #20]
          break;
90005ffe:	e01b      	b.n	90006038 <HAL_RCCEx_GetPeriphCLKFreq+0x1664>
          if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
90006000:	4b05      	ldr	r3, [pc, #20]	@ (90006018 <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
90006002:	681b      	ldr	r3, [r3, #0]
90006004:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
90006008:	2b00      	cmp	r3, #0
9000600a:	d017      	beq.n	9000603c <HAL_RCCEx_GetPeriphCLKFreq+0x1668>
            frequency = HSE_VALUE;
9000600c:	4b05      	ldr	r3, [pc, #20]	@ (90006024 <HAL_RCCEx_GetPeriphCLKFreq+0x1650>)
9000600e:	617b      	str	r3, [r7, #20]
          break;
90006010:	e014      	b.n	9000603c <HAL_RCCEx_GetPeriphCLKFreq+0x1668>
          break;
90006012:	bf00      	nop
90006014:	e019      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
90006016:	bf00      	nop
90006018:	58024400 	.word	0x58024400
9000601c:	03d09000 	.word	0x03d09000
90006020:	003d0900 	.word	0x003d0900
90006024:	016e3600 	.word	0x016e3600
90006028:	00b71b00 	.word	0x00b71b00
9000602c:	02dc6c00 	.word	0x02dc6c00
          break;
90006030:	bf00      	nop
90006032:	e00a      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90006034:	bf00      	nop
90006036:	e008      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
90006038:	bf00      	nop
9000603a:	e006      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
9000603c:	bf00      	nop
      break;
9000603e:	e004      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      break;
90006040:	bf00      	nop
90006042:	e002      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      break;
90006044:	bf00      	nop
90006046:	e000      	b.n	9000604a <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      break;
90006048:	bf00      	nop
  }

  return frequency;
9000604a:	697b      	ldr	r3, [r7, #20]
}
9000604c:	4618      	mov	r0, r3
9000604e:	3718      	adds	r7, #24
90006050:	46bd      	mov	sp, r7
90006052:	bd80      	pop	{r7, pc}

90006054 <RCC_GetCLKPFreq>:
/**
  * @brief  Compute PLL2 VCO output frequency
  * @retval Value of PLL2 VCO output frequency
  */
static uint32_t RCC_GetCLKPFreq(void)
{
90006054:	b480      	push	{r7}
90006056:	b083      	sub	sp, #12
90006058:	af00      	add	r7, sp, #0
  uint32_t frequency = 0U;
9000605a:	2300      	movs	r3, #0
9000605c:	607b      	str	r3, [r7, #4]
  uint32_t ckpclocksource;

  ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
9000605e:	4b1f      	ldr	r3, [pc, #124]	@ (900060dc <RCC_GetCLKPFreq+0x88>)
90006060:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
90006062:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
90006066:	603b      	str	r3, [r7, #0]

  if (ckpclocksource == RCC_CLKPSOURCE_HSI)
90006068:	683b      	ldr	r3, [r7, #0]
9000606a:	2b00      	cmp	r3, #0
9000606c:	d115      	bne.n	9000609a <RCC_GetCLKPFreq+0x46>
  {
    if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
9000606e:	4b1b      	ldr	r3, [pc, #108]	@ (900060dc <RCC_GetCLKPFreq+0x88>)
90006070:	681b      	ldr	r3, [r3, #0]
90006072:	f003 0304 	and.w	r3, r3, #4
90006076:	2b00      	cmp	r3, #0
90006078:	d028      	beq.n	900060cc <RCC_GetCLKPFreq+0x78>
    {
      if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
9000607a:	4b18      	ldr	r3, [pc, #96]	@ (900060dc <RCC_GetCLKPFreq+0x88>)
9000607c:	681b      	ldr	r3, [r3, #0]
9000607e:	f003 0320 	and.w	r3, r3, #32
90006082:	2b00      	cmp	r3, #0
90006084:	d022      	beq.n	900060cc <RCC_GetCLKPFreq+0x78>
      {
        frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
90006086:	4b15      	ldr	r3, [pc, #84]	@ (900060dc <RCC_GetCLKPFreq+0x88>)
90006088:	681b      	ldr	r3, [r3, #0]
9000608a:	08db      	lsrs	r3, r3, #3
9000608c:	f003 0303 	and.w	r3, r3, #3
90006090:	4a13      	ldr	r2, [pc, #76]	@ (900060e0 <RCC_GetCLKPFreq+0x8c>)
90006092:	fa22 f303 	lsr.w	r3, r2, r3
90006096:	607b      	str	r3, [r7, #4]
90006098:	e018      	b.n	900060cc <RCC_GetCLKPFreq+0x78>
      {
        /* Can't retrieve HSIDIV value */
      }
    }
  }
  else if (ckpclocksource == RCC_CLKPSOURCE_CSI)
9000609a:	683b      	ldr	r3, [r7, #0]
9000609c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
900060a0:	d108      	bne.n	900060b4 <RCC_GetCLKPFreq+0x60>
  {
    if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
900060a2:	4b0e      	ldr	r3, [pc, #56]	@ (900060dc <RCC_GetCLKPFreq+0x88>)
900060a4:	681b      	ldr	r3, [r3, #0]
900060a6:	f403 7380 	and.w	r3, r3, #256	@ 0x100
900060aa:	2b00      	cmp	r3, #0
900060ac:	d00e      	beq.n	900060cc <RCC_GetCLKPFreq+0x78>
    {
      frequency = CSI_VALUE;
900060ae:	4b0d      	ldr	r3, [pc, #52]	@ (900060e4 <RCC_GetCLKPFreq+0x90>)
900060b0:	607b      	str	r3, [r7, #4]
900060b2:	e00b      	b.n	900060cc <RCC_GetCLKPFreq+0x78>
    }
  }
  else if (ckpclocksource == RCC_CLKPSOURCE_HSE)
900060b4:	683b      	ldr	r3, [r7, #0]
900060b6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
900060ba:	d107      	bne.n	900060cc <RCC_GetCLKPFreq+0x78>
  {
    if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
900060bc:	4b07      	ldr	r3, [pc, #28]	@ (900060dc <RCC_GetCLKPFreq+0x88>)
900060be:	681b      	ldr	r3, [r3, #0]
900060c0:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
900060c4:	2b00      	cmp	r3, #0
900060c6:	d001      	beq.n	900060cc <RCC_GetCLKPFreq+0x78>
    {
      frequency = HSE_VALUE;
900060c8:	4b07      	ldr	r3, [pc, #28]	@ (900060e8 <RCC_GetCLKPFreq+0x94>)
900060ca:	607b      	str	r3, [r7, #4]
  {
    /* Nothing to do, case the CKPER is disabled */
    /* frequency is by default set to 0          */
  }

  return frequency;
900060cc:	687b      	ldr	r3, [r7, #4]
}
900060ce:	4618      	mov	r0, r3
900060d0:	370c      	adds	r7, #12
900060d2:	46bd      	mov	sp, r7
900060d4:	f85d 7b04 	ldr.w	r7, [sp], #4
900060d8:	4770      	bx	lr
900060da:	bf00      	nop
900060dc:	58024400 	.word	0x58024400
900060e0:	03d09000 	.word	0x03d09000
900060e4:	003d0900 	.word	0x003d0900
900060e8:	016e3600 	.word	0x016e3600

900060ec <HAL_RTC_Init>:
  * @brief  Initialize the RTC peripheral
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
{
900060ec:	b580      	push	{r7, lr}
900060ee:	b084      	sub	sp, #16
900060f0:	af00      	add	r7, sp, #0
900060f2:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_ERROR;
900060f4:	2301      	movs	r3, #1
900060f6:	73fb      	strb	r3, [r7, #15]

  /* Check the RTC peripheral state */
  if (hrtc != NULL)
900060f8:	687b      	ldr	r3, [r7, #4]
900060fa:	2b00      	cmp	r3, #0
900060fc:	d079      	beq.n	900061f2 <HAL_RTC_Init+0x106>
      {
        hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
      }
    }
#else
    if (hrtc->State == HAL_RTC_STATE_RESET)
900060fe:	687b      	ldr	r3, [r7, #4]
90006100:	f893 302d 	ldrb.w	r3, [r3, #45]	@ 0x2d
90006104:	b2db      	uxtb	r3, r3
90006106:	2b00      	cmp	r3, #0
90006108:	d106      	bne.n	90006118 <HAL_RTC_Init+0x2c>
    {
      /* Allocate lock resource and initialize it */
      hrtc->Lock = HAL_UNLOCKED;
9000610a:	687b      	ldr	r3, [r7, #4]
9000610c:	2200      	movs	r2, #0
9000610e:	f883 202c 	strb.w	r2, [r3, #44]	@ 0x2c

      /* Initialize RTC MSP */
      HAL_RTC_MspInit(hrtc);
90006112:	6878      	ldr	r0, [r7, #4]
90006114:	f7fa fac6 	bl	900006a4 <HAL_RTC_MspInit>
    }
#endif /* (USE_HAL_RTC_REGISTER_CALLBACKS) */

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_BUSY;
90006118:	687b      	ldr	r3, [r7, #4]
9000611a:	2202      	movs	r2, #2
9000611c:	f883 202d 	strb.w	r2, [r3, #45]	@ 0x2d

    /* Check whether the calendar needs to be initialized */
    if (__HAL_RTC_IS_CALENDAR_INITIALIZED(hrtc) == 0U)
90006120:	4b36      	ldr	r3, [pc, #216]	@ (900061fc <HAL_RTC_Init+0x110>)
90006122:	68db      	ldr	r3, [r3, #12]
90006124:	f003 0310 	and.w	r3, r3, #16
90006128:	2b10      	cmp	r3, #16
9000612a:	d059      	beq.n	900061e0 <HAL_RTC_Init+0xf4>
    {
      /* Check that the RTC mode is not 'binary only' */
      if (__HAL_RTC_GET_BINARY_MODE(hrtc) != RTC_BINARY_ONLY)
9000612c:	4b33      	ldr	r3, [pc, #204]	@ (900061fc <HAL_RTC_Init+0x110>)
9000612e:	68db      	ldr	r3, [r3, #12]
90006130:	f403 7340 	and.w	r3, r3, #768	@ 0x300
90006134:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
90006138:	d04f      	beq.n	900061da <HAL_RTC_Init+0xee>
      {
        /* Disable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
9000613a:	4b30      	ldr	r3, [pc, #192]	@ (900061fc <HAL_RTC_Init+0x110>)
9000613c:	22ca      	movs	r2, #202	@ 0xca
9000613e:	625a      	str	r2, [r3, #36]	@ 0x24
90006140:	4b2e      	ldr	r3, [pc, #184]	@ (900061fc <HAL_RTC_Init+0x110>)
90006142:	2253      	movs	r2, #83	@ 0x53
90006144:	625a      	str	r2, [r3, #36]	@ 0x24

        /* Enter Initialization mode */
        status = RTC_EnterInitMode(hrtc);
90006146:	6878      	ldr	r0, [r7, #4]
90006148:	f000 fa56 	bl	900065f8 <RTC_EnterInitMode>
9000614c:	4603      	mov	r3, r0
9000614e:	73fb      	strb	r3, [r7, #15]

        if (status == HAL_OK)
90006150:	7bfb      	ldrb	r3, [r7, #15]
90006152:	2b00      	cmp	r3, #0
90006154:	d13d      	bne.n	900061d2 <HAL_RTC_Init+0xe6>
        {
#if defined(RTC_CR_OSEL)
          /* Clear RTC_CR FMT, OSEL and POL Bits */
          CLEAR_BIT(RTC->CR, (RTC_CR_FMT | RTC_CR_POL | RTC_CR_OSEL | RTC_CR_TAMPOE));
90006156:	4b29      	ldr	r3, [pc, #164]	@ (900061fc <HAL_RTC_Init+0x110>)
90006158:	699a      	ldr	r2, [r3, #24]
9000615a:	4928      	ldr	r1, [pc, #160]	@ (900061fc <HAL_RTC_Init+0x110>)
9000615c:	4b28      	ldr	r3, [pc, #160]	@ (90006200 <HAL_RTC_Init+0x114>)
9000615e:	4013      	ands	r3, r2
90006160:	618b      	str	r3, [r1, #24]

          /* Set RTC_CR register */
          SET_BIT(RTC->CR, (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity));
90006162:	4b26      	ldr	r3, [pc, #152]	@ (900061fc <HAL_RTC_Init+0x110>)
90006164:	699a      	ldr	r2, [r3, #24]
90006166:	687b      	ldr	r3, [r7, #4]
90006168:	6859      	ldr	r1, [r3, #4]
9000616a:	687b      	ldr	r3, [r7, #4]
9000616c:	691b      	ldr	r3, [r3, #16]
9000616e:	4319      	orrs	r1, r3
90006170:	687b      	ldr	r3, [r7, #4]
90006172:	699b      	ldr	r3, [r3, #24]
90006174:	430b      	orrs	r3, r1
90006176:	4921      	ldr	r1, [pc, #132]	@ (900061fc <HAL_RTC_Init+0x110>)
90006178:	4313      	orrs	r3, r2
9000617a:	618b      	str	r3, [r1, #24]
          /* Set RTC_CR register */
          SET_BIT(RTC->CR, hrtc->Init.HourFormat);
#endif /* RTC_CR_OSEL */

          /* Configure the RTC PRER */
          WRITE_REG(RTC->PRER, ((hrtc->Init.SynchPrediv) | (hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos)));
9000617c:	687b      	ldr	r3, [r7, #4]
9000617e:	68da      	ldr	r2, [r3, #12]
90006180:	687b      	ldr	r3, [r7, #4]
90006182:	689b      	ldr	r3, [r3, #8]
90006184:	041b      	lsls	r3, r3, #16
90006186:	491d      	ldr	r1, [pc, #116]	@ (900061fc <HAL_RTC_Init+0x110>)
90006188:	4313      	orrs	r3, r2
9000618a:	610b      	str	r3, [r1, #16]

          /* Configure the Binary mode */
          MODIFY_REG(RTC->ICSR, RTC_ICSR_BIN | RTC_ICSR_BCDU, hrtc->Init.BinMode | hrtc->Init.BinMixBcdU);
9000618c:	4b1b      	ldr	r3, [pc, #108]	@ (900061fc <HAL_RTC_Init+0x110>)
9000618e:	68db      	ldr	r3, [r3, #12]
90006190:	f423 52f8 	bic.w	r2, r3, #7936	@ 0x1f00
90006194:	687b      	ldr	r3, [r7, #4]
90006196:	6a59      	ldr	r1, [r3, #36]	@ 0x24
90006198:	687b      	ldr	r3, [r7, #4]
9000619a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
9000619c:	430b      	orrs	r3, r1
9000619e:	4917      	ldr	r1, [pc, #92]	@ (900061fc <HAL_RTC_Init+0x110>)
900061a0:	4313      	orrs	r3, r2
900061a2:	60cb      	str	r3, [r1, #12]

          /* Exit Initialization mode */
          status = RTC_ExitInitMode(hrtc);
900061a4:	6878      	ldr	r0, [r7, #4]
900061a6:	f000 fa63 	bl	90006670 <RTC_ExitInitMode>
900061aa:	4603      	mov	r3, r0
900061ac:	73fb      	strb	r3, [r7, #15]

#if defined(RTC_CR_OSEL)
          if (status == HAL_OK)
900061ae:	7bfb      	ldrb	r3, [r7, #15]
900061b0:	2b00      	cmp	r3, #0
900061b2:	d10e      	bne.n	900061d2 <HAL_RTC_Init+0xe6>
          {
#if defined(RTC_CR_OUT2EN)
            MODIFY_REG(RTC->CR, \
900061b4:	4b11      	ldr	r3, [pc, #68]	@ (900061fc <HAL_RTC_Init+0x110>)
900061b6:	699b      	ldr	r3, [r3, #24]
900061b8:	f023 4260 	bic.w	r2, r3, #3758096384	@ 0xe0000000
900061bc:	687b      	ldr	r3, [r7, #4]
900061be:	6a19      	ldr	r1, [r3, #32]
900061c0:	687b      	ldr	r3, [r7, #4]
900061c2:	69db      	ldr	r3, [r3, #28]
900061c4:	4319      	orrs	r1, r3
900061c6:	687b      	ldr	r3, [r7, #4]
900061c8:	695b      	ldr	r3, [r3, #20]
900061ca:	430b      	orrs	r3, r1
900061cc:	490b      	ldr	r1, [pc, #44]	@ (900061fc <HAL_RTC_Init+0x110>)
900061ce:	4313      	orrs	r3, r2
900061d0:	618b      	str	r3, [r1, #24]
          }
#endif /* RTC_CR_OSEL */
        }

        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
900061d2:	4b0a      	ldr	r3, [pc, #40]	@ (900061fc <HAL_RTC_Init+0x110>)
900061d4:	22ff      	movs	r2, #255	@ 0xff
900061d6:	625a      	str	r2, [r3, #36]	@ 0x24
900061d8:	e004      	b.n	900061e4 <HAL_RTC_Init+0xf8>

      }
      else
      {
        /* The calendar does not need to be initialized as the 'binary only' mode is selected */
        status = HAL_OK;
900061da:	2300      	movs	r3, #0
900061dc:	73fb      	strb	r3, [r7, #15]
900061de:	e001      	b.n	900061e4 <HAL_RTC_Init+0xf8>
      }
    }
    else
    {
      /* The calendar is already initialized */
      status = HAL_OK;
900061e0:	2300      	movs	r3, #0
900061e2:	73fb      	strb	r3, [r7, #15]
    }

    if (status == HAL_OK)
900061e4:	7bfb      	ldrb	r3, [r7, #15]
900061e6:	2b00      	cmp	r3, #0
900061e8:	d103      	bne.n	900061f2 <HAL_RTC_Init+0x106>
    {
      /* Change RTC state */
      hrtc->State = HAL_RTC_STATE_READY;
900061ea:	687b      	ldr	r3, [r7, #4]
900061ec:	2201      	movs	r2, #1
900061ee:	f883 202d 	strb.w	r2, [r3, #45]	@ 0x2d
    }
  }

  return status;
900061f2:	7bfb      	ldrb	r3, [r7, #15]
}
900061f4:	4618      	mov	r0, r3
900061f6:	3710      	adds	r7, #16
900061f8:	46bd      	mov	sp, r7
900061fa:	bd80      	pop	{r7, pc}
900061fc:	58004000 	.word	0x58004000
90006200:	fb8fffbf 	.word	0xfb8fffbf

90006204 <HAL_RTC_SetTime>:
  *             @arg RTC_FORMAT_BIN: Binary format
  *             @arg RTC_FORMAT_BCD: BCD format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
{
90006204:	b590      	push	{r4, r7, lr}
90006206:	b087      	sub	sp, #28
90006208:	af00      	add	r7, sp, #0
9000620a:	60f8      	str	r0, [r7, #12]
9000620c:	60b9      	str	r1, [r7, #8]
9000620e:	607a      	str	r2, [r7, #4]
    assert_param(IS_RTC_FORMAT(Format));
  }
#endif /* USE_FULL_ASSERT */

  /* Process Locked */
  __HAL_LOCK(hrtc);
90006210:	68fb      	ldr	r3, [r7, #12]
90006212:	f893 302c 	ldrb.w	r3, [r3, #44]	@ 0x2c
90006216:	2b01      	cmp	r3, #1
90006218:	d101      	bne.n	9000621e <HAL_RTC_SetTime+0x1a>
9000621a:	2302      	movs	r3, #2
9000621c:	e07c      	b.n	90006318 <HAL_RTC_SetTime+0x114>
9000621e:	68fb      	ldr	r3, [r7, #12]
90006220:	2201      	movs	r2, #1
90006222:	f883 202c 	strb.w	r2, [r3, #44]	@ 0x2c

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_BUSY;
90006226:	68fb      	ldr	r3, [r7, #12]
90006228:	2202      	movs	r2, #2
9000622a:	f883 202d 	strb.w	r2, [r3, #45]	@ 0x2d

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
9000622e:	4b3c      	ldr	r3, [pc, #240]	@ (90006320 <HAL_RTC_SetTime+0x11c>)
90006230:	22ca      	movs	r2, #202	@ 0xca
90006232:	625a      	str	r2, [r3, #36]	@ 0x24
90006234:	4b3a      	ldr	r3, [pc, #232]	@ (90006320 <HAL_RTC_SetTime+0x11c>)
90006236:	2253      	movs	r2, #83	@ 0x53
90006238:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Enter Initialization mode */
  status = RTC_EnterInitMode(hrtc);
9000623a:	68f8      	ldr	r0, [r7, #12]
9000623c:	f000 f9dc 	bl	900065f8 <RTC_EnterInitMode>
90006240:	4603      	mov	r3, r0
90006242:	74fb      	strb	r3, [r7, #19]
  if (status == HAL_OK)
90006244:	7cfb      	ldrb	r3, [r7, #19]
90006246:	2b00      	cmp	r3, #0
90006248:	d157      	bne.n	900062fa <HAL_RTC_SetTime+0xf6>
  {
    /* Check Binary mode ((32-bit free-running counter) */
    if (READ_BIT(RTC->ICSR, RTC_ICSR_BIN) != RTC_BINARY_ONLY)
9000624a:	4b35      	ldr	r3, [pc, #212]	@ (90006320 <HAL_RTC_SetTime+0x11c>)
9000624c:	68db      	ldr	r3, [r3, #12]
9000624e:	f403 7340 	and.w	r3, r3, #768	@ 0x300
90006252:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
90006256:	d04b      	beq.n	900062f0 <HAL_RTC_SetTime+0xec>
    {
      if (Format == RTC_FORMAT_BIN)
90006258:	687b      	ldr	r3, [r7, #4]
9000625a:	2b00      	cmp	r3, #0
9000625c:	d125      	bne.n	900062aa <HAL_RTC_SetTime+0xa6>
      {
        if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
9000625e:	4b30      	ldr	r3, [pc, #192]	@ (90006320 <HAL_RTC_SetTime+0x11c>)
90006260:	699b      	ldr	r3, [r3, #24]
90006262:	f003 0340 	and.w	r3, r3, #64	@ 0x40
90006266:	2b00      	cmp	r3, #0
90006268:	d102      	bne.n	90006270 <HAL_RTC_SetTime+0x6c>
          assert_param(IS_RTC_HOUR12(sTime->Hours));
          assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
        }
        else
        {
          sTime->TimeFormat = 0x00U;
9000626a:	68bb      	ldr	r3, [r7, #8]
9000626c:	2200      	movs	r2, #0
9000626e:	70da      	strb	r2, [r3, #3]
          assert_param(IS_RTC_HOUR24(sTime->Hours));
        }
        assert_param(IS_RTC_MINUTES(sTime->Minutes));
        assert_param(IS_RTC_SECONDS(sTime->Seconds));

        tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << RTC_TR_HU_Pos) | \
90006270:	68bb      	ldr	r3, [r7, #8]
90006272:	781b      	ldrb	r3, [r3, #0]
90006274:	4618      	mov	r0, r3
90006276:	f000 fa39 	bl	900066ec <RTC_ByteToBcd2>
9000627a:	4603      	mov	r3, r0
9000627c:	041c      	lsls	r4, r3, #16
                            ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << RTC_TR_MNU_Pos) | \
9000627e:	68bb      	ldr	r3, [r7, #8]
90006280:	785b      	ldrb	r3, [r3, #1]
90006282:	4618      	mov	r0, r3
90006284:	f000 fa32 	bl	900066ec <RTC_ByteToBcd2>
90006288:	4603      	mov	r3, r0
9000628a:	021b      	lsls	r3, r3, #8
        tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << RTC_TR_HU_Pos) | \
9000628c:	431c      	orrs	r4, r3
                            ((uint32_t)RTC_ByteToBcd2(sTime->Seconds) << RTC_TR_SU_Pos) | \
9000628e:	68bb      	ldr	r3, [r7, #8]
90006290:	789b      	ldrb	r3, [r3, #2]
90006292:	4618      	mov	r0, r3
90006294:	f000 fa2a 	bl	900066ec <RTC_ByteToBcd2>
90006298:	4603      	mov	r3, r0
                            ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << RTC_TR_MNU_Pos) | \
9000629a:	ea44 0203 	orr.w	r2, r4, r3
                            (((uint32_t)sTime->TimeFormat) << RTC_TR_PM_Pos));
9000629e:	68bb      	ldr	r3, [r7, #8]
900062a0:	78db      	ldrb	r3, [r3, #3]
900062a2:	059b      	lsls	r3, r3, #22
        tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << RTC_TR_HU_Pos) | \
900062a4:	4313      	orrs	r3, r2
900062a6:	617b      	str	r3, [r7, #20]
900062a8:	e017      	b.n	900062da <HAL_RTC_SetTime+0xd6>
      }
      else
      {
        if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
900062aa:	4b1d      	ldr	r3, [pc, #116]	@ (90006320 <HAL_RTC_SetTime+0x11c>)
900062ac:	699b      	ldr	r3, [r3, #24]
900062ae:	f003 0340 	and.w	r3, r3, #64	@ 0x40
900062b2:	2b00      	cmp	r3, #0
900062b4:	d102      	bne.n	900062bc <HAL_RTC_SetTime+0xb8>
          assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sTime->Hours)));
          assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
        }
        else
        {
          sTime->TimeFormat = 0x00U;
900062b6:	68bb      	ldr	r3, [r7, #8]
900062b8:	2200      	movs	r2, #0
900062ba:	70da      	strb	r2, [r3, #3]
          assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
        }
        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));
        tmpreg = (((uint32_t)(sTime->Hours) << RTC_TR_HU_Pos) | \
900062bc:	68bb      	ldr	r3, [r7, #8]
900062be:	781b      	ldrb	r3, [r3, #0]
900062c0:	041a      	lsls	r2, r3, #16
                  ((uint32_t)(sTime->Minutes) << RTC_TR_MNU_Pos) | \
900062c2:	68bb      	ldr	r3, [r7, #8]
900062c4:	785b      	ldrb	r3, [r3, #1]
900062c6:	021b      	lsls	r3, r3, #8
        tmpreg = (((uint32_t)(sTime->Hours) << RTC_TR_HU_Pos) | \
900062c8:	4313      	orrs	r3, r2
                  ((uint32_t)(sTime->Seconds) << RTC_TR_SU_Pos) | \
900062ca:	68ba      	ldr	r2, [r7, #8]
900062cc:	7892      	ldrb	r2, [r2, #2]
                  ((uint32_t)(sTime->Minutes) << RTC_TR_MNU_Pos) | \
900062ce:	431a      	orrs	r2, r3
                  ((uint32_t)(sTime->TimeFormat) << RTC_TR_PM_Pos));
900062d0:	68bb      	ldr	r3, [r7, #8]
900062d2:	78db      	ldrb	r3, [r3, #3]
900062d4:	059b      	lsls	r3, r3, #22
        tmpreg = (((uint32_t)(sTime->Hours) << RTC_TR_HU_Pos) | \
900062d6:	4313      	orrs	r3, r2
900062d8:	617b      	str	r3, [r7, #20]
      }

      /* Set the RTC_TR register */
      WRITE_REG(RTC->TR, (tmpreg & RTC_TR_RESERVED_MASK));
900062da:	4911      	ldr	r1, [pc, #68]	@ (90006320 <HAL_RTC_SetTime+0x11c>)
900062dc:	697a      	ldr	r2, [r7, #20]
900062de:	4b11      	ldr	r3, [pc, #68]	@ (90006324 <HAL_RTC_SetTime+0x120>)
900062e0:	4013      	ands	r3, r2
900062e2:	600b      	str	r3, [r1, #0]

      /* Clear the bits to be configured */
      CLEAR_BIT(RTC->CR, RTC_CR_BKP);
900062e4:	4b0e      	ldr	r3, [pc, #56]	@ (90006320 <HAL_RTC_SetTime+0x11c>)
900062e6:	699b      	ldr	r3, [r3, #24]
900062e8:	4a0d      	ldr	r2, [pc, #52]	@ (90006320 <HAL_RTC_SetTime+0x11c>)
900062ea:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
900062ee:	6193      	str	r3, [r2, #24]
    }

    /* Exit Initialization mode */
    status = RTC_ExitInitMode(hrtc);
900062f0:	68f8      	ldr	r0, [r7, #12]
900062f2:	f000 f9bd 	bl	90006670 <RTC_ExitInitMode>
900062f6:	4603      	mov	r3, r0
900062f8:	74fb      	strb	r3, [r7, #19]
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
900062fa:	4b09      	ldr	r3, [pc, #36]	@ (90006320 <HAL_RTC_SetTime+0x11c>)
900062fc:	22ff      	movs	r2, #255	@ 0xff
900062fe:	625a      	str	r2, [r3, #36]	@ 0x24

  if (status == HAL_OK)
90006300:	7cfb      	ldrb	r3, [r7, #19]
90006302:	2b00      	cmp	r3, #0
90006304:	d103      	bne.n	9000630e <HAL_RTC_SetTime+0x10a>
  {
    /* Change RTC state */
    hrtc->State = HAL_RTC_STATE_READY;
90006306:	68fb      	ldr	r3, [r7, #12]
90006308:	2201      	movs	r2, #1
9000630a:	f883 202d 	strb.w	r2, [r3, #45]	@ 0x2d
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
9000630e:	68fb      	ldr	r3, [r7, #12]
90006310:	2200      	movs	r2, #0
90006312:	f883 202c 	strb.w	r2, [r3, #44]	@ 0x2c

  return status;
90006316:	7cfb      	ldrb	r3, [r7, #19]
}
90006318:	4618      	mov	r0, r3
9000631a:	371c      	adds	r7, #28
9000631c:	46bd      	mov	sp, r7
9000631e:	bd90      	pop	{r4, r7, pc}
90006320:	58004000 	.word	0x58004000
90006324:	007f7f7f 	.word	0x007f7f7f

90006328 <HAL_RTC_GetTime>:
  *            @arg RTC_FORMAT_BIN: Binary format
  *            @arg RTC_FORMAT_BCD: BCD format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_GetTime(const RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
{
90006328:	b580      	push	{r7, lr}
9000632a:	b086      	sub	sp, #24
9000632c:	af00      	add	r7, sp, #0
9000632e:	60f8      	str	r0, [r7, #12]
90006330:	60b9      	str	r1, [r7, #8]
90006332:	607a      	str	r2, [r7, #4]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(hrtc);

  /* Get subseconds structure field from the corresponding register */
  sTime->SubSeconds = READ_REG(RTC->SSR);
90006334:	4b2b      	ldr	r3, [pc, #172]	@ (900063e4 <HAL_RTC_GetTime+0xbc>)
90006336:	689a      	ldr	r2, [r3, #8]
90006338:	68bb      	ldr	r3, [r7, #8]
9000633a:	605a      	str	r2, [r3, #4]

  if (READ_BIT(RTC->ICSR, RTC_ICSR_BIN) != RTC_BINARY_ONLY)
9000633c:	4b29      	ldr	r3, [pc, #164]	@ (900063e4 <HAL_RTC_GetTime+0xbc>)
9000633e:	68db      	ldr	r3, [r3, #12]
90006340:	f403 7340 	and.w	r3, r3, #768	@ 0x300
90006344:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
90006348:	d047      	beq.n	900063da <HAL_RTC_GetTime+0xb2>
  {
    /* Check the parameters */
    assert_param(IS_RTC_FORMAT(Format));

    /* Get SecondFraction structure field from the corresponding register field */
    sTime->SecondFraction = (uint32_t)(READ_REG(RTC->PRER) & RTC_PRER_PREDIV_S);
9000634a:	4b26      	ldr	r3, [pc, #152]	@ (900063e4 <HAL_RTC_GetTime+0xbc>)
9000634c:	691b      	ldr	r3, [r3, #16]
9000634e:	f3c3 020e 	ubfx	r2, r3, #0, #15
90006352:	68bb      	ldr	r3, [r7, #8]
90006354:	609a      	str	r2, [r3, #8]

    /* Get the TR register */
    tmpreg = (uint32_t)(READ_REG(RTC->TR) & RTC_TR_RESERVED_MASK);
90006356:	4b23      	ldr	r3, [pc, #140]	@ (900063e4 <HAL_RTC_GetTime+0xbc>)
90006358:	681a      	ldr	r2, [r3, #0]
9000635a:	4b23      	ldr	r3, [pc, #140]	@ (900063e8 <HAL_RTC_GetTime+0xc0>)
9000635c:	4013      	ands	r3, r2
9000635e:	617b      	str	r3, [r7, #20]

    /* Fill the structure fields with the read parameters */
    sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> RTC_TR_HU_Pos);
90006360:	697b      	ldr	r3, [r7, #20]
90006362:	0c1b      	lsrs	r3, r3, #16
90006364:	b2db      	uxtb	r3, r3
90006366:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
9000636a:	b2da      	uxtb	r2, r3
9000636c:	68bb      	ldr	r3, [r7, #8]
9000636e:	701a      	strb	r2, [r3, #0]
    sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >> RTC_TR_MNU_Pos);
90006370:	697b      	ldr	r3, [r7, #20]
90006372:	0a1b      	lsrs	r3, r3, #8
90006374:	b2db      	uxtb	r3, r3
90006376:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
9000637a:	b2da      	uxtb	r2, r3
9000637c:	68bb      	ldr	r3, [r7, #8]
9000637e:	705a      	strb	r2, [r3, #1]
    sTime->Seconds = (uint8_t)((tmpreg & (RTC_TR_ST | RTC_TR_SU)) >> RTC_TR_SU_Pos);
90006380:	697b      	ldr	r3, [r7, #20]
90006382:	b2db      	uxtb	r3, r3
90006384:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
90006388:	b2da      	uxtb	r2, r3
9000638a:	68bb      	ldr	r3, [r7, #8]
9000638c:	709a      	strb	r2, [r3, #2]
    sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> RTC_TR_PM_Pos);
9000638e:	697b      	ldr	r3, [r7, #20]
90006390:	0d9b      	lsrs	r3, r3, #22
90006392:	b2db      	uxtb	r3, r3
90006394:	f003 0301 	and.w	r3, r3, #1
90006398:	b2da      	uxtb	r2, r3
9000639a:	68bb      	ldr	r3, [r7, #8]
9000639c:	70da      	strb	r2, [r3, #3]

    /* Check the input parameters format */
    if (Format == RTC_FORMAT_BIN)
9000639e:	687b      	ldr	r3, [r7, #4]
900063a0:	2b00      	cmp	r3, #0
900063a2:	d11a      	bne.n	900063da <HAL_RTC_GetTime+0xb2>
    {
      /* Convert the time structure parameters to Binary format */
      sTime->Hours = (uint8_t)RTC_Bcd2ToByte(sTime->Hours);
900063a4:	68bb      	ldr	r3, [r7, #8]
900063a6:	781b      	ldrb	r3, [r3, #0]
900063a8:	4618      	mov	r0, r3
900063aa:	f000 f9bf 	bl	9000672c <RTC_Bcd2ToByte>
900063ae:	4603      	mov	r3, r0
900063b0:	461a      	mov	r2, r3
900063b2:	68bb      	ldr	r3, [r7, #8]
900063b4:	701a      	strb	r2, [r3, #0]
      sTime->Minutes = (uint8_t)RTC_Bcd2ToByte(sTime->Minutes);
900063b6:	68bb      	ldr	r3, [r7, #8]
900063b8:	785b      	ldrb	r3, [r3, #1]
900063ba:	4618      	mov	r0, r3
900063bc:	f000 f9b6 	bl	9000672c <RTC_Bcd2ToByte>
900063c0:	4603      	mov	r3, r0
900063c2:	461a      	mov	r2, r3
900063c4:	68bb      	ldr	r3, [r7, #8]
900063c6:	705a      	strb	r2, [r3, #1]
      sTime->Seconds = (uint8_t)RTC_Bcd2ToByte(sTime->Seconds);
900063c8:	68bb      	ldr	r3, [r7, #8]
900063ca:	789b      	ldrb	r3, [r3, #2]
900063cc:	4618      	mov	r0, r3
900063ce:	f000 f9ad 	bl	9000672c <RTC_Bcd2ToByte>
900063d2:	4603      	mov	r3, r0
900063d4:	461a      	mov	r2, r3
900063d6:	68bb      	ldr	r3, [r7, #8]
900063d8:	709a      	strb	r2, [r3, #2]
    }
  }

  return HAL_OK;
900063da:	2300      	movs	r3, #0
}
900063dc:	4618      	mov	r0, r3
900063de:	3718      	adds	r7, #24
900063e0:	46bd      	mov	sp, r7
900063e2:	bd80      	pop	{r7, pc}
900063e4:	58004000 	.word	0x58004000
900063e8:	007f7f7f 	.word	0x007f7f7f

900063ec <HAL_RTC_SetDate>:
  *            @arg RTC_FORMAT_BIN: Binary format
  *            @arg RTC_FORMAT_BCD: BCD format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
{
900063ec:	b590      	push	{r4, r7, lr}
900063ee:	b087      	sub	sp, #28
900063f0:	af00      	add	r7, sp, #0
900063f2:	60f8      	str	r0, [r7, #12]
900063f4:	60b9      	str	r1, [r7, #8]
900063f6:	607a      	str	r2, [r7, #4]

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));

  /* Process Locked */
  __HAL_LOCK(hrtc);
900063f8:	68fb      	ldr	r3, [r7, #12]
900063fa:	f893 302c 	ldrb.w	r3, [r3, #44]	@ 0x2c
900063fe:	2b01      	cmp	r3, #1
90006400:	d101      	bne.n	90006406 <HAL_RTC_SetDate+0x1a>
90006402:	2302      	movs	r3, #2
90006404:	e06f      	b.n	900064e6 <HAL_RTC_SetDate+0xfa>
90006406:	68fb      	ldr	r3, [r7, #12]
90006408:	2201      	movs	r2, #1
9000640a:	f883 202c 	strb.w	r2, [r3, #44]	@ 0x2c

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_BUSY;
9000640e:	68fb      	ldr	r3, [r7, #12]
90006410:	2202      	movs	r2, #2
90006412:	f883 202d 	strb.w	r2, [r3, #45]	@ 0x2d

  if ((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
90006416:	687b      	ldr	r3, [r7, #4]
90006418:	2b00      	cmp	r3, #0
9000641a:	d10e      	bne.n	9000643a <HAL_RTC_SetDate+0x4e>
9000641c:	68bb      	ldr	r3, [r7, #8]
9000641e:	785b      	ldrb	r3, [r3, #1]
90006420:	f003 0310 	and.w	r3, r3, #16
90006424:	2b00      	cmp	r3, #0
90006426:	d008      	beq.n	9000643a <HAL_RTC_SetDate+0x4e>
  {
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
90006428:	68bb      	ldr	r3, [r7, #8]
9000642a:	785b      	ldrb	r3, [r3, #1]
9000642c:	f023 0310 	bic.w	r3, r3, #16
90006430:	b2db      	uxtb	r3, r3
90006432:	330a      	adds	r3, #10
90006434:	b2da      	uxtb	r2, r3
90006436:	68bb      	ldr	r3, [r7, #8]
90006438:	705a      	strb	r2, [r3, #1]
  }

  assert_param(IS_RTC_WEEKDAY(sDate->WeekDay));

  if (Format == RTC_FORMAT_BIN)
9000643a:	687b      	ldr	r3, [r7, #4]
9000643c:	2b00      	cmp	r3, #0
9000643e:	d11c      	bne.n	9000647a <HAL_RTC_SetDate+0x8e>
  {
    assert_param(IS_RTC_YEAR(sDate->Year));
    assert_param(IS_RTC_MONTH(sDate->Month));
    assert_param(IS_RTC_DATE(sDate->Date));

    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << RTC_DR_YU_Pos) | \
90006440:	68bb      	ldr	r3, [r7, #8]
90006442:	78db      	ldrb	r3, [r3, #3]
90006444:	4618      	mov	r0, r3
90006446:	f000 f951 	bl	900066ec <RTC_ByteToBcd2>
9000644a:	4603      	mov	r3, r0
9000644c:	041c      	lsls	r4, r3, #16
                  ((uint32_t)RTC_ByteToBcd2(sDate->Month) << RTC_DR_MU_Pos) | \
9000644e:	68bb      	ldr	r3, [r7, #8]
90006450:	785b      	ldrb	r3, [r3, #1]
90006452:	4618      	mov	r0, r3
90006454:	f000 f94a 	bl	900066ec <RTC_ByteToBcd2>
90006458:	4603      	mov	r3, r0
9000645a:	021b      	lsls	r3, r3, #8
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << RTC_DR_YU_Pos) | \
9000645c:	431c      	orrs	r4, r3
                  ((uint32_t)RTC_ByteToBcd2(sDate->Date) << RTC_DR_DU_Pos) | \
9000645e:	68bb      	ldr	r3, [r7, #8]
90006460:	789b      	ldrb	r3, [r3, #2]
90006462:	4618      	mov	r0, r3
90006464:	f000 f942 	bl	900066ec <RTC_ByteToBcd2>
90006468:	4603      	mov	r3, r0
                  ((uint32_t)RTC_ByteToBcd2(sDate->Month) << RTC_DR_MU_Pos) | \
9000646a:	ea44 0203 	orr.w	r2, r4, r3
                  ((uint32_t)sDate->WeekDay << RTC_DR_WDU_Pos));
9000646e:	68bb      	ldr	r3, [r7, #8]
90006470:	781b      	ldrb	r3, [r3, #0]
90006472:	035b      	lsls	r3, r3, #13
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << RTC_DR_YU_Pos) | \
90006474:	4313      	orrs	r3, r2
90006476:	617b      	str	r3, [r7, #20]
90006478:	e00e      	b.n	90006498 <HAL_RTC_SetDate+0xac>
  {
    assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(sDate->Year)));
    assert_param(IS_RTC_MONTH(RTC_Bcd2ToByte(sDate->Month)));
    assert_param(IS_RTC_DATE(RTC_Bcd2ToByte(sDate->Date)));

    datetmpreg = ((((uint32_t)sDate->Year) << RTC_DR_YU_Pos) | \
9000647a:	68bb      	ldr	r3, [r7, #8]
9000647c:	78db      	ldrb	r3, [r3, #3]
9000647e:	041a      	lsls	r2, r3, #16
                  (((uint32_t)sDate->Month) << RTC_DR_MU_Pos) | \
90006480:	68bb      	ldr	r3, [r7, #8]
90006482:	785b      	ldrb	r3, [r3, #1]
90006484:	021b      	lsls	r3, r3, #8
    datetmpreg = ((((uint32_t)sDate->Year) << RTC_DR_YU_Pos) | \
90006486:	4313      	orrs	r3, r2
                  (((uint32_t)sDate->Date) << RTC_DR_DU_Pos) | \
90006488:	68ba      	ldr	r2, [r7, #8]
9000648a:	7892      	ldrb	r2, [r2, #2]
                  (((uint32_t)sDate->Month) << RTC_DR_MU_Pos) | \
9000648c:	431a      	orrs	r2, r3
                  (((uint32_t)sDate->WeekDay) << RTC_DR_WDU_Pos));
9000648e:	68bb      	ldr	r3, [r7, #8]
90006490:	781b      	ldrb	r3, [r3, #0]
90006492:	035b      	lsls	r3, r3, #13
    datetmpreg = ((((uint32_t)sDate->Year) << RTC_DR_YU_Pos) | \
90006494:	4313      	orrs	r3, r2
90006496:	617b      	str	r3, [r7, #20]
  }

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
90006498:	4b15      	ldr	r3, [pc, #84]	@ (900064f0 <HAL_RTC_SetDate+0x104>)
9000649a:	22ca      	movs	r2, #202	@ 0xca
9000649c:	625a      	str	r2, [r3, #36]	@ 0x24
9000649e:	4b14      	ldr	r3, [pc, #80]	@ (900064f0 <HAL_RTC_SetDate+0x104>)
900064a0:	2253      	movs	r2, #83	@ 0x53
900064a2:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Enter Initialization mode */
  status = RTC_EnterInitMode(hrtc);
900064a4:	68f8      	ldr	r0, [r7, #12]
900064a6:	f000 f8a7 	bl	900065f8 <RTC_EnterInitMode>
900064aa:	4603      	mov	r3, r0
900064ac:	74fb      	strb	r3, [r7, #19]
  if (status == HAL_OK)
900064ae:	7cfb      	ldrb	r3, [r7, #19]
900064b0:	2b00      	cmp	r3, #0
900064b2:	d109      	bne.n	900064c8 <HAL_RTC_SetDate+0xdc>
  {
    /* Set the RTC_DR register */
    WRITE_REG(RTC->DR, (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK));
900064b4:	490e      	ldr	r1, [pc, #56]	@ (900064f0 <HAL_RTC_SetDate+0x104>)
900064b6:	697a      	ldr	r2, [r7, #20]
900064b8:	4b0e      	ldr	r3, [pc, #56]	@ (900064f4 <HAL_RTC_SetDate+0x108>)
900064ba:	4013      	ands	r3, r2
900064bc:	604b      	str	r3, [r1, #4]

    /* Exit Initialization mode */
    status = RTC_ExitInitMode(hrtc);
900064be:	68f8      	ldr	r0, [r7, #12]
900064c0:	f000 f8d6 	bl	90006670 <RTC_ExitInitMode>
900064c4:	4603      	mov	r3, r0
900064c6:	74fb      	strb	r3, [r7, #19]
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
900064c8:	4b09      	ldr	r3, [pc, #36]	@ (900064f0 <HAL_RTC_SetDate+0x104>)
900064ca:	22ff      	movs	r2, #255	@ 0xff
900064cc:	625a      	str	r2, [r3, #36]	@ 0x24

  if (status == HAL_OK)
900064ce:	7cfb      	ldrb	r3, [r7, #19]
900064d0:	2b00      	cmp	r3, #0
900064d2:	d103      	bne.n	900064dc <HAL_RTC_SetDate+0xf0>
  {
    /* Change RTC state */
    hrtc->State = HAL_RTC_STATE_READY;
900064d4:	68fb      	ldr	r3, [r7, #12]
900064d6:	2201      	movs	r2, #1
900064d8:	f883 202d 	strb.w	r2, [r3, #45]	@ 0x2d
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
900064dc:	68fb      	ldr	r3, [r7, #12]
900064de:	2200      	movs	r2, #0
900064e0:	f883 202c 	strb.w	r2, [r3, #44]	@ 0x2c

  return status;
900064e4:	7cfb      	ldrb	r3, [r7, #19]
}
900064e6:	4618      	mov	r0, r3
900064e8:	371c      	adds	r7, #28
900064ea:	46bd      	mov	sp, r7
900064ec:	bd90      	pop	{r4, r7, pc}
900064ee:	bf00      	nop
900064f0:	58004000 	.word	0x58004000
900064f4:	00ffff3f 	.word	0x00ffff3f

900064f8 <HAL_RTC_GetDate>:
  *            @arg RTC_FORMAT_BIN: Binary format
  *            @arg RTC_FORMAT_BCD: BCD format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_GetDate(const RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
{
900064f8:	b580      	push	{r7, lr}
900064fa:	b086      	sub	sp, #24
900064fc:	af00      	add	r7, sp, #0
900064fe:	60f8      	str	r0, [r7, #12]
90006500:	60b9      	str	r1, [r7, #8]
90006502:	607a      	str	r2, [r7, #4]

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));

  /* Get the DR register */
  datetmpreg = (uint32_t)(READ_REG(RTC->DR) & RTC_DR_RESERVED_MASK);
90006504:	4b21      	ldr	r3, [pc, #132]	@ (9000658c <HAL_RTC_GetDate+0x94>)
90006506:	685a      	ldr	r2, [r3, #4]
90006508:	4b21      	ldr	r3, [pc, #132]	@ (90006590 <HAL_RTC_GetDate+0x98>)
9000650a:	4013      	ands	r3, r2
9000650c:	617b      	str	r3, [r7, #20]

  /* Fill the structure fields with the read parameters */
  sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> RTC_DR_YU_Pos);
9000650e:	697b      	ldr	r3, [r7, #20]
90006510:	0c1b      	lsrs	r3, r3, #16
90006512:	b2da      	uxtb	r2, r3
90006514:	68bb      	ldr	r3, [r7, #8]
90006516:	70da      	strb	r2, [r3, #3]
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> RTC_DR_MU_Pos);
90006518:	697b      	ldr	r3, [r7, #20]
9000651a:	0a1b      	lsrs	r3, r3, #8
9000651c:	b2db      	uxtb	r3, r3
9000651e:	f003 031f 	and.w	r3, r3, #31
90006522:	b2da      	uxtb	r2, r3
90006524:	68bb      	ldr	r3, [r7, #8]
90006526:	705a      	strb	r2, [r3, #1]
  sDate->Date = (uint8_t)((datetmpreg & (RTC_DR_DT | RTC_DR_DU)) >> RTC_DR_DU_Pos);
90006528:	697b      	ldr	r3, [r7, #20]
9000652a:	b2db      	uxtb	r3, r3
9000652c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
90006530:	b2da      	uxtb	r2, r3
90006532:	68bb      	ldr	r3, [r7, #8]
90006534:	709a      	strb	r2, [r3, #2]
  sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> RTC_DR_WDU_Pos);
90006536:	697b      	ldr	r3, [r7, #20]
90006538:	0b5b      	lsrs	r3, r3, #13
9000653a:	b2db      	uxtb	r3, r3
9000653c:	f003 0307 	and.w	r3, r3, #7
90006540:	b2da      	uxtb	r2, r3
90006542:	68bb      	ldr	r3, [r7, #8]
90006544:	701a      	strb	r2, [r3, #0]

  /* Check the input parameters format */
  if (Format == RTC_FORMAT_BIN)
90006546:	687b      	ldr	r3, [r7, #4]
90006548:	2b00      	cmp	r3, #0
9000654a:	d11a      	bne.n	90006582 <HAL_RTC_GetDate+0x8a>
  {
    /* Convert the date structure parameters to Binary format */
    sDate->Year = (uint8_t)RTC_Bcd2ToByte(sDate->Year);
9000654c:	68bb      	ldr	r3, [r7, #8]
9000654e:	78db      	ldrb	r3, [r3, #3]
90006550:	4618      	mov	r0, r3
90006552:	f000 f8eb 	bl	9000672c <RTC_Bcd2ToByte>
90006556:	4603      	mov	r3, r0
90006558:	461a      	mov	r2, r3
9000655a:	68bb      	ldr	r3, [r7, #8]
9000655c:	70da      	strb	r2, [r3, #3]
    sDate->Month = (uint8_t)RTC_Bcd2ToByte(sDate->Month);
9000655e:	68bb      	ldr	r3, [r7, #8]
90006560:	785b      	ldrb	r3, [r3, #1]
90006562:	4618      	mov	r0, r3
90006564:	f000 f8e2 	bl	9000672c <RTC_Bcd2ToByte>
90006568:	4603      	mov	r3, r0
9000656a:	461a      	mov	r2, r3
9000656c:	68bb      	ldr	r3, [r7, #8]
9000656e:	705a      	strb	r2, [r3, #1]
    sDate->Date = (uint8_t)RTC_Bcd2ToByte(sDate->Date);
90006570:	68bb      	ldr	r3, [r7, #8]
90006572:	789b      	ldrb	r3, [r3, #2]
90006574:	4618      	mov	r0, r3
90006576:	f000 f8d9 	bl	9000672c <RTC_Bcd2ToByte>
9000657a:	4603      	mov	r3, r0
9000657c:	461a      	mov	r2, r3
9000657e:	68bb      	ldr	r3, [r7, #8]
90006580:	709a      	strb	r2, [r3, #2]
  }
  return HAL_OK;
90006582:	2300      	movs	r3, #0
}
90006584:	4618      	mov	r0, r3
90006586:	3718      	adds	r7, #24
90006588:	46bd      	mov	sp, r7
9000658a:	bd80      	pop	{r7, pc}
9000658c:	58004000 	.word	0x58004000
90006590:	00ffff3f 	.word	0x00ffff3f

90006594 <HAL_RTC_WaitForSynchro>:
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
{
90006594:	b580      	push	{r7, lr}
90006596:	b084      	sub	sp, #16
90006598:	af00      	add	r7, sp, #0
9000659a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Clear RSF flag */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_RSF);
9000659c:	4b15      	ldr	r3, [pc, #84]	@ (900065f4 <HAL_RTC_WaitForSynchro+0x60>)
9000659e:	68db      	ldr	r3, [r3, #12]
900065a0:	4a14      	ldr	r2, [pc, #80]	@ (900065f4 <HAL_RTC_WaitForSynchro+0x60>)
900065a2:	f023 0320 	bic.w	r3, r3, #32
900065a6:	60d3      	str	r3, [r2, #12]

  tickstart = HAL_GetTick();
900065a8:	f7fb f88c 	bl	900016c4 <HAL_GetTick>
900065ac:	60f8      	str	r0, [r7, #12]

  /* Wait the registers to be synchronised */
  while (READ_BIT(RTC->ICSR, RTC_ICSR_RSF) == 0U)
900065ae:	e013      	b.n	900065d8 <HAL_RTC_WaitForSynchro+0x44>
  {
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
900065b0:	f7fb f888 	bl	900016c4 <HAL_GetTick>
900065b4:	4602      	mov	r2, r0
900065b6:	68fb      	ldr	r3, [r7, #12]
900065b8:	1ad3      	subs	r3, r2, r3
900065ba:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
900065be:	d90b      	bls.n	900065d8 <HAL_RTC_WaitForSynchro+0x44>
    {
      /* New check to avoid false timeout detection in case of preemption */
      if (READ_BIT(RTC->ICSR, RTC_ICSR_RSF) == 0U)
900065c0:	4b0c      	ldr	r3, [pc, #48]	@ (900065f4 <HAL_RTC_WaitForSynchro+0x60>)
900065c2:	68db      	ldr	r3, [r3, #12]
900065c4:	f003 0320 	and.w	r3, r3, #32
900065c8:	2b00      	cmp	r3, #0
900065ca:	d10c      	bne.n	900065e6 <HAL_RTC_WaitForSynchro+0x52>
      {
        /* Change RTC state */
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
900065cc:	687b      	ldr	r3, [r7, #4]
900065ce:	2203      	movs	r2, #3
900065d0:	f883 202d 	strb.w	r2, [r3, #45]	@ 0x2d
        return HAL_TIMEOUT;
900065d4:	2303      	movs	r3, #3
900065d6:	e008      	b.n	900065ea <HAL_RTC_WaitForSynchro+0x56>
  while (READ_BIT(RTC->ICSR, RTC_ICSR_RSF) == 0U)
900065d8:	4b06      	ldr	r3, [pc, #24]	@ (900065f4 <HAL_RTC_WaitForSynchro+0x60>)
900065da:	68db      	ldr	r3, [r3, #12]
900065dc:	f003 0320 	and.w	r3, r3, #32
900065e0:	2b00      	cmp	r3, #0
900065e2:	d0e5      	beq.n	900065b0 <HAL_RTC_WaitForSynchro+0x1c>
900065e4:	e000      	b.n	900065e8 <HAL_RTC_WaitForSynchro+0x54>
      }
      else
      {
        break;
900065e6:	bf00      	nop
      }
    }
  }

  return HAL_OK;
900065e8:	2300      	movs	r3, #0
}
900065ea:	4618      	mov	r0, r3
900065ec:	3710      	adds	r7, #16
900065ee:	46bd      	mov	sp, r7
900065f0:	bd80      	pop	{r7, pc}
900065f2:	bf00      	nop
900065f4:	58004000 	.word	0x58004000

900065f8 <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
{
900065f8:	b580      	push	{r7, lr}
900065fa:	b084      	sub	sp, #16
900065fc:	af00      	add	r7, sp, #0
900065fe:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
90006600:	2300      	movs	r3, #0
90006602:	73fb      	strb	r3, [r7, #15]

  /* Check if the Initialization mode is set */
  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
90006604:	4b19      	ldr	r3, [pc, #100]	@ (9000666c <RTC_EnterInitMode+0x74>)
90006606:	68db      	ldr	r3, [r3, #12]
90006608:	f003 0340 	and.w	r3, r3, #64	@ 0x40
9000660c:	2b00      	cmp	r3, #0
9000660e:	d128      	bne.n	90006662 <RTC_EnterInitMode+0x6a>
  {
    /* Set the Initialization mode */
    SET_BIT(RTC->ICSR, RTC_ICSR_INIT);
90006610:	4b16      	ldr	r3, [pc, #88]	@ (9000666c <RTC_EnterInitMode+0x74>)
90006612:	68db      	ldr	r3, [r3, #12]
90006614:	4a15      	ldr	r2, [pc, #84]	@ (9000666c <RTC_EnterInitMode+0x74>)
90006616:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
9000661a:	60d3      	str	r3, [r2, #12]

    tickstart = HAL_GetTick();
9000661c:	f7fb f852 	bl	900016c4 <HAL_GetTick>
90006620:	60b8      	str	r0, [r7, #8]
    /* Wait till RTC is in INIT state and if Time out is reached exit */
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
90006622:	e013      	b.n	9000664c <RTC_EnterInitMode+0x54>
    {
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
90006624:	f7fb f84e 	bl	900016c4 <HAL_GetTick>
90006628:	4602      	mov	r2, r0
9000662a:	68bb      	ldr	r3, [r7, #8]
9000662c:	1ad3      	subs	r3, r2, r3
9000662e:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
90006632:	d90b      	bls.n	9000664c <RTC_EnterInitMode+0x54>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
90006634:	4b0d      	ldr	r3, [pc, #52]	@ (9000666c <RTC_EnterInitMode+0x74>)
90006636:	68db      	ldr	r3, [r3, #12]
90006638:	f003 0340 	and.w	r3, r3, #64	@ 0x40
9000663c:	2b00      	cmp	r3, #0
9000663e:	d10f      	bne.n	90006660 <RTC_EnterInitMode+0x68>
        {
          status = HAL_TIMEOUT;
90006640:	2303      	movs	r3, #3
90006642:	73fb      	strb	r3, [r7, #15]

          /* Change RTC state */
          hrtc->State = HAL_RTC_STATE_TIMEOUT;
90006644:	687b      	ldr	r3, [r7, #4]
90006646:	2203      	movs	r2, #3
90006648:	f883 202d 	strb.w	r2, [r3, #45]	@ 0x2d
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
9000664c:	4b07      	ldr	r3, [pc, #28]	@ (9000666c <RTC_EnterInitMode+0x74>)
9000664e:	68db      	ldr	r3, [r3, #12]
90006650:	f003 0340 	and.w	r3, r3, #64	@ 0x40
90006654:	2b00      	cmp	r3, #0
90006656:	d104      	bne.n	90006662 <RTC_EnterInitMode+0x6a>
90006658:	7bfb      	ldrb	r3, [r7, #15]
9000665a:	2b03      	cmp	r3, #3
9000665c:	d1e2      	bne.n	90006624 <RTC_EnterInitMode+0x2c>
9000665e:	e000      	b.n	90006662 <RTC_EnterInitMode+0x6a>
        }
        else
        {
          break;
90006660:	bf00      	nop
        }
      }
    }
  }

  return status;
90006662:	7bfb      	ldrb	r3, [r7, #15]
}
90006664:	4618      	mov	r0, r3
90006666:	3710      	adds	r7, #16
90006668:	46bd      	mov	sp, r7
9000666a:	bd80      	pop	{r7, pc}
9000666c:	58004000 	.word	0x58004000

90006670 <RTC_ExitInitMode>:
  * @brief  Exit the RTC Initialization mode.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
{
90006670:	b580      	push	{r7, lr}
90006672:	b084      	sub	sp, #16
90006674:	af00      	add	r7, sp, #0
90006676:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
90006678:	2300      	movs	r3, #0
9000667a:	73fb      	strb	r3, [r7, #15]

  /* Exit Initialization mode */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
9000667c:	4b1a      	ldr	r3, [pc, #104]	@ (900066e8 <RTC_ExitInitMode+0x78>)
9000667e:	68db      	ldr	r3, [r3, #12]
90006680:	4a19      	ldr	r2, [pc, #100]	@ (900066e8 <RTC_ExitInitMode+0x78>)
90006682:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
90006686:	60d3      	str	r3, [r2, #12]

  /* If CR_BYPSHAD bit = 0, wait for synchro */
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
90006688:	4b17      	ldr	r3, [pc, #92]	@ (900066e8 <RTC_ExitInitMode+0x78>)
9000668a:	699b      	ldr	r3, [r3, #24]
9000668c:	f003 0320 	and.w	r3, r3, #32
90006690:	2b00      	cmp	r3, #0
90006692:	d10c      	bne.n	900066ae <RTC_ExitInitMode+0x3e>
  {
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
90006694:	6878      	ldr	r0, [r7, #4]
90006696:	f7ff ff7d 	bl	90006594 <HAL_RTC_WaitForSynchro>
9000669a:	4603      	mov	r3, r0
9000669c:	2b00      	cmp	r3, #0
9000669e:	d01e      	beq.n	900066de <RTC_ExitInitMode+0x6e>
    {
      /* Change RTC state */
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
900066a0:	687b      	ldr	r3, [r7, #4]
900066a2:	2203      	movs	r2, #3
900066a4:	f883 202d 	strb.w	r2, [r3, #45]	@ 0x2d
      status = HAL_TIMEOUT;
900066a8:	2303      	movs	r3, #3
900066aa:	73fb      	strb	r3, [r7, #15]
900066ac:	e017      	b.n	900066de <RTC_ExitInitMode+0x6e>
    }
  }
  else /* WA 2.9.6 Calendar initialization may fail in case of consecutive INIT mode entry. */
  {
    /* Clear BYPSHAD bit */
    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
900066ae:	4b0e      	ldr	r3, [pc, #56]	@ (900066e8 <RTC_ExitInitMode+0x78>)
900066b0:	699b      	ldr	r3, [r3, #24]
900066b2:	4a0d      	ldr	r2, [pc, #52]	@ (900066e8 <RTC_ExitInitMode+0x78>)
900066b4:	f023 0320 	bic.w	r3, r3, #32
900066b8:	6193      	str	r3, [r2, #24]
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
900066ba:	6878      	ldr	r0, [r7, #4]
900066bc:	f7ff ff6a 	bl	90006594 <HAL_RTC_WaitForSynchro>
900066c0:	4603      	mov	r3, r0
900066c2:	2b00      	cmp	r3, #0
900066c4:	d005      	beq.n	900066d2 <RTC_ExitInitMode+0x62>
    {
      /* Change RTC state */
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
900066c6:	687b      	ldr	r3, [r7, #4]
900066c8:	2203      	movs	r2, #3
900066ca:	f883 202d 	strb.w	r2, [r3, #45]	@ 0x2d
      status = HAL_TIMEOUT;
900066ce:	2303      	movs	r3, #3
900066d0:	73fb      	strb	r3, [r7, #15]
    }
    /* Restore BYPSHAD bit */
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
900066d2:	4b05      	ldr	r3, [pc, #20]	@ (900066e8 <RTC_ExitInitMode+0x78>)
900066d4:	699b      	ldr	r3, [r3, #24]
900066d6:	4a04      	ldr	r2, [pc, #16]	@ (900066e8 <RTC_ExitInitMode+0x78>)
900066d8:	f043 0320 	orr.w	r3, r3, #32
900066dc:	6193      	str	r3, [r2, #24]
  }
  return status;
900066de:	7bfb      	ldrb	r3, [r7, #15]
}
900066e0:	4618      	mov	r0, r3
900066e2:	3710      	adds	r7, #16
900066e4:	46bd      	mov	sp, r7
900066e6:	bd80      	pop	{r7, pc}
900066e8:	58004000 	.word	0x58004000

900066ec <RTC_ByteToBcd2>:
  * @brief  Convert a 2 digit decimal to BCD format.
  * @param  Value Byte to be converted
  * @retval Converted byte
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
900066ec:	b480      	push	{r7}
900066ee:	b085      	sub	sp, #20
900066f0:	af00      	add	r7, sp, #0
900066f2:	4603      	mov	r3, r0
900066f4:	71fb      	strb	r3, [r7, #7]
  uint32_t bcd_high = 0U;
900066f6:	2300      	movs	r3, #0
900066f8:	60fb      	str	r3, [r7, #12]
  uint8_t tmp_value = Value;
900066fa:	79fb      	ldrb	r3, [r7, #7]
900066fc:	72fb      	strb	r3, [r7, #11]

  while (tmp_value >= 10U)
900066fe:	e005      	b.n	9000670c <RTC_ByteToBcd2+0x20>
  {
    bcd_high++;
90006700:	68fb      	ldr	r3, [r7, #12]
90006702:	3301      	adds	r3, #1
90006704:	60fb      	str	r3, [r7, #12]
    tmp_value -= 10U;
90006706:	7afb      	ldrb	r3, [r7, #11]
90006708:	3b0a      	subs	r3, #10
9000670a:	72fb      	strb	r3, [r7, #11]
  while (tmp_value >= 10U)
9000670c:	7afb      	ldrb	r3, [r7, #11]
9000670e:	2b09      	cmp	r3, #9
90006710:	d8f6      	bhi.n	90006700 <RTC_ByteToBcd2+0x14>
  }

  return ((uint8_t)(bcd_high << 4U) | tmp_value);
90006712:	68fb      	ldr	r3, [r7, #12]
90006714:	b2db      	uxtb	r3, r3
90006716:	011b      	lsls	r3, r3, #4
90006718:	b2da      	uxtb	r2, r3
9000671a:	7afb      	ldrb	r3, [r7, #11]
9000671c:	4313      	orrs	r3, r2
9000671e:	b2db      	uxtb	r3, r3
}
90006720:	4618      	mov	r0, r3
90006722:	3714      	adds	r7, #20
90006724:	46bd      	mov	sp, r7
90006726:	f85d 7b04 	ldr.w	r7, [sp], #4
9000672a:	4770      	bx	lr

9000672c <RTC_Bcd2ToByte>:
  * @brief  Convert from 2 digit BCD to Binary.
  * @param  Value BCD value to be converted
  * @retval Converted word
  */
uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
9000672c:	b480      	push	{r7}
9000672e:	b085      	sub	sp, #20
90006730:	af00      	add	r7, sp, #0
90006732:	4603      	mov	r3, r0
90006734:	71fb      	strb	r3, [r7, #7]
  uint32_t tmp;

  tmp = (((uint32_t)Value & 0xF0U) >> 4) * 10U;
90006736:	79fb      	ldrb	r3, [r7, #7]
90006738:	091b      	lsrs	r3, r3, #4
9000673a:	b2db      	uxtb	r3, r3
9000673c:	461a      	mov	r2, r3
9000673e:	4613      	mov	r3, r2
90006740:	009b      	lsls	r3, r3, #2
90006742:	4413      	add	r3, r2
90006744:	005b      	lsls	r3, r3, #1
90006746:	60fb      	str	r3, [r7, #12]

  return (uint8_t)(tmp + ((uint32_t)Value & 0x0FU));
90006748:	68fb      	ldr	r3, [r7, #12]
9000674a:	b2da      	uxtb	r2, r3
9000674c:	79fb      	ldrb	r3, [r7, #7]
9000674e:	f003 030f 	and.w	r3, r3, #15
90006752:	b2db      	uxtb	r3, r3
90006754:	4413      	add	r3, r2
90006756:	b2db      	uxtb	r3, r3
}
90006758:	4618      	mov	r0, r3
9000675a:	3714      	adds	r7, #20
9000675c:	46bd      	mov	sp, r7
9000675e:	f85d 7b04 	ldr.w	r7, [sp], #4
90006762:	4770      	bx	lr

90006764 <HAL_RTCEx_PrivilegeModeSet>:
  * @param  privilegeState  Privilege state
  * @retval HAL_StatusTypeDef
  */
HAL_StatusTypeDef HAL_RTCEx_PrivilegeModeSet(const RTC_HandleTypeDef *hrtc,
                                             const RTC_PrivilegeStateTypeDef *privilegeState)
{
90006764:	b480      	push	{r7}
90006766:	b083      	sub	sp, #12
90006768:	af00      	add	r7, sp, #0
9000676a:	6078      	str	r0, [r7, #4]
9000676c:	6039      	str	r1, [r7, #0]
  assert_param(IS_RTC_PRIVILEGE_BKUP_ZONE(privilegeState->backupRegisterPrivZone));
  assert_param(IS_RTC_BKP(privilegeState->backupRegisterStartZone2));
  assert_param(IS_RTC_BKP(privilegeState->backupRegisterStartZone3));

  /* RTC privilege configuration */
  WRITE_REG(RTC->PRIVCFGR, privilegeState->rtcPrivilegeFull | privilegeState->rtcPrivilegeFeatures);
9000676e:	683b      	ldr	r3, [r7, #0]
90006770:	681a      	ldr	r2, [r3, #0]
90006772:	683b      	ldr	r3, [r7, #0]
90006774:	685b      	ldr	r3, [r3, #4]
90006776:	4910      	ldr	r1, [pc, #64]	@ (900067b8 <HAL_RTCEx_PrivilegeModeSet+0x54>)
90006778:	4313      	orrs	r3, r2
9000677a:	61cb      	str	r3, [r1, #28]

  /* TAMP, Monotonic counter and Backup registers privilege configuration */
  WRITE_REG(TAMP->PRIVCFGR, privilegeState->tampPrivilegeFull | privilegeState->backupRegisterPrivZone | \
9000677c:	683b      	ldr	r3, [r7, #0]
9000677e:	689a      	ldr	r2, [r3, #8]
90006780:	683b      	ldr	r3, [r7, #0]
90006782:	68db      	ldr	r3, [r3, #12]
90006784:	431a      	orrs	r2, r3
90006786:	683b      	ldr	r3, [r7, #0]
90006788:	699b      	ldr	r3, [r3, #24]
9000678a:	490c      	ldr	r1, [pc, #48]	@ (900067bc <HAL_RTCEx_PrivilegeModeSet+0x58>)
9000678c:	4313      	orrs	r3, r2
9000678e:	624b      	str	r3, [r1, #36]	@ 0x24
            privilegeState->MonotonicCounterPrivilege);

  /* Backup register start zone */
  MODIFY_REG(TAMP->CFGR,
90006790:	4b0a      	ldr	r3, [pc, #40]	@ (900067bc <HAL_RTCEx_PrivilegeModeSet+0x58>)
90006792:	6a1b      	ldr	r3, [r3, #32]
90006794:	f003 22ff 	and.w	r2, r3, #4278255360	@ 0xff00ff00
90006798:	683b      	ldr	r3, [r7, #0]
9000679a:	6919      	ldr	r1, [r3, #16]
9000679c:	683b      	ldr	r3, [r7, #0]
9000679e:	695b      	ldr	r3, [r3, #20]
900067a0:	041b      	lsls	r3, r3, #16
900067a2:	430b      	orrs	r3, r1
900067a4:	4905      	ldr	r1, [pc, #20]	@ (900067bc <HAL_RTCEx_PrivilegeModeSet+0x58>)
900067a6:	4313      	orrs	r3, r2
900067a8:	620b      	str	r3, [r1, #32]
             (TAMP_CFGR_BKPRW | TAMP_CFGR_BKPW),
             ((privilegeState->backupRegisterStartZone2 << TAMP_CFGR_BKPRW_Pos) | (privilegeState->backupRegisterStartZone3 << TAMP_CFGR_BKPW_Pos)));

  return HAL_OK;
900067aa:	2300      	movs	r3, #0
}
900067ac:	4618      	mov	r0, r3
900067ae:	370c      	adds	r7, #12
900067b0:	46bd      	mov	sp, r7
900067b2:	f85d 7b04 	ldr.w	r7, [sp], #4
900067b6:	4770      	bx	lr
900067b8:	58004000 	.word	0x58004000
900067bc:	58004400 	.word	0x58004400

900067c0 <HAL_SD_Init>:
            SD_HandleTypeDef and create the associated handle.
  * @param  hsd: Pointer to the SD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_Init(SD_HandleTypeDef *hsd)
{
900067c0:	b580      	push	{r7, lr}
900067c2:	b08a      	sub	sp, #40	@ 0x28
900067c4:	af00      	add	r7, sp, #0
900067c6:	6078      	str	r0, [r7, #4]
  uint32_t speedgrade;
  uint32_t unitsize;
  uint32_t tickstart;

  /* Check the SD handle allocation */
  if (hsd == NULL)
900067c8:	687b      	ldr	r3, [r7, #4]
900067ca:	2b00      	cmp	r3, #0
900067cc:	d101      	bne.n	900067d2 <HAL_SD_Init+0x12>
  {
    return HAL_ERROR;
900067ce:	2301      	movs	r3, #1
900067d0:	e075      	b.n	900068be <HAL_SD_Init+0xfe>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));

  if (hsd->State == HAL_SD_STATE_RESET)
900067d2:	687b      	ldr	r3, [r7, #4]
900067d4:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
900067d8:	b2db      	uxtb	r3, r3
900067da:	2b00      	cmp	r3, #0
900067dc:	d105      	bne.n	900067ea <HAL_SD_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    hsd->Lock = HAL_UNLOCKED;
900067de:	687b      	ldr	r3, [r7, #4]
900067e0:	2200      	movs	r2, #0
900067e2:	761a      	strb	r2, [r3, #24]

    /* Init the low level hardware */
    hsd->MspInitCallback(hsd);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_SD_MspInit(hsd);
900067e4:	6878      	ldr	r0, [r7, #4]
900067e6:	f7f9 ffbd 	bl	90000764 <HAL_SD_MspInit>
#endif /* USE_HAL_SD_REGISTER_CALLBACKS */
  }

  hsd->State = HAL_SD_STATE_PROGRAMMING;
900067ea:	687b      	ldr	r3, [r7, #4]
900067ec:	2204      	movs	r2, #4
900067ee:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  /* Initialize the Card parameters */
  if (HAL_SD_InitCard(hsd) != HAL_OK)
900067f2:	6878      	ldr	r0, [r7, #4]
900067f4:	f000 f868 	bl	900068c8 <HAL_SD_InitCard>
900067f8:	4603      	mov	r3, r0
900067fa:	2b00      	cmp	r3, #0
900067fc:	d001      	beq.n	90006802 <HAL_SD_Init+0x42>
  {
    return HAL_ERROR;
900067fe:	2301      	movs	r3, #1
90006800:	e05d      	b.n	900068be <HAL_SD_Init+0xfe>
  }

  if (HAL_SD_GetCardStatus(hsd, &CardStatus) != HAL_OK)
90006802:	f107 0308 	add.w	r3, r7, #8
90006806:	4619      	mov	r1, r3
90006808:	6878      	ldr	r0, [r7, #4]
9000680a:	f000 fdbb 	bl	90007384 <HAL_SD_GetCardStatus>
9000680e:	4603      	mov	r3, r0
90006810:	2b00      	cmp	r3, #0
90006812:	d001      	beq.n	90006818 <HAL_SD_Init+0x58>
  {
    return HAL_ERROR;
90006814:	2301      	movs	r3, #1
90006816:	e052      	b.n	900068be <HAL_SD_Init+0xfe>
  }
  /* Get Initial Card Speed from Card Status*/
  speedgrade = CardStatus.UhsSpeedGrade;
90006818:	7e3b      	ldrb	r3, [r7, #24]
9000681a:	b2db      	uxtb	r3, r3
9000681c:	627b      	str	r3, [r7, #36]	@ 0x24
  unitsize = CardStatus.UhsAllocationUnitSize;
9000681e:	7e7b      	ldrb	r3, [r7, #25]
90006820:	b2db      	uxtb	r3, r3
90006822:	623b      	str	r3, [r7, #32]
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
90006824:	687b      	ldr	r3, [r7, #4]
90006826:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90006828:	2b01      	cmp	r3, #1
9000682a:	d10a      	bne.n	90006842 <HAL_SD_Init+0x82>
9000682c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
9000682e:	2b00      	cmp	r3, #0
90006830:	d102      	bne.n	90006838 <HAL_SD_Init+0x78>
90006832:	6a3b      	ldr	r3, [r7, #32]
90006834:	2b00      	cmp	r3, #0
90006836:	d004      	beq.n	90006842 <HAL_SD_Init+0x82>
  {
    hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
90006838:	687b      	ldr	r3, [r7, #4]
9000683a:	f44f 7200 	mov.w	r2, #512	@ 0x200
9000683e:	659a      	str	r2, [r3, #88]	@ 0x58
90006840:	e00b      	b.n	9000685a <HAL_SD_Init+0x9a>
  }
  else
  {
    if (hsd->SdCard.CardType == CARD_SDHC_SDXC)
90006842:	687b      	ldr	r3, [r7, #4]
90006844:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90006846:	2b01      	cmp	r3, #1
90006848:	d104      	bne.n	90006854 <HAL_SD_Init+0x94>
    {
      hsd->SdCard.CardSpeed  = CARD_HIGH_SPEED;
9000684a:	687b      	ldr	r3, [r7, #4]
9000684c:	f44f 7280 	mov.w	r2, #256	@ 0x100
90006850:	659a      	str	r2, [r3, #88]	@ 0x58
90006852:	e002      	b.n	9000685a <HAL_SD_Init+0x9a>
    }
    else
    {
      hsd->SdCard.CardSpeed  = CARD_NORMAL_SPEED;
90006854:	687b      	ldr	r3, [r7, #4]
90006856:	2200      	movs	r2, #0
90006858:	659a      	str	r2, [r3, #88]	@ 0x58
    }

  }
  /* Configure the bus wide */
  if (HAL_SD_ConfigWideBusOperation(hsd, hsd->Init.BusWide) != HAL_OK)
9000685a:	687b      	ldr	r3, [r7, #4]
9000685c:	68db      	ldr	r3, [r3, #12]
9000685e:	4619      	mov	r1, r3
90006860:	6878      	ldr	r0, [r7, #4]
90006862:	f000 fe79 	bl	90007558 <HAL_SD_ConfigWideBusOperation>
90006866:	4603      	mov	r3, r0
90006868:	2b00      	cmp	r3, #0
9000686a:	d001      	beq.n	90006870 <HAL_SD_Init+0xb0>
  {
    return HAL_ERROR;
9000686c:	2301      	movs	r3, #1
9000686e:	e026      	b.n	900068be <HAL_SD_Init+0xfe>
  }

  /* Verify that SD card is ready to use after Initialization */
  tickstart = HAL_GetTick();
90006870:	f7fa ff28 	bl	900016c4 <HAL_GetTick>
90006874:	61f8      	str	r0, [r7, #28]
  while ((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
90006876:	e011      	b.n	9000689c <HAL_SD_Init+0xdc>
  {
    if ((HAL_GetTick() - tickstart) >=  SDMMC_SWDATATIMEOUT)
90006878:	f7fa ff24 	bl	900016c4 <HAL_GetTick>
9000687c:	4602      	mov	r2, r0
9000687e:	69fb      	ldr	r3, [r7, #28]
90006880:	1ad3      	subs	r3, r2, r3
90006882:	f1b3 3fff 	cmp.w	r3, #4294967295
90006886:	d109      	bne.n	9000689c <HAL_SD_Init+0xdc>
    {
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
90006888:	687b      	ldr	r3, [r7, #4]
9000688a:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
9000688e:	635a      	str	r2, [r3, #52]	@ 0x34
      hsd->State = HAL_SD_STATE_READY;
90006890:	687b      	ldr	r3, [r7, #4]
90006892:	2201      	movs	r2, #1
90006894:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      return HAL_TIMEOUT;
90006898:	2303      	movs	r3, #3
9000689a:	e010      	b.n	900068be <HAL_SD_Init+0xfe>
  while ((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
9000689c:	6878      	ldr	r0, [r7, #4]
9000689e:	f000 ff6b 	bl	90007778 <HAL_SD_GetCardState>
900068a2:	4603      	mov	r3, r0
900068a4:	2b04      	cmp	r3, #4
900068a6:	d1e7      	bne.n	90006878 <HAL_SD_Init+0xb8>
    }
  }

  /* Initialize the error code */
  hsd->ErrorCode = HAL_SD_ERROR_NONE;
900068a8:	687b      	ldr	r3, [r7, #4]
900068aa:	2200      	movs	r2, #0
900068ac:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Initialize the SD operation */
  hsd->Context = SD_CONTEXT_NONE;
900068ae:	687b      	ldr	r3, [r7, #4]
900068b0:	2200      	movs	r2, #0
900068b2:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Initialize the SD state */
  hsd->State = HAL_SD_STATE_READY;
900068b4:	687b      	ldr	r3, [r7, #4]
900068b6:	2201      	movs	r2, #1
900068b8:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return HAL_OK;
900068bc:	2300      	movs	r3, #0
}
900068be:	4618      	mov	r0, r3
900068c0:	3728      	adds	r7, #40	@ 0x28
900068c2:	46bd      	mov	sp, r7
900068c4:	bd80      	pop	{r7, pc}
	...

900068c8 <HAL_SD_InitCard>:
  * @note   This function initializes the SD card. It could be used when a card
            re-initialization is needed.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_InitCard(SD_HandleTypeDef *hsd)
{
900068c8:	b590      	push	{r4, r7, lr}
900068ca:	b08d      	sub	sp, #52	@ 0x34
900068cc:	af02      	add	r7, sp, #8
900068ce:	6078      	str	r0, [r7, #4]
  uint32_t errorstate;
  SD_InitTypeDef Init = {0U};
900068d0:	f107 030c 	add.w	r3, r7, #12
900068d4:	2200      	movs	r2, #0
900068d6:	601a      	str	r2, [r3, #0]
900068d8:	605a      	str	r2, [r3, #4]
900068da:	609a      	str	r2, [r3, #8]
900068dc:	60da      	str	r2, [r3, #12]
900068de:	611a      	str	r2, [r3, #16]
  uint32_t sdmmc_clk;

  /* Default SDMMC peripheral configuration for SD card initialization */
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
900068e0:	2300      	movs	r3, #0
900068e2:	60fb      	str	r3, [r7, #12]
  Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
900068e4:	2300      	movs	r3, #0
900068e6:	613b      	str	r3, [r7, #16]
  Init.BusWide             = SDMMC_BUS_WIDE_1B;
900068e8:	2300      	movs	r3, #0
900068ea:	617b      	str	r3, [r7, #20]
  Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
900068ec:	2300      	movs	r3, #0
900068ee:	61bb      	str	r3, [r7, #24]

  /* Init Clock should be less or equal to 400Khz*/
  sdmmc_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC12);
900068f0:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
900068f4:	f7fe f86e 	bl	900049d4 <HAL_RCCEx_GetPeriphCLKFreq>
900068f8:	6278      	str	r0, [r7, #36]	@ 0x24
  if (sdmmc_clk == 0U)
900068fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
900068fc:	2b00      	cmp	r3, #0
900068fe:	d109      	bne.n	90006914 <HAL_SD_InitCard+0x4c>
  {
    hsd->State = HAL_SD_STATE_READY;
90006900:	687b      	ldr	r3, [r7, #4]
90006902:	2201      	movs	r2, #1
90006904:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    hsd->ErrorCode = SDMMC_ERROR_INVALID_PARAMETER;
90006908:	687b      	ldr	r3, [r7, #4]
9000690a:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
9000690e:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
90006910:	2301      	movs	r3, #1
90006912:	e070      	b.n	900069f6 <HAL_SD_InitCard+0x12e>
  }
  Init.ClockDiv = sdmmc_clk / (2U * SD_INIT_FREQ);
90006914:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
90006916:	0a1b      	lsrs	r3, r3, #8
90006918:	4a39      	ldr	r2, [pc, #228]	@ (90006a00 <HAL_SD_InitCard+0x138>)
9000691a:	fba2 2303 	umull	r2, r3, r2, r3
9000691e:	091b      	lsrs	r3, r3, #4
90006920:	61fb      	str	r3, [r7, #28]
  /* Set Transceiver polarity */
  hsd->Instance->POWER |= SDMMC_POWER_DIRPOL;
#endif /* USE_SD_TRANSCEIVER  */

  /* Initialize SDMMC peripheral interface with default configuration */
  (void)SDMMC_Init(hsd->Instance, Init);
90006922:	687b      	ldr	r3, [r7, #4]
90006924:	681c      	ldr	r4, [r3, #0]
90006926:	466a      	mov	r2, sp
90006928:	f107 0318 	add.w	r3, r7, #24
9000692c:	e893 0003 	ldmia.w	r3, {r0, r1}
90006930:	e882 0003 	stmia.w	r2, {r0, r1}
90006934:	f107 030c 	add.w	r3, r7, #12
90006938:	cb0e      	ldmia	r3, {r1, r2, r3}
9000693a:	4620      	mov	r0, r4
9000693c:	f001 faf6 	bl	90007f2c <SDMMC_Init>

  /* Set Power State to ON */
  (void)SDMMC_PowerState_ON(hsd->Instance);
90006940:	687b      	ldr	r3, [r7, #4]
90006942:	681b      	ldr	r3, [r3, #0]
90006944:	4618      	mov	r0, r3
90006946:	f001 fb39 	bl	90007fbc <SDMMC_PowerState_ON>

  /* wait 74 Cycles: required power up waiting time before starting
     the SD initialization sequence */
  if (Init.ClockDiv != 0U)
9000694a:	69fb      	ldr	r3, [r7, #28]
9000694c:	2b00      	cmp	r3, #0
9000694e:	d005      	beq.n	9000695c <HAL_SD_InitCard+0x94>
  {
    sdmmc_clk = sdmmc_clk / (2U * Init.ClockDiv);
90006950:	69fb      	ldr	r3, [r7, #28]
90006952:	005b      	lsls	r3, r3, #1
90006954:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
90006956:	fbb2 f3f3 	udiv	r3, r2, r3
9000695a:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  if (sdmmc_clk != 0U)
9000695c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
9000695e:	2b00      	cmp	r3, #0
90006960:	d007      	beq.n	90006972 <HAL_SD_InitCard+0xaa>
  {
    HAL_Delay(1U + (74U * 1000U / (sdmmc_clk)));
90006962:	4a28      	ldr	r2, [pc, #160]	@ (90006a04 <HAL_SD_InitCard+0x13c>)
90006964:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
90006966:	fbb2 f3f3 	udiv	r3, r2, r3
9000696a:	3301      	adds	r3, #1
9000696c:	4618      	mov	r0, r3
9000696e:	f7fa feb5 	bl	900016dc <HAL_Delay>
  }

  /* Identify card operating voltage */
  errorstate = SD_PowerON(hsd);
90006972:	6878      	ldr	r0, [r7, #4]
90006974:	f000 ffee 	bl	90007954 <SD_PowerON>
90006978:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_SD_ERROR_NONE)
9000697a:	6a3b      	ldr	r3, [r7, #32]
9000697c:	2b00      	cmp	r3, #0
9000697e:	d00b      	beq.n	90006998 <HAL_SD_InitCard+0xd0>
  {
    hsd->State = HAL_SD_STATE_READY;
90006980:	687b      	ldr	r3, [r7, #4]
90006982:	2201      	movs	r2, #1
90006984:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    hsd->ErrorCode |= errorstate;
90006988:	687b      	ldr	r3, [r7, #4]
9000698a:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
9000698c:	6a3b      	ldr	r3, [r7, #32]
9000698e:	431a      	orrs	r2, r3
90006990:	687b      	ldr	r3, [r7, #4]
90006992:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
90006994:	2301      	movs	r3, #1
90006996:	e02e      	b.n	900069f6 <HAL_SD_InitCard+0x12e>
  }

  /* Card initialization */
  errorstate = SD_InitCard(hsd);
90006998:	6878      	ldr	r0, [r7, #4]
9000699a:	f000 ff0d 	bl	900077b8 <SD_InitCard>
9000699e:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_SD_ERROR_NONE)
900069a0:	6a3b      	ldr	r3, [r7, #32]
900069a2:	2b00      	cmp	r3, #0
900069a4:	d00b      	beq.n	900069be <HAL_SD_InitCard+0xf6>
  {
    hsd->State = HAL_SD_STATE_READY;
900069a6:	687b      	ldr	r3, [r7, #4]
900069a8:	2201      	movs	r2, #1
900069aa:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    hsd->ErrorCode |= errorstate;
900069ae:	687b      	ldr	r3, [r7, #4]
900069b0:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
900069b2:	6a3b      	ldr	r3, [r7, #32]
900069b4:	431a      	orrs	r2, r3
900069b6:	687b      	ldr	r3, [r7, #4]
900069b8:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
900069ba:	2301      	movs	r3, #1
900069bc:	e01b      	b.n	900069f6 <HAL_SD_InitCard+0x12e>
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
900069be:	687b      	ldr	r3, [r7, #4]
900069c0:	681b      	ldr	r3, [r3, #0]
900069c2:	f44f 7100 	mov.w	r1, #512	@ 0x200
900069c6:	4618      	mov	r0, r3
900069c8:	f001 fb8e 	bl	900080e8 <SDMMC_CmdBlockLength>
900069cc:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_SD_ERROR_NONE)
900069ce:	6a3b      	ldr	r3, [r7, #32]
900069d0:	2b00      	cmp	r3, #0
900069d2:	d00f      	beq.n	900069f4 <HAL_SD_InitCard+0x12c>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
900069d4:	687b      	ldr	r3, [r7, #4]
900069d6:	681b      	ldr	r3, [r3, #0]
900069d8:	4a0b      	ldr	r2, [pc, #44]	@ (90006a08 <HAL_SD_InitCard+0x140>)
900069da:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->ErrorCode |= errorstate;
900069dc:	687b      	ldr	r3, [r7, #4]
900069de:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
900069e0:	6a3b      	ldr	r3, [r7, #32]
900069e2:	431a      	orrs	r2, r3
900069e4:	687b      	ldr	r3, [r7, #4]
900069e6:	635a      	str	r2, [r3, #52]	@ 0x34
    hsd->State = HAL_SD_STATE_READY;
900069e8:	687b      	ldr	r3, [r7, #4]
900069ea:	2201      	movs	r2, #1
900069ec:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    return HAL_ERROR;
900069f0:	2301      	movs	r3, #1
900069f2:	e000      	b.n	900069f6 <HAL_SD_InitCard+0x12e>
  }

  return HAL_OK;
900069f4:	2300      	movs	r3, #0
}
900069f6:	4618      	mov	r0, r3
900069f8:	372c      	adds	r7, #44	@ 0x2c
900069fa:	46bd      	mov	sp, r7
900069fc:	bd90      	pop	{r4, r7, pc}
900069fe:	bf00      	nop
90006a00:	014f8b59 	.word	0x014f8b59
90006a04:	00012110 	.word	0x00012110
90006a08:	1fe00fff 	.word	0x1fe00fff

90006a0c <HAL_SD_ReadBlocks>:
  * @param  Timeout: Specify timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks,
                                    uint32_t Timeout)
{
90006a0c:	b580      	push	{r7, lr}
90006a0e:	b092      	sub	sp, #72	@ 0x48
90006a10:	af00      	add	r7, sp, #0
90006a12:	60f8      	str	r0, [r7, #12]
90006a14:	60b9      	str	r1, [r7, #8]
90006a16:	607a      	str	r2, [r7, #4]
90006a18:	603b      	str	r3, [r7, #0]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
90006a1a:	f7fa fe53 	bl	900016c4 <HAL_GetTick>
90006a1e:	6338      	str	r0, [r7, #48]	@ 0x30
  uint32_t count;
  uint32_t data;
  uint32_t dataremaining;
  uint32_t add = BlockAdd;
90006a20:	687b      	ldr	r3, [r7, #4]
90006a22:	63bb      	str	r3, [r7, #56]	@ 0x38
  uint8_t *tempbuff = pData;
90006a24:	68bb      	ldr	r3, [r7, #8]
90006a26:	637b      	str	r3, [r7, #52]	@ 0x34

  if (NULL == pData)
90006a28:	68bb      	ldr	r3, [r7, #8]
90006a2a:	2b00      	cmp	r3, #0
90006a2c:	d107      	bne.n	90006a3e <HAL_SD_ReadBlocks+0x32>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
90006a2e:	68fb      	ldr	r3, [r7, #12]
90006a30:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006a32:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
90006a36:	68fb      	ldr	r3, [r7, #12]
90006a38:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
90006a3a:	2301      	movs	r3, #1
90006a3c:	e167      	b.n	90006d0e <HAL_SD_ReadBlocks+0x302>
  }

  if (hsd->State == HAL_SD_STATE_READY)
90006a3e:	68fb      	ldr	r3, [r7, #12]
90006a40:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
90006a44:	b2db      	uxtb	r3, r3
90006a46:	2b01      	cmp	r3, #1
90006a48:	f040 815a 	bne.w	90006d00 <HAL_SD_ReadBlocks+0x2f4>
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
90006a4c:	68fb      	ldr	r3, [r7, #12]
90006a4e:	2200      	movs	r2, #0
90006a50:	635a      	str	r2, [r3, #52]	@ 0x34

    if ((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
90006a52:	6bba      	ldr	r2, [r7, #56]	@ 0x38
90006a54:	683b      	ldr	r3, [r7, #0]
90006a56:	441a      	add	r2, r3
90006a58:	68fb      	ldr	r3, [r7, #12]
90006a5a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
90006a5c:	429a      	cmp	r2, r3
90006a5e:	d907      	bls.n	90006a70 <HAL_SD_ReadBlocks+0x64>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
90006a60:	68fb      	ldr	r3, [r7, #12]
90006a62:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006a64:	f043 7200 	orr.w	r2, r3, #33554432	@ 0x2000000
90006a68:	68fb      	ldr	r3, [r7, #12]
90006a6a:	635a      	str	r2, [r3, #52]	@ 0x34
      return HAL_ERROR;
90006a6c:	2301      	movs	r3, #1
90006a6e:	e14e      	b.n	90006d0e <HAL_SD_ReadBlocks+0x302>
    }

    hsd->State = HAL_SD_STATE_BUSY;
90006a70:	68fb      	ldr	r3, [r7, #12]
90006a72:	2203      	movs	r2, #3
90006a74:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;
90006a78:	68fb      	ldr	r3, [r7, #12]
90006a7a:	681b      	ldr	r3, [r3, #0]
90006a7c:	2200      	movs	r2, #0
90006a7e:	62da      	str	r2, [r3, #44]	@ 0x2c

    if (hsd->SdCard.CardType != CARD_SDHC_SDXC)
90006a80:	68fb      	ldr	r3, [r7, #12]
90006a82:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90006a84:	2b01      	cmp	r3, #1
90006a86:	d002      	beq.n	90006a8e <HAL_SD_ReadBlocks+0x82>
    {
      add *= BLOCKSIZE;
90006a88:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
90006a8a:	025b      	lsls	r3, r3, #9
90006a8c:	63bb      	str	r3, [r7, #56]	@ 0x38
    }

    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
90006a8e:	f04f 33ff 	mov.w	r3, #4294967295
90006a92:	617b      	str	r3, [r7, #20]
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
90006a94:	683b      	ldr	r3, [r7, #0]
90006a96:	025b      	lsls	r3, r3, #9
90006a98:	61bb      	str	r3, [r7, #24]
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
90006a9a:	2390      	movs	r3, #144	@ 0x90
90006a9c:	61fb      	str	r3, [r7, #28]
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
90006a9e:	2302      	movs	r3, #2
90006aa0:	623b      	str	r3, [r7, #32]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
90006aa2:	2300      	movs	r3, #0
90006aa4:	627b      	str	r3, [r7, #36]	@ 0x24
    config.DPSM          = SDMMC_DPSM_DISABLE;
90006aa6:	2300      	movs	r3, #0
90006aa8:	62bb      	str	r3, [r7, #40]	@ 0x28
    (void)SDMMC_ConfigData(hsd->Instance, &config);
90006aaa:	68fb      	ldr	r3, [r7, #12]
90006aac:	681b      	ldr	r3, [r3, #0]
90006aae:	f107 0214 	add.w	r2, r7, #20
90006ab2:	4611      	mov	r1, r2
90006ab4:	4618      	mov	r0, r3
90006ab6:	f001 faeb 	bl	90008090 <SDMMC_ConfigData>
    __SDMMC_CMDTRANS_ENABLE(hsd->Instance);
90006aba:	68fb      	ldr	r3, [r7, #12]
90006abc:	681b      	ldr	r3, [r3, #0]
90006abe:	68da      	ldr	r2, [r3, #12]
90006ac0:	68fb      	ldr	r3, [r7, #12]
90006ac2:	681b      	ldr	r3, [r3, #0]
90006ac4:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
90006ac8:	60da      	str	r2, [r3, #12]

    /* Read block(s) in polling mode */
    if (NumberOfBlocks > 1U)
90006aca:	683b      	ldr	r3, [r7, #0]
90006acc:	2b01      	cmp	r3, #1
90006ace:	d90a      	bls.n	90006ae6 <HAL_SD_ReadBlocks+0xda>
    {
      hsd->Context = SD_CONTEXT_READ_MULTIPLE_BLOCK;
90006ad0:	68fb      	ldr	r3, [r7, #12]
90006ad2:	2202      	movs	r2, #2
90006ad4:	62da      	str	r2, [r3, #44]	@ 0x2c

      /* Read Multi Block command */
      errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
90006ad6:	68fb      	ldr	r3, [r7, #12]
90006ad8:	681b      	ldr	r3, [r3, #0]
90006ada:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
90006adc:	4618      	mov	r0, r3
90006ade:	f001 fb49 	bl	90008174 <SDMMC_CmdReadMultiBlock>
90006ae2:	6478      	str	r0, [r7, #68]	@ 0x44
90006ae4:	e009      	b.n	90006afa <HAL_SD_ReadBlocks+0xee>
    }
    else
    {
      hsd->Context = SD_CONTEXT_READ_SINGLE_BLOCK;
90006ae6:	68fb      	ldr	r3, [r7, #12]
90006ae8:	2201      	movs	r2, #1
90006aea:	62da      	str	r2, [r3, #44]	@ 0x2c

      /* Read Single Block command */
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
90006aec:	68fb      	ldr	r3, [r7, #12]
90006aee:	681b      	ldr	r3, [r3, #0]
90006af0:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
90006af2:	4618      	mov	r0, r3
90006af4:	f001 fb1b 	bl	9000812e <SDMMC_CmdReadSingleBlock>
90006af8:	6478      	str	r0, [r7, #68]	@ 0x44
    }
    if (errorstate != HAL_SD_ERROR_NONE)
90006afa:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
90006afc:	2b00      	cmp	r3, #0
90006afe:	d012      	beq.n	90006b26 <HAL_SD_ReadBlocks+0x11a>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90006b00:	68fb      	ldr	r3, [r7, #12]
90006b02:	681b      	ldr	r3, [r3, #0]
90006b04:	4a84      	ldr	r2, [pc, #528]	@ (90006d18 <HAL_SD_ReadBlocks+0x30c>)
90006b06:	639a      	str	r2, [r3, #56]	@ 0x38
      hsd->ErrorCode |= errorstate;
90006b08:	68fb      	ldr	r3, [r7, #12]
90006b0a:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
90006b0c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
90006b0e:	431a      	orrs	r2, r3
90006b10:	68fb      	ldr	r3, [r7, #12]
90006b12:	635a      	str	r2, [r3, #52]	@ 0x34
      hsd->State = HAL_SD_STATE_READY;
90006b14:	68fb      	ldr	r3, [r7, #12]
90006b16:	2201      	movs	r2, #1
90006b18:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      hsd->Context = SD_CONTEXT_NONE;
90006b1c:	68fb      	ldr	r3, [r7, #12]
90006b1e:	2200      	movs	r2, #0
90006b20:	62da      	str	r2, [r3, #44]	@ 0x2c
      return HAL_ERROR;
90006b22:	2301      	movs	r3, #1
90006b24:	e0f3      	b.n	90006d0e <HAL_SD_ReadBlocks+0x302>
    }

    /* Poll on SDMMC flags */
    dataremaining = config.DataLength;
90006b26:	69bb      	ldr	r3, [r7, #24]
90006b28:	63fb      	str	r3, [r7, #60]	@ 0x3c
    while (!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
90006b2a:	e058      	b.n	90006bde <HAL_SD_ReadBlocks+0x1d2>
    {
      if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) && (dataremaining >= SDMMC_FIFO_SIZE))
90006b2c:	68fb      	ldr	r3, [r7, #12]
90006b2e:	681b      	ldr	r3, [r3, #0]
90006b30:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006b32:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
90006b36:	2b00      	cmp	r3, #0
90006b38:	d033      	beq.n	90006ba2 <HAL_SD_ReadBlocks+0x196>
90006b3a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
90006b3c:	2b1f      	cmp	r3, #31
90006b3e:	d930      	bls.n	90006ba2 <HAL_SD_ReadBlocks+0x196>
      {
        /* Read data from SDMMC Rx FIFO */
        for (count = 0U; count < (SDMMC_FIFO_SIZE / 4U); count++)
90006b40:	2300      	movs	r3, #0
90006b42:	643b      	str	r3, [r7, #64]	@ 0x40
90006b44:	e027      	b.n	90006b96 <HAL_SD_ReadBlocks+0x18a>
        {
          data = SDMMC_ReadFIFO(hsd->Instance);
90006b46:	68fb      	ldr	r3, [r7, #12]
90006b48:	681b      	ldr	r3, [r3, #0]
90006b4a:	4618      	mov	r0, r3
90006b4c:	f001 fa18 	bl	90007f80 <SDMMC_ReadFIFO>
90006b50:	62f8      	str	r0, [r7, #44]	@ 0x2c
          *tempbuff = (uint8_t)(data & 0xFFU);
90006b52:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
90006b54:	b2da      	uxtb	r2, r3
90006b56:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
90006b58:	701a      	strb	r2, [r3, #0]
          tempbuff++;
90006b5a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
90006b5c:	3301      	adds	r3, #1
90006b5e:	637b      	str	r3, [r7, #52]	@ 0x34
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
90006b60:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
90006b62:	0a1b      	lsrs	r3, r3, #8
90006b64:	b2da      	uxtb	r2, r3
90006b66:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
90006b68:	701a      	strb	r2, [r3, #0]
          tempbuff++;
90006b6a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
90006b6c:	3301      	adds	r3, #1
90006b6e:	637b      	str	r3, [r7, #52]	@ 0x34
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
90006b70:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
90006b72:	0c1b      	lsrs	r3, r3, #16
90006b74:	b2da      	uxtb	r2, r3
90006b76:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
90006b78:	701a      	strb	r2, [r3, #0]
          tempbuff++;
90006b7a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
90006b7c:	3301      	adds	r3, #1
90006b7e:	637b      	str	r3, [r7, #52]	@ 0x34
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
90006b80:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
90006b82:	0e1b      	lsrs	r3, r3, #24
90006b84:	b2da      	uxtb	r2, r3
90006b86:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
90006b88:	701a      	strb	r2, [r3, #0]
          tempbuff++;
90006b8a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
90006b8c:	3301      	adds	r3, #1
90006b8e:	637b      	str	r3, [r7, #52]	@ 0x34
        for (count = 0U; count < (SDMMC_FIFO_SIZE / 4U); count++)
90006b90:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
90006b92:	3301      	adds	r3, #1
90006b94:	643b      	str	r3, [r7, #64]	@ 0x40
90006b96:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
90006b98:	2b07      	cmp	r3, #7
90006b9a:	d9d4      	bls.n	90006b46 <HAL_SD_ReadBlocks+0x13a>
        }
        dataremaining -= SDMMC_FIFO_SIZE;
90006b9c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
90006b9e:	3b20      	subs	r3, #32
90006ba0:	63fb      	str	r3, [r7, #60]	@ 0x3c
      }

      if (((HAL_GetTick() - tickstart) >=  Timeout) || (Timeout == 0U))
90006ba2:	f7fa fd8f 	bl	900016c4 <HAL_GetTick>
90006ba6:	4602      	mov	r2, r0
90006ba8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
90006baa:	1ad3      	subs	r3, r2, r3
90006bac:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
90006bae:	429a      	cmp	r2, r3
90006bb0:	d902      	bls.n	90006bb8 <HAL_SD_ReadBlocks+0x1ac>
90006bb2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
90006bb4:	2b00      	cmp	r3, #0
90006bb6:	d112      	bne.n	90006bde <HAL_SD_ReadBlocks+0x1d2>
      {
        /* Clear all the static flags */
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90006bb8:	68fb      	ldr	r3, [r7, #12]
90006bba:	681b      	ldr	r3, [r3, #0]
90006bbc:	4a56      	ldr	r2, [pc, #344]	@ (90006d18 <HAL_SD_ReadBlocks+0x30c>)
90006bbe:	639a      	str	r2, [r3, #56]	@ 0x38
        hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
90006bc0:	68fb      	ldr	r3, [r7, #12]
90006bc2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006bc4:	f043 4200 	orr.w	r2, r3, #2147483648	@ 0x80000000
90006bc8:	68fb      	ldr	r3, [r7, #12]
90006bca:	635a      	str	r2, [r3, #52]	@ 0x34
        hsd->State = HAL_SD_STATE_READY;
90006bcc:	68fb      	ldr	r3, [r7, #12]
90006bce:	2201      	movs	r2, #1
90006bd0:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
        hsd->Context = SD_CONTEXT_NONE;
90006bd4:	68fb      	ldr	r3, [r7, #12]
90006bd6:	2200      	movs	r2, #0
90006bd8:	62da      	str	r2, [r3, #44]	@ 0x2c
        return HAL_TIMEOUT;
90006bda:	2303      	movs	r3, #3
90006bdc:	e097      	b.n	90006d0e <HAL_SD_ReadBlocks+0x302>
    while (!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
90006bde:	68fb      	ldr	r3, [r7, #12]
90006be0:	681b      	ldr	r3, [r3, #0]
90006be2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006be4:	f403 7395 	and.w	r3, r3, #298	@ 0x12a
90006be8:	2b00      	cmp	r3, #0
90006bea:	d09f      	beq.n	90006b2c <HAL_SD_ReadBlocks+0x120>
      }
    }
    __SDMMC_CMDTRANS_DISABLE(hsd->Instance);
90006bec:	68fb      	ldr	r3, [r7, #12]
90006bee:	681b      	ldr	r3, [r3, #0]
90006bf0:	68da      	ldr	r2, [r3, #12]
90006bf2:	68fb      	ldr	r3, [r7, #12]
90006bf4:	681b      	ldr	r3, [r3, #0]
90006bf6:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
90006bfa:	60da      	str	r2, [r3, #12]

    /* Send stop transmission command in case of multiblock read */
    if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
90006bfc:	68fb      	ldr	r3, [r7, #12]
90006bfe:	681b      	ldr	r3, [r3, #0]
90006c00:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006c02:	f403 7380 	and.w	r3, r3, #256	@ 0x100
90006c06:	2b00      	cmp	r3, #0
90006c08:	d022      	beq.n	90006c50 <HAL_SD_ReadBlocks+0x244>
90006c0a:	683b      	ldr	r3, [r7, #0]
90006c0c:	2b01      	cmp	r3, #1
90006c0e:	d91f      	bls.n	90006c50 <HAL_SD_ReadBlocks+0x244>
    {
      if (hsd->SdCard.CardType != CARD_SECURED)
90006c10:	68fb      	ldr	r3, [r7, #12]
90006c12:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90006c14:	2b03      	cmp	r3, #3
90006c16:	d01b      	beq.n	90006c50 <HAL_SD_ReadBlocks+0x244>
      {
        /* Send stop transmission command */
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
90006c18:	68fb      	ldr	r3, [r7, #12]
90006c1a:	681b      	ldr	r3, [r3, #0]
90006c1c:	4618      	mov	r0, r3
90006c1e:	f001 fb13 	bl	90008248 <SDMMC_CmdStopTransfer>
90006c22:	6478      	str	r0, [r7, #68]	@ 0x44
        if (errorstate != HAL_SD_ERROR_NONE)
90006c24:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
90006c26:	2b00      	cmp	r3, #0
90006c28:	d012      	beq.n	90006c50 <HAL_SD_ReadBlocks+0x244>
        {
          /* Clear all the static flags */
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90006c2a:	68fb      	ldr	r3, [r7, #12]
90006c2c:	681b      	ldr	r3, [r3, #0]
90006c2e:	4a3a      	ldr	r2, [pc, #232]	@ (90006d18 <HAL_SD_ReadBlocks+0x30c>)
90006c30:	639a      	str	r2, [r3, #56]	@ 0x38
          hsd->ErrorCode |= errorstate;
90006c32:	68fb      	ldr	r3, [r7, #12]
90006c34:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
90006c36:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
90006c38:	431a      	orrs	r2, r3
90006c3a:	68fb      	ldr	r3, [r7, #12]
90006c3c:	635a      	str	r2, [r3, #52]	@ 0x34
          hsd->State = HAL_SD_STATE_READY;
90006c3e:	68fb      	ldr	r3, [r7, #12]
90006c40:	2201      	movs	r2, #1
90006c42:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
          hsd->Context = SD_CONTEXT_NONE;
90006c46:	68fb      	ldr	r3, [r7, #12]
90006c48:	2200      	movs	r2, #0
90006c4a:	62da      	str	r2, [r3, #44]	@ 0x2c
          return HAL_ERROR;
90006c4c:	2301      	movs	r3, #1
90006c4e:	e05e      	b.n	90006d0e <HAL_SD_ReadBlocks+0x302>
        }
      }
    }

    /* Get error state */
    if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
90006c50:	68fb      	ldr	r3, [r7, #12]
90006c52:	681b      	ldr	r3, [r3, #0]
90006c54:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006c56:	f003 0308 	and.w	r3, r3, #8
90006c5a:	2b00      	cmp	r3, #0
90006c5c:	d012      	beq.n	90006c84 <HAL_SD_ReadBlocks+0x278>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90006c5e:	68fb      	ldr	r3, [r7, #12]
90006c60:	681b      	ldr	r3, [r3, #0]
90006c62:	4a2d      	ldr	r2, [pc, #180]	@ (90006d18 <HAL_SD_ReadBlocks+0x30c>)
90006c64:	639a      	str	r2, [r3, #56]	@ 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
90006c66:	68fb      	ldr	r3, [r7, #12]
90006c68:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006c6a:	f043 0208 	orr.w	r2, r3, #8
90006c6e:	68fb      	ldr	r3, [r7, #12]
90006c70:	635a      	str	r2, [r3, #52]	@ 0x34
      hsd->State = HAL_SD_STATE_READY;
90006c72:	68fb      	ldr	r3, [r7, #12]
90006c74:	2201      	movs	r2, #1
90006c76:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      hsd->Context = SD_CONTEXT_NONE;
90006c7a:	68fb      	ldr	r3, [r7, #12]
90006c7c:	2200      	movs	r2, #0
90006c7e:	62da      	str	r2, [r3, #44]	@ 0x2c
      return HAL_ERROR;
90006c80:	2301      	movs	r3, #1
90006c82:	e044      	b.n	90006d0e <HAL_SD_ReadBlocks+0x302>
    }
    else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
90006c84:	68fb      	ldr	r3, [r7, #12]
90006c86:	681b      	ldr	r3, [r3, #0]
90006c88:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006c8a:	f003 0302 	and.w	r3, r3, #2
90006c8e:	2b00      	cmp	r3, #0
90006c90:	d012      	beq.n	90006cb8 <HAL_SD_ReadBlocks+0x2ac>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90006c92:	68fb      	ldr	r3, [r7, #12]
90006c94:	681b      	ldr	r3, [r3, #0]
90006c96:	4a20      	ldr	r2, [pc, #128]	@ (90006d18 <HAL_SD_ReadBlocks+0x30c>)
90006c98:	639a      	str	r2, [r3, #56]	@ 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
90006c9a:	68fb      	ldr	r3, [r7, #12]
90006c9c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006c9e:	f043 0202 	orr.w	r2, r3, #2
90006ca2:	68fb      	ldr	r3, [r7, #12]
90006ca4:	635a      	str	r2, [r3, #52]	@ 0x34
      hsd->State = HAL_SD_STATE_READY;
90006ca6:	68fb      	ldr	r3, [r7, #12]
90006ca8:	2201      	movs	r2, #1
90006caa:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      hsd->Context = SD_CONTEXT_NONE;
90006cae:	68fb      	ldr	r3, [r7, #12]
90006cb0:	2200      	movs	r2, #0
90006cb2:	62da      	str	r2, [r3, #44]	@ 0x2c
      return HAL_ERROR;
90006cb4:	2301      	movs	r3, #1
90006cb6:	e02a      	b.n	90006d0e <HAL_SD_ReadBlocks+0x302>
    }
    else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
90006cb8:	68fb      	ldr	r3, [r7, #12]
90006cba:	681b      	ldr	r3, [r3, #0]
90006cbc:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006cbe:	f003 0320 	and.w	r3, r3, #32
90006cc2:	2b00      	cmp	r3, #0
90006cc4:	d012      	beq.n	90006cec <HAL_SD_ReadBlocks+0x2e0>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90006cc6:	68fb      	ldr	r3, [r7, #12]
90006cc8:	681b      	ldr	r3, [r3, #0]
90006cca:	4a13      	ldr	r2, [pc, #76]	@ (90006d18 <HAL_SD_ReadBlocks+0x30c>)
90006ccc:	639a      	str	r2, [r3, #56]	@ 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
90006cce:	68fb      	ldr	r3, [r7, #12]
90006cd0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006cd2:	f043 0220 	orr.w	r2, r3, #32
90006cd6:	68fb      	ldr	r3, [r7, #12]
90006cd8:	635a      	str	r2, [r3, #52]	@ 0x34
      hsd->State = HAL_SD_STATE_READY;
90006cda:	68fb      	ldr	r3, [r7, #12]
90006cdc:	2201      	movs	r2, #1
90006cde:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      hsd->Context = SD_CONTEXT_NONE;
90006ce2:	68fb      	ldr	r3, [r7, #12]
90006ce4:	2200      	movs	r2, #0
90006ce6:	62da      	str	r2, [r3, #44]	@ 0x2c
      return HAL_ERROR;
90006ce8:	2301      	movs	r3, #1
90006cea:	e010      	b.n	90006d0e <HAL_SD_ReadBlocks+0x302>
    {
      /* Nothing to do */
    }

    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
90006cec:	68fb      	ldr	r3, [r7, #12]
90006cee:	681b      	ldr	r3, [r3, #0]
90006cf0:	4a0a      	ldr	r2, [pc, #40]	@ (90006d1c <HAL_SD_ReadBlocks+0x310>)
90006cf2:	639a      	str	r2, [r3, #56]	@ 0x38

    hsd->State = HAL_SD_STATE_READY;
90006cf4:	68fb      	ldr	r3, [r7, #12]
90006cf6:	2201      	movs	r2, #1
90006cf8:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

    return HAL_OK;
90006cfc:	2300      	movs	r3, #0
90006cfe:	e006      	b.n	90006d0e <HAL_SD_ReadBlocks+0x302>
  }
  else
  {
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
90006d00:	68fb      	ldr	r3, [r7, #12]
90006d02:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006d04:	f043 5200 	orr.w	r2, r3, #536870912	@ 0x20000000
90006d08:	68fb      	ldr	r3, [r7, #12]
90006d0a:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
90006d0c:	2301      	movs	r3, #1
  }
}
90006d0e:	4618      	mov	r0, r3
90006d10:	3748      	adds	r7, #72	@ 0x48
90006d12:	46bd      	mov	sp, r7
90006d14:	bd80      	pop	{r7, pc}
90006d16:	bf00      	nop
90006d18:	1fe00fff 	.word	0x1fe00fff
90006d1c:	18000f3a 	.word	0x18000f3a

90006d20 <HAL_SD_WriteBlocks>:
  * @param  Timeout: Specify timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, const uint8_t *pData, uint32_t BlockAdd,
                                     uint32_t NumberOfBlocks, uint32_t Timeout)
{
90006d20:	b580      	push	{r7, lr}
90006d22:	b092      	sub	sp, #72	@ 0x48
90006d24:	af00      	add	r7, sp, #0
90006d26:	60f8      	str	r0, [r7, #12]
90006d28:	60b9      	str	r1, [r7, #8]
90006d2a:	607a      	str	r2, [r7, #4]
90006d2c:	603b      	str	r3, [r7, #0]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
90006d2e:	f7fa fcc9 	bl	900016c4 <HAL_GetTick>
90006d32:	6338      	str	r0, [r7, #48]	@ 0x30
  uint32_t count;
  uint32_t data;
  uint32_t dataremaining;
  uint32_t add = BlockAdd;
90006d34:	687b      	ldr	r3, [r7, #4]
90006d36:	63bb      	str	r3, [r7, #56]	@ 0x38
  const uint8_t *tempbuff = pData;
90006d38:	68bb      	ldr	r3, [r7, #8]
90006d3a:	637b      	str	r3, [r7, #52]	@ 0x34

  if (NULL == pData)
90006d3c:	68bb      	ldr	r3, [r7, #8]
90006d3e:	2b00      	cmp	r3, #0
90006d40:	d107      	bne.n	90006d52 <HAL_SD_WriteBlocks+0x32>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
90006d42:	68fb      	ldr	r3, [r7, #12]
90006d44:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006d46:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
90006d4a:	68fb      	ldr	r3, [r7, #12]
90006d4c:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
90006d4e:	2301      	movs	r3, #1
90006d50:	e16b      	b.n	9000702a <HAL_SD_WriteBlocks+0x30a>
  }

  if (hsd->State == HAL_SD_STATE_READY)
90006d52:	68fb      	ldr	r3, [r7, #12]
90006d54:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
90006d58:	b2db      	uxtb	r3, r3
90006d5a:	2b01      	cmp	r3, #1
90006d5c:	f040 815e 	bne.w	9000701c <HAL_SD_WriteBlocks+0x2fc>
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
90006d60:	68fb      	ldr	r3, [r7, #12]
90006d62:	2200      	movs	r2, #0
90006d64:	635a      	str	r2, [r3, #52]	@ 0x34

    if ((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
90006d66:	6bba      	ldr	r2, [r7, #56]	@ 0x38
90006d68:	683b      	ldr	r3, [r7, #0]
90006d6a:	441a      	add	r2, r3
90006d6c:	68fb      	ldr	r3, [r7, #12]
90006d6e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
90006d70:	429a      	cmp	r2, r3
90006d72:	d907      	bls.n	90006d84 <HAL_SD_WriteBlocks+0x64>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
90006d74:	68fb      	ldr	r3, [r7, #12]
90006d76:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006d78:	f043 7200 	orr.w	r2, r3, #33554432	@ 0x2000000
90006d7c:	68fb      	ldr	r3, [r7, #12]
90006d7e:	635a      	str	r2, [r3, #52]	@ 0x34
      return HAL_ERROR;
90006d80:	2301      	movs	r3, #1
90006d82:	e152      	b.n	9000702a <HAL_SD_WriteBlocks+0x30a>
    }

    hsd->State = HAL_SD_STATE_BUSY;
90006d84:	68fb      	ldr	r3, [r7, #12]
90006d86:	2203      	movs	r2, #3
90006d88:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;
90006d8c:	68fb      	ldr	r3, [r7, #12]
90006d8e:	681b      	ldr	r3, [r3, #0]
90006d90:	2200      	movs	r2, #0
90006d92:	62da      	str	r2, [r3, #44]	@ 0x2c

    if (hsd->SdCard.CardType != CARD_SDHC_SDXC)
90006d94:	68fb      	ldr	r3, [r7, #12]
90006d96:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90006d98:	2b01      	cmp	r3, #1
90006d9a:	d002      	beq.n	90006da2 <HAL_SD_WriteBlocks+0x82>
    {
      add *= BLOCKSIZE;
90006d9c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
90006d9e:	025b      	lsls	r3, r3, #9
90006da0:	63bb      	str	r3, [r7, #56]	@ 0x38
    }

    /* Configure the SD DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
90006da2:	f04f 33ff 	mov.w	r3, #4294967295
90006da6:	61bb      	str	r3, [r7, #24]
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
90006da8:	683b      	ldr	r3, [r7, #0]
90006daa:	025b      	lsls	r3, r3, #9
90006dac:	61fb      	str	r3, [r7, #28]
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
90006dae:	2390      	movs	r3, #144	@ 0x90
90006db0:	623b      	str	r3, [r7, #32]
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
90006db2:	2300      	movs	r3, #0
90006db4:	627b      	str	r3, [r7, #36]	@ 0x24
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
90006db6:	2300      	movs	r3, #0
90006db8:	62bb      	str	r3, [r7, #40]	@ 0x28
    config.DPSM          = SDMMC_DPSM_DISABLE;
90006dba:	2300      	movs	r3, #0
90006dbc:	62fb      	str	r3, [r7, #44]	@ 0x2c
    (void)SDMMC_ConfigData(hsd->Instance, &config);
90006dbe:	68fb      	ldr	r3, [r7, #12]
90006dc0:	681b      	ldr	r3, [r3, #0]
90006dc2:	f107 0218 	add.w	r2, r7, #24
90006dc6:	4611      	mov	r1, r2
90006dc8:	4618      	mov	r0, r3
90006dca:	f001 f961 	bl	90008090 <SDMMC_ConfigData>
    __SDMMC_CMDTRANS_ENABLE(hsd->Instance);
90006dce:	68fb      	ldr	r3, [r7, #12]
90006dd0:	681b      	ldr	r3, [r3, #0]
90006dd2:	68da      	ldr	r2, [r3, #12]
90006dd4:	68fb      	ldr	r3, [r7, #12]
90006dd6:	681b      	ldr	r3, [r3, #0]
90006dd8:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
90006ddc:	60da      	str	r2, [r3, #12]

    /* Write Blocks in Polling mode */
    if (NumberOfBlocks > 1U)
90006dde:	683b      	ldr	r3, [r7, #0]
90006de0:	2b01      	cmp	r3, #1
90006de2:	d90a      	bls.n	90006dfa <HAL_SD_WriteBlocks+0xda>
    {
      hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
90006de4:	68fb      	ldr	r3, [r7, #12]
90006de6:	2220      	movs	r2, #32
90006de8:	62da      	str	r2, [r3, #44]	@ 0x2c

      /* Write Multi Block command */
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
90006dea:	68fb      	ldr	r3, [r7, #12]
90006dec:	681b      	ldr	r3, [r3, #0]
90006dee:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
90006df0:	4618      	mov	r0, r3
90006df2:	f001 fa05 	bl	90008200 <SDMMC_CmdWriteMultiBlock>
90006df6:	6478      	str	r0, [r7, #68]	@ 0x44
90006df8:	e009      	b.n	90006e0e <HAL_SD_WriteBlocks+0xee>
    }
    else
    {
      hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
90006dfa:	68fb      	ldr	r3, [r7, #12]
90006dfc:	2210      	movs	r2, #16
90006dfe:	62da      	str	r2, [r3, #44]	@ 0x2c

      /* Write Single Block command */
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
90006e00:	68fb      	ldr	r3, [r7, #12]
90006e02:	681b      	ldr	r3, [r3, #0]
90006e04:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
90006e06:	4618      	mov	r0, r3
90006e08:	f001 f9d7 	bl	900081ba <SDMMC_CmdWriteSingleBlock>
90006e0c:	6478      	str	r0, [r7, #68]	@ 0x44
    }
    if (errorstate != HAL_SD_ERROR_NONE)
90006e0e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
90006e10:	2b00      	cmp	r3, #0
90006e12:	d012      	beq.n	90006e3a <HAL_SD_WriteBlocks+0x11a>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90006e14:	68fb      	ldr	r3, [r7, #12]
90006e16:	681b      	ldr	r3, [r3, #0]
90006e18:	4a86      	ldr	r2, [pc, #536]	@ (90007034 <HAL_SD_WriteBlocks+0x314>)
90006e1a:	639a      	str	r2, [r3, #56]	@ 0x38
      hsd->ErrorCode |= errorstate;
90006e1c:	68fb      	ldr	r3, [r7, #12]
90006e1e:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
90006e20:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
90006e22:	431a      	orrs	r2, r3
90006e24:	68fb      	ldr	r3, [r7, #12]
90006e26:	635a      	str	r2, [r3, #52]	@ 0x34
      hsd->State = HAL_SD_STATE_READY;
90006e28:	68fb      	ldr	r3, [r7, #12]
90006e2a:	2201      	movs	r2, #1
90006e2c:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      hsd->Context = SD_CONTEXT_NONE;
90006e30:	68fb      	ldr	r3, [r7, #12]
90006e32:	2200      	movs	r2, #0
90006e34:	62da      	str	r2, [r3, #44]	@ 0x2c
      return HAL_ERROR;
90006e36:	2301      	movs	r3, #1
90006e38:	e0f7      	b.n	9000702a <HAL_SD_WriteBlocks+0x30a>
    }

    /* Write block(s) in polling mode */
    dataremaining = config.DataLength;
90006e3a:	69fb      	ldr	r3, [r7, #28]
90006e3c:	63fb      	str	r3, [r7, #60]	@ 0x3c
    while (!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT |
90006e3e:	e05c      	b.n	90006efa <HAL_SD_WriteBlocks+0x1da>
                              SDMMC_FLAG_DATAEND))
    {
      if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) && (dataremaining >= SDMMC_FIFO_SIZE))
90006e40:	68fb      	ldr	r3, [r7, #12]
90006e42:	681b      	ldr	r3, [r3, #0]
90006e44:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006e46:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
90006e4a:	2b00      	cmp	r3, #0
90006e4c:	d037      	beq.n	90006ebe <HAL_SD_WriteBlocks+0x19e>
90006e4e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
90006e50:	2b1f      	cmp	r3, #31
90006e52:	d934      	bls.n	90006ebe <HAL_SD_WriteBlocks+0x19e>
      {
        /* Write data to SDMMC Tx FIFO */
        for (count = 0U; count < (SDMMC_FIFO_SIZE / 4U); count++)
90006e54:	2300      	movs	r3, #0
90006e56:	643b      	str	r3, [r7, #64]	@ 0x40
90006e58:	e02b      	b.n	90006eb2 <HAL_SD_WriteBlocks+0x192>
        {
          data = (uint32_t)(*tempbuff);
90006e5a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
90006e5c:	781b      	ldrb	r3, [r3, #0]
90006e5e:	617b      	str	r3, [r7, #20]
          tempbuff++;
90006e60:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
90006e62:	3301      	adds	r3, #1
90006e64:	637b      	str	r3, [r7, #52]	@ 0x34
          data |= ((uint32_t)(*tempbuff) << 8U);
90006e66:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
90006e68:	781b      	ldrb	r3, [r3, #0]
90006e6a:	021a      	lsls	r2, r3, #8
90006e6c:	697b      	ldr	r3, [r7, #20]
90006e6e:	4313      	orrs	r3, r2
90006e70:	617b      	str	r3, [r7, #20]
          tempbuff++;
90006e72:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
90006e74:	3301      	adds	r3, #1
90006e76:	637b      	str	r3, [r7, #52]	@ 0x34
          data |= ((uint32_t)(*tempbuff) << 16U);
90006e78:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
90006e7a:	781b      	ldrb	r3, [r3, #0]
90006e7c:	041a      	lsls	r2, r3, #16
90006e7e:	697b      	ldr	r3, [r7, #20]
90006e80:	4313      	orrs	r3, r2
90006e82:	617b      	str	r3, [r7, #20]
          tempbuff++;
90006e84:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
90006e86:	3301      	adds	r3, #1
90006e88:	637b      	str	r3, [r7, #52]	@ 0x34
          data |= ((uint32_t)(*tempbuff) << 24U);
90006e8a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
90006e8c:	781b      	ldrb	r3, [r3, #0]
90006e8e:	061a      	lsls	r2, r3, #24
90006e90:	697b      	ldr	r3, [r7, #20]
90006e92:	4313      	orrs	r3, r2
90006e94:	617b      	str	r3, [r7, #20]
          tempbuff++;
90006e96:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
90006e98:	3301      	adds	r3, #1
90006e9a:	637b      	str	r3, [r7, #52]	@ 0x34
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
90006e9c:	68fb      	ldr	r3, [r7, #12]
90006e9e:	681b      	ldr	r3, [r3, #0]
90006ea0:	f107 0214 	add.w	r2, r7, #20
90006ea4:	4611      	mov	r1, r2
90006ea6:	4618      	mov	r0, r3
90006ea8:	f001 f877 	bl	90007f9a <SDMMC_WriteFIFO>
        for (count = 0U; count < (SDMMC_FIFO_SIZE / 4U); count++)
90006eac:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
90006eae:	3301      	adds	r3, #1
90006eb0:	643b      	str	r3, [r7, #64]	@ 0x40
90006eb2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
90006eb4:	2b07      	cmp	r3, #7
90006eb6:	d9d0      	bls.n	90006e5a <HAL_SD_WriteBlocks+0x13a>
        }
        dataremaining -= SDMMC_FIFO_SIZE;
90006eb8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
90006eba:	3b20      	subs	r3, #32
90006ebc:	63fb      	str	r3, [r7, #60]	@ 0x3c
      }

      if (((HAL_GetTick() - tickstart) >=  Timeout) || (Timeout == 0U))
90006ebe:	f7fa fc01 	bl	900016c4 <HAL_GetTick>
90006ec2:	4602      	mov	r2, r0
90006ec4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
90006ec6:	1ad3      	subs	r3, r2, r3
90006ec8:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
90006eca:	429a      	cmp	r2, r3
90006ecc:	d902      	bls.n	90006ed4 <HAL_SD_WriteBlocks+0x1b4>
90006ece:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
90006ed0:	2b00      	cmp	r3, #0
90006ed2:	d112      	bne.n	90006efa <HAL_SD_WriteBlocks+0x1da>
      {
        /* Clear all the static flags */
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90006ed4:	68fb      	ldr	r3, [r7, #12]
90006ed6:	681b      	ldr	r3, [r3, #0]
90006ed8:	4a56      	ldr	r2, [pc, #344]	@ (90007034 <HAL_SD_WriteBlocks+0x314>)
90006eda:	639a      	str	r2, [r3, #56]	@ 0x38
        hsd->ErrorCode |= errorstate;
90006edc:	68fb      	ldr	r3, [r7, #12]
90006ede:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
90006ee0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
90006ee2:	431a      	orrs	r2, r3
90006ee4:	68fb      	ldr	r3, [r7, #12]
90006ee6:	635a      	str	r2, [r3, #52]	@ 0x34
        hsd->State = HAL_SD_STATE_READY;
90006ee8:	68fb      	ldr	r3, [r7, #12]
90006eea:	2201      	movs	r2, #1
90006eec:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
        hsd->Context = SD_CONTEXT_NONE;
90006ef0:	68fb      	ldr	r3, [r7, #12]
90006ef2:	2200      	movs	r2, #0
90006ef4:	62da      	str	r2, [r3, #44]	@ 0x2c
        return HAL_TIMEOUT;
90006ef6:	2303      	movs	r3, #3
90006ef8:	e097      	b.n	9000702a <HAL_SD_WriteBlocks+0x30a>
    while (!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT |
90006efa:	68fb      	ldr	r3, [r7, #12]
90006efc:	681b      	ldr	r3, [r3, #0]
90006efe:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006f00:	f403 738d 	and.w	r3, r3, #282	@ 0x11a
90006f04:	2b00      	cmp	r3, #0
90006f06:	d09b      	beq.n	90006e40 <HAL_SD_WriteBlocks+0x120>
      }
    }
    __SDMMC_CMDTRANS_DISABLE(hsd->Instance);
90006f08:	68fb      	ldr	r3, [r7, #12]
90006f0a:	681b      	ldr	r3, [r3, #0]
90006f0c:	68da      	ldr	r2, [r3, #12]
90006f0e:	68fb      	ldr	r3, [r7, #12]
90006f10:	681b      	ldr	r3, [r3, #0]
90006f12:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
90006f16:	60da      	str	r2, [r3, #12]

    /* Send stop transmission command in case of multiblock write */
    if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
90006f18:	68fb      	ldr	r3, [r7, #12]
90006f1a:	681b      	ldr	r3, [r3, #0]
90006f1c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006f1e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
90006f22:	2b00      	cmp	r3, #0
90006f24:	d022      	beq.n	90006f6c <HAL_SD_WriteBlocks+0x24c>
90006f26:	683b      	ldr	r3, [r7, #0]
90006f28:	2b01      	cmp	r3, #1
90006f2a:	d91f      	bls.n	90006f6c <HAL_SD_WriteBlocks+0x24c>
    {
      if (hsd->SdCard.CardType != CARD_SECURED)
90006f2c:	68fb      	ldr	r3, [r7, #12]
90006f2e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90006f30:	2b03      	cmp	r3, #3
90006f32:	d01b      	beq.n	90006f6c <HAL_SD_WriteBlocks+0x24c>
      {
        /* Send stop transmission command */
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
90006f34:	68fb      	ldr	r3, [r7, #12]
90006f36:	681b      	ldr	r3, [r3, #0]
90006f38:	4618      	mov	r0, r3
90006f3a:	f001 f985 	bl	90008248 <SDMMC_CmdStopTransfer>
90006f3e:	6478      	str	r0, [r7, #68]	@ 0x44
        if (errorstate != HAL_SD_ERROR_NONE)
90006f40:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
90006f42:	2b00      	cmp	r3, #0
90006f44:	d012      	beq.n	90006f6c <HAL_SD_WriteBlocks+0x24c>
        {
          /* Clear all the static flags */
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90006f46:	68fb      	ldr	r3, [r7, #12]
90006f48:	681b      	ldr	r3, [r3, #0]
90006f4a:	4a3a      	ldr	r2, [pc, #232]	@ (90007034 <HAL_SD_WriteBlocks+0x314>)
90006f4c:	639a      	str	r2, [r3, #56]	@ 0x38
          hsd->ErrorCode |= errorstate;
90006f4e:	68fb      	ldr	r3, [r7, #12]
90006f50:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
90006f52:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
90006f54:	431a      	orrs	r2, r3
90006f56:	68fb      	ldr	r3, [r7, #12]
90006f58:	635a      	str	r2, [r3, #52]	@ 0x34
          hsd->State = HAL_SD_STATE_READY;
90006f5a:	68fb      	ldr	r3, [r7, #12]
90006f5c:	2201      	movs	r2, #1
90006f5e:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
          hsd->Context = SD_CONTEXT_NONE;
90006f62:	68fb      	ldr	r3, [r7, #12]
90006f64:	2200      	movs	r2, #0
90006f66:	62da      	str	r2, [r3, #44]	@ 0x2c
          return HAL_ERROR;
90006f68:	2301      	movs	r3, #1
90006f6a:	e05e      	b.n	9000702a <HAL_SD_WriteBlocks+0x30a>
        }
      }
    }

    /* Get error state */
    if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
90006f6c:	68fb      	ldr	r3, [r7, #12]
90006f6e:	681b      	ldr	r3, [r3, #0]
90006f70:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006f72:	f003 0308 	and.w	r3, r3, #8
90006f76:	2b00      	cmp	r3, #0
90006f78:	d012      	beq.n	90006fa0 <HAL_SD_WriteBlocks+0x280>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90006f7a:	68fb      	ldr	r3, [r7, #12]
90006f7c:	681b      	ldr	r3, [r3, #0]
90006f7e:	4a2d      	ldr	r2, [pc, #180]	@ (90007034 <HAL_SD_WriteBlocks+0x314>)
90006f80:	639a      	str	r2, [r3, #56]	@ 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
90006f82:	68fb      	ldr	r3, [r7, #12]
90006f84:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006f86:	f043 0208 	orr.w	r2, r3, #8
90006f8a:	68fb      	ldr	r3, [r7, #12]
90006f8c:	635a      	str	r2, [r3, #52]	@ 0x34
      hsd->State = HAL_SD_STATE_READY;
90006f8e:	68fb      	ldr	r3, [r7, #12]
90006f90:	2201      	movs	r2, #1
90006f92:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      hsd->Context = SD_CONTEXT_NONE;
90006f96:	68fb      	ldr	r3, [r7, #12]
90006f98:	2200      	movs	r2, #0
90006f9a:	62da      	str	r2, [r3, #44]	@ 0x2c
      return HAL_ERROR;
90006f9c:	2301      	movs	r3, #1
90006f9e:	e044      	b.n	9000702a <HAL_SD_WriteBlocks+0x30a>
    }
    else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
90006fa0:	68fb      	ldr	r3, [r7, #12]
90006fa2:	681b      	ldr	r3, [r3, #0]
90006fa4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006fa6:	f003 0302 	and.w	r3, r3, #2
90006faa:	2b00      	cmp	r3, #0
90006fac:	d012      	beq.n	90006fd4 <HAL_SD_WriteBlocks+0x2b4>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90006fae:	68fb      	ldr	r3, [r7, #12]
90006fb0:	681b      	ldr	r3, [r3, #0]
90006fb2:	4a20      	ldr	r2, [pc, #128]	@ (90007034 <HAL_SD_WriteBlocks+0x314>)
90006fb4:	639a      	str	r2, [r3, #56]	@ 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
90006fb6:	68fb      	ldr	r3, [r7, #12]
90006fb8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006fba:	f043 0202 	orr.w	r2, r3, #2
90006fbe:	68fb      	ldr	r3, [r7, #12]
90006fc0:	635a      	str	r2, [r3, #52]	@ 0x34
      hsd->State = HAL_SD_STATE_READY;
90006fc2:	68fb      	ldr	r3, [r7, #12]
90006fc4:	2201      	movs	r2, #1
90006fc6:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      hsd->Context = SD_CONTEXT_NONE;
90006fca:	68fb      	ldr	r3, [r7, #12]
90006fcc:	2200      	movs	r2, #0
90006fce:	62da      	str	r2, [r3, #44]	@ 0x2c
      return HAL_ERROR;
90006fd0:	2301      	movs	r3, #1
90006fd2:	e02a      	b.n	9000702a <HAL_SD_WriteBlocks+0x30a>
    }
    else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR))
90006fd4:	68fb      	ldr	r3, [r7, #12]
90006fd6:	681b      	ldr	r3, [r3, #0]
90006fd8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006fda:	f003 0310 	and.w	r3, r3, #16
90006fde:	2b00      	cmp	r3, #0
90006fe0:	d012      	beq.n	90007008 <HAL_SD_WriteBlocks+0x2e8>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90006fe2:	68fb      	ldr	r3, [r7, #12]
90006fe4:	681b      	ldr	r3, [r3, #0]
90006fe6:	4a13      	ldr	r2, [pc, #76]	@ (90007034 <HAL_SD_WriteBlocks+0x314>)
90006fe8:	639a      	str	r2, [r3, #56]	@ 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
90006fea:	68fb      	ldr	r3, [r7, #12]
90006fec:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90006fee:	f043 0210 	orr.w	r2, r3, #16
90006ff2:	68fb      	ldr	r3, [r7, #12]
90006ff4:	635a      	str	r2, [r3, #52]	@ 0x34
      hsd->State = HAL_SD_STATE_READY;
90006ff6:	68fb      	ldr	r3, [r7, #12]
90006ff8:	2201      	movs	r2, #1
90006ffa:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
      hsd->Context = SD_CONTEXT_NONE;
90006ffe:	68fb      	ldr	r3, [r7, #12]
90007000:	2200      	movs	r2, #0
90007002:	62da      	str	r2, [r3, #44]	@ 0x2c
      return HAL_ERROR;
90007004:	2301      	movs	r3, #1
90007006:	e010      	b.n	9000702a <HAL_SD_WriteBlocks+0x30a>
    {
      /* Nothing to do */
    }

    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
90007008:	68fb      	ldr	r3, [r7, #12]
9000700a:	681b      	ldr	r3, [r3, #0]
9000700c:	4a0a      	ldr	r2, [pc, #40]	@ (90007038 <HAL_SD_WriteBlocks+0x318>)
9000700e:	639a      	str	r2, [r3, #56]	@ 0x38

    hsd->State = HAL_SD_STATE_READY;
90007010:	68fb      	ldr	r3, [r7, #12]
90007012:	2201      	movs	r2, #1
90007014:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

    return HAL_OK;
90007018:	2300      	movs	r3, #0
9000701a:	e006      	b.n	9000702a <HAL_SD_WriteBlocks+0x30a>
  }
  else
  {
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
9000701c:	68fb      	ldr	r3, [r7, #12]
9000701e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90007020:	f043 5200 	orr.w	r2, r3, #536870912	@ 0x20000000
90007024:	68fb      	ldr	r3, [r7, #12]
90007026:	635a      	str	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
90007028:	2301      	movs	r3, #1
  }
}
9000702a:	4618      	mov	r0, r3
9000702c:	3748      	adds	r7, #72	@ 0x48
9000702e:	46bd      	mov	sp, r7
90007030:	bd80      	pop	{r7, pc}
90007032:	bf00      	nop
90007034:	1fe00fff 	.word	0x1fe00fff
90007038:	18000f3a 	.word	0x18000f3a

9000703c <HAL_SD_GetCardCSD>:
  * @param  pCSD: Pointer to a HAL_SD_CardCSDTypeDef structure that
  *         contains all CSD register parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardCSD(SD_HandleTypeDef *hsd, HAL_SD_CardCSDTypeDef *pCSD)
{
9000703c:	b480      	push	{r7}
9000703e:	b083      	sub	sp, #12
90007040:	af00      	add	r7, sp, #0
90007042:	6078      	str	r0, [r7, #4]
90007044:	6039      	str	r1, [r7, #0]
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
90007046:	687b      	ldr	r3, [r7, #4]
90007048:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
9000704a:	0f9b      	lsrs	r3, r3, #30
9000704c:	b2da      	uxtb	r2, r3
9000704e:	683b      	ldr	r3, [r7, #0]
90007050:	701a      	strb	r2, [r3, #0]

  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
90007052:	687b      	ldr	r3, [r7, #4]
90007054:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
90007056:	0e9b      	lsrs	r3, r3, #26
90007058:	b2db      	uxtb	r3, r3
9000705a:	f003 030f 	and.w	r3, r3, #15
9000705e:	b2da      	uxtb	r2, r3
90007060:	683b      	ldr	r3, [r7, #0]
90007062:	705a      	strb	r2, [r3, #1]

  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
90007064:	687b      	ldr	r3, [r7, #4]
90007066:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
90007068:	0e1b      	lsrs	r3, r3, #24
9000706a:	b2db      	uxtb	r3, r3
9000706c:	f003 0303 	and.w	r3, r3, #3
90007070:	b2da      	uxtb	r2, r3
90007072:	683b      	ldr	r3, [r7, #0]
90007074:	709a      	strb	r2, [r3, #2]

  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
90007076:	687b      	ldr	r3, [r7, #4]
90007078:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
9000707a:	0c1b      	lsrs	r3, r3, #16
9000707c:	b2da      	uxtb	r2, r3
9000707e:	683b      	ldr	r3, [r7, #0]
90007080:	70da      	strb	r2, [r3, #3]

  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
90007082:	687b      	ldr	r3, [r7, #4]
90007084:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
90007086:	0a1b      	lsrs	r3, r3, #8
90007088:	b2da      	uxtb	r2, r3
9000708a:	683b      	ldr	r3, [r7, #0]
9000708c:	711a      	strb	r2, [r3, #4]

  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
9000708e:	687b      	ldr	r3, [r7, #4]
90007090:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
90007092:	b2da      	uxtb	r2, r3
90007094:	683b      	ldr	r3, [r7, #0]
90007096:	715a      	strb	r2, [r3, #5]

  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
90007098:	687b      	ldr	r3, [r7, #4]
9000709a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
9000709c:	0d1b      	lsrs	r3, r3, #20
9000709e:	b29a      	uxth	r2, r3
900070a0:	683b      	ldr	r3, [r7, #0]
900070a2:	80da      	strh	r2, [r3, #6]

  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
900070a4:	687b      	ldr	r3, [r7, #4]
900070a6:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
900070a8:	0c1b      	lsrs	r3, r3, #16
900070aa:	b2db      	uxtb	r3, r3
900070ac:	f003 030f 	and.w	r3, r3, #15
900070b0:	b2da      	uxtb	r2, r3
900070b2:	683b      	ldr	r3, [r7, #0]
900070b4:	721a      	strb	r2, [r3, #8]

  pCSD->PartBlockRead   = (uint8_t)((hsd->CSD[1] & 0x00008000U) >> 15U);
900070b6:	687b      	ldr	r3, [r7, #4]
900070b8:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
900070ba:	0bdb      	lsrs	r3, r3, #15
900070bc:	b2db      	uxtb	r3, r3
900070be:	f003 0301 	and.w	r3, r3, #1
900070c2:	b2da      	uxtb	r2, r3
900070c4:	683b      	ldr	r3, [r7, #0]
900070c6:	725a      	strb	r2, [r3, #9]

  pCSD->WrBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00004000U) >> 14U);
900070c8:	687b      	ldr	r3, [r7, #4]
900070ca:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
900070cc:	0b9b      	lsrs	r3, r3, #14
900070ce:	b2db      	uxtb	r3, r3
900070d0:	f003 0301 	and.w	r3, r3, #1
900070d4:	b2da      	uxtb	r2, r3
900070d6:	683b      	ldr	r3, [r7, #0]
900070d8:	729a      	strb	r2, [r3, #10]

  pCSD->RdBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00002000U) >> 13U);
900070da:	687b      	ldr	r3, [r7, #4]
900070dc:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
900070de:	0b5b      	lsrs	r3, r3, #13
900070e0:	b2db      	uxtb	r3, r3
900070e2:	f003 0301 	and.w	r3, r3, #1
900070e6:	b2da      	uxtb	r2, r3
900070e8:	683b      	ldr	r3, [r7, #0]
900070ea:	72da      	strb	r2, [r3, #11]

  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);
900070ec:	687b      	ldr	r3, [r7, #4]
900070ee:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
900070f0:	0b1b      	lsrs	r3, r3, #12
900070f2:	b2db      	uxtb	r3, r3
900070f4:	f003 0301 	and.w	r3, r3, #1
900070f8:	b2da      	uxtb	r2, r3
900070fa:	683b      	ldr	r3, [r7, #0]
900070fc:	731a      	strb	r2, [r3, #12]

  pCSD->Reserved2 = 0U; /*!< Reserved */
900070fe:	683b      	ldr	r3, [r7, #0]
90007100:	2200      	movs	r2, #0
90007102:	735a      	strb	r2, [r3, #13]

  if (hsd->SdCard.CardType == CARD_SDSC)
90007104:	687b      	ldr	r3, [r7, #4]
90007106:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90007108:	2b00      	cmp	r3, #0
9000710a:	d163      	bne.n	900071d4 <HAL_SD_GetCardCSD+0x198>
  {
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
9000710c:	687b      	ldr	r3, [r7, #4]
9000710e:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
90007110:	009a      	lsls	r2, r3, #2
90007112:	f640 73fc 	movw	r3, #4092	@ 0xffc
90007116:	4013      	ands	r3, r2
90007118:	687a      	ldr	r2, [r7, #4]
9000711a:	6e52      	ldr	r2, [r2, #100]	@ 0x64
9000711c:	0f92      	lsrs	r2, r2, #30
9000711e:	431a      	orrs	r2, r3
90007120:	683b      	ldr	r3, [r7, #0]
90007122:	611a      	str	r2, [r3, #16]

    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
90007124:	687b      	ldr	r3, [r7, #4]
90007126:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
90007128:	0edb      	lsrs	r3, r3, #27
9000712a:	b2db      	uxtb	r3, r3
9000712c:	f003 0307 	and.w	r3, r3, #7
90007130:	b2da      	uxtb	r2, r3
90007132:	683b      	ldr	r3, [r7, #0]
90007134:	751a      	strb	r2, [r3, #20]

    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x07000000U) >> 24U);
90007136:	687b      	ldr	r3, [r7, #4]
90007138:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
9000713a:	0e1b      	lsrs	r3, r3, #24
9000713c:	b2db      	uxtb	r3, r3
9000713e:	f003 0307 	and.w	r3, r3, #7
90007142:	b2da      	uxtb	r2, r3
90007144:	683b      	ldr	r3, [r7, #0]
90007146:	755a      	strb	r2, [r3, #21]

    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
90007148:	687b      	ldr	r3, [r7, #4]
9000714a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
9000714c:	0d5b      	lsrs	r3, r3, #21
9000714e:	b2db      	uxtb	r3, r3
90007150:	f003 0307 	and.w	r3, r3, #7
90007154:	b2da      	uxtb	r2, r3
90007156:	683b      	ldr	r3, [r7, #0]
90007158:	759a      	strb	r2, [r3, #22]

    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
9000715a:	687b      	ldr	r3, [r7, #4]
9000715c:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
9000715e:	0c9b      	lsrs	r3, r3, #18
90007160:	b2db      	uxtb	r3, r3
90007162:	f003 0307 	and.w	r3, r3, #7
90007166:	b2da      	uxtb	r2, r3
90007168:	683b      	ldr	r3, [r7, #0]
9000716a:	75da      	strb	r2, [r3, #23]

    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
9000716c:	687b      	ldr	r3, [r7, #4]
9000716e:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
90007170:	0bdb      	lsrs	r3, r3, #15
90007172:	b2db      	uxtb	r3, r3
90007174:	f003 0307 	and.w	r3, r3, #7
90007178:	b2da      	uxtb	r2, r3
9000717a:	683b      	ldr	r3, [r7, #0]
9000717c:	761a      	strb	r2, [r3, #24]

    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
9000717e:	683b      	ldr	r3, [r7, #0]
90007180:	691b      	ldr	r3, [r3, #16]
90007182:	1c5a      	adds	r2, r3, #1
90007184:	687b      	ldr	r3, [r7, #4]
90007186:	649a      	str	r2, [r3, #72]	@ 0x48
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
90007188:	683b      	ldr	r3, [r7, #0]
9000718a:	7e1b      	ldrb	r3, [r3, #24]
9000718c:	b2db      	uxtb	r3, r3
9000718e:	f003 0307 	and.w	r3, r3, #7
90007192:	3302      	adds	r3, #2
90007194:	2201      	movs	r2, #1
90007196:	fa02 f303 	lsl.w	r3, r2, r3
9000719a:	687a      	ldr	r2, [r7, #4]
9000719c:	6c92      	ldr	r2, [r2, #72]	@ 0x48
9000719e:	fb03 f202 	mul.w	r2, r3, r2
900071a2:	687b      	ldr	r3, [r7, #4]
900071a4:	649a      	str	r2, [r3, #72]	@ 0x48
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
900071a6:	683b      	ldr	r3, [r7, #0]
900071a8:	7a1b      	ldrb	r3, [r3, #8]
900071aa:	b2db      	uxtb	r3, r3
900071ac:	f003 030f 	and.w	r3, r3, #15
900071b0:	2201      	movs	r2, #1
900071b2:	409a      	lsls	r2, r3
900071b4:	687b      	ldr	r3, [r7, #4]
900071b6:	64da      	str	r2, [r3, #76]	@ 0x4c

    hsd->SdCard.LogBlockNbr = (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / BLOCKSIZE);
900071b8:	687b      	ldr	r3, [r7, #4]
900071ba:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
900071bc:	687a      	ldr	r2, [r7, #4]
900071be:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
900071c0:	0a52      	lsrs	r2, r2, #9
900071c2:	fb03 f202 	mul.w	r2, r3, r2
900071c6:	687b      	ldr	r3, [r7, #4]
900071c8:	651a      	str	r2, [r3, #80]	@ 0x50
    hsd->SdCard.LogBlockSize = BLOCKSIZE;
900071ca:	687b      	ldr	r3, [r7, #4]
900071cc:	f44f 7200 	mov.w	r2, #512	@ 0x200
900071d0:	655a      	str	r2, [r3, #84]	@ 0x54
900071d2:	e031      	b.n	90007238 <HAL_SD_GetCardCSD+0x1fc>
  }
  else if (hsd->SdCard.CardType == CARD_SDHC_SDXC)
900071d4:	687b      	ldr	r3, [r7, #4]
900071d6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
900071d8:	2b01      	cmp	r3, #1
900071da:	d11d      	bne.n	90007218 <HAL_SD_GetCardCSD+0x1dc>
  {
    /* Byte 7 */
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
900071dc:	687b      	ldr	r3, [r7, #4]
900071de:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
900071e0:	041b      	lsls	r3, r3, #16
900071e2:	f403 127c 	and.w	r2, r3, #4128768	@ 0x3f0000
900071e6:	687b      	ldr	r3, [r7, #4]
900071e8:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
900071ea:	0c1b      	lsrs	r3, r3, #16
900071ec:	431a      	orrs	r2, r3
900071ee:	683b      	ldr	r3, [r7, #0]
900071f0:	611a      	str	r2, [r3, #16]

    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
900071f2:	683b      	ldr	r3, [r7, #0]
900071f4:	691b      	ldr	r3, [r3, #16]
900071f6:	3301      	adds	r3, #1
900071f8:	029a      	lsls	r2, r3, #10
900071fa:	687b      	ldr	r3, [r7, #4]
900071fc:	649a      	str	r2, [r3, #72]	@ 0x48
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr;
900071fe:	687b      	ldr	r3, [r7, #4]
90007200:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
90007202:	687b      	ldr	r3, [r7, #4]
90007204:	651a      	str	r2, [r3, #80]	@ 0x50
    hsd->SdCard.BlockSize = BLOCKSIZE;
90007206:	687b      	ldr	r3, [r7, #4]
90007208:	f44f 7200 	mov.w	r2, #512	@ 0x200
9000720c:	64da      	str	r2, [r3, #76]	@ 0x4c
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
9000720e:	687b      	ldr	r3, [r7, #4]
90007210:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
90007212:	687b      	ldr	r3, [r7, #4]
90007214:	655a      	str	r2, [r3, #84]	@ 0x54
90007216:	e00f      	b.n	90007238 <HAL_SD_GetCardCSD+0x1fc>
  }
  else
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
90007218:	687b      	ldr	r3, [r7, #4]
9000721a:	681b      	ldr	r3, [r3, #0]
9000721c:	4a58      	ldr	r2, [pc, #352]	@ (90007380 <HAL_SD_GetCardCSD+0x344>)
9000721e:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
90007220:	687b      	ldr	r3, [r7, #4]
90007222:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90007224:	f043 5280 	orr.w	r2, r3, #268435456	@ 0x10000000
90007228:	687b      	ldr	r3, [r7, #4]
9000722a:	635a      	str	r2, [r3, #52]	@ 0x34
    hsd->State = HAL_SD_STATE_READY;
9000722c:	687b      	ldr	r3, [r7, #4]
9000722e:	2201      	movs	r2, #1
90007230:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    return HAL_ERROR;
90007234:	2301      	movs	r3, #1
90007236:	e09d      	b.n	90007374 <HAL_SD_GetCardCSD+0x338>
  }

  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
90007238:	687b      	ldr	r3, [r7, #4]
9000723a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
9000723c:	0b9b      	lsrs	r3, r3, #14
9000723e:	b2db      	uxtb	r3, r3
90007240:	f003 0301 	and.w	r3, r3, #1
90007244:	b2da      	uxtb	r2, r3
90007246:	683b      	ldr	r3, [r7, #0]
90007248:	765a      	strb	r2, [r3, #25]

  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
9000724a:	687b      	ldr	r3, [r7, #4]
9000724c:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
9000724e:	09db      	lsrs	r3, r3, #7
90007250:	b2db      	uxtb	r3, r3
90007252:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
90007256:	b2da      	uxtb	r2, r3
90007258:	683b      	ldr	r3, [r7, #0]
9000725a:	769a      	strb	r2, [r3, #26]

  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
9000725c:	687b      	ldr	r3, [r7, #4]
9000725e:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
90007260:	b2db      	uxtb	r3, r3
90007262:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
90007266:	b2da      	uxtb	r2, r3
90007268:	683b      	ldr	r3, [r7, #0]
9000726a:	76da      	strb	r2, [r3, #27]

  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
9000726c:	687b      	ldr	r3, [r7, #4]
9000726e:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
90007270:	0fdb      	lsrs	r3, r3, #31
90007272:	b2da      	uxtb	r2, r3
90007274:	683b      	ldr	r3, [r7, #0]
90007276:	771a      	strb	r2, [r3, #28]

  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
90007278:	687b      	ldr	r3, [r7, #4]
9000727a:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
9000727c:	0f5b      	lsrs	r3, r3, #29
9000727e:	b2db      	uxtb	r3, r3
90007280:	f003 0303 	and.w	r3, r3, #3
90007284:	b2da      	uxtb	r2, r3
90007286:	683b      	ldr	r3, [r7, #0]
90007288:	775a      	strb	r2, [r3, #29]

  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
9000728a:	687b      	ldr	r3, [r7, #4]
9000728c:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
9000728e:	0e9b      	lsrs	r3, r3, #26
90007290:	b2db      	uxtb	r3, r3
90007292:	f003 0307 	and.w	r3, r3, #7
90007296:	b2da      	uxtb	r2, r3
90007298:	683b      	ldr	r3, [r7, #0]
9000729a:	779a      	strb	r2, [r3, #30]

  pCSD->MaxWrBlockLen = (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
9000729c:	687b      	ldr	r3, [r7, #4]
9000729e:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
900072a0:	0d9b      	lsrs	r3, r3, #22
900072a2:	b2db      	uxtb	r3, r3
900072a4:	f003 030f 	and.w	r3, r3, #15
900072a8:	b2da      	uxtb	r2, r3
900072aa:	683b      	ldr	r3, [r7, #0]
900072ac:	77da      	strb	r2, [r3, #31]

  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
900072ae:	687b      	ldr	r3, [r7, #4]
900072b0:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
900072b2:	0d5b      	lsrs	r3, r3, #21
900072b4:	b2db      	uxtb	r3, r3
900072b6:	f003 0301 	and.w	r3, r3, #1
900072ba:	b2da      	uxtb	r2, r3
900072bc:	683b      	ldr	r3, [r7, #0]
900072be:	f883 2020 	strb.w	r2, [r3, #32]

  pCSD->Reserved3 = 0;
900072c2:	683b      	ldr	r3, [r7, #0]
900072c4:	2200      	movs	r2, #0
900072c6:	f883 2021 	strb.w	r2, [r3, #33]	@ 0x21

  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
900072ca:	687b      	ldr	r3, [r7, #4]
900072cc:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
900072ce:	0c1b      	lsrs	r3, r3, #16
900072d0:	b2db      	uxtb	r3, r3
900072d2:	f003 0301 	and.w	r3, r3, #1
900072d6:	b2da      	uxtb	r2, r3
900072d8:	683b      	ldr	r3, [r7, #0]
900072da:	f883 2022 	strb.w	r2, [r3, #34]	@ 0x22

  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
900072de:	687b      	ldr	r3, [r7, #4]
900072e0:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
900072e2:	0bdb      	lsrs	r3, r3, #15
900072e4:	b2db      	uxtb	r3, r3
900072e6:	f003 0301 	and.w	r3, r3, #1
900072ea:	b2da      	uxtb	r2, r3
900072ec:	683b      	ldr	r3, [r7, #0]
900072ee:	f883 2023 	strb.w	r2, [r3, #35]	@ 0x23

  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
900072f2:	687b      	ldr	r3, [r7, #4]
900072f4:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
900072f6:	0b9b      	lsrs	r3, r3, #14
900072f8:	b2db      	uxtb	r3, r3
900072fa:	f003 0301 	and.w	r3, r3, #1
900072fe:	b2da      	uxtb	r2, r3
90007300:	683b      	ldr	r3, [r7, #0]
90007302:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
90007306:	687b      	ldr	r3, [r7, #4]
90007308:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
9000730a:	0b5b      	lsrs	r3, r3, #13
9000730c:	b2db      	uxtb	r3, r3
9000730e:	f003 0301 	and.w	r3, r3, #1
90007312:	b2da      	uxtb	r2, r3
90007314:	683b      	ldr	r3, [r7, #0]
90007316:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25

  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
9000731a:	687b      	ldr	r3, [r7, #4]
9000731c:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
9000731e:	0b1b      	lsrs	r3, r3, #12
90007320:	b2db      	uxtb	r3, r3
90007322:	f003 0301 	and.w	r3, r3, #1
90007326:	b2da      	uxtb	r2, r3
90007328:	683b      	ldr	r3, [r7, #0]
9000732a:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26

  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
9000732e:	687b      	ldr	r3, [r7, #4]
90007330:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
90007332:	0a9b      	lsrs	r3, r3, #10
90007334:	b2db      	uxtb	r3, r3
90007336:	f003 0303 	and.w	r3, r3, #3
9000733a:	b2da      	uxtb	r2, r3
9000733c:	683b      	ldr	r3, [r7, #0]
9000733e:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27

  pCSD->ECC = (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
90007342:	687b      	ldr	r3, [r7, #4]
90007344:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
90007346:	0a1b      	lsrs	r3, r3, #8
90007348:	b2db      	uxtb	r3, r3
9000734a:	f003 0303 	and.w	r3, r3, #3
9000734e:	b2da      	uxtb	r2, r3
90007350:	683b      	ldr	r3, [r7, #0]
90007352:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28

  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
90007356:	687b      	ldr	r3, [r7, #4]
90007358:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
9000735a:	085b      	lsrs	r3, r3, #1
9000735c:	b2db      	uxtb	r3, r3
9000735e:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
90007362:	b2da      	uxtb	r2, r3
90007364:	683b      	ldr	r3, [r7, #0]
90007366:	f883 2029 	strb.w	r2, [r3, #41]	@ 0x29

  pCSD->Reserved4 = 1;
9000736a:	683b      	ldr	r3, [r7, #0]
9000736c:	2201      	movs	r2, #1
9000736e:	f883 202a 	strb.w	r2, [r3, #42]	@ 0x2a

  return HAL_OK;
90007372:	2300      	movs	r3, #0
}
90007374:	4618      	mov	r0, r3
90007376:	370c      	adds	r7, #12
90007378:	46bd      	mov	sp, r7
9000737a:	f85d 7b04 	ldr.w	r7, [sp], #4
9000737e:	4770      	bx	lr
90007380:	1fe00fff 	.word	0x1fe00fff

90007384 <HAL_SD_GetCardStatus>:
  * @param  pStatus: Pointer to the HAL_SD_CardStatusTypeDef structure that
  *         will contain the SD card status information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardStatus(SD_HandleTypeDef *hsd, HAL_SD_CardStatusTypeDef *pStatus)
{
90007384:	b580      	push	{r7, lr}
90007386:	b094      	sub	sp, #80	@ 0x50
90007388:	af00      	add	r7, sp, #0
9000738a:	6078      	str	r0, [r7, #4]
9000738c:	6039      	str	r1, [r7, #0]
  uint32_t sd_status[16];
  uint32_t errorstate;
  HAL_StatusTypeDef status = HAL_OK;
9000738e:	2300      	movs	r3, #0
90007390:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f

  if (hsd->State == HAL_SD_STATE_BUSY)
90007394:	687b      	ldr	r3, [r7, #4]
90007396:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
9000739a:	b2db      	uxtb	r3, r3
9000739c:	2b03      	cmp	r3, #3
9000739e:	d101      	bne.n	900073a4 <HAL_SD_GetCardStatus+0x20>
  {
    return HAL_ERROR;
900073a0:	2301      	movs	r3, #1
900073a2:	e0a7      	b.n	900074f4 <HAL_SD_GetCardStatus+0x170>
  }

  errorstate = SD_SendSDStatus(hsd, sd_status);
900073a4:	f107 0308 	add.w	r3, r7, #8
900073a8:	4619      	mov	r1, r3
900073aa:	6878      	ldr	r0, [r7, #4]
900073ac:	f000 fb60 	bl	90007a70 <SD_SendSDStatus>
900073b0:	64b8      	str	r0, [r7, #72]	@ 0x48
  if (errorstate != HAL_SD_ERROR_NONE)
900073b2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
900073b4:	2b00      	cmp	r3, #0
900073b6:	d011      	beq.n	900073dc <HAL_SD_GetCardStatus+0x58>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
900073b8:	687b      	ldr	r3, [r7, #4]
900073ba:	681b      	ldr	r3, [r3, #0]
900073bc:	4a4f      	ldr	r2, [pc, #316]	@ (900074fc <HAL_SD_GetCardStatus+0x178>)
900073be:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->ErrorCode |= errorstate;
900073c0:	687b      	ldr	r3, [r7, #4]
900073c2:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
900073c4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
900073c6:	431a      	orrs	r2, r3
900073c8:	687b      	ldr	r3, [r7, #4]
900073ca:	635a      	str	r2, [r3, #52]	@ 0x34
    hsd->State = HAL_SD_STATE_READY;
900073cc:	687b      	ldr	r3, [r7, #4]
900073ce:	2201      	movs	r2, #1
900073d0:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    status = HAL_ERROR;
900073d4:	2301      	movs	r3, #1
900073d6:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
900073da:	e070      	b.n	900074be <HAL_SD_GetCardStatus+0x13a>
  }
  else
  {
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
900073dc:	68bb      	ldr	r3, [r7, #8]
900073de:	099b      	lsrs	r3, r3, #6
900073e0:	b2db      	uxtb	r3, r3
900073e2:	f003 0303 	and.w	r3, r3, #3
900073e6:	b2da      	uxtb	r2, r3
900073e8:	683b      	ldr	r3, [r7, #0]
900073ea:	701a      	strb	r2, [r3, #0]

    pStatus->SecuredMode = (uint8_t)((sd_status[0] & 0x20U) >> 5U);
900073ec:	68bb      	ldr	r3, [r7, #8]
900073ee:	095b      	lsrs	r3, r3, #5
900073f0:	b2db      	uxtb	r3, r3
900073f2:	f003 0301 	and.w	r3, r3, #1
900073f6:	b2da      	uxtb	r2, r3
900073f8:	683b      	ldr	r3, [r7, #0]
900073fa:	705a      	strb	r2, [r3, #1]

    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
900073fc:	68bb      	ldr	r3, [r7, #8]
900073fe:	0a1b      	lsrs	r3, r3, #8
90007400:	b29b      	uxth	r3, r3
90007402:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
90007406:	b29a      	uxth	r2, r3
90007408:	68bb      	ldr	r3, [r7, #8]
9000740a:	0e1b      	lsrs	r3, r3, #24
9000740c:	b29b      	uxth	r3, r3
9000740e:	4313      	orrs	r3, r2
90007410:	b29a      	uxth	r2, r3
90007412:	683b      	ldr	r3, [r7, #0]
90007414:	805a      	strh	r2, [r3, #2]

    pStatus->ProtectedAreaSize = (((sd_status[1] & 0xFFU) << 24U)    | ((sd_status[1] & 0xFF00U) << 8U) |
90007416:	68fb      	ldr	r3, [r7, #12]
90007418:	061a      	lsls	r2, r3, #24
9000741a:	68fb      	ldr	r3, [r7, #12]
9000741c:	021b      	lsls	r3, r3, #8
9000741e:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
90007422:	431a      	orrs	r2, r3
                                  ((sd_status[1] & 0xFF0000U) >> 8U) | ((sd_status[1] & 0xFF000000U) >> 24U));
90007424:	68fb      	ldr	r3, [r7, #12]
90007426:	0a1b      	lsrs	r3, r3, #8
90007428:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
    pStatus->ProtectedAreaSize = (((sd_status[1] & 0xFFU) << 24U)    | ((sd_status[1] & 0xFF00U) << 8U) |
9000742c:	431a      	orrs	r2, r3
                                  ((sd_status[1] & 0xFF0000U) >> 8U) | ((sd_status[1] & 0xFF000000U) >> 24U));
9000742e:	68fb      	ldr	r3, [r7, #12]
90007430:	0e1b      	lsrs	r3, r3, #24
90007432:	431a      	orrs	r2, r3
    pStatus->ProtectedAreaSize = (((sd_status[1] & 0xFFU) << 24U)    | ((sd_status[1] & 0xFF00U) << 8U) |
90007434:	683b      	ldr	r3, [r7, #0]
90007436:	605a      	str	r2, [r3, #4]

    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
90007438:	693b      	ldr	r3, [r7, #16]
9000743a:	b2da      	uxtb	r2, r3
9000743c:	683b      	ldr	r3, [r7, #0]
9000743e:	721a      	strb	r2, [r3, #8]

    pStatus->PerformanceMove = (uint8_t)((sd_status[2] & 0xFF00U) >> 8U);
90007440:	693b      	ldr	r3, [r7, #16]
90007442:	0a1b      	lsrs	r3, r3, #8
90007444:	b2da      	uxtb	r2, r3
90007446:	683b      	ldr	r3, [r7, #0]
90007448:	725a      	strb	r2, [r3, #9]

    pStatus->AllocationUnitSize = (uint8_t)((sd_status[2] & 0xF00000U) >> 20U);
9000744a:	693b      	ldr	r3, [r7, #16]
9000744c:	0d1b      	lsrs	r3, r3, #20
9000744e:	b2db      	uxtb	r3, r3
90007450:	f003 030f 	and.w	r3, r3, #15
90007454:	b2da      	uxtb	r2, r3
90007456:	683b      	ldr	r3, [r7, #0]
90007458:	729a      	strb	r2, [r3, #10]

    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
9000745a:	693b      	ldr	r3, [r7, #16]
9000745c:	0c1b      	lsrs	r3, r3, #16
9000745e:	b29b      	uxth	r3, r3
90007460:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
90007464:	b29a      	uxth	r2, r3
90007466:	697b      	ldr	r3, [r7, #20]
90007468:	b29b      	uxth	r3, r3
9000746a:	b2db      	uxtb	r3, r3
9000746c:	b29b      	uxth	r3, r3
9000746e:	4313      	orrs	r3, r2
90007470:	b29a      	uxth	r2, r3
90007472:	683b      	ldr	r3, [r7, #0]
90007474:	819a      	strh	r2, [r3, #12]

    pStatus->EraseTimeout = (uint8_t)((sd_status[3] & 0xFC00U) >> 10U);
90007476:	697b      	ldr	r3, [r7, #20]
90007478:	0a9b      	lsrs	r3, r3, #10
9000747a:	b2db      	uxtb	r3, r3
9000747c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
90007480:	b2da      	uxtb	r2, r3
90007482:	683b      	ldr	r3, [r7, #0]
90007484:	739a      	strb	r2, [r3, #14]

    pStatus->EraseOffset = (uint8_t)((sd_status[3] & 0x0300U) >> 8U);
90007486:	697b      	ldr	r3, [r7, #20]
90007488:	0a1b      	lsrs	r3, r3, #8
9000748a:	b2db      	uxtb	r3, r3
9000748c:	f003 0303 	and.w	r3, r3, #3
90007490:	b2da      	uxtb	r2, r3
90007492:	683b      	ldr	r3, [r7, #0]
90007494:	73da      	strb	r2, [r3, #15]

    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
90007496:	697b      	ldr	r3, [r7, #20]
90007498:	091b      	lsrs	r3, r3, #4
9000749a:	b2db      	uxtb	r3, r3
9000749c:	f003 030f 	and.w	r3, r3, #15
900074a0:	b2da      	uxtb	r2, r3
900074a2:	683b      	ldr	r3, [r7, #0]
900074a4:	741a      	strb	r2, [r3, #16]
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
900074a6:	697b      	ldr	r3, [r7, #20]
900074a8:	b2db      	uxtb	r3, r3
900074aa:	f003 030f 	and.w	r3, r3, #15
900074ae:	b2da      	uxtb	r2, r3
900074b0:	683b      	ldr	r3, [r7, #0]
900074b2:	745a      	strb	r2, [r3, #17]
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
900074b4:	69bb      	ldr	r3, [r7, #24]
900074b6:	0e1b      	lsrs	r3, r3, #24
900074b8:	b2da      	uxtb	r2, r3
900074ba:	683b      	ldr	r3, [r7, #0]
900074bc:	749a      	strb	r2, [r3, #18]
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
900074be:	687b      	ldr	r3, [r7, #4]
900074c0:	681b      	ldr	r3, [r3, #0]
900074c2:	f44f 7100 	mov.w	r1, #512	@ 0x200
900074c6:	4618      	mov	r0, r3
900074c8:	f000 fe0e 	bl	900080e8 <SDMMC_CmdBlockLength>
900074cc:	64b8      	str	r0, [r7, #72]	@ 0x48
  if (errorstate != HAL_SD_ERROR_NONE)
900074ce:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
900074d0:	2b00      	cmp	r3, #0
900074d2:	d00d      	beq.n	900074f0 <HAL_SD_GetCardStatus+0x16c>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
900074d4:	687b      	ldr	r3, [r7, #4]
900074d6:	681b      	ldr	r3, [r3, #0]
900074d8:	4a08      	ldr	r2, [pc, #32]	@ (900074fc <HAL_SD_GetCardStatus+0x178>)
900074da:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->ErrorCode = errorstate;
900074dc:	687b      	ldr	r3, [r7, #4]
900074de:	6cba      	ldr	r2, [r7, #72]	@ 0x48
900074e0:	635a      	str	r2, [r3, #52]	@ 0x34
    hsd->State = HAL_SD_STATE_READY;
900074e2:	687b      	ldr	r3, [r7, #4]
900074e4:	2201      	movs	r2, #1
900074e6:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
    status = HAL_ERROR;
900074ea:	2301      	movs	r3, #1
900074ec:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
  }

  return status;
900074f0:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
}
900074f4:	4618      	mov	r0, r3
900074f6:	3750      	adds	r7, #80	@ 0x50
900074f8:	46bd      	mov	sp, r7
900074fa:	bd80      	pop	{r7, pc}
900074fc:	1fe00fff 	.word	0x1fe00fff

90007500 <HAL_SD_GetCardInfo>:
  * @param  pCardInfo: Pointer to the HAL_SD_CardInfoTypeDef structure that
  *         will contain the SD card status information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardInfo(const SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypeDef *pCardInfo)
{
90007500:	b480      	push	{r7}
90007502:	b083      	sub	sp, #12
90007504:	af00      	add	r7, sp, #0
90007506:	6078      	str	r0, [r7, #4]
90007508:	6039      	str	r1, [r7, #0]
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
9000750a:	687b      	ldr	r3, [r7, #4]
9000750c:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
9000750e:	683b      	ldr	r3, [r7, #0]
90007510:	601a      	str	r2, [r3, #0]
  pCardInfo->CardVersion  = (uint32_t)(hsd->SdCard.CardVersion);
90007512:	687b      	ldr	r3, [r7, #4]
90007514:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
90007516:	683b      	ldr	r3, [r7, #0]
90007518:	605a      	str	r2, [r3, #4]
  pCardInfo->Class        = (uint32_t)(hsd->SdCard.Class);
9000751a:	687b      	ldr	r3, [r7, #4]
9000751c:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
9000751e:	683b      	ldr	r3, [r7, #0]
90007520:	609a      	str	r2, [r3, #8]
  pCardInfo->RelCardAdd   = (uint32_t)(hsd->SdCard.RelCardAdd);
90007522:	687b      	ldr	r3, [r7, #4]
90007524:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
90007526:	683b      	ldr	r3, [r7, #0]
90007528:	60da      	str	r2, [r3, #12]
  pCardInfo->BlockNbr     = (uint32_t)(hsd->SdCard.BlockNbr);
9000752a:	687b      	ldr	r3, [r7, #4]
9000752c:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
9000752e:	683b      	ldr	r3, [r7, #0]
90007530:	611a      	str	r2, [r3, #16]
  pCardInfo->BlockSize    = (uint32_t)(hsd->SdCard.BlockSize);
90007532:	687b      	ldr	r3, [r7, #4]
90007534:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
90007536:	683b      	ldr	r3, [r7, #0]
90007538:	615a      	str	r2, [r3, #20]
  pCardInfo->LogBlockNbr  = (uint32_t)(hsd->SdCard.LogBlockNbr);
9000753a:	687b      	ldr	r3, [r7, #4]
9000753c:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
9000753e:	683b      	ldr	r3, [r7, #0]
90007540:	619a      	str	r2, [r3, #24]
  pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
90007542:	687b      	ldr	r3, [r7, #4]
90007544:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
90007546:	683b      	ldr	r3, [r7, #0]
90007548:	61da      	str	r2, [r3, #28]

  return HAL_OK;
9000754a:	2300      	movs	r3, #0
}
9000754c:	4618      	mov	r0, r3
9000754e:	370c      	adds	r7, #12
90007550:	46bd      	mov	sp, r7
90007552:	f85d 7b04 	ldr.w	r7, [sp], #4
90007556:	4770      	bx	lr

90007558 <HAL_SD_ConfigWideBusOperation>:
  *            @arg SDMMC_BUS_WIDE_4B: 4-bit data transfer
  *            @arg SDMMC_BUS_WIDE_1B: 1-bit data transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_ConfigWideBusOperation(SD_HandleTypeDef *hsd, uint32_t WideMode)
{
90007558:	b590      	push	{r4, r7, lr}
9000755a:	b08d      	sub	sp, #52	@ 0x34
9000755c:	af02      	add	r7, sp, #8
9000755e:	6078      	str	r0, [r7, #4]
90007560:	6039      	str	r1, [r7, #0]
  SDMMC_InitTypeDef Init;
  uint32_t errorstate;
  uint32_t sdmmc_clk;

  HAL_StatusTypeDef status = HAL_OK;
90007562:	2300      	movs	r3, #0
90007564:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

  /* Check the parameters */
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));

  /* Change State */
  hsd->State = HAL_SD_STATE_BUSY;
90007568:	687b      	ldr	r3, [r7, #4]
9000756a:	2203      	movs	r2, #3
9000756c:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  if (hsd->SdCard.CardType != CARD_SECURED)
90007570:	687b      	ldr	r3, [r7, #4]
90007572:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90007574:	2b03      	cmp	r3, #3
90007576:	d02e      	beq.n	900075d6 <HAL_SD_ConfigWideBusOperation+0x7e>
  {
    if (WideMode == SDMMC_BUS_WIDE_8B)
90007578:	683b      	ldr	r3, [r7, #0]
9000757a:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
9000757e:	d106      	bne.n	9000758e <HAL_SD_ConfigWideBusOperation+0x36>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
90007580:	687b      	ldr	r3, [r7, #4]
90007582:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90007584:	f043 5280 	orr.w	r2, r3, #268435456	@ 0x10000000
90007588:	687b      	ldr	r3, [r7, #4]
9000758a:	635a      	str	r2, [r3, #52]	@ 0x34
9000758c:	e029      	b.n	900075e2 <HAL_SD_ConfigWideBusOperation+0x8a>
    }
    else if (WideMode == SDMMC_BUS_WIDE_4B)
9000758e:	683b      	ldr	r3, [r7, #0]
90007590:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
90007594:	d10a      	bne.n	900075ac <HAL_SD_ConfigWideBusOperation+0x54>
    {
      errorstate = SD_WideBus_Enable(hsd);
90007596:	6878      	ldr	r0, [r7, #4]
90007598:	f000 fb62 	bl	90007c60 <SD_WideBus_Enable>
9000759c:	6238      	str	r0, [r7, #32]

      hsd->ErrorCode |= errorstate;
9000759e:	687b      	ldr	r3, [r7, #4]
900075a0:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
900075a2:	6a3b      	ldr	r3, [r7, #32]
900075a4:	431a      	orrs	r2, r3
900075a6:	687b      	ldr	r3, [r7, #4]
900075a8:	635a      	str	r2, [r3, #52]	@ 0x34
900075aa:	e01a      	b.n	900075e2 <HAL_SD_ConfigWideBusOperation+0x8a>
    }
    else if (WideMode == SDMMC_BUS_WIDE_1B)
900075ac:	683b      	ldr	r3, [r7, #0]
900075ae:	2b00      	cmp	r3, #0
900075b0:	d10a      	bne.n	900075c8 <HAL_SD_ConfigWideBusOperation+0x70>
    {
      errorstate = SD_WideBus_Disable(hsd);
900075b2:	6878      	ldr	r0, [r7, #4]
900075b4:	f000 fb9f 	bl	90007cf6 <SD_WideBus_Disable>
900075b8:	6238      	str	r0, [r7, #32]

      hsd->ErrorCode |= errorstate;
900075ba:	687b      	ldr	r3, [r7, #4]
900075bc:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
900075be:	6a3b      	ldr	r3, [r7, #32]
900075c0:	431a      	orrs	r2, r3
900075c2:	687b      	ldr	r3, [r7, #4]
900075c4:	635a      	str	r2, [r3, #52]	@ 0x34
900075c6:	e00c      	b.n	900075e2 <HAL_SD_ConfigWideBusOperation+0x8a>
    }
    else
    {
      /* WideMode is not a valid argument*/
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
900075c8:	687b      	ldr	r3, [r7, #4]
900075ca:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
900075cc:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
900075d0:	687b      	ldr	r3, [r7, #4]
900075d2:	635a      	str	r2, [r3, #52]	@ 0x34
900075d4:	e005      	b.n	900075e2 <HAL_SD_ConfigWideBusOperation+0x8a>
    }
  }
  else
  {
    /* SD Card does not support this feature */
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
900075d6:	687b      	ldr	r3, [r7, #4]
900075d8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
900075da:	f043 5280 	orr.w	r2, r3, #268435456	@ 0x10000000
900075de:	687b      	ldr	r3, [r7, #4]
900075e0:	635a      	str	r2, [r3, #52]	@ 0x34
  }

  if (hsd->ErrorCode != HAL_SD_ERROR_NONE)
900075e2:	687b      	ldr	r3, [r7, #4]
900075e4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
900075e6:	2b00      	cmp	r3, #0
900075e8:	d007      	beq.n	900075fa <HAL_SD_ConfigWideBusOperation+0xa2>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
900075ea:	687b      	ldr	r3, [r7, #4]
900075ec:	681b      	ldr	r3, [r3, #0]
900075ee:	4a5e      	ldr	r2, [pc, #376]	@ (90007768 <HAL_SD_ConfigWideBusOperation+0x210>)
900075f0:	639a      	str	r2, [r3, #56]	@ 0x38
    status = HAL_ERROR;
900075f2:	2301      	movs	r3, #1
900075f4:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
900075f8:	e094      	b.n	90007724 <HAL_SD_ConfigWideBusOperation+0x1cc>
  }
  else
  {
    sdmmc_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC12);
900075fa:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
900075fe:	f7fd f9e9 	bl	900049d4 <HAL_RCCEx_GetPeriphCLKFreq>
90007602:	61f8      	str	r0, [r7, #28]
    if (sdmmc_clk != 0U)
90007604:	69fb      	ldr	r3, [r7, #28]
90007606:	2b00      	cmp	r3, #0
90007608:	f000 8083 	beq.w	90007712 <HAL_SD_ConfigWideBusOperation+0x1ba>
    {
      /* Configure the SDMMC peripheral */
      Init.ClockEdge           = hsd->Init.ClockEdge;
9000760c:	687b      	ldr	r3, [r7, #4]
9000760e:	685b      	ldr	r3, [r3, #4]
90007610:	60bb      	str	r3, [r7, #8]
      Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
90007612:	687b      	ldr	r3, [r7, #4]
90007614:	689b      	ldr	r3, [r3, #8]
90007616:	60fb      	str	r3, [r7, #12]
      Init.BusWide             = WideMode;
90007618:	683b      	ldr	r3, [r7, #0]
9000761a:	613b      	str	r3, [r7, #16]
      Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
9000761c:	687b      	ldr	r3, [r7, #4]
9000761e:	691b      	ldr	r3, [r3, #16]
90007620:	617b      	str	r3, [r7, #20]

      /* Check if user Clock div < Normal speed 25Mhz, no change in Clockdiv */
      if (hsd->Init.ClockDiv >= (sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ)))
90007622:	687b      	ldr	r3, [r7, #4]
90007624:	695a      	ldr	r2, [r3, #20]
90007626:	69fb      	ldr	r3, [r7, #28]
90007628:	4950      	ldr	r1, [pc, #320]	@ (9000776c <HAL_SD_ConfigWideBusOperation+0x214>)
9000762a:	fba1 1303 	umull	r1, r3, r1, r3
9000762e:	0e1b      	lsrs	r3, r3, #24
90007630:	429a      	cmp	r2, r3
90007632:	d303      	bcc.n	9000763c <HAL_SD_ConfigWideBusOperation+0xe4>
      {
        Init.ClockDiv = hsd->Init.ClockDiv;
90007634:	687b      	ldr	r3, [r7, #4]
90007636:	695b      	ldr	r3, [r3, #20]
90007638:	61bb      	str	r3, [r7, #24]
9000763a:	e05a      	b.n	900076f2 <HAL_SD_ConfigWideBusOperation+0x19a>
      }
      else if (hsd->SdCard.CardSpeed == CARD_ULTRA_HIGH_SPEED)
9000763c:	687b      	ldr	r3, [r7, #4]
9000763e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
90007640:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
90007644:	d103      	bne.n	9000764e <HAL_SD_ConfigWideBusOperation+0xf6>
      {
        /* UltraHigh speed SD card,user Clock div */
        Init.ClockDiv = hsd->Init.ClockDiv;
90007646:	687b      	ldr	r3, [r7, #4]
90007648:	695b      	ldr	r3, [r3, #20]
9000764a:	61bb      	str	r3, [r7, #24]
9000764c:	e051      	b.n	900076f2 <HAL_SD_ConfigWideBusOperation+0x19a>
      }
      else if (hsd->SdCard.CardSpeed == CARD_HIGH_SPEED)
9000764e:	687b      	ldr	r3, [r7, #4]
90007650:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
90007652:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
90007656:	d126      	bne.n	900076a6 <HAL_SD_ConfigWideBusOperation+0x14e>
      {
        /* High speed SD card, Max Frequency = 50Mhz */
        if (hsd->Init.ClockDiv == 0U)
90007658:	687b      	ldr	r3, [r7, #4]
9000765a:	695b      	ldr	r3, [r3, #20]
9000765c:	2b00      	cmp	r3, #0
9000765e:	d10e      	bne.n	9000767e <HAL_SD_ConfigWideBusOperation+0x126>
        {
          if (sdmmc_clk > SD_HIGH_SPEED_FREQ)
90007660:	69fb      	ldr	r3, [r7, #28]
90007662:	4a43      	ldr	r2, [pc, #268]	@ (90007770 <HAL_SD_ConfigWideBusOperation+0x218>)
90007664:	4293      	cmp	r3, r2
90007666:	d906      	bls.n	90007676 <HAL_SD_ConfigWideBusOperation+0x11e>
          {
            Init.ClockDiv = sdmmc_clk / (2U * SD_HIGH_SPEED_FREQ);
90007668:	69fb      	ldr	r3, [r7, #28]
9000766a:	4a40      	ldr	r2, [pc, #256]	@ (9000776c <HAL_SD_ConfigWideBusOperation+0x214>)
9000766c:	fba2 2303 	umull	r2, r3, r2, r3
90007670:	0e5b      	lsrs	r3, r3, #25
90007672:	61bb      	str	r3, [r7, #24]
90007674:	e03d      	b.n	900076f2 <HAL_SD_ConfigWideBusOperation+0x19a>
          }
          else
          {
            Init.ClockDiv = hsd->Init.ClockDiv;
90007676:	687b      	ldr	r3, [r7, #4]
90007678:	695b      	ldr	r3, [r3, #20]
9000767a:	61bb      	str	r3, [r7, #24]
9000767c:	e039      	b.n	900076f2 <HAL_SD_ConfigWideBusOperation+0x19a>
          }
        }
        else
        {
          if ((sdmmc_clk / (2U * hsd->Init.ClockDiv)) > SD_HIGH_SPEED_FREQ)
9000767e:	687b      	ldr	r3, [r7, #4]
90007680:	695b      	ldr	r3, [r3, #20]
90007682:	005b      	lsls	r3, r3, #1
90007684:	69fa      	ldr	r2, [r7, #28]
90007686:	fbb2 f3f3 	udiv	r3, r2, r3
9000768a:	4a39      	ldr	r2, [pc, #228]	@ (90007770 <HAL_SD_ConfigWideBusOperation+0x218>)
9000768c:	4293      	cmp	r3, r2
9000768e:	d906      	bls.n	9000769e <HAL_SD_ConfigWideBusOperation+0x146>
          {
            Init.ClockDiv = sdmmc_clk / (2U * SD_HIGH_SPEED_FREQ);
90007690:	69fb      	ldr	r3, [r7, #28]
90007692:	4a36      	ldr	r2, [pc, #216]	@ (9000776c <HAL_SD_ConfigWideBusOperation+0x214>)
90007694:	fba2 2303 	umull	r2, r3, r2, r3
90007698:	0e5b      	lsrs	r3, r3, #25
9000769a:	61bb      	str	r3, [r7, #24]
9000769c:	e029      	b.n	900076f2 <HAL_SD_ConfigWideBusOperation+0x19a>
          }
          else
          {
            Init.ClockDiv = hsd->Init.ClockDiv;
9000769e:	687b      	ldr	r3, [r7, #4]
900076a0:	695b      	ldr	r3, [r3, #20]
900076a2:	61bb      	str	r3, [r7, #24]
900076a4:	e025      	b.n	900076f2 <HAL_SD_ConfigWideBusOperation+0x19a>
        }
      }
      else
      {
        /* No High speed SD card, Max Frequency = 25Mhz */
        if (hsd->Init.ClockDiv == 0U)
900076a6:	687b      	ldr	r3, [r7, #4]
900076a8:	695b      	ldr	r3, [r3, #20]
900076aa:	2b00      	cmp	r3, #0
900076ac:	d10e      	bne.n	900076cc <HAL_SD_ConfigWideBusOperation+0x174>
        {
          if (sdmmc_clk > SD_NORMAL_SPEED_FREQ)
900076ae:	69fb      	ldr	r3, [r7, #28]
900076b0:	4a30      	ldr	r2, [pc, #192]	@ (90007774 <HAL_SD_ConfigWideBusOperation+0x21c>)
900076b2:	4293      	cmp	r3, r2
900076b4:	d906      	bls.n	900076c4 <HAL_SD_ConfigWideBusOperation+0x16c>
          {
            Init.ClockDiv = sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ);
900076b6:	69fb      	ldr	r3, [r7, #28]
900076b8:	4a2c      	ldr	r2, [pc, #176]	@ (9000776c <HAL_SD_ConfigWideBusOperation+0x214>)
900076ba:	fba2 2303 	umull	r2, r3, r2, r3
900076be:	0e1b      	lsrs	r3, r3, #24
900076c0:	61bb      	str	r3, [r7, #24]
900076c2:	e016      	b.n	900076f2 <HAL_SD_ConfigWideBusOperation+0x19a>
          }
          else
          {
            Init.ClockDiv = hsd->Init.ClockDiv;
900076c4:	687b      	ldr	r3, [r7, #4]
900076c6:	695b      	ldr	r3, [r3, #20]
900076c8:	61bb      	str	r3, [r7, #24]
900076ca:	e012      	b.n	900076f2 <HAL_SD_ConfigWideBusOperation+0x19a>
          }
        }
        else
        {
          if ((sdmmc_clk / (2U * hsd->Init.ClockDiv)) > SD_NORMAL_SPEED_FREQ)
900076cc:	687b      	ldr	r3, [r7, #4]
900076ce:	695b      	ldr	r3, [r3, #20]
900076d0:	005b      	lsls	r3, r3, #1
900076d2:	69fa      	ldr	r2, [r7, #28]
900076d4:	fbb2 f3f3 	udiv	r3, r2, r3
900076d8:	4a26      	ldr	r2, [pc, #152]	@ (90007774 <HAL_SD_ConfigWideBusOperation+0x21c>)
900076da:	4293      	cmp	r3, r2
900076dc:	d906      	bls.n	900076ec <HAL_SD_ConfigWideBusOperation+0x194>
          {
            Init.ClockDiv = sdmmc_clk / (2U * SD_NORMAL_SPEED_FREQ);
900076de:	69fb      	ldr	r3, [r7, #28]
900076e0:	4a22      	ldr	r2, [pc, #136]	@ (9000776c <HAL_SD_ConfigWideBusOperation+0x214>)
900076e2:	fba2 2303 	umull	r2, r3, r2, r3
900076e6:	0e1b      	lsrs	r3, r3, #24
900076e8:	61bb      	str	r3, [r7, #24]
900076ea:	e002      	b.n	900076f2 <HAL_SD_ConfigWideBusOperation+0x19a>
          }
          else
          {
            Init.ClockDiv = hsd->Init.ClockDiv;
900076ec:	687b      	ldr	r3, [r7, #4]
900076ee:	695b      	ldr	r3, [r3, #20]
900076f0:	61bb      	str	r3, [r7, #24]

#if (USE_SD_TRANSCEIVER != 0U)
      Init.TranceiverPresent = hsd->Init.TranceiverPresent;
#endif /* USE_SD_TRANSCEIVER */

      (void)SDMMC_Init(hsd->Instance, Init);
900076f2:	687b      	ldr	r3, [r7, #4]
900076f4:	681c      	ldr	r4, [r3, #0]
900076f6:	466a      	mov	r2, sp
900076f8:	f107 0314 	add.w	r3, r7, #20
900076fc:	e893 0003 	ldmia.w	r3, {r0, r1}
90007700:	e882 0003 	stmia.w	r2, {r0, r1}
90007704:	f107 0308 	add.w	r3, r7, #8
90007708:	cb0e      	ldmia	r3, {r1, r2, r3}
9000770a:	4620      	mov	r0, r4
9000770c:	f000 fc0e 	bl	90007f2c <SDMMC_Init>
90007710:	e008      	b.n	90007724 <HAL_SD_ConfigWideBusOperation+0x1cc>
    }
    else
    {
      hsd->ErrorCode |= SDMMC_ERROR_INVALID_PARAMETER;
90007712:	687b      	ldr	r3, [r7, #4]
90007714:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90007716:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
9000771a:	687b      	ldr	r3, [r7, #4]
9000771c:	635a      	str	r2, [r3, #52]	@ 0x34
      status = HAL_ERROR;
9000771e:	2301      	movs	r3, #1
90007720:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    }
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
90007724:	687b      	ldr	r3, [r7, #4]
90007726:	681b      	ldr	r3, [r3, #0]
90007728:	f44f 7100 	mov.w	r1, #512	@ 0x200
9000772c:	4618      	mov	r0, r3
9000772e:	f000 fcdb 	bl	900080e8 <SDMMC_CmdBlockLength>
90007732:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_SD_ERROR_NONE)
90007734:	6a3b      	ldr	r3, [r7, #32]
90007736:	2b00      	cmp	r3, #0
90007738:	d00c      	beq.n	90007754 <HAL_SD_ConfigWideBusOperation+0x1fc>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
9000773a:	687b      	ldr	r3, [r7, #4]
9000773c:	681b      	ldr	r3, [r3, #0]
9000773e:	4a0a      	ldr	r2, [pc, #40]	@ (90007768 <HAL_SD_ConfigWideBusOperation+0x210>)
90007740:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->ErrorCode |= errorstate;
90007742:	687b      	ldr	r3, [r7, #4]
90007744:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
90007746:	6a3b      	ldr	r3, [r7, #32]
90007748:	431a      	orrs	r2, r3
9000774a:	687b      	ldr	r3, [r7, #4]
9000774c:	635a      	str	r2, [r3, #52]	@ 0x34
    status = HAL_ERROR;
9000774e:	2301      	movs	r3, #1
90007750:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Change State */
  hsd->State = HAL_SD_STATE_READY;
90007754:	687b      	ldr	r3, [r7, #4]
90007756:	2201      	movs	r2, #1
90007758:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return status;
9000775c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
90007760:	4618      	mov	r0, r3
90007762:	372c      	adds	r7, #44	@ 0x2c
90007764:	46bd      	mov	sp, r7
90007766:	bd90      	pop	{r4, r7, pc}
90007768:	1fe00fff 	.word	0x1fe00fff
9000776c:	55e63b89 	.word	0x55e63b89
90007770:	02faf080 	.word	0x02faf080
90007774:	017d7840 	.word	0x017d7840

90007778 <HAL_SD_GetCardState>:
  * @brief  Gets the current sd card data state.
  * @param  hsd: pointer to SD handle
  * @retval Card state
  */
HAL_SD_CardStateTypeDef HAL_SD_GetCardState(SD_HandleTypeDef *hsd)
{
90007778:	b580      	push	{r7, lr}
9000777a:	b086      	sub	sp, #24
9000777c:	af00      	add	r7, sp, #0
9000777e:	6078      	str	r0, [r7, #4]
  uint32_t cardstate;
  uint32_t errorstate;
  uint32_t resp1 = 0;
90007780:	2300      	movs	r3, #0
90007782:	60fb      	str	r3, [r7, #12]

  errorstate = SD_SendStatus(hsd, &resp1);
90007784:	f107 030c 	add.w	r3, r7, #12
90007788:	4619      	mov	r1, r3
9000778a:	6878      	ldr	r0, [r7, #4]
9000778c:	f000 fa40 	bl	90007c10 <SD_SendStatus>
90007790:	6178      	str	r0, [r7, #20]
  if (errorstate != HAL_SD_ERROR_NONE)
90007792:	697b      	ldr	r3, [r7, #20]
90007794:	2b00      	cmp	r3, #0
90007796:	d005      	beq.n	900077a4 <HAL_SD_GetCardState+0x2c>
  {
    hsd->ErrorCode |= errorstate;
90007798:	687b      	ldr	r3, [r7, #4]
9000779a:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
9000779c:	697b      	ldr	r3, [r7, #20]
9000779e:	431a      	orrs	r2, r3
900077a0:	687b      	ldr	r3, [r7, #4]
900077a2:	635a      	str	r2, [r3, #52]	@ 0x34
  }

  cardstate = ((resp1 >> 9U) & 0x0FU);
900077a4:	68fb      	ldr	r3, [r7, #12]
900077a6:	0a5b      	lsrs	r3, r3, #9
900077a8:	f003 030f 	and.w	r3, r3, #15
900077ac:	613b      	str	r3, [r7, #16]

  return (HAL_SD_CardStateTypeDef)cardstate;
900077ae:	693b      	ldr	r3, [r7, #16]
}
900077b0:	4618      	mov	r0, r3
900077b2:	3718      	adds	r7, #24
900077b4:	46bd      	mov	sp, r7
900077b6:	bd80      	pop	{r7, pc}

900077b8 <SD_InitCard>:
  * @brief  Initializes the sd card.
  * @param  hsd: Pointer to SD handle
  * @retval SD Card error state
  */
static uint32_t SD_InitCard(SD_HandleTypeDef *hsd)
{
900077b8:	b580      	push	{r7, lr}
900077ba:	b090      	sub	sp, #64	@ 0x40
900077bc:	af00      	add	r7, sp, #0
900077be:	6078      	str	r0, [r7, #4]
  HAL_SD_CardCSDTypeDef CSD;
  uint32_t errorstate;
  uint16_t sd_rca = 0U;
900077c0:	2300      	movs	r3, #0
900077c2:	817b      	strh	r3, [r7, #10]
  uint32_t tickstart = HAL_GetTick();
900077c4:	f7f9 ff7e 	bl	900016c4 <HAL_GetTick>
900077c8:	63f8      	str	r0, [r7, #60]	@ 0x3c

  /* Check the power State */
  if (SDMMC_GetPowerState(hsd->Instance) == 0U)
900077ca:	687b      	ldr	r3, [r7, #4]
900077cc:	681b      	ldr	r3, [r3, #0]
900077ce:	4618      	mov	r0, r3
900077d0:	f000 fc05 	bl	90007fde <SDMMC_GetPowerState>
900077d4:	4603      	mov	r3, r0
900077d6:	2b00      	cmp	r3, #0
900077d8:	d102      	bne.n	900077e0 <SD_InitCard+0x28>
  {
    /* Power off */
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
900077da:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
900077de:	e0b5      	b.n	9000794c <SD_InitCard+0x194>
  }

  if (hsd->SdCard.CardType != CARD_SECURED)
900077e0:	687b      	ldr	r3, [r7, #4]
900077e2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
900077e4:	2b03      	cmp	r3, #3
900077e6:	d02e      	beq.n	90007846 <SD_InitCard+0x8e>
  {
    /* Send CMD2 ALL_SEND_CID */
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
900077e8:	687b      	ldr	r3, [r7, #4]
900077ea:	681b      	ldr	r3, [r3, #0]
900077ec:	4618      	mov	r0, r3
900077ee:	f000 fe50 	bl	90008492 <SDMMC_CmdSendCID>
900077f2:	63b8      	str	r0, [r7, #56]	@ 0x38
    if (errorstate != HAL_SD_ERROR_NONE)
900077f4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
900077f6:	2b00      	cmp	r3, #0
900077f8:	d001      	beq.n	900077fe <SD_InitCard+0x46>
    {
      return errorstate;
900077fa:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
900077fc:	e0a6      	b.n	9000794c <SD_InitCard+0x194>
    }
    else
    {
      /* Get Card identification number data */
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
900077fe:	687b      	ldr	r3, [r7, #4]
90007800:	681b      	ldr	r3, [r3, #0]
90007802:	2100      	movs	r1, #0
90007804:	4618      	mov	r0, r3
90007806:	f000 fc30 	bl	9000806a <SDMMC_GetResponse>
9000780a:	4602      	mov	r2, r0
9000780c:	687b      	ldr	r3, [r7, #4]
9000780e:	66da      	str	r2, [r3, #108]	@ 0x6c
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
90007810:	687b      	ldr	r3, [r7, #4]
90007812:	681b      	ldr	r3, [r3, #0]
90007814:	2104      	movs	r1, #4
90007816:	4618      	mov	r0, r3
90007818:	f000 fc27 	bl	9000806a <SDMMC_GetResponse>
9000781c:	4602      	mov	r2, r0
9000781e:	687b      	ldr	r3, [r7, #4]
90007820:	671a      	str	r2, [r3, #112]	@ 0x70
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
90007822:	687b      	ldr	r3, [r7, #4]
90007824:	681b      	ldr	r3, [r3, #0]
90007826:	2108      	movs	r1, #8
90007828:	4618      	mov	r0, r3
9000782a:	f000 fc1e 	bl	9000806a <SDMMC_GetResponse>
9000782e:	4602      	mov	r2, r0
90007830:	687b      	ldr	r3, [r7, #4]
90007832:	675a      	str	r2, [r3, #116]	@ 0x74
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
90007834:	687b      	ldr	r3, [r7, #4]
90007836:	681b      	ldr	r3, [r3, #0]
90007838:	210c      	movs	r1, #12
9000783a:	4618      	mov	r0, r3
9000783c:	f000 fc15 	bl	9000806a <SDMMC_GetResponse>
90007840:	4602      	mov	r2, r0
90007842:	687b      	ldr	r3, [r7, #4]
90007844:	679a      	str	r2, [r3, #120]	@ 0x78
    }
  }

  if (hsd->SdCard.CardType != CARD_SECURED)
90007846:	687b      	ldr	r3, [r7, #4]
90007848:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
9000784a:	2b03      	cmp	r3, #3
9000784c:	d01d      	beq.n	9000788a <SD_InitCard+0xd2>
  {
    /* Send CMD3 SET_REL_ADDR with argument 0 */
    /* SD Card publishes its RCA. */
    while (sd_rca == 0U)
9000784e:	e019      	b.n	90007884 <SD_InitCard+0xcc>
    {
      errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
90007850:	687b      	ldr	r3, [r7, #4]
90007852:	681b      	ldr	r3, [r3, #0]
90007854:	f107 020a 	add.w	r2, r7, #10
90007858:	4611      	mov	r1, r2
9000785a:	4618      	mov	r0, r3
9000785c:	f000 fe58 	bl	90008510 <SDMMC_CmdSetRelAdd>
90007860:	63b8      	str	r0, [r7, #56]	@ 0x38
      if (errorstate != HAL_SD_ERROR_NONE)
90007862:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
90007864:	2b00      	cmp	r3, #0
90007866:	d001      	beq.n	9000786c <SD_InitCard+0xb4>
      {
        return errorstate;
90007868:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
9000786a:	e06f      	b.n	9000794c <SD_InitCard+0x194>
      }
      if ((HAL_GetTick() - tickstart) >=  SDMMC_CMDTIMEOUT)
9000786c:	f7f9 ff2a 	bl	900016c4 <HAL_GetTick>
90007870:	4602      	mov	r2, r0
90007872:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
90007874:	1ad3      	subs	r3, r2, r3
90007876:	f241 3287 	movw	r2, #4999	@ 0x1387
9000787a:	4293      	cmp	r3, r2
9000787c:	d902      	bls.n	90007884 <SD_InitCard+0xcc>
      {
        return HAL_SD_ERROR_TIMEOUT;
9000787e:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
90007882:	e063      	b.n	9000794c <SD_InitCard+0x194>
    while (sd_rca == 0U)
90007884:	897b      	ldrh	r3, [r7, #10]
90007886:	2b00      	cmp	r3, #0
90007888:	d0e2      	beq.n	90007850 <SD_InitCard+0x98>
      }
    }
  }
  if (hsd->SdCard.CardType != CARD_SECURED)
9000788a:	687b      	ldr	r3, [r7, #4]
9000788c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
9000788e:	2b03      	cmp	r3, #3
90007890:	d036      	beq.n	90007900 <SD_InitCard+0x148>
  {
    /* Get the SD card RCA */
    hsd->SdCard.RelCardAdd = sd_rca;
90007892:	897b      	ldrh	r3, [r7, #10]
90007894:	461a      	mov	r2, r3
90007896:	687b      	ldr	r3, [r7, #4]
90007898:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Send CMD9 SEND_CSD with argument as card's RCA */
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
9000789a:	687b      	ldr	r3, [r7, #4]
9000789c:	681a      	ldr	r2, [r3, #0]
9000789e:	687b      	ldr	r3, [r7, #4]
900078a0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
900078a2:	041b      	lsls	r3, r3, #16
900078a4:	4619      	mov	r1, r3
900078a6:	4610      	mov	r0, r2
900078a8:	f000 fe12 	bl	900084d0 <SDMMC_CmdSendCSD>
900078ac:	63b8      	str	r0, [r7, #56]	@ 0x38
    if (errorstate != HAL_SD_ERROR_NONE)
900078ae:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
900078b0:	2b00      	cmp	r3, #0
900078b2:	d001      	beq.n	900078b8 <SD_InitCard+0x100>
    {
      return errorstate;
900078b4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
900078b6:	e049      	b.n	9000794c <SD_InitCard+0x194>
    }
    else
    {
      /* Get Card Specific Data */
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
900078b8:	687b      	ldr	r3, [r7, #4]
900078ba:	681b      	ldr	r3, [r3, #0]
900078bc:	2100      	movs	r1, #0
900078be:	4618      	mov	r0, r3
900078c0:	f000 fbd3 	bl	9000806a <SDMMC_GetResponse>
900078c4:	4602      	mov	r2, r0
900078c6:	687b      	ldr	r3, [r7, #4]
900078c8:	65da      	str	r2, [r3, #92]	@ 0x5c
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
900078ca:	687b      	ldr	r3, [r7, #4]
900078cc:	681b      	ldr	r3, [r3, #0]
900078ce:	2104      	movs	r1, #4
900078d0:	4618      	mov	r0, r3
900078d2:	f000 fbca 	bl	9000806a <SDMMC_GetResponse>
900078d6:	4602      	mov	r2, r0
900078d8:	687b      	ldr	r3, [r7, #4]
900078da:	661a      	str	r2, [r3, #96]	@ 0x60
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
900078dc:	687b      	ldr	r3, [r7, #4]
900078de:	681b      	ldr	r3, [r3, #0]
900078e0:	2108      	movs	r1, #8
900078e2:	4618      	mov	r0, r3
900078e4:	f000 fbc1 	bl	9000806a <SDMMC_GetResponse>
900078e8:	4602      	mov	r2, r0
900078ea:	687b      	ldr	r3, [r7, #4]
900078ec:	665a      	str	r2, [r3, #100]	@ 0x64
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
900078ee:	687b      	ldr	r3, [r7, #4]
900078f0:	681b      	ldr	r3, [r3, #0]
900078f2:	210c      	movs	r1, #12
900078f4:	4618      	mov	r0, r3
900078f6:	f000 fbb8 	bl	9000806a <SDMMC_GetResponse>
900078fa:	4602      	mov	r2, r0
900078fc:	687b      	ldr	r3, [r7, #4]
900078fe:	669a      	str	r2, [r3, #104]	@ 0x68
    }
  }

  /* Get the Card Class */
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
90007900:	687b      	ldr	r3, [r7, #4]
90007902:	681b      	ldr	r3, [r3, #0]
90007904:	2104      	movs	r1, #4
90007906:	4618      	mov	r0, r3
90007908:	f000 fbaf 	bl	9000806a <SDMMC_GetResponse>
9000790c:	4603      	mov	r3, r0
9000790e:	0d1a      	lsrs	r2, r3, #20
90007910:	687b      	ldr	r3, [r7, #4]
90007912:	641a      	str	r2, [r3, #64]	@ 0x40

  /* Get CSD parameters */
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
90007914:	f107 030c 	add.w	r3, r7, #12
90007918:	4619      	mov	r1, r3
9000791a:	6878      	ldr	r0, [r7, #4]
9000791c:	f7ff fb8e 	bl	9000703c <HAL_SD_GetCardCSD>
90007920:	4603      	mov	r3, r0
90007922:	2b00      	cmp	r3, #0
90007924:	d002      	beq.n	9000792c <SD_InitCard+0x174>
  {
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
90007926:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
9000792a:	e00f      	b.n	9000794c <SD_InitCard+0x194>
  }

  /* Select the Card */
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16U));
9000792c:	687b      	ldr	r3, [r7, #4]
9000792e:	681a      	ldr	r2, [r3, #0]
90007930:	687b      	ldr	r3, [r7, #4]
90007932:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
90007934:	041b      	lsls	r3, r3, #16
90007936:	4619      	mov	r1, r3
90007938:	4610      	mov	r0, r2
9000793a:	f000 fcc1 	bl	900082c0 <SDMMC_CmdSelDesel>
9000793e:	63b8      	str	r0, [r7, #56]	@ 0x38
  if (errorstate != HAL_SD_ERROR_NONE)
90007940:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
90007942:	2b00      	cmp	r3, #0
90007944:	d001      	beq.n	9000794a <SD_InitCard+0x192>
  {
    return errorstate;
90007946:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
90007948:	e000      	b.n	9000794c <SD_InitCard+0x194>
  }

  /* All cards are initialized */
  return HAL_SD_ERROR_NONE;
9000794a:	2300      	movs	r3, #0
}
9000794c:	4618      	mov	r0, r3
9000794e:	3740      	adds	r7, #64	@ 0x40
90007950:	46bd      	mov	sp, r7
90007952:	bd80      	pop	{r7, pc}

90007954 <SD_PowerON>:
  *         in the SD handle.
  * @param  hsd: Pointer to SD handle
  * @retval error state
  */
static uint32_t SD_PowerON(SD_HandleTypeDef *hsd)
{
90007954:	b580      	push	{r7, lr}
90007956:	b086      	sub	sp, #24
90007958:	af00      	add	r7, sp, #0
9000795a:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
9000795c:	2300      	movs	r3, #0
9000795e:	60bb      	str	r3, [r7, #8]
  uint32_t response = 0U;
90007960:	2300      	movs	r3, #0
90007962:	617b      	str	r3, [r7, #20]
  uint32_t validvoltage = 0U;
90007964:	2300      	movs	r3, #0
90007966:	613b      	str	r3, [r7, #16]
#if (USE_SD_TRANSCEIVER != 0U)
  uint32_t tickstart = HAL_GetTick();
#endif /* USE_SD_TRANSCEIVER  */

  /* CMD0: GO_IDLE_STATE */
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
90007968:	687b      	ldr	r3, [r7, #4]
9000796a:	681b      	ldr	r3, [r3, #0]
9000796c:	4618      	mov	r0, r3
9000796e:	f000 fcca 	bl	90008306 <SDMMC_CmdGoIdleState>
90007972:	60f8      	str	r0, [r7, #12]
  if (errorstate != HAL_SD_ERROR_NONE)
90007974:	68fb      	ldr	r3, [r7, #12]
90007976:	2b00      	cmp	r3, #0
90007978:	d001      	beq.n	9000797e <SD_PowerON+0x2a>
  {
    return errorstate;
9000797a:	68fb      	ldr	r3, [r7, #12]
9000797c:	e071      	b.n	90007a62 <SD_PowerON+0x10e>
  }

  /* CMD8: SEND_IF_COND: Command available only on V2.0 cards */
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
9000797e:	687b      	ldr	r3, [r7, #4]
90007980:	681b      	ldr	r3, [r3, #0]
90007982:	4618      	mov	r0, r3
90007984:	f000 fcdd 	bl	90008342 <SDMMC_CmdOperCond>
90007988:	60f8      	str	r0, [r7, #12]
  if (errorstate == SDMMC_ERROR_CMD_RSP_TIMEOUT) /* No response to CMD8 */
9000798a:	68fb      	ldr	r3, [r7, #12]
9000798c:	2b04      	cmp	r3, #4
9000798e:	d10d      	bne.n	900079ac <SD_PowerON+0x58>
  {
    hsd->SdCard.CardVersion = CARD_V1_X;
90007990:	687b      	ldr	r3, [r7, #4]
90007992:	2200      	movs	r2, #0
90007994:	63da      	str	r2, [r3, #60]	@ 0x3c
    /* CMD0: GO_IDLE_STATE */
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
90007996:	687b      	ldr	r3, [r7, #4]
90007998:	681b      	ldr	r3, [r3, #0]
9000799a:	4618      	mov	r0, r3
9000799c:	f000 fcb3 	bl	90008306 <SDMMC_CmdGoIdleState>
900079a0:	60f8      	str	r0, [r7, #12]
    if (errorstate != HAL_SD_ERROR_NONE)
900079a2:	68fb      	ldr	r3, [r7, #12]
900079a4:	2b00      	cmp	r3, #0
900079a6:	d004      	beq.n	900079b2 <SD_PowerON+0x5e>
    {
      return errorstate;
900079a8:	68fb      	ldr	r3, [r7, #12]
900079aa:	e05a      	b.n	90007a62 <SD_PowerON+0x10e>
    }

  }
  else
  {
    hsd->SdCard.CardVersion = CARD_V2_X;
900079ac:	687b      	ldr	r3, [r7, #4]
900079ae:	2201      	movs	r2, #1
900079b0:	63da      	str	r2, [r3, #60]	@ 0x3c
  }

  if (hsd->SdCard.CardVersion == CARD_V2_X)
900079b2:	687b      	ldr	r3, [r7, #4]
900079b4:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
900079b6:	2b01      	cmp	r3, #1
900079b8:	d137      	bne.n	90007a2a <SD_PowerON+0xd6>
  {
    /* SEND CMD55 APP_CMD with RCA as 0 */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
900079ba:	687b      	ldr	r3, [r7, #4]
900079bc:	681b      	ldr	r3, [r3, #0]
900079be:	2100      	movs	r1, #0
900079c0:	4618      	mov	r0, r3
900079c2:	f000 fcde 	bl	90008382 <SDMMC_CmdAppCommand>
900079c6:	60f8      	str	r0, [r7, #12]
    if (errorstate != HAL_SD_ERROR_NONE)
900079c8:	68fb      	ldr	r3, [r7, #12]
900079ca:	2b00      	cmp	r3, #0
900079cc:	d02d      	beq.n	90007a2a <SD_PowerON+0xd6>
    {
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
900079ce:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
900079d2:	e046      	b.n	90007a62 <SD_PowerON+0x10e>
  /* SD CARD */
  /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
  while ((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
  {
    /* SEND CMD55 APP_CMD with RCA as 0 */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
900079d4:	687b      	ldr	r3, [r7, #4]
900079d6:	681b      	ldr	r3, [r3, #0]
900079d8:	2100      	movs	r1, #0
900079da:	4618      	mov	r0, r3
900079dc:	f000 fcd1 	bl	90008382 <SDMMC_CmdAppCommand>
900079e0:	60f8      	str	r0, [r7, #12]
    if (errorstate != HAL_SD_ERROR_NONE)
900079e2:	68fb      	ldr	r3, [r7, #12]
900079e4:	2b00      	cmp	r3, #0
900079e6:	d001      	beq.n	900079ec <SD_PowerON+0x98>
    {
      return errorstate;
900079e8:	68fb      	ldr	r3, [r7, #12]
900079ea:	e03a      	b.n	90007a62 <SD_PowerON+0x10e>
    }

    /* Send CMD41 */
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY |
900079ec:	687b      	ldr	r3, [r7, #4]
900079ee:	681b      	ldr	r3, [r3, #0]
900079f0:	491e      	ldr	r1, [pc, #120]	@ (90007a6c <SD_PowerON+0x118>)
900079f2:	4618      	mov	r0, r3
900079f4:	f000 fce8 	bl	900083c8 <SDMMC_CmdAppOperCommand>
900079f8:	60f8      	str	r0, [r7, #12]
                                         SD_SWITCH_1_8V_CAPACITY);
    if (errorstate != HAL_SD_ERROR_NONE)
900079fa:	68fb      	ldr	r3, [r7, #12]
900079fc:	2b00      	cmp	r3, #0
900079fe:	d002      	beq.n	90007a06 <SD_PowerON+0xb2>
    {
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
90007a00:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
90007a04:	e02d      	b.n	90007a62 <SD_PowerON+0x10e>
    }

    /* Get command response */
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
90007a06:	687b      	ldr	r3, [r7, #4]
90007a08:	681b      	ldr	r3, [r3, #0]
90007a0a:	2100      	movs	r1, #0
90007a0c:	4618      	mov	r0, r3
90007a0e:	f000 fb2c 	bl	9000806a <SDMMC_GetResponse>
90007a12:	6178      	str	r0, [r7, #20]

    /* Get operating voltage*/
    validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
90007a14:	697b      	ldr	r3, [r7, #20]
90007a16:	0fdb      	lsrs	r3, r3, #31
90007a18:	2b01      	cmp	r3, #1
90007a1a:	d101      	bne.n	90007a20 <SD_PowerON+0xcc>
90007a1c:	2301      	movs	r3, #1
90007a1e:	e000      	b.n	90007a22 <SD_PowerON+0xce>
90007a20:	2300      	movs	r3, #0
90007a22:	613b      	str	r3, [r7, #16]

    count++;
90007a24:	68bb      	ldr	r3, [r7, #8]
90007a26:	3301      	adds	r3, #1
90007a28:	60bb      	str	r3, [r7, #8]
  while ((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
90007a2a:	68bb      	ldr	r3, [r7, #8]
90007a2c:	f64f 72fe 	movw	r2, #65534	@ 0xfffe
90007a30:	4293      	cmp	r3, r2
90007a32:	d802      	bhi.n	90007a3a <SD_PowerON+0xe6>
90007a34:	693b      	ldr	r3, [r7, #16]
90007a36:	2b00      	cmp	r3, #0
90007a38:	d0cc      	beq.n	900079d4 <SD_PowerON+0x80>
  }

  if (count >= SDMMC_MAX_VOLT_TRIAL)
90007a3a:	68bb      	ldr	r3, [r7, #8]
90007a3c:	f64f 72fe 	movw	r2, #65534	@ 0xfffe
90007a40:	4293      	cmp	r3, r2
90007a42:	d902      	bls.n	90007a4a <SD_PowerON+0xf6>
  {
    return HAL_SD_ERROR_INVALID_VOLTRANGE;
90007a44:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
90007a48:	e00b      	b.n	90007a62 <SD_PowerON+0x10e>
  }

  /* Set default card type */
  hsd->SdCard.CardType = CARD_SDSC;
90007a4a:	687b      	ldr	r3, [r7, #4]
90007a4c:	2200      	movs	r2, #0
90007a4e:	639a      	str	r2, [r3, #56]	@ 0x38

  if ((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY)
90007a50:	697b      	ldr	r3, [r7, #20]
90007a52:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
90007a56:	2b00      	cmp	r3, #0
90007a58:	d002      	beq.n	90007a60 <SD_PowerON+0x10c>
  {
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
90007a5a:	687b      	ldr	r3, [r7, #4]
90007a5c:	2201      	movs	r2, #1
90007a5e:	639a      	str	r2, [r3, #56]	@ 0x38
      }
    }
#endif /* USE_SD_TRANSCEIVER  */
  }

  return HAL_SD_ERROR_NONE;
90007a60:	2300      	movs	r3, #0
}
90007a62:	4618      	mov	r0, r3
90007a64:	3718      	adds	r7, #24
90007a66:	46bd      	mov	sp, r7
90007a68:	bd80      	pop	{r7, pc}
90007a6a:	bf00      	nop
90007a6c:	c1100000 	.word	0xc1100000

90007a70 <SD_SendSDStatus>:
  * @param  pSDstatus: Pointer to the buffer that will contain the SD card status
  *         SD Status register)
  * @retval error state
  */
static uint32_t SD_SendSDStatus(SD_HandleTypeDef *hsd, uint32_t *pSDstatus)
{
90007a70:	b580      	push	{r7, lr}
90007a72:	b08c      	sub	sp, #48	@ 0x30
90007a74:	af00      	add	r7, sp, #0
90007a76:	6078      	str	r0, [r7, #4]
90007a78:	6039      	str	r1, [r7, #0]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
90007a7a:	f7f9 fe23 	bl	900016c4 <HAL_GetTick>
90007a7e:	6278      	str	r0, [r7, #36]	@ 0x24
  uint32_t count;
  uint32_t *pData = pSDstatus;
90007a80:	683b      	ldr	r3, [r7, #0]
90007a82:	62bb      	str	r3, [r7, #40]	@ 0x28

  /* Check SD response */
  if ((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
90007a84:	687b      	ldr	r3, [r7, #4]
90007a86:	681b      	ldr	r3, [r3, #0]
90007a88:	2100      	movs	r1, #0
90007a8a:	4618      	mov	r0, r3
90007a8c:	f000 faed 	bl	9000806a <SDMMC_GetResponse>
90007a90:	4603      	mov	r3, r0
90007a92:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
90007a96:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
90007a9a:	d102      	bne.n	90007aa2 <SD_SendSDStatus+0x32>
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
90007a9c:	f44f 6300 	mov.w	r3, #2048	@ 0x800
90007aa0:	e0b0      	b.n	90007c04 <SD_SendSDStatus+0x194>
  }

  /* Set block size for card if it is not equal to current block size for card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 64U);
90007aa2:	687b      	ldr	r3, [r7, #4]
90007aa4:	681b      	ldr	r3, [r3, #0]
90007aa6:	2140      	movs	r1, #64	@ 0x40
90007aa8:	4618      	mov	r0, r3
90007aaa:	f000 fb1d 	bl	900080e8 <SDMMC_CmdBlockLength>
90007aae:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_SD_ERROR_NONE)
90007ab0:	6a3b      	ldr	r3, [r7, #32]
90007ab2:	2b00      	cmp	r3, #0
90007ab4:	d005      	beq.n	90007ac2 <SD_SendSDStatus+0x52>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_NONE;
90007ab6:	687b      	ldr	r3, [r7, #4]
90007ab8:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
90007aba:	687b      	ldr	r3, [r7, #4]
90007abc:	635a      	str	r2, [r3, #52]	@ 0x34
    return errorstate;
90007abe:	6a3b      	ldr	r3, [r7, #32]
90007ac0:	e0a0      	b.n	90007c04 <SD_SendSDStatus+0x194>
  }

  /* Send CMD55 */
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
90007ac2:	687b      	ldr	r3, [r7, #4]
90007ac4:	681a      	ldr	r2, [r3, #0]
90007ac6:	687b      	ldr	r3, [r7, #4]
90007ac8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
90007aca:	041b      	lsls	r3, r3, #16
90007acc:	4619      	mov	r1, r3
90007ace:	4610      	mov	r0, r2
90007ad0:	f000 fc57 	bl	90008382 <SDMMC_CmdAppCommand>
90007ad4:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_SD_ERROR_NONE)
90007ad6:	6a3b      	ldr	r3, [r7, #32]
90007ad8:	2b00      	cmp	r3, #0
90007ada:	d005      	beq.n	90007ae8 <SD_SendSDStatus+0x78>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_NONE;
90007adc:	687b      	ldr	r3, [r7, #4]
90007ade:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
90007ae0:	687b      	ldr	r3, [r7, #4]
90007ae2:	635a      	str	r2, [r3, #52]	@ 0x34
    return errorstate;
90007ae4:	6a3b      	ldr	r3, [r7, #32]
90007ae6:	e08d      	b.n	90007c04 <SD_SendSDStatus+0x194>
  }

  /* Configure the SD DPSM (Data Path State Machine) */
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
90007ae8:	f04f 33ff 	mov.w	r3, #4294967295
90007aec:	60bb      	str	r3, [r7, #8]
  config.DataLength    = 64U;
90007aee:	2340      	movs	r3, #64	@ 0x40
90007af0:	60fb      	str	r3, [r7, #12]
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B;
90007af2:	2360      	movs	r3, #96	@ 0x60
90007af4:	613b      	str	r3, [r7, #16]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
90007af6:	2302      	movs	r3, #2
90007af8:	617b      	str	r3, [r7, #20]
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
90007afa:	2300      	movs	r3, #0
90007afc:	61bb      	str	r3, [r7, #24]
  config.DPSM          = SDMMC_DPSM_ENABLE;
90007afe:	2301      	movs	r3, #1
90007b00:	61fb      	str	r3, [r7, #28]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
90007b02:	687b      	ldr	r3, [r7, #4]
90007b04:	681b      	ldr	r3, [r3, #0]
90007b06:	f107 0208 	add.w	r2, r7, #8
90007b0a:	4611      	mov	r1, r2
90007b0c:	4618      	mov	r0, r3
90007b0e:	f000 fabf 	bl	90008090 <SDMMC_ConfigData>

  /* Send ACMD13 (SD_APP_STAUS)  with argument as card's RCA */
  errorstate = SDMMC_CmdStatusRegister(hsd->Instance);
90007b12:	687b      	ldr	r3, [r7, #4]
90007b14:	681b      	ldr	r3, [r3, #0]
90007b16:	4618      	mov	r0, r3
90007b18:	f000 fd3f 	bl	9000859a <SDMMC_CmdStatusRegister>
90007b1c:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_SD_ERROR_NONE)
90007b1e:	6a3b      	ldr	r3, [r7, #32]
90007b20:	2b00      	cmp	r3, #0
90007b22:	d02b      	beq.n	90007b7c <SD_SendSDStatus+0x10c>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_NONE;
90007b24:	687b      	ldr	r3, [r7, #4]
90007b26:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
90007b28:	687b      	ldr	r3, [r7, #4]
90007b2a:	635a      	str	r2, [r3, #52]	@ 0x34
    return errorstate;
90007b2c:	6a3b      	ldr	r3, [r7, #32]
90007b2e:	e069      	b.n	90007c04 <SD_SendSDStatus+0x194>
  }

  /* Get status data */
  while (!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
  {
    if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
90007b30:	687b      	ldr	r3, [r7, #4]
90007b32:	681b      	ldr	r3, [r3, #0]
90007b34:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90007b36:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
90007b3a:	2b00      	cmp	r3, #0
90007b3c:	d013      	beq.n	90007b66 <SD_SendSDStatus+0xf6>
    {
      for (count = 0U; count < 8U; count++)
90007b3e:	2300      	movs	r3, #0
90007b40:	62fb      	str	r3, [r7, #44]	@ 0x2c
90007b42:	e00d      	b.n	90007b60 <SD_SendSDStatus+0xf0>
      {
        *pData = SDMMC_ReadFIFO(hsd->Instance);
90007b44:	687b      	ldr	r3, [r7, #4]
90007b46:	681b      	ldr	r3, [r3, #0]
90007b48:	4618      	mov	r0, r3
90007b4a:	f000 fa19 	bl	90007f80 <SDMMC_ReadFIFO>
90007b4e:	4602      	mov	r2, r0
90007b50:	6abb      	ldr	r3, [r7, #40]	@ 0x28
90007b52:	601a      	str	r2, [r3, #0]
        pData++;
90007b54:	6abb      	ldr	r3, [r7, #40]	@ 0x28
90007b56:	3304      	adds	r3, #4
90007b58:	62bb      	str	r3, [r7, #40]	@ 0x28
      for (count = 0U; count < 8U; count++)
90007b5a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
90007b5c:	3301      	adds	r3, #1
90007b5e:	62fb      	str	r3, [r7, #44]	@ 0x2c
90007b60:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
90007b62:	2b07      	cmp	r3, #7
90007b64:	d9ee      	bls.n	90007b44 <SD_SendSDStatus+0xd4>
      }
    }

    if ((HAL_GetTick() - tickstart) >=  SDMMC_SWDATATIMEOUT)
90007b66:	f7f9 fdad 	bl	900016c4 <HAL_GetTick>
90007b6a:	4602      	mov	r2, r0
90007b6c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
90007b6e:	1ad3      	subs	r3, r2, r3
90007b70:	f1b3 3fff 	cmp.w	r3, #4294967295
90007b74:	d102      	bne.n	90007b7c <SD_SendSDStatus+0x10c>
    {
      return HAL_SD_ERROR_TIMEOUT;
90007b76:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
90007b7a:	e043      	b.n	90007c04 <SD_SendSDStatus+0x194>
  while (!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
90007b7c:	687b      	ldr	r3, [r7, #4]
90007b7e:	681b      	ldr	r3, [r3, #0]
90007b80:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90007b82:	f403 7395 	and.w	r3, r3, #298	@ 0x12a
90007b86:	2b00      	cmp	r3, #0
90007b88:	d0d2      	beq.n	90007b30 <SD_SendSDStatus+0xc0>
    }
  }

  if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
90007b8a:	687b      	ldr	r3, [r7, #4]
90007b8c:	681b      	ldr	r3, [r3, #0]
90007b8e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90007b90:	f003 0308 	and.w	r3, r3, #8
90007b94:	2b00      	cmp	r3, #0
90007b96:	d001      	beq.n	90007b9c <SD_SendSDStatus+0x12c>
  {
    return HAL_SD_ERROR_DATA_TIMEOUT;
90007b98:	2308      	movs	r3, #8
90007b9a:	e033      	b.n	90007c04 <SD_SendSDStatus+0x194>
  }
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
90007b9c:	687b      	ldr	r3, [r7, #4]
90007b9e:	681b      	ldr	r3, [r3, #0]
90007ba0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90007ba2:	f003 0302 	and.w	r3, r3, #2
90007ba6:	2b00      	cmp	r3, #0
90007ba8:	d001      	beq.n	90007bae <SD_SendSDStatus+0x13e>
  {
    return HAL_SD_ERROR_DATA_CRC_FAIL;
90007baa:	2302      	movs	r3, #2
90007bac:	e02a      	b.n	90007c04 <SD_SendSDStatus+0x194>
  }
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
90007bae:	687b      	ldr	r3, [r7, #4]
90007bb0:	681b      	ldr	r3, [r3, #0]
90007bb2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90007bb4:	f003 0320 	and.w	r3, r3, #32
90007bb8:	2b00      	cmp	r3, #0
90007bba:	d017      	beq.n	90007bec <SD_SendSDStatus+0x17c>
  {
    return HAL_SD_ERROR_RX_OVERRUN;
90007bbc:	2320      	movs	r3, #32
90007bbe:	e021      	b.n	90007c04 <SD_SendSDStatus+0x194>
    /* Nothing to do */
  }

  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DPSMACT)))
  {
    *pData = SDMMC_ReadFIFO(hsd->Instance);
90007bc0:	687b      	ldr	r3, [r7, #4]
90007bc2:	681b      	ldr	r3, [r3, #0]
90007bc4:	4618      	mov	r0, r3
90007bc6:	f000 f9db 	bl	90007f80 <SDMMC_ReadFIFO>
90007bca:	4602      	mov	r2, r0
90007bcc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
90007bce:	601a      	str	r2, [r3, #0]
    pData++;
90007bd0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
90007bd2:	3304      	adds	r3, #4
90007bd4:	62bb      	str	r3, [r7, #40]	@ 0x28

    if ((HAL_GetTick() - tickstart) >=  SDMMC_SWDATATIMEOUT)
90007bd6:	f7f9 fd75 	bl	900016c4 <HAL_GetTick>
90007bda:	4602      	mov	r2, r0
90007bdc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
90007bde:	1ad3      	subs	r3, r2, r3
90007be0:	f1b3 3fff 	cmp.w	r3, #4294967295
90007be4:	d102      	bne.n	90007bec <SD_SendSDStatus+0x17c>
    {
      return HAL_SD_ERROR_TIMEOUT;
90007be6:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
90007bea:	e00b      	b.n	90007c04 <SD_SendSDStatus+0x194>
  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DPSMACT)))
90007bec:	687b      	ldr	r3, [r7, #4]
90007bee:	681b      	ldr	r3, [r3, #0]
90007bf0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90007bf2:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
90007bf6:	2b00      	cmp	r3, #0
90007bf8:	d1e2      	bne.n	90007bc0 <SD_SendSDStatus+0x150>
    }
  }

  /* Clear all the static status flags*/
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
90007bfa:	687b      	ldr	r3, [r7, #4]
90007bfc:	681b      	ldr	r3, [r3, #0]
90007bfe:	4a03      	ldr	r2, [pc, #12]	@ (90007c0c <SD_SendSDStatus+0x19c>)
90007c00:	639a      	str	r2, [r3, #56]	@ 0x38

  return HAL_SD_ERROR_NONE;
90007c02:	2300      	movs	r3, #0
}
90007c04:	4618      	mov	r0, r3
90007c06:	3730      	adds	r7, #48	@ 0x30
90007c08:	46bd      	mov	sp, r7
90007c0a:	bd80      	pop	{r7, pc}
90007c0c:	18000f3a 	.word	0x18000f3a

90007c10 <SD_SendStatus>:
  * @param  pCardStatus: pointer to the buffer that will contain the SD card
  *         status (Card Status register)
  * @retval error state
  */
static uint32_t SD_SendStatus(SD_HandleTypeDef *hsd, uint32_t *pCardStatus)
{
90007c10:	b580      	push	{r7, lr}
90007c12:	b084      	sub	sp, #16
90007c14:	af00      	add	r7, sp, #0
90007c16:	6078      	str	r0, [r7, #4]
90007c18:	6039      	str	r1, [r7, #0]
  uint32_t errorstate;

  if (pCardStatus == NULL)
90007c1a:	683b      	ldr	r3, [r7, #0]
90007c1c:	2b00      	cmp	r3, #0
90007c1e:	d102      	bne.n	90007c26 <SD_SendStatus+0x16>
  {
    return HAL_SD_ERROR_PARAM;
90007c20:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
90007c24:	e018      	b.n	90007c58 <SD_SendStatus+0x48>
  }

  /* Send Status command */
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
90007c26:	687b      	ldr	r3, [r7, #4]
90007c28:	681a      	ldr	r2, [r3, #0]
90007c2a:	687b      	ldr	r3, [r7, #4]
90007c2c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
90007c2e:	041b      	lsls	r3, r3, #16
90007c30:	4619      	mov	r1, r3
90007c32:	4610      	mov	r0, r2
90007c34:	f000 fc8e 	bl	90008554 <SDMMC_CmdSendStatus>
90007c38:	60f8      	str	r0, [r7, #12]
  if (errorstate != HAL_SD_ERROR_NONE)
90007c3a:	68fb      	ldr	r3, [r7, #12]
90007c3c:	2b00      	cmp	r3, #0
90007c3e:	d001      	beq.n	90007c44 <SD_SendStatus+0x34>
  {
    return errorstate;
90007c40:	68fb      	ldr	r3, [r7, #12]
90007c42:	e009      	b.n	90007c58 <SD_SendStatus+0x48>
  }

  /* Get SD card status */
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
90007c44:	687b      	ldr	r3, [r7, #4]
90007c46:	681b      	ldr	r3, [r3, #0]
90007c48:	2100      	movs	r1, #0
90007c4a:	4618      	mov	r0, r3
90007c4c:	f000 fa0d 	bl	9000806a <SDMMC_GetResponse>
90007c50:	4602      	mov	r2, r0
90007c52:	683b      	ldr	r3, [r7, #0]
90007c54:	601a      	str	r2, [r3, #0]

  return HAL_SD_ERROR_NONE;
90007c56:	2300      	movs	r3, #0
}
90007c58:	4618      	mov	r0, r3
90007c5a:	3710      	adds	r7, #16
90007c5c:	46bd      	mov	sp, r7
90007c5e:	bd80      	pop	{r7, pc}

90007c60 <SD_WideBus_Enable>:
  * @brief  Enables the SDMMC wide bus mode.
  * @param  hsd: pointer to SD handle
  * @retval error state
  */
static uint32_t SD_WideBus_Enable(SD_HandleTypeDef *hsd)
{
90007c60:	b580      	push	{r7, lr}
90007c62:	b086      	sub	sp, #24
90007c64:	af00      	add	r7, sp, #0
90007c66:	6078      	str	r0, [r7, #4]
  uint32_t scr[2U] = {0UL, 0UL};
90007c68:	2300      	movs	r3, #0
90007c6a:	60fb      	str	r3, [r7, #12]
90007c6c:	2300      	movs	r3, #0
90007c6e:	613b      	str	r3, [r7, #16]
  uint32_t errorstate;

  if ((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
90007c70:	687b      	ldr	r3, [r7, #4]
90007c72:	681b      	ldr	r3, [r3, #0]
90007c74:	2100      	movs	r1, #0
90007c76:	4618      	mov	r0, r3
90007c78:	f000 f9f7 	bl	9000806a <SDMMC_GetResponse>
90007c7c:	4603      	mov	r3, r0
90007c7e:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
90007c82:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
90007c86:	d102      	bne.n	90007c8e <SD_WideBus_Enable+0x2e>
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
90007c88:	f44f 6300 	mov.w	r3, #2048	@ 0x800
90007c8c:	e02f      	b.n	90007cee <SD_WideBus_Enable+0x8e>
  }

  /* Get SCR Register */
  errorstate = SD_FindSCR(hsd, scr);
90007c8e:	f107 030c 	add.w	r3, r7, #12
90007c92:	4619      	mov	r1, r3
90007c94:	6878      	ldr	r0, [r7, #4]
90007c96:	f000 f879 	bl	90007d8c <SD_FindSCR>
90007c9a:	6178      	str	r0, [r7, #20]
  if (errorstate != HAL_SD_ERROR_NONE)
90007c9c:	697b      	ldr	r3, [r7, #20]
90007c9e:	2b00      	cmp	r3, #0
90007ca0:	d001      	beq.n	90007ca6 <SD_WideBus_Enable+0x46>
  {
    return errorstate;
90007ca2:	697b      	ldr	r3, [r7, #20]
90007ca4:	e023      	b.n	90007cee <SD_WideBus_Enable+0x8e>
  }

  /* If requested card supports wide bus operation */
  if ((scr[1U] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
90007ca6:	693b      	ldr	r3, [r7, #16]
90007ca8:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
90007cac:	2b00      	cmp	r3, #0
90007cae:	d01c      	beq.n	90007cea <SD_WideBus_Enable+0x8a>
  {
    /* Send CMD55 APP_CMD with argument as card's RCA.*/
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
90007cb0:	687b      	ldr	r3, [r7, #4]
90007cb2:	681a      	ldr	r2, [r3, #0]
90007cb4:	687b      	ldr	r3, [r7, #4]
90007cb6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
90007cb8:	041b      	lsls	r3, r3, #16
90007cba:	4619      	mov	r1, r3
90007cbc:	4610      	mov	r0, r2
90007cbe:	f000 fb60 	bl	90008382 <SDMMC_CmdAppCommand>
90007cc2:	6178      	str	r0, [r7, #20]
    if (errorstate != HAL_SD_ERROR_NONE)
90007cc4:	697b      	ldr	r3, [r7, #20]
90007cc6:	2b00      	cmp	r3, #0
90007cc8:	d001      	beq.n	90007cce <SD_WideBus_Enable+0x6e>
    {
      return errorstate;
90007cca:	697b      	ldr	r3, [r7, #20]
90007ccc:	e00f      	b.n	90007cee <SD_WideBus_Enable+0x8e>
    }

    /* Send ACMD6 APP_CMD with argument as 2 for wide bus mode */
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2U);
90007cce:	687b      	ldr	r3, [r7, #4]
90007cd0:	681b      	ldr	r3, [r3, #0]
90007cd2:	2102      	movs	r1, #2
90007cd4:	4618      	mov	r0, r3
90007cd6:	f000 fb97 	bl	90008408 <SDMMC_CmdBusWidth>
90007cda:	6178      	str	r0, [r7, #20]
    if (errorstate != HAL_SD_ERROR_NONE)
90007cdc:	697b      	ldr	r3, [r7, #20]
90007cde:	2b00      	cmp	r3, #0
90007ce0:	d001      	beq.n	90007ce6 <SD_WideBus_Enable+0x86>
    {
      return errorstate;
90007ce2:	697b      	ldr	r3, [r7, #20]
90007ce4:	e003      	b.n	90007cee <SD_WideBus_Enable+0x8e>
    }

    return HAL_SD_ERROR_NONE;
90007ce6:	2300      	movs	r3, #0
90007ce8:	e001      	b.n	90007cee <SD_WideBus_Enable+0x8e>
  }
  else
  {
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
90007cea:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
  }
}
90007cee:	4618      	mov	r0, r3
90007cf0:	3718      	adds	r7, #24
90007cf2:	46bd      	mov	sp, r7
90007cf4:	bd80      	pop	{r7, pc}

90007cf6 <SD_WideBus_Disable>:
  * @brief  Disables the SDMMC wide bus mode.
  * @param  hsd: Pointer to SD handle
  * @retval error state
  */
static uint32_t SD_WideBus_Disable(SD_HandleTypeDef *hsd)
{
90007cf6:	b580      	push	{r7, lr}
90007cf8:	b086      	sub	sp, #24
90007cfa:	af00      	add	r7, sp, #0
90007cfc:	6078      	str	r0, [r7, #4]
  uint32_t scr[2U] = {0UL, 0UL};
90007cfe:	2300      	movs	r3, #0
90007d00:	60fb      	str	r3, [r7, #12]
90007d02:	2300      	movs	r3, #0
90007d04:	613b      	str	r3, [r7, #16]
  uint32_t errorstate;

  if ((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
90007d06:	687b      	ldr	r3, [r7, #4]
90007d08:	681b      	ldr	r3, [r3, #0]
90007d0a:	2100      	movs	r1, #0
90007d0c:	4618      	mov	r0, r3
90007d0e:	f000 f9ac 	bl	9000806a <SDMMC_GetResponse>
90007d12:	4603      	mov	r3, r0
90007d14:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
90007d18:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
90007d1c:	d102      	bne.n	90007d24 <SD_WideBus_Disable+0x2e>
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
90007d1e:	f44f 6300 	mov.w	r3, #2048	@ 0x800
90007d22:	e02f      	b.n	90007d84 <SD_WideBus_Disable+0x8e>
  }

  /* Get SCR Register */
  errorstate = SD_FindSCR(hsd, scr);
90007d24:	f107 030c 	add.w	r3, r7, #12
90007d28:	4619      	mov	r1, r3
90007d2a:	6878      	ldr	r0, [r7, #4]
90007d2c:	f000 f82e 	bl	90007d8c <SD_FindSCR>
90007d30:	6178      	str	r0, [r7, #20]
  if (errorstate != HAL_SD_ERROR_NONE)
90007d32:	697b      	ldr	r3, [r7, #20]
90007d34:	2b00      	cmp	r3, #0
90007d36:	d001      	beq.n	90007d3c <SD_WideBus_Disable+0x46>
  {
    return errorstate;
90007d38:	697b      	ldr	r3, [r7, #20]
90007d3a:	e023      	b.n	90007d84 <SD_WideBus_Disable+0x8e>
  }

  /* If requested card supports 1 bit mode operation */
  if ((scr[1U] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
90007d3c:	693b      	ldr	r3, [r7, #16]
90007d3e:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
90007d42:	2b00      	cmp	r3, #0
90007d44:	d01c      	beq.n	90007d80 <SD_WideBus_Disable+0x8a>
  {
    /* Send CMD55 APP_CMD with argument as card's RCA */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
90007d46:	687b      	ldr	r3, [r7, #4]
90007d48:	681a      	ldr	r2, [r3, #0]
90007d4a:	687b      	ldr	r3, [r7, #4]
90007d4c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
90007d4e:	041b      	lsls	r3, r3, #16
90007d50:	4619      	mov	r1, r3
90007d52:	4610      	mov	r0, r2
90007d54:	f000 fb15 	bl	90008382 <SDMMC_CmdAppCommand>
90007d58:	6178      	str	r0, [r7, #20]
    if (errorstate != HAL_SD_ERROR_NONE)
90007d5a:	697b      	ldr	r3, [r7, #20]
90007d5c:	2b00      	cmp	r3, #0
90007d5e:	d001      	beq.n	90007d64 <SD_WideBus_Disable+0x6e>
    {
      return errorstate;
90007d60:	697b      	ldr	r3, [r7, #20]
90007d62:	e00f      	b.n	90007d84 <SD_WideBus_Disable+0x8e>
    }

    /* Send ACMD6 APP_CMD with argument as 0 for single bus mode */
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
90007d64:	687b      	ldr	r3, [r7, #4]
90007d66:	681b      	ldr	r3, [r3, #0]
90007d68:	2100      	movs	r1, #0
90007d6a:	4618      	mov	r0, r3
90007d6c:	f000 fb4c 	bl	90008408 <SDMMC_CmdBusWidth>
90007d70:	6178      	str	r0, [r7, #20]
    if (errorstate != HAL_SD_ERROR_NONE)
90007d72:	697b      	ldr	r3, [r7, #20]
90007d74:	2b00      	cmp	r3, #0
90007d76:	d001      	beq.n	90007d7c <SD_WideBus_Disable+0x86>
    {
      return errorstate;
90007d78:	697b      	ldr	r3, [r7, #20]
90007d7a:	e003      	b.n	90007d84 <SD_WideBus_Disable+0x8e>
    }

    return HAL_SD_ERROR_NONE;
90007d7c:	2300      	movs	r3, #0
90007d7e:	e001      	b.n	90007d84 <SD_WideBus_Disable+0x8e>
  }
  else
  {
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
90007d80:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
  }
}
90007d84:	4618      	mov	r0, r3
90007d86:	3718      	adds	r7, #24
90007d88:	46bd      	mov	sp, r7
90007d8a:	bd80      	pop	{r7, pc}

90007d8c <SD_FindSCR>:
  * @param  hsd: Pointer to SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value
  * @retval error state
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
90007d8c:	b580      	push	{r7, lr}
90007d8e:	b08e      	sub	sp, #56	@ 0x38
90007d90:	af00      	add	r7, sp, #0
90007d92:	6078      	str	r0, [r7, #4]
90007d94:	6039      	str	r1, [r7, #0]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
90007d96:	f7f9 fc95 	bl	900016c4 <HAL_GetTick>
90007d9a:	6338      	str	r0, [r7, #48]	@ 0x30
  uint32_t index = 0U;
90007d9c:	2300      	movs	r3, #0
90007d9e:	637b      	str	r3, [r7, #52]	@ 0x34
  uint32_t tempscr[2U] = {0UL, 0UL};
90007da0:	2300      	movs	r3, #0
90007da2:	60bb      	str	r3, [r7, #8]
90007da4:	2300      	movs	r3, #0
90007da6:	60fb      	str	r3, [r7, #12]
  uint32_t *scr = pSCR;
90007da8:	683b      	ldr	r3, [r7, #0]
90007daa:	62fb      	str	r3, [r7, #44]	@ 0x2c

  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
90007dac:	687b      	ldr	r3, [r7, #4]
90007dae:	681b      	ldr	r3, [r3, #0]
90007db0:	2108      	movs	r1, #8
90007db2:	4618      	mov	r0, r3
90007db4:	f000 f998 	bl	900080e8 <SDMMC_CmdBlockLength>
90007db8:	62b8      	str	r0, [r7, #40]	@ 0x28
  if (errorstate != HAL_SD_ERROR_NONE)
90007dba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
90007dbc:	2b00      	cmp	r3, #0
90007dbe:	d001      	beq.n	90007dc4 <SD_FindSCR+0x38>
  {
    return errorstate;
90007dc0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
90007dc2:	e0ad      	b.n	90007f20 <SD_FindSCR+0x194>
  }

  /* Send CMD55 APP_CMD with argument as card's RCA */
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
90007dc4:	687b      	ldr	r3, [r7, #4]
90007dc6:	681a      	ldr	r2, [r3, #0]
90007dc8:	687b      	ldr	r3, [r7, #4]
90007dca:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
90007dcc:	041b      	lsls	r3, r3, #16
90007dce:	4619      	mov	r1, r3
90007dd0:	4610      	mov	r0, r2
90007dd2:	f000 fad6 	bl	90008382 <SDMMC_CmdAppCommand>
90007dd6:	62b8      	str	r0, [r7, #40]	@ 0x28
  if (errorstate != HAL_SD_ERROR_NONE)
90007dd8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
90007dda:	2b00      	cmp	r3, #0
90007ddc:	d001      	beq.n	90007de2 <SD_FindSCR+0x56>
  {
    return errorstate;
90007dde:	6abb      	ldr	r3, [r7, #40]	@ 0x28
90007de0:	e09e      	b.n	90007f20 <SD_FindSCR+0x194>
  }

  config.DataTimeOut   = SDMMC_DATATIMEOUT;
90007de2:	f04f 33ff 	mov.w	r3, #4294967295
90007de6:	613b      	str	r3, [r7, #16]
  config.DataLength    = 8U;
90007de8:	2308      	movs	r3, #8
90007dea:	617b      	str	r3, [r7, #20]
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
90007dec:	2330      	movs	r3, #48	@ 0x30
90007dee:	61bb      	str	r3, [r7, #24]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
90007df0:	2302      	movs	r3, #2
90007df2:	61fb      	str	r3, [r7, #28]
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
90007df4:	2300      	movs	r3, #0
90007df6:	623b      	str	r3, [r7, #32]
  config.DPSM          = SDMMC_DPSM_ENABLE;
90007df8:	2301      	movs	r3, #1
90007dfa:	627b      	str	r3, [r7, #36]	@ 0x24
  (void)SDMMC_ConfigData(hsd->Instance, &config);
90007dfc:	687b      	ldr	r3, [r7, #4]
90007dfe:	681b      	ldr	r3, [r3, #0]
90007e00:	f107 0210 	add.w	r2, r7, #16
90007e04:	4611      	mov	r1, r2
90007e06:	4618      	mov	r0, r3
90007e08:	f000 f942 	bl	90008090 <SDMMC_ConfigData>

  /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
  errorstate = SDMMC_CmdSendSCR(hsd->Instance);
90007e0c:	687b      	ldr	r3, [r7, #4]
90007e0e:	681b      	ldr	r3, [r3, #0]
90007e10:	4618      	mov	r0, r3
90007e12:	f000 fb1c 	bl	9000844e <SDMMC_CmdSendSCR>
90007e16:	62b8      	str	r0, [r7, #40]	@ 0x28
  if (errorstate != HAL_SD_ERROR_NONE)
90007e18:	6abb      	ldr	r3, [r7, #40]	@ 0x28
90007e1a:	2b00      	cmp	r3, #0
90007e1c:	d027      	beq.n	90007e6e <SD_FindSCR+0xe2>
  {
    return errorstate;
90007e1e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
90007e20:	e07e      	b.n	90007f20 <SD_FindSCR+0x194>
  }

  while (!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND |
                            SDMMC_FLAG_DATAEND))
  {
    if ((!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOE)) && (index == 0U))
90007e22:	687b      	ldr	r3, [r7, #4]
90007e24:	681b      	ldr	r3, [r3, #0]
90007e26:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90007e28:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
90007e2c:	2b00      	cmp	r3, #0
90007e2e:	d113      	bne.n	90007e58 <SD_FindSCR+0xcc>
90007e30:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
90007e32:	2b00      	cmp	r3, #0
90007e34:	d110      	bne.n	90007e58 <SD_FindSCR+0xcc>
    {
      tempscr[0] = SDMMC_ReadFIFO(hsd->Instance);
90007e36:	687b      	ldr	r3, [r7, #4]
90007e38:	681b      	ldr	r3, [r3, #0]
90007e3a:	4618      	mov	r0, r3
90007e3c:	f000 f8a0 	bl	90007f80 <SDMMC_ReadFIFO>
90007e40:	4603      	mov	r3, r0
90007e42:	60bb      	str	r3, [r7, #8]
      tempscr[1] = SDMMC_ReadFIFO(hsd->Instance);
90007e44:	687b      	ldr	r3, [r7, #4]
90007e46:	681b      	ldr	r3, [r3, #0]
90007e48:	4618      	mov	r0, r3
90007e4a:	f000 f899 	bl	90007f80 <SDMMC_ReadFIFO>
90007e4e:	4603      	mov	r3, r0
90007e50:	60fb      	str	r3, [r7, #12]
      index++;
90007e52:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
90007e54:	3301      	adds	r3, #1
90007e56:	637b      	str	r3, [r7, #52]	@ 0x34
    }

    if ((HAL_GetTick() - tickstart) >=  SDMMC_SWDATATIMEOUT)
90007e58:	f7f9 fc34 	bl	900016c4 <HAL_GetTick>
90007e5c:	4602      	mov	r2, r0
90007e5e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
90007e60:	1ad3      	subs	r3, r2, r3
90007e62:	f1b3 3fff 	cmp.w	r3, #4294967295
90007e66:	d102      	bne.n	90007e6e <SD_FindSCR+0xe2>
    {
      return HAL_SD_ERROR_TIMEOUT;
90007e68:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
90007e6c:	e058      	b.n	90007f20 <SD_FindSCR+0x194>
  while (!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND |
90007e6e:	687b      	ldr	r3, [r7, #4]
90007e70:	681b      	ldr	r3, [r3, #0]
90007e72:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
90007e74:	f240 532a 	movw	r3, #1322	@ 0x52a
90007e78:	4013      	ands	r3, r2
90007e7a:	2b00      	cmp	r3, #0
90007e7c:	d0d1      	beq.n	90007e22 <SD_FindSCR+0x96>
    }
  }

  if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
90007e7e:	687b      	ldr	r3, [r7, #4]
90007e80:	681b      	ldr	r3, [r3, #0]
90007e82:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90007e84:	f003 0308 	and.w	r3, r3, #8
90007e88:	2b00      	cmp	r3, #0
90007e8a:	d005      	beq.n	90007e98 <SD_FindSCR+0x10c>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
90007e8c:	687b      	ldr	r3, [r7, #4]
90007e8e:	681b      	ldr	r3, [r3, #0]
90007e90:	2208      	movs	r2, #8
90007e92:	639a      	str	r2, [r3, #56]	@ 0x38

    return HAL_SD_ERROR_DATA_TIMEOUT;
90007e94:	2308      	movs	r3, #8
90007e96:	e043      	b.n	90007f20 <SD_FindSCR+0x194>
  }
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
90007e98:	687b      	ldr	r3, [r7, #4]
90007e9a:	681b      	ldr	r3, [r3, #0]
90007e9c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90007e9e:	f003 0302 	and.w	r3, r3, #2
90007ea2:	2b00      	cmp	r3, #0
90007ea4:	d005      	beq.n	90007eb2 <SD_FindSCR+0x126>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
90007ea6:	687b      	ldr	r3, [r7, #4]
90007ea8:	681b      	ldr	r3, [r3, #0]
90007eaa:	2202      	movs	r2, #2
90007eac:	639a      	str	r2, [r3, #56]	@ 0x38

    return HAL_SD_ERROR_DATA_CRC_FAIL;
90007eae:	2302      	movs	r3, #2
90007eb0:	e036      	b.n	90007f20 <SD_FindSCR+0x194>
  }
  else if (__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
90007eb2:	687b      	ldr	r3, [r7, #4]
90007eb4:	681b      	ldr	r3, [r3, #0]
90007eb6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90007eb8:	f003 0320 	and.w	r3, r3, #32
90007ebc:	2b00      	cmp	r3, #0
90007ebe:	d005      	beq.n	90007ecc <SD_FindSCR+0x140>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
90007ec0:	687b      	ldr	r3, [r7, #4]
90007ec2:	681b      	ldr	r3, [r3, #0]
90007ec4:	2220      	movs	r2, #32
90007ec6:	639a      	str	r2, [r3, #56]	@ 0x38

    return HAL_SD_ERROR_RX_OVERRUN;
90007ec8:	2320      	movs	r3, #32
90007eca:	e029      	b.n	90007f20 <SD_FindSCR+0x194>
  }
  else
  {
    /* No error flag set */
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
90007ecc:	687b      	ldr	r3, [r7, #4]
90007ece:	681b      	ldr	r3, [r3, #0]
90007ed0:	4a15      	ldr	r2, [pc, #84]	@ (90007f28 <SD_FindSCR+0x19c>)
90007ed2:	639a      	str	r2, [r3, #56]	@ 0x38

    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8U) | \
90007ed4:	68fb      	ldr	r3, [r7, #12]
90007ed6:	061a      	lsls	r2, r3, #24
90007ed8:	68fb      	ldr	r3, [r7, #12]
90007eda:	021b      	lsls	r3, r3, #8
90007edc:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
90007ee0:	431a      	orrs	r2, r3
            ((tempscr[1] & SDMMC_16TO23BITS) >> 8U) | ((tempscr[1] & SDMMC_24TO31BITS) >> 24U));
90007ee2:	68fb      	ldr	r3, [r7, #12]
90007ee4:	0a1b      	lsrs	r3, r3, #8
90007ee6:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8U) | \
90007eea:	431a      	orrs	r2, r3
            ((tempscr[1] & SDMMC_16TO23BITS) >> 8U) | ((tempscr[1] & SDMMC_24TO31BITS) >> 24U));
90007eec:	68fb      	ldr	r3, [r7, #12]
90007eee:	0e1b      	lsrs	r3, r3, #24
90007ef0:	431a      	orrs	r2, r3
    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8U) | \
90007ef2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
90007ef4:	601a      	str	r2, [r3, #0]
    scr++;
90007ef6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
90007ef8:	3304      	adds	r3, #4
90007efa:	62fb      	str	r3, [r7, #44]	@ 0x2c
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8U) | \
90007efc:	68bb      	ldr	r3, [r7, #8]
90007efe:	061a      	lsls	r2, r3, #24
90007f00:	68bb      	ldr	r3, [r7, #8]
90007f02:	021b      	lsls	r3, r3, #8
90007f04:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
90007f08:	431a      	orrs	r2, r3
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8U) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24U));
90007f0a:	68bb      	ldr	r3, [r7, #8]
90007f0c:	0a1b      	lsrs	r3, r3, #8
90007f0e:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8U) | \
90007f12:	431a      	orrs	r2, r3
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8U) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24U));
90007f14:	68bb      	ldr	r3, [r7, #8]
90007f16:	0e1b      	lsrs	r3, r3, #24
90007f18:	431a      	orrs	r2, r3
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8U) | \
90007f1a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
90007f1c:	601a      	str	r2, [r3, #0]

  }

  return HAL_SD_ERROR_NONE;
90007f1e:	2300      	movs	r3, #0
}
90007f20:	4618      	mov	r0, r3
90007f22:	3738      	adds	r7, #56	@ 0x38
90007f24:	46bd      	mov	sp, r7
90007f26:	bd80      	pop	{r7, pc}
90007f28:	18000f3a 	.word	0x18000f3a

90007f2c <SDMMC_Init>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Init: SDMMC initialization structure
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_Init(SDMMC_TypeDef *SDMMCx, SDMMC_InitTypeDef Init)
{
90007f2c:	b084      	sub	sp, #16
90007f2e:	b480      	push	{r7}
90007f30:	b085      	sub	sp, #20
90007f32:	af00      	add	r7, sp, #0
90007f34:	6078      	str	r0, [r7, #4]
90007f36:	f107 001c 	add.w	r0, r7, #28
90007f3a:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  uint32_t tmpreg = 0;
90007f3e:	2300      	movs	r3, #0
90007f40:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDMMC_BUS_WIDE(Init.BusWide));
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
  assert_param(IS_SDMMC_CLKDIV(Init.ClockDiv));

  /* Set SDMMC configuration parameters */
  tmpreg |= (Init.ClockEdge           | \
90007f42:	69fa      	ldr	r2, [r7, #28]
             Init.ClockPowerSave      | \
90007f44:	6a3b      	ldr	r3, [r7, #32]
  tmpreg |= (Init.ClockEdge           | \
90007f46:	431a      	orrs	r2, r3
             Init.BusWide             | \
90007f48:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
             Init.ClockPowerSave      | \
90007f4a:	431a      	orrs	r2, r3
             Init.HardwareFlowControl | \
90007f4c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
             Init.BusWide             | \
90007f4e:	431a      	orrs	r2, r3
             Init.ClockDiv
90007f50:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
             Init.HardwareFlowControl | \
90007f52:	4313      	orrs	r3, r2
  tmpreg |= (Init.ClockEdge           | \
90007f54:	68fa      	ldr	r2, [r7, #12]
90007f56:	4313      	orrs	r3, r2
90007f58:	60fb      	str	r3, [r7, #12]
            );

  /* Write to SDMMC CLKCR */
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
90007f5a:	687b      	ldr	r3, [r7, #4]
90007f5c:	685a      	ldr	r2, [r3, #4]
90007f5e:	4b07      	ldr	r3, [pc, #28]	@ (90007f7c <SDMMC_Init+0x50>)
90007f60:	4013      	ands	r3, r2
90007f62:	68fa      	ldr	r2, [r7, #12]
90007f64:	431a      	orrs	r2, r3
90007f66:	687b      	ldr	r3, [r7, #4]
90007f68:	605a      	str	r2, [r3, #4]

  return HAL_OK;
90007f6a:	2300      	movs	r3, #0
}
90007f6c:	4618      	mov	r0, r3
90007f6e:	3714      	adds	r7, #20
90007f70:	46bd      	mov	sp, r7
90007f72:	f85d 7b04 	ldr.w	r7, [sp], #4
90007f76:	b004      	add	sp, #16
90007f78:	4770      	bx	lr
90007f7a:	bf00      	nop
90007f7c:	ffc02c00 	.word	0xffc02c00

90007f80 <SDMMC_ReadFIFO>:
  * @brief  Read data (word) from Rx FIFO in blocking mode (polling)
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_ReadFIFO(const SDMMC_TypeDef *SDMMCx)
{
90007f80:	b480      	push	{r7}
90007f82:	b083      	sub	sp, #12
90007f84:	af00      	add	r7, sp, #0
90007f86:	6078      	str	r0, [r7, #4]
  /* Read data from Rx FIFO */
  return (SDMMCx->FIFO);
90007f88:	687b      	ldr	r3, [r7, #4]
90007f8a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
}
90007f8e:	4618      	mov	r0, r3
90007f90:	370c      	adds	r7, #12
90007f92:	46bd      	mov	sp, r7
90007f94:	f85d 7b04 	ldr.w	r7, [sp], #4
90007f98:	4770      	bx	lr

90007f9a <SDMMC_WriteFIFO>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  pWriteData: pointer to data to write
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_WriteFIFO(SDMMC_TypeDef *SDMMCx, uint32_t *pWriteData)
{
90007f9a:	b480      	push	{r7}
90007f9c:	b083      	sub	sp, #12
90007f9e:	af00      	add	r7, sp, #0
90007fa0:	6078      	str	r0, [r7, #4]
90007fa2:	6039      	str	r1, [r7, #0]
  /* Write data to FIFO */
  SDMMCx->FIFO = *pWriteData;
90007fa4:	683b      	ldr	r3, [r7, #0]
90007fa6:	681a      	ldr	r2, [r3, #0]
90007fa8:	687b      	ldr	r3, [r7, #4]
90007faa:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

  return HAL_OK;
90007fae:	2300      	movs	r3, #0
}
90007fb0:	4618      	mov	r0, r3
90007fb2:	370c      	adds	r7, #12
90007fb4:	46bd      	mov	sp, r7
90007fb6:	f85d 7b04 	ldr.w	r7, [sp], #4
90007fba:	4770      	bx	lr

90007fbc <SDMMC_PowerState_ON>:
  * @brief  Set SDMMC Power state to ON.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_PowerState_ON(SDMMC_TypeDef *SDMMCx)
{
90007fbc:	b480      	push	{r7}
90007fbe:	b083      	sub	sp, #12
90007fc0:	af00      	add	r7, sp, #0
90007fc2:	6078      	str	r0, [r7, #4]
  /* Set power state to ON */
  SDMMCx->POWER |= SDMMC_POWER_PWRCTRL;
90007fc4:	687b      	ldr	r3, [r7, #4]
90007fc6:	681b      	ldr	r3, [r3, #0]
90007fc8:	f043 0203 	orr.w	r2, r3, #3
90007fcc:	687b      	ldr	r3, [r7, #4]
90007fce:	601a      	str	r2, [r3, #0]

  return HAL_OK;
90007fd0:	2300      	movs	r3, #0
}
90007fd2:	4618      	mov	r0, r3
90007fd4:	370c      	adds	r7, #12
90007fd6:	46bd      	mov	sp, r7
90007fd8:	f85d 7b04 	ldr.w	r7, [sp], #4
90007fdc:	4770      	bx	lr

90007fde <SDMMC_GetPowerState>:
  *            - 0x00: Power OFF
  *            - 0x02: Power UP
  *            - 0x03: Power ON
  */
uint32_t SDMMC_GetPowerState(const SDMMC_TypeDef *SDMMCx)
{
90007fde:	b480      	push	{r7}
90007fe0:	b083      	sub	sp, #12
90007fe2:	af00      	add	r7, sp, #0
90007fe4:	6078      	str	r0, [r7, #4]
  return (SDMMCx->POWER & SDMMC_POWER_PWRCTRL);
90007fe6:	687b      	ldr	r3, [r7, #4]
90007fe8:	681b      	ldr	r3, [r3, #0]
90007fea:	f003 0303 	and.w	r3, r3, #3
}
90007fee:	4618      	mov	r0, r3
90007ff0:	370c      	adds	r7, #12
90007ff2:	46bd      	mov	sp, r7
90007ff4:	f85d 7b04 	ldr.w	r7, [sp], #4
90007ff8:	4770      	bx	lr
	...

90007ffc <SDMMC_SendCommand>:
  * @param  Command: pointer to a SDMMC_CmdInitTypeDef structure that contains
  *         the configuration information for the SDMMC command
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_SendCommand(SDMMC_TypeDef *SDMMCx, const SDMMC_CmdInitTypeDef *Command)
{
90007ffc:	b480      	push	{r7}
90007ffe:	b085      	sub	sp, #20
90008000:	af00      	add	r7, sp, #0
90008002:	6078      	str	r0, [r7, #4]
90008004:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
90008006:	2300      	movs	r3, #0
90008008:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDMMC_RESPONSE(Command->Response));
  assert_param(IS_SDMMC_WAIT(Command->WaitForInterrupt));
  assert_param(IS_SDMMC_CPSM(Command->CPSM));

  /* Set the SDMMC Argument value */
  SDMMCx->ARG = Command->Argument;
9000800a:	683b      	ldr	r3, [r7, #0]
9000800c:	681a      	ldr	r2, [r3, #0]
9000800e:	687b      	ldr	r3, [r7, #4]
90008010:	609a      	str	r2, [r3, #8]

  /* Set SDMMC command parameters */
  tmpreg |= (uint32_t)(Command->CmdIndex         | \
90008012:	683b      	ldr	r3, [r7, #0]
90008014:	685a      	ldr	r2, [r3, #4]
                       Command->Response         | \
90008016:	683b      	ldr	r3, [r7, #0]
90008018:	689b      	ldr	r3, [r3, #8]
  tmpreg |= (uint32_t)(Command->CmdIndex         | \
9000801a:	431a      	orrs	r2, r3
                       Command->WaitForInterrupt | \
9000801c:	683b      	ldr	r3, [r7, #0]
9000801e:	68db      	ldr	r3, [r3, #12]
                       Command->Response         | \
90008020:	431a      	orrs	r2, r3
                       Command->CPSM);
90008022:	683b      	ldr	r3, [r7, #0]
90008024:	691b      	ldr	r3, [r3, #16]
                       Command->WaitForInterrupt | \
90008026:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)(Command->CmdIndex         | \
90008028:	68fa      	ldr	r2, [r7, #12]
9000802a:	4313      	orrs	r3, r2
9000802c:	60fb      	str	r3, [r7, #12]

  /* Write to SDMMC CMD register */
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
9000802e:	687b      	ldr	r3, [r7, #4]
90008030:	68da      	ldr	r2, [r3, #12]
90008032:	4b06      	ldr	r3, [pc, #24]	@ (9000804c <SDMMC_SendCommand+0x50>)
90008034:	4013      	ands	r3, r2
90008036:	68fa      	ldr	r2, [r7, #12]
90008038:	431a      	orrs	r2, r3
9000803a:	687b      	ldr	r3, [r7, #4]
9000803c:	60da      	str	r2, [r3, #12]

  return HAL_OK;
9000803e:	2300      	movs	r3, #0
}
90008040:	4618      	mov	r0, r3
90008042:	3714      	adds	r7, #20
90008044:	46bd      	mov	sp, r7
90008046:	f85d 7b04 	ldr.w	r7, [sp], #4
9000804a:	4770      	bx	lr
9000804c:	fffee0c0 	.word	0xfffee0c0

90008050 <SDMMC_GetCommandResponse>:
  * @brief  Return the command index of last command for which response received
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval Command index of the last command response received
  */
uint8_t SDMMC_GetCommandResponse(const SDMMC_TypeDef *SDMMCx)
{
90008050:	b480      	push	{r7}
90008052:	b083      	sub	sp, #12
90008054:	af00      	add	r7, sp, #0
90008056:	6078      	str	r0, [r7, #4]
  return (uint8_t)(SDMMCx->RESPCMD);
90008058:	687b      	ldr	r3, [r7, #4]
9000805a:	691b      	ldr	r3, [r3, #16]
9000805c:	b2db      	uxtb	r3, r3
}
9000805e:	4618      	mov	r0, r3
90008060:	370c      	adds	r7, #12
90008062:	46bd      	mov	sp, r7
90008064:	f85d 7b04 	ldr.w	r7, [sp], #4
90008068:	4770      	bx	lr

9000806a <SDMMC_GetResponse>:
  *            @arg SDMMC_RESP3: Response Register 3
  *            @arg SDMMC_RESP4: Response Register 4
  * @retval The Corresponding response register value
  */
uint32_t SDMMC_GetResponse(const SDMMC_TypeDef *SDMMCx, uint32_t Response)
{
9000806a:	b480      	push	{r7}
9000806c:	b085      	sub	sp, #20
9000806e:	af00      	add	r7, sp, #0
90008070:	6078      	str	r0, [r7, #4]
90008072:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_SDMMC_RESP(Response));

  /* Get the response */
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;
90008074:	687b      	ldr	r3, [r7, #4]
90008076:	3314      	adds	r3, #20
90008078:	461a      	mov	r2, r3
9000807a:	683b      	ldr	r3, [r7, #0]
9000807c:	4413      	add	r3, r2
9000807e:	60fb      	str	r3, [r7, #12]

  return (*(__IO uint32_t *) tmp);
90008080:	68fb      	ldr	r3, [r7, #12]
90008082:	681b      	ldr	r3, [r3, #0]
}
90008084:	4618      	mov	r0, r3
90008086:	3714      	adds	r7, #20
90008088:	46bd      	mov	sp, r7
9000808a:	f85d 7b04 	ldr.w	r7, [sp], #4
9000808e:	4770      	bx	lr

90008090 <SDMMC_ConfigData>:
  * @param  Data : pointer to a SDMMC_DataInitTypeDef structure
  *         that contains the configuration information for the SDMMC data.
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_ConfigData(SDMMC_TypeDef *SDMMCx, const SDMMC_DataInitTypeDef *Data)
{
90008090:	b480      	push	{r7}
90008092:	b085      	sub	sp, #20
90008094:	af00      	add	r7, sp, #0
90008096:	6078      	str	r0, [r7, #4]
90008098:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
9000809a:	2300      	movs	r3, #0
9000809c:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDMMC_TRANSFER_DIR(Data->TransferDir));
  assert_param(IS_SDMMC_TRANSFER_MODE(Data->TransferMode));
  assert_param(IS_SDMMC_DPSM(Data->DPSM));

  /* Set the SDMMC Data TimeOut value */
  SDMMCx->DTIMER = Data->DataTimeOut;
9000809e:	683b      	ldr	r3, [r7, #0]
900080a0:	681a      	ldr	r2, [r3, #0]
900080a2:	687b      	ldr	r3, [r7, #4]
900080a4:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Set the SDMMC DataLength value */
  SDMMCx->DLEN = Data->DataLength;
900080a6:	683b      	ldr	r3, [r7, #0]
900080a8:	685a      	ldr	r2, [r3, #4]
900080aa:	687b      	ldr	r3, [r7, #4]
900080ac:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Set the SDMMC data configuration parameters */
  tmpreg |= (uint32_t)(Data->DataBlockSize | \
900080ae:	683b      	ldr	r3, [r7, #0]
900080b0:	689a      	ldr	r2, [r3, #8]
                       Data->TransferDir   | \
900080b2:	683b      	ldr	r3, [r7, #0]
900080b4:	68db      	ldr	r3, [r3, #12]
  tmpreg |= (uint32_t)(Data->DataBlockSize | \
900080b6:	431a      	orrs	r2, r3
                       Data->TransferMode  | \
900080b8:	683b      	ldr	r3, [r7, #0]
900080ba:	691b      	ldr	r3, [r3, #16]
                       Data->TransferDir   | \
900080bc:	431a      	orrs	r2, r3
                       Data->DPSM);
900080be:	683b      	ldr	r3, [r7, #0]
900080c0:	695b      	ldr	r3, [r3, #20]
                       Data->TransferMode  | \
900080c2:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)(Data->DataBlockSize | \
900080c4:	68fa      	ldr	r2, [r7, #12]
900080c6:	4313      	orrs	r3, r2
900080c8:	60fb      	str	r3, [r7, #12]

  /* Write to SDMMC DCTRL */
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
900080ca:	687b      	ldr	r3, [r7, #4]
900080cc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
900080ce:	f023 02ff 	bic.w	r2, r3, #255	@ 0xff
900080d2:	68fb      	ldr	r3, [r7, #12]
900080d4:	431a      	orrs	r2, r3
900080d6:	687b      	ldr	r3, [r7, #4]
900080d8:	62da      	str	r2, [r3, #44]	@ 0x2c

  return HAL_OK;
900080da:	2300      	movs	r3, #0

}
900080dc:	4618      	mov	r0, r3
900080de:	3714      	adds	r7, #20
900080e0:	46bd      	mov	sp, r7
900080e2:	f85d 7b04 	ldr.w	r7, [sp], #4
900080e6:	4770      	bx	lr

900080e8 <SDMMC_CmdBlockLength>:
  * @brief  Send the Data Block Length command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdBlockLength(SDMMC_TypeDef *SDMMCx, uint32_t BlockSize)
{
900080e8:	b580      	push	{r7, lr}
900080ea:	b088      	sub	sp, #32
900080ec:	af00      	add	r7, sp, #0
900080ee:	6078      	str	r0, [r7, #4]
900080f0:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
900080f2:	683b      	ldr	r3, [r7, #0]
900080f4:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
900080f6:	2310      	movs	r3, #16
900080f8:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900080fa:	f44f 7380 	mov.w	r3, #256	@ 0x100
900080fe:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
90008100:	2300      	movs	r3, #0
90008102:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90008104:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
90008108:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
9000810a:	f107 0308 	add.w	r3, r7, #8
9000810e:	4619      	mov	r1, r3
90008110:	6878      	ldr	r0, [r7, #4]
90008112:	f7ff ff73 	bl	90007ffc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SET_BLOCKLEN, SDMMC_CMDTIMEOUT);
90008116:	f241 3288 	movw	r2, #5000	@ 0x1388
9000811a:	2110      	movs	r1, #16
9000811c:	6878      	ldr	r0, [r7, #4]
9000811e:	f000 fa5f 	bl	900085e0 <SDMMC_GetCmdResp1>
90008122:	61f8      	str	r0, [r7, #28]

  return errorstate;
90008124:	69fb      	ldr	r3, [r7, #28]
}
90008126:	4618      	mov	r0, r3
90008128:	3720      	adds	r7, #32
9000812a:	46bd      	mov	sp, r7
9000812c:	bd80      	pop	{r7, pc}

9000812e <SDMMC_CmdReadSingleBlock>:
  * @brief  Send the Read Single Block command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdReadSingleBlock(SDMMC_TypeDef *SDMMCx, uint32_t ReadAdd)
{
9000812e:	b580      	push	{r7, lr}
90008130:	b088      	sub	sp, #32
90008132:	af00      	add	r7, sp, #0
90008134:	6078      	str	r0, [r7, #4]
90008136:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
90008138:	683b      	ldr	r3, [r7, #0]
9000813a:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
9000813c:	2311      	movs	r3, #17
9000813e:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90008140:	f44f 7380 	mov.w	r3, #256	@ 0x100
90008144:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
90008146:	2300      	movs	r3, #0
90008148:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000814a:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
9000814e:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90008150:	f107 0308 	add.w	r3, r7, #8
90008154:	4619      	mov	r1, r3
90008156:	6878      	ldr	r0, [r7, #4]
90008158:	f7ff ff50 	bl	90007ffc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
9000815c:	f241 3288 	movw	r2, #5000	@ 0x1388
90008160:	2111      	movs	r1, #17
90008162:	6878      	ldr	r0, [r7, #4]
90008164:	f000 fa3c 	bl	900085e0 <SDMMC_GetCmdResp1>
90008168:	61f8      	str	r0, [r7, #28]

  return errorstate;
9000816a:	69fb      	ldr	r3, [r7, #28]
}
9000816c:	4618      	mov	r0, r3
9000816e:	3720      	adds	r7, #32
90008170:	46bd      	mov	sp, r7
90008172:	bd80      	pop	{r7, pc}

90008174 <SDMMC_CmdReadMultiBlock>:
  * @brief  Send the Read Multi Block command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdReadMultiBlock(SDMMC_TypeDef *SDMMCx, uint32_t ReadAdd)
{
90008174:	b580      	push	{r7, lr}
90008176:	b088      	sub	sp, #32
90008178:	af00      	add	r7, sp, #0
9000817a:	6078      	str	r0, [r7, #4]
9000817c:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
9000817e:	683b      	ldr	r3, [r7, #0]
90008180:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
90008182:	2312      	movs	r3, #18
90008184:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90008186:	f44f 7380 	mov.w	r3, #256	@ 0x100
9000818a:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
9000818c:	2300      	movs	r3, #0
9000818e:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90008190:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
90008194:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90008196:	f107 0308 	add.w	r3, r7, #8
9000819a:	4619      	mov	r1, r3
9000819c:	6878      	ldr	r0, [r7, #4]
9000819e:	f7ff ff2d 	bl	90007ffc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_MULT_BLOCK, SDMMC_CMDTIMEOUT);
900081a2:	f241 3288 	movw	r2, #5000	@ 0x1388
900081a6:	2112      	movs	r1, #18
900081a8:	6878      	ldr	r0, [r7, #4]
900081aa:	f000 fa19 	bl	900085e0 <SDMMC_GetCmdResp1>
900081ae:	61f8      	str	r0, [r7, #28]

  return errorstate;
900081b0:	69fb      	ldr	r3, [r7, #28]
}
900081b2:	4618      	mov	r0, r3
900081b4:	3720      	adds	r7, #32
900081b6:	46bd      	mov	sp, r7
900081b8:	bd80      	pop	{r7, pc}

900081ba <SDMMC_CmdWriteSingleBlock>:
  * @brief  Send the Write Single Block command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdWriteSingleBlock(SDMMC_TypeDef *SDMMCx, uint32_t WriteAdd)
{
900081ba:	b580      	push	{r7, lr}
900081bc:	b088      	sub	sp, #32
900081be:	af00      	add	r7, sp, #0
900081c0:	6078      	str	r0, [r7, #4]
900081c2:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
900081c4:	683b      	ldr	r3, [r7, #0]
900081c6:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
900081c8:	2318      	movs	r3, #24
900081ca:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900081cc:	f44f 7380 	mov.w	r3, #256	@ 0x100
900081d0:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
900081d2:	2300      	movs	r3, #0
900081d4:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900081d6:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
900081da:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900081dc:	f107 0308 	add.w	r3, r7, #8
900081e0:	4619      	mov	r1, r3
900081e2:	6878      	ldr	r0, [r7, #4]
900081e4:	f7ff ff0a 	bl	90007ffc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
900081e8:	f241 3288 	movw	r2, #5000	@ 0x1388
900081ec:	2118      	movs	r1, #24
900081ee:	6878      	ldr	r0, [r7, #4]
900081f0:	f000 f9f6 	bl	900085e0 <SDMMC_GetCmdResp1>
900081f4:	61f8      	str	r0, [r7, #28]

  return errorstate;
900081f6:	69fb      	ldr	r3, [r7, #28]
}
900081f8:	4618      	mov	r0, r3
900081fa:	3720      	adds	r7, #32
900081fc:	46bd      	mov	sp, r7
900081fe:	bd80      	pop	{r7, pc}

90008200 <SDMMC_CmdWriteMultiBlock>:
  * @brief  Send the Write Multi Block command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdWriteMultiBlock(SDMMC_TypeDef *SDMMCx, uint32_t WriteAdd)
{
90008200:	b580      	push	{r7, lr}
90008202:	b088      	sub	sp, #32
90008204:	af00      	add	r7, sp, #0
90008206:	6078      	str	r0, [r7, #4]
90008208:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
9000820a:	683b      	ldr	r3, [r7, #0]
9000820c:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
9000820e:	2319      	movs	r3, #25
90008210:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90008212:	f44f 7380 	mov.w	r3, #256	@ 0x100
90008216:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
90008218:	2300      	movs	r3, #0
9000821a:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000821c:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
90008220:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90008222:	f107 0308 	add.w	r3, r7, #8
90008226:	4619      	mov	r1, r3
90008228:	6878      	ldr	r0, [r7, #4]
9000822a:	f7ff fee7 	bl	90007ffc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_MULT_BLOCK, SDMMC_CMDTIMEOUT);
9000822e:	f241 3288 	movw	r2, #5000	@ 0x1388
90008232:	2119      	movs	r1, #25
90008234:	6878      	ldr	r0, [r7, #4]
90008236:	f000 f9d3 	bl	900085e0 <SDMMC_GetCmdResp1>
9000823a:	61f8      	str	r0, [r7, #28]

  return errorstate;
9000823c:	69fb      	ldr	r3, [r7, #28]
}
9000823e:	4618      	mov	r0, r3
90008240:	3720      	adds	r7, #32
90008242:	46bd      	mov	sp, r7
90008244:	bd80      	pop	{r7, pc}
	...

90008248 <SDMMC_CmdStopTransfer>:
  * @brief  Send the Stop Transfer command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdStopTransfer(SDMMC_TypeDef *SDMMCx)
{
90008248:	b580      	push	{r7, lr}
9000824a:	b088      	sub	sp, #32
9000824c:	af00      	add	r7, sp, #0
9000824e:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD12 STOP_TRANSMISSION  */
  sdmmc_cmdinit.Argument         = 0U;
90008250:	2300      	movs	r3, #0
90008252:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
90008254:	230c      	movs	r3, #12
90008256:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90008258:	f44f 7380 	mov.w	r3, #256	@ 0x100
9000825c:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
9000825e:	2300      	movs	r3, #0
90008260:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90008262:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
90008266:	61bb      	str	r3, [r7, #24]

  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
90008268:	687b      	ldr	r3, [r7, #4]
9000826a:	68db      	ldr	r3, [r3, #12]
9000826c:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
90008270:	687b      	ldr	r3, [r7, #4]
90008272:	60da      	str	r2, [r3, #12]
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
90008274:	687b      	ldr	r3, [r7, #4]
90008276:	68db      	ldr	r3, [r3, #12]
90008278:	f023 0240 	bic.w	r2, r3, #64	@ 0x40
9000827c:	687b      	ldr	r3, [r7, #4]
9000827e:	60da      	str	r2, [r3, #12]

  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90008280:	f107 0308 	add.w	r3, r7, #8
90008284:	4619      	mov	r1, r3
90008286:	6878      	ldr	r0, [r7, #4]
90008288:	f7ff feb8 	bl	90007ffc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_STOP_TRANSMISSION, SDMMC_STOPTRANSFERTIMEOUT);
9000828c:	4a0b      	ldr	r2, [pc, #44]	@ (900082bc <SDMMC_CmdStopTransfer+0x74>)
9000828e:	210c      	movs	r1, #12
90008290:	6878      	ldr	r0, [r7, #4]
90008292:	f000 f9a5 	bl	900085e0 <SDMMC_GetCmdResp1>
90008296:	61f8      	str	r0, [r7, #28]

  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
90008298:	687b      	ldr	r3, [r7, #4]
9000829a:	68db      	ldr	r3, [r3, #12]
9000829c:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
900082a0:	687b      	ldr	r3, [r7, #4]
900082a2:	60da      	str	r2, [r3, #12]

  /* Ignore Address Out Of Range Error, Not relevant at end of memory */
  if (errorstate == SDMMC_ERROR_ADDR_OUT_OF_RANGE)
900082a4:	69fb      	ldr	r3, [r7, #28]
900082a6:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
900082aa:	d101      	bne.n	900082b0 <SDMMC_CmdStopTransfer+0x68>
  {
    errorstate = SDMMC_ERROR_NONE;
900082ac:	2300      	movs	r3, #0
900082ae:	61fb      	str	r3, [r7, #28]
  }

  return errorstate;
900082b0:	69fb      	ldr	r3, [r7, #28]
}
900082b2:	4618      	mov	r0, r3
900082b4:	3720      	adds	r7, #32
900082b6:	46bd      	mov	sp, r7
900082b8:	bd80      	pop	{r7, pc}
900082ba:	bf00      	nop
900082bc:	05f5e100 	.word	0x05f5e100

900082c0 <SDMMC_CmdSelDesel>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  addr: Address of the card to be selected
  * @retval HAL status
  */
uint32_t SDMMC_CmdSelDesel(SDMMC_TypeDef *SDMMCx, uint32_t Addr)
{
900082c0:	b580      	push	{r7, lr}
900082c2:	b088      	sub	sp, #32
900082c4:	af00      	add	r7, sp, #0
900082c6:	6078      	str	r0, [r7, #4]
900082c8:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD7 SDMMC_SEL_DESEL_CARD */
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
900082ca:	683b      	ldr	r3, [r7, #0]
900082cc:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
900082ce:	2307      	movs	r3, #7
900082d0:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900082d2:	f44f 7380 	mov.w	r3, #256	@ 0x100
900082d6:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
900082d8:	2300      	movs	r3, #0
900082da:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900082dc:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
900082e0:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900082e2:	f107 0308 	add.w	r3, r7, #8
900082e6:	4619      	mov	r1, r3
900082e8:	6878      	ldr	r0, [r7, #4]
900082ea:	f7ff fe87 	bl	90007ffc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEL_DESEL_CARD, SDMMC_CMDTIMEOUT);
900082ee:	f241 3288 	movw	r2, #5000	@ 0x1388
900082f2:	2107      	movs	r1, #7
900082f4:	6878      	ldr	r0, [r7, #4]
900082f6:	f000 f973 	bl	900085e0 <SDMMC_GetCmdResp1>
900082fa:	61f8      	str	r0, [r7, #28]

  return errorstate;
900082fc:	69fb      	ldr	r3, [r7, #28]
}
900082fe:	4618      	mov	r0, r3
90008300:	3720      	adds	r7, #32
90008302:	46bd      	mov	sp, r7
90008304:	bd80      	pop	{r7, pc}

90008306 <SDMMC_CmdGoIdleState>:
  * @brief  Send the Go Idle State command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdGoIdleState(SDMMC_TypeDef *SDMMCx)
{
90008306:	b580      	push	{r7, lr}
90008308:	b088      	sub	sp, #32
9000830a:	af00      	add	r7, sp, #0
9000830c:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0U;
9000830e:	2300      	movs	r3, #0
90008310:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
90008312:	2300      	movs	r3, #0
90008314:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_NO;
90008316:	2300      	movs	r3, #0
90008318:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
9000831a:	2300      	movs	r3, #0
9000831c:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000831e:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
90008322:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90008324:	f107 0308 	add.w	r3, r7, #8
90008328:	4619      	mov	r1, r3
9000832a:	6878      	ldr	r0, [r7, #4]
9000832c:	f7ff fe66 	bl	90007ffc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdError(SDMMCx);
90008330:	6878      	ldr	r0, [r7, #4]
90008332:	f000 fb97 	bl	90008a64 <SDMMC_GetCmdError>
90008336:	61f8      	str	r0, [r7, #28]

  return errorstate;
90008338:	69fb      	ldr	r3, [r7, #28]
}
9000833a:	4618      	mov	r0, r3
9000833c:	3720      	adds	r7, #32
9000833e:	46bd      	mov	sp, r7
90008340:	bd80      	pop	{r7, pc}

90008342 <SDMMC_CmdOperCond>:
  * @brief  Send the Operating Condition command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdOperCond(SDMMC_TypeDef *SDMMCx)
{
90008342:	b580      	push	{r7, lr}
90008344:	b088      	sub	sp, #32
90008346:	af00      	add	r7, sp, #0
90008348:	6078      	str	r0, [r7, #4]
  /* Send CMD8 to verify SD card interface operating condition */
  /* Argument: - [31:12]: Reserved (shall be set to '0')
  - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
  - [7:0]: Check Pattern (recommended 0xAA) */
  /* CMD Response: R7 */
  sdmmc_cmdinit.Argument         = SDMMC_CHECK_PATTERN;
9000834a:	f44f 73d5 	mov.w	r3, #426	@ 0x1aa
9000834e:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
90008350:	2308      	movs	r3, #8
90008352:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90008354:	f44f 7380 	mov.w	r3, #256	@ 0x100
90008358:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
9000835a:	2300      	movs	r3, #0
9000835c:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000835e:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
90008362:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90008364:	f107 0308 	add.w	r3, r7, #8
90008368:	4619      	mov	r1, r3
9000836a:	6878      	ldr	r0, [r7, #4]
9000836c:	f7ff fe46 	bl	90007ffc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp7(SDMMCx);
90008370:	6878      	ldr	r0, [r7, #4]
90008372:	f000 fb29 	bl	900089c8 <SDMMC_GetCmdResp7>
90008376:	61f8      	str	r0, [r7, #28]

  return errorstate;
90008378:	69fb      	ldr	r3, [r7, #28]
}
9000837a:	4618      	mov	r0, r3
9000837c:	3720      	adds	r7, #32
9000837e:	46bd      	mov	sp, r7
90008380:	bd80      	pop	{r7, pc}

90008382 <SDMMC_CmdAppCommand>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdAppCommand(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
90008382:	b580      	push	{r7, lr}
90008384:	b088      	sub	sp, #32
90008386:	af00      	add	r7, sp, #0
90008388:	6078      	str	r0, [r7, #4]
9000838a:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = (uint32_t)Argument;
9000838c:	683b      	ldr	r3, [r7, #0]
9000838e:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_CMD;
90008390:	2337      	movs	r3, #55	@ 0x37
90008392:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90008394:	f44f 7380 	mov.w	r3, #256	@ 0x100
90008398:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
9000839a:	2300      	movs	r3, #0
9000839c:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000839e:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
900083a2:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900083a4:	f107 0308 	add.w	r3, r7, #8
900083a8:	4619      	mov	r1, r3
900083aa:	6878      	ldr	r0, [r7, #4]
900083ac:	f7ff fe26 	bl	90007ffc <SDMMC_SendCommand>

  /* Check for error conditions */
  /* If there is a HAL_ERROR, it is a MMC card, else
  it is a SD card: SD card 2.0 (voltage range mismatch)
     or SD card 1.x */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_CMD, SDMMC_CMDTIMEOUT);
900083b0:	f241 3288 	movw	r2, #5000	@ 0x1388
900083b4:	2137      	movs	r1, #55	@ 0x37
900083b6:	6878      	ldr	r0, [r7, #4]
900083b8:	f000 f912 	bl	900085e0 <SDMMC_GetCmdResp1>
900083bc:	61f8      	str	r0, [r7, #28]

  return errorstate;
900083be:	69fb      	ldr	r3, [r7, #28]
}
900083c0:	4618      	mov	r0, r3
900083c2:	3720      	adds	r7, #32
900083c4:	46bd      	mov	sp, r7
900083c6:	bd80      	pop	{r7, pc}

900083c8 <SDMMC_CmdAppOperCommand>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdAppOperCommand(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
900083c8:	b580      	push	{r7, lr}
900083ca:	b088      	sub	sp, #32
900083cc:	af00      	add	r7, sp, #0
900083ce:	6078      	str	r0, [r7, #4]
900083d0:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = Argument;
900083d2:	683b      	ldr	r3, [r7, #0]
900083d4:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_OP_COND;
900083d6:	2329      	movs	r3, #41	@ 0x29
900083d8:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900083da:	f44f 7380 	mov.w	r3, #256	@ 0x100
900083de:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
900083e0:	2300      	movs	r3, #0
900083e2:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900083e4:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
900083e8:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900083ea:	f107 0308 	add.w	r3, r7, #8
900083ee:	4619      	mov	r1, r3
900083f0:	6878      	ldr	r0, [r7, #4]
900083f2:	f7ff fe03 	bl	90007ffc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp3(SDMMCx);
900083f6:	6878      	ldr	r0, [r7, #4]
900083f8:	f000 fa2e 	bl	90008858 <SDMMC_GetCmdResp3>
900083fc:	61f8      	str	r0, [r7, #28]

  return errorstate;
900083fe:	69fb      	ldr	r3, [r7, #28]
}
90008400:	4618      	mov	r0, r3
90008402:	3720      	adds	r7, #32
90008404:	46bd      	mov	sp, r7
90008406:	bd80      	pop	{r7, pc}

90008408 <SDMMC_CmdBusWidth>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  BusWidth: BusWidth
  * @retval HAL status
  */
uint32_t SDMMC_CmdBusWidth(SDMMC_TypeDef *SDMMCx, uint32_t BusWidth)
{
90008408:	b580      	push	{r7, lr}
9000840a:	b088      	sub	sp, #32
9000840c:	af00      	add	r7, sp, #0
9000840e:	6078      	str	r0, [r7, #4]
90008410:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = (uint32_t)BusWidth;
90008412:	683b      	ldr	r3, [r7, #0]
90008414:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_SD_SET_BUSWIDTH;
90008416:	2306      	movs	r3, #6
90008418:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9000841a:	f44f 7380 	mov.w	r3, #256	@ 0x100
9000841e:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
90008420:	2300      	movs	r3, #0
90008422:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90008424:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
90008428:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
9000842a:	f107 0308 	add.w	r3, r7, #8
9000842e:	4619      	mov	r1, r3
90008430:	6878      	ldr	r0, [r7, #4]
90008432:	f7ff fde3 	bl	90007ffc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_SD_SET_BUSWIDTH, SDMMC_CMDTIMEOUT);
90008436:	f241 3288 	movw	r2, #5000	@ 0x1388
9000843a:	2106      	movs	r1, #6
9000843c:	6878      	ldr	r0, [r7, #4]
9000843e:	f000 f8cf 	bl	900085e0 <SDMMC_GetCmdResp1>
90008442:	61f8      	str	r0, [r7, #28]

  return errorstate;
90008444:	69fb      	ldr	r3, [r7, #28]
}
90008446:	4618      	mov	r0, r3
90008448:	3720      	adds	r7, #32
9000844a:	46bd      	mov	sp, r7
9000844c:	bd80      	pop	{r7, pc}

9000844e <SDMMC_CmdSendSCR>:
  * @brief  Send the Send SCR command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendSCR(SDMMC_TypeDef *SDMMCx)
{
9000844e:	b580      	push	{r7, lr}
90008450:	b088      	sub	sp, #32
90008452:	af00      	add	r7, sp, #0
90008454:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD51 SD_APP_SEND_SCR */
  sdmmc_cmdinit.Argument         = 0U;
90008456:	2300      	movs	r3, #0
90008458:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
9000845a:	2333      	movs	r3, #51	@ 0x33
9000845c:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9000845e:	f44f 7380 	mov.w	r3, #256	@ 0x100
90008462:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
90008464:	2300      	movs	r3, #0
90008466:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90008468:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
9000846c:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
9000846e:	f107 0308 	add.w	r3, r7, #8
90008472:	4619      	mov	r1, r3
90008474:	6878      	ldr	r0, [r7, #4]
90008476:	f7ff fdc1 	bl	90007ffc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_APP_SEND_SCR, SDMMC_CMDTIMEOUT);
9000847a:	f241 3288 	movw	r2, #5000	@ 0x1388
9000847e:	2133      	movs	r1, #51	@ 0x33
90008480:	6878      	ldr	r0, [r7, #4]
90008482:	f000 f8ad 	bl	900085e0 <SDMMC_GetCmdResp1>
90008486:	61f8      	str	r0, [r7, #28]

  return errorstate;
90008488:	69fb      	ldr	r3, [r7, #28]
}
9000848a:	4618      	mov	r0, r3
9000848c:	3720      	adds	r7, #32
9000848e:	46bd      	mov	sp, r7
90008490:	bd80      	pop	{r7, pc}

90008492 <SDMMC_CmdSendCID>:
  * @brief  Send the Send CID command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCID(SDMMC_TypeDef *SDMMCx)
{
90008492:	b580      	push	{r7, lr}
90008494:	b088      	sub	sp, #32
90008496:	af00      	add	r7, sp, #0
90008498:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD2 ALL_SEND_CID */
  sdmmc_cmdinit.Argument         = 0U;
9000849a:	2300      	movs	r3, #0
9000849c:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
9000849e:	2302      	movs	r3, #2
900084a0:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
900084a2:	f44f 7340 	mov.w	r3, #768	@ 0x300
900084a6:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
900084a8:	2300      	movs	r3, #0
900084aa:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900084ac:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
900084b0:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900084b2:	f107 0308 	add.w	r3, r7, #8
900084b6:	4619      	mov	r1, r3
900084b8:	6878      	ldr	r0, [r7, #4]
900084ba:	f7ff fd9f 	bl	90007ffc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
900084be:	6878      	ldr	r0, [r7, #4]
900084c0:	f000 f980 	bl	900087c4 <SDMMC_GetCmdResp2>
900084c4:	61f8      	str	r0, [r7, #28]

  return errorstate;
900084c6:	69fb      	ldr	r3, [r7, #28]
}
900084c8:	4618      	mov	r0, r3
900084ca:	3720      	adds	r7, #32
900084cc:	46bd      	mov	sp, r7
900084ce:	bd80      	pop	{r7, pc}

900084d0 <SDMMC_CmdSendCSD>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCSD(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
900084d0:	b580      	push	{r7, lr}
900084d2:	b088      	sub	sp, #32
900084d4:	af00      	add	r7, sp, #0
900084d6:	6078      	str	r0, [r7, #4]
900084d8:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
900084da:	683b      	ldr	r3, [r7, #0]
900084dc:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_CSD;
900084de:	2309      	movs	r3, #9
900084e0:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
900084e2:	f44f 7340 	mov.w	r3, #768	@ 0x300
900084e6:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
900084e8:	2300      	movs	r3, #0
900084ea:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900084ec:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
900084f0:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900084f2:	f107 0308 	add.w	r3, r7, #8
900084f6:	4619      	mov	r1, r3
900084f8:	6878      	ldr	r0, [r7, #4]
900084fa:	f7ff fd7f 	bl	90007ffc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
900084fe:	6878      	ldr	r0, [r7, #4]
90008500:	f000 f960 	bl	900087c4 <SDMMC_GetCmdResp2>
90008504:	61f8      	str	r0, [r7, #28]

  return errorstate;
90008506:	69fb      	ldr	r3, [r7, #28]
}
90008508:	4618      	mov	r0, r3
9000850a:	3720      	adds	r7, #32
9000850c:	46bd      	mov	sp, r7
9000850e:	bd80      	pop	{r7, pc}

90008510 <SDMMC_CmdSetRelAdd>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  pRCA: Card RCA
  * @retval HAL status
  */
uint32_t SDMMC_CmdSetRelAdd(SDMMC_TypeDef *SDMMCx, uint16_t *pRCA)
{
90008510:	b580      	push	{r7, lr}
90008512:	b088      	sub	sp, #32
90008514:	af00      	add	r7, sp, #0
90008516:	6078      	str	r0, [r7, #4]
90008518:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = 0U;
9000851a:	2300      	movs	r3, #0
9000851c:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
9000851e:	2303      	movs	r3, #3
90008520:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90008522:	f44f 7380 	mov.w	r3, #256	@ 0x100
90008526:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
90008528:	2300      	movs	r3, #0
9000852a:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9000852c:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
90008530:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90008532:	f107 0308 	add.w	r3, r7, #8
90008536:	4619      	mov	r1, r3
90008538:	6878      	ldr	r0, [r7, #4]
9000853a:	f7ff fd5f 	bl	90007ffc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp6(SDMMCx, SDMMC_CMD_SET_REL_ADDR, pRCA);
9000853e:	683a      	ldr	r2, [r7, #0]
90008540:	2103      	movs	r1, #3
90008542:	6878      	ldr	r0, [r7, #4]
90008544:	f000 f9c8 	bl	900088d8 <SDMMC_GetCmdResp6>
90008548:	61f8      	str	r0, [r7, #28]

  return errorstate;
9000854a:	69fb      	ldr	r3, [r7, #28]
}
9000854c:	4618      	mov	r0, r3
9000854e:	3720      	adds	r7, #32
90008550:	46bd      	mov	sp, r7
90008552:	bd80      	pop	{r7, pc}

90008554 <SDMMC_CmdSendStatus>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendStatus(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
90008554:	b580      	push	{r7, lr}
90008556:	b088      	sub	sp, #32
90008558:	af00      	add	r7, sp, #0
9000855a:	6078      	str	r0, [r7, #4]
9000855c:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = Argument;
9000855e:	683b      	ldr	r3, [r7, #0]
90008560:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
90008562:	230d      	movs	r3, #13
90008564:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90008566:	f44f 7380 	mov.w	r3, #256	@ 0x100
9000856a:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
9000856c:	2300      	movs	r3, #0
9000856e:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90008570:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
90008574:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90008576:	f107 0308 	add.w	r3, r7, #8
9000857a:	4619      	mov	r1, r3
9000857c:	6878      	ldr	r0, [r7, #4]
9000857e:	f7ff fd3d 	bl	90007ffc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEND_STATUS, SDMMC_CMDTIMEOUT);
90008582:	f241 3288 	movw	r2, #5000	@ 0x1388
90008586:	210d      	movs	r1, #13
90008588:	6878      	ldr	r0, [r7, #4]
9000858a:	f000 f829 	bl	900085e0 <SDMMC_GetCmdResp1>
9000858e:	61f8      	str	r0, [r7, #28]

  return errorstate;
90008590:	69fb      	ldr	r3, [r7, #28]
}
90008592:	4618      	mov	r0, r3
90008594:	3720      	adds	r7, #32
90008596:	46bd      	mov	sp, r7
90008598:	bd80      	pop	{r7, pc}

9000859a <SDMMC_CmdStatusRegister>:
  * @brief  Send the Status register command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdStatusRegister(SDMMC_TypeDef *SDMMCx)
{
9000859a:	b580      	push	{r7, lr}
9000859c:	b088      	sub	sp, #32
9000859e:	af00      	add	r7, sp, #0
900085a0:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0U;
900085a2:	2300      	movs	r3, #0
900085a4:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_STATUS;
900085a6:	230d      	movs	r3, #13
900085a8:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900085aa:	f44f 7380 	mov.w	r3, #256	@ 0x100
900085ae:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
900085b0:	2300      	movs	r3, #0
900085b2:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900085b4:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
900085b8:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900085ba:	f107 0308 	add.w	r3, r7, #8
900085be:	4619      	mov	r1, r3
900085c0:	6878      	ldr	r0, [r7, #4]
900085c2:	f7ff fd1b 	bl	90007ffc <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_APP_STATUS, SDMMC_CMDTIMEOUT);
900085c6:	f241 3288 	movw	r2, #5000	@ 0x1388
900085ca:	210d      	movs	r1, #13
900085cc:	6878      	ldr	r0, [r7, #4]
900085ce:	f000 f807 	bl	900085e0 <SDMMC_GetCmdResp1>
900085d2:	61f8      	str	r0, [r7, #28]

  return errorstate;
900085d4:	69fb      	ldr	r3, [r7, #28]
}
900085d6:	4618      	mov	r0, r3
900085d8:	3720      	adds	r7, #32
900085da:	46bd      	mov	sp, r7
900085dc:	bd80      	pop	{r7, pc}
	...

900085e0 <SDMMC_GetCmdResp1>:
  * @param  hsd: SD handle
  * @param  SD_CMD: The sent command index
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp1(SDMMC_TypeDef *SDMMCx, uint8_t SD_CMD, uint32_t Timeout)
{
900085e0:	b580      	push	{r7, lr}
900085e2:	b088      	sub	sp, #32
900085e4:	af00      	add	r7, sp, #0
900085e6:	60f8      	str	r0, [r7, #12]
900085e8:	460b      	mov	r3, r1
900085ea:	607a      	str	r2, [r7, #4]
900085ec:	72fb      	strb	r3, [r7, #11]
  uint32_t response_r1;
  uint32_t sta_reg;

  /* 8 is the number of required instructions cycles for the below loop statement.
  The Timeout is expressed in ms */
  uint32_t count = Timeout * (SystemCoreClock / 8U / 1000U);
900085ee:	4b70      	ldr	r3, [pc, #448]	@ (900087b0 <SDMMC_GetCmdResp1+0x1d0>)
900085f0:	681b      	ldr	r3, [r3, #0]
900085f2:	4a70      	ldr	r2, [pc, #448]	@ (900087b4 <SDMMC_GetCmdResp1+0x1d4>)
900085f4:	fba2 2303 	umull	r2, r3, r2, r3
900085f8:	0a5a      	lsrs	r2, r3, #9
900085fa:	687b      	ldr	r3, [r7, #4]
900085fc:	fb02 f303 	mul.w	r3, r2, r3
90008600:	61fb      	str	r3, [r7, #28]

  do
  {
    if (count-- == 0U)
90008602:	69fb      	ldr	r3, [r7, #28]
90008604:	1e5a      	subs	r2, r3, #1
90008606:	61fa      	str	r2, [r7, #28]
90008608:	2b00      	cmp	r3, #0
9000860a:	d102      	bne.n	90008612 <SDMMC_GetCmdResp1+0x32>
    {
      return SDMMC_ERROR_TIMEOUT;
9000860c:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
90008610:	e0c9      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
    }
    sta_reg = SDMMCx->STA;
90008612:	68fb      	ldr	r3, [r7, #12]
90008614:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90008616:	61bb      	str	r3, [r7, #24]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT |
90008618:	69ba      	ldr	r2, [r7, #24]
9000861a:	4b67      	ldr	r3, [pc, #412]	@ (900087b8 <SDMMC_GetCmdResp1+0x1d8>)
9000861c:	4013      	ands	r3, r2
                        SDMMC_FLAG_BUSYD0END)) == 0U) || ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
9000861e:	2b00      	cmp	r3, #0
90008620:	d0ef      	beq.n	90008602 <SDMMC_GetCmdResp1+0x22>
90008622:	69bb      	ldr	r3, [r7, #24]
90008624:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
90008628:	2b00      	cmp	r3, #0
9000862a:	d1ea      	bne.n	90008602 <SDMMC_GetCmdResp1+0x22>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
9000862c:	68fb      	ldr	r3, [r7, #12]
9000862e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90008630:	f003 0304 	and.w	r3, r3, #4
90008634:	2b00      	cmp	r3, #0
90008636:	d004      	beq.n	90008642 <SDMMC_GetCmdResp1+0x62>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
90008638:	68fb      	ldr	r3, [r7, #12]
9000863a:	2204      	movs	r2, #4
9000863c:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
9000863e:	2304      	movs	r3, #4
90008640:	e0b1      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
90008642:	68fb      	ldr	r3, [r7, #12]
90008644:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90008646:	f003 0301 	and.w	r3, r3, #1
9000864a:	2b00      	cmp	r3, #0
9000864c:	d004      	beq.n	90008658 <SDMMC_GetCmdResp1+0x78>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
9000864e:	68fb      	ldr	r3, [r7, #12]
90008650:	2201      	movs	r2, #1
90008652:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
90008654:	2301      	movs	r3, #1
90008656:	e0a6      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  {
    /* Nothing to do */
  }

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
90008658:	68fb      	ldr	r3, [r7, #12]
9000865a:	4a58      	ldr	r2, [pc, #352]	@ (900087bc <SDMMC_GetCmdResp1+0x1dc>)
9000865c:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Check response received is of desired command */
  if (SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
9000865e:	68f8      	ldr	r0, [r7, #12]
90008660:	f7ff fcf6 	bl	90008050 <SDMMC_GetCommandResponse>
90008664:	4603      	mov	r3, r0
90008666:	461a      	mov	r2, r3
90008668:	7afb      	ldrb	r3, [r7, #11]
9000866a:	4293      	cmp	r3, r2
9000866c:	d001      	beq.n	90008672 <SDMMC_GetCmdResp1+0x92>
  {
    return SDMMC_ERROR_CMD_CRC_FAIL;
9000866e:	2301      	movs	r3, #1
90008670:	e099      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }

  /* We have received response, retrieve it for analysis  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);
90008672:	2100      	movs	r1, #0
90008674:	68f8      	ldr	r0, [r7, #12]
90008676:	f7ff fcf8 	bl	9000806a <SDMMC_GetResponse>
9000867a:	6178      	str	r0, [r7, #20]

  if ((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
9000867c:	697a      	ldr	r2, [r7, #20]
9000867e:	4b50      	ldr	r3, [pc, #320]	@ (900087c0 <SDMMC_GetCmdResp1+0x1e0>)
90008680:	4013      	ands	r3, r2
90008682:	2b00      	cmp	r3, #0
90008684:	d101      	bne.n	9000868a <SDMMC_GetCmdResp1+0xaa>
  {
    return SDMMC_ERROR_NONE;
90008686:	2300      	movs	r3, #0
90008688:	e08d      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
9000868a:	697b      	ldr	r3, [r7, #20]
9000868c:	2b00      	cmp	r3, #0
9000868e:	da02      	bge.n	90008696 <SDMMC_GetCmdResp1+0xb6>
  {
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
90008690:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
90008694:	e087      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
90008696:	697b      	ldr	r3, [r7, #20]
90008698:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
9000869c:	2b00      	cmp	r3, #0
9000869e:	d001      	beq.n	900086a4 <SDMMC_GetCmdResp1+0xc4>
  {
    return SDMMC_ERROR_ADDR_MISALIGNED;
900086a0:	2340      	movs	r3, #64	@ 0x40
900086a2:	e080      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
900086a4:	697b      	ldr	r3, [r7, #20]
900086a6:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
900086aa:	2b00      	cmp	r3, #0
900086ac:	d001      	beq.n	900086b2 <SDMMC_GetCmdResp1+0xd2>
  {
    return SDMMC_ERROR_BLOCK_LEN_ERR;
900086ae:	2380      	movs	r3, #128	@ 0x80
900086b0:	e079      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
900086b2:	697b      	ldr	r3, [r7, #20]
900086b4:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
900086b8:	2b00      	cmp	r3, #0
900086ba:	d002      	beq.n	900086c2 <SDMMC_GetCmdResp1+0xe2>
  {
    return SDMMC_ERROR_ERASE_SEQ_ERR;
900086bc:	f44f 7380 	mov.w	r3, #256	@ 0x100
900086c0:	e071      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
900086c2:	697b      	ldr	r3, [r7, #20]
900086c4:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
900086c8:	2b00      	cmp	r3, #0
900086ca:	d002      	beq.n	900086d2 <SDMMC_GetCmdResp1+0xf2>
  {
    return SDMMC_ERROR_BAD_ERASE_PARAM;
900086cc:	f44f 7300 	mov.w	r3, #512	@ 0x200
900086d0:	e069      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
900086d2:	697b      	ldr	r3, [r7, #20]
900086d4:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
900086d8:	2b00      	cmp	r3, #0
900086da:	d002      	beq.n	900086e2 <SDMMC_GetCmdResp1+0x102>
  {
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
900086dc:	f44f 6380 	mov.w	r3, #1024	@ 0x400
900086e0:	e061      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
900086e2:	697b      	ldr	r3, [r7, #20]
900086e4:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
900086e8:	2b00      	cmp	r3, #0
900086ea:	d002      	beq.n	900086f2 <SDMMC_GetCmdResp1+0x112>
  {
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
900086ec:	f44f 6300 	mov.w	r3, #2048	@ 0x800
900086f0:	e059      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
900086f2:	697b      	ldr	r3, [r7, #20]
900086f4:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
900086f8:	2b00      	cmp	r3, #0
900086fa:	d002      	beq.n	90008702 <SDMMC_GetCmdResp1+0x122>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
900086fc:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
90008700:	e051      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
90008702:	697b      	ldr	r3, [r7, #20]
90008704:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
90008708:	2b00      	cmp	r3, #0
9000870a:	d002      	beq.n	90008712 <SDMMC_GetCmdResp1+0x132>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
9000870c:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
90008710:	e049      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
90008712:	697b      	ldr	r3, [r7, #20]
90008714:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
90008718:	2b00      	cmp	r3, #0
9000871a:	d002      	beq.n	90008722 <SDMMC_GetCmdResp1+0x142>
  {
    return SDMMC_ERROR_CARD_ECC_FAILED;
9000871c:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
90008720:	e041      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
90008722:	697b      	ldr	r3, [r7, #20]
90008724:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
90008728:	2b00      	cmp	r3, #0
9000872a:	d002      	beq.n	90008732 <SDMMC_GetCmdResp1+0x152>
  {
    return SDMMC_ERROR_CC_ERR;
9000872c:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
90008730:	e039      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
90008732:	697b      	ldr	r3, [r7, #20]
90008734:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
90008738:	2b00      	cmp	r3, #0
9000873a:	d002      	beq.n	90008742 <SDMMC_GetCmdResp1+0x162>
  {
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
9000873c:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
90008740:	e031      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
90008742:	697b      	ldr	r3, [r7, #20]
90008744:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
90008748:	2b00      	cmp	r3, #0
9000874a:	d002      	beq.n	90008752 <SDMMC_GetCmdResp1+0x172>
  {
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
9000874c:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
90008750:	e029      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
90008752:	697b      	ldr	r3, [r7, #20]
90008754:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
90008758:	2b00      	cmp	r3, #0
9000875a:	d002      	beq.n	90008762 <SDMMC_GetCmdResp1+0x182>
  {
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
9000875c:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
90008760:	e021      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
90008762:	697b      	ldr	r3, [r7, #20]
90008764:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
90008768:	2b00      	cmp	r3, #0
9000876a:	d002      	beq.n	90008772 <SDMMC_GetCmdResp1+0x192>
  {
    return SDMMC_ERROR_WP_ERASE_SKIP;
9000876c:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
90008770:	e019      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
90008772:	697b      	ldr	r3, [r7, #20]
90008774:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
90008778:	2b00      	cmp	r3, #0
9000877a:	d002      	beq.n	90008782 <SDMMC_GetCmdResp1+0x1a2>
  {
    return SDMMC_ERROR_CARD_ECC_DISABLED;
9000877c:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
90008780:	e011      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
90008782:	697b      	ldr	r3, [r7, #20]
90008784:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
90008788:	2b00      	cmp	r3, #0
9000878a:	d002      	beq.n	90008792 <SDMMC_GetCmdResp1+0x1b2>
  {
    return SDMMC_ERROR_ERASE_RESET;
9000878c:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
90008790:	e009      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_AKE_SEQ_ERROR) == SDMMC_OCR_AKE_SEQ_ERROR)
90008792:	697b      	ldr	r3, [r7, #20]
90008794:	f003 0308 	and.w	r3, r3, #8
90008798:	2b00      	cmp	r3, #0
9000879a:	d002      	beq.n	900087a2 <SDMMC_GetCmdResp1+0x1c2>
  {
    return SDMMC_ERROR_AKE_SEQ_ERR;
9000879c:	f44f 0300 	mov.w	r3, #8388608	@ 0x800000
900087a0:	e001      	b.n	900087a6 <SDMMC_GetCmdResp1+0x1c6>
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
900087a2:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
  }
}
900087a6:	4618      	mov	r0, r3
900087a8:	3720      	adds	r7, #32
900087aa:	46bd      	mov	sp, r7
900087ac:	bd80      	pop	{r7, pc}
900087ae:	bf00      	nop
900087b0:	24000074 	.word	0x24000074
900087b4:	10624dd3 	.word	0x10624dd3
900087b8:	00200045 	.word	0x00200045
900087bc:	002000c5 	.word	0x002000c5
900087c0:	fdffe008 	.word	0xfdffe008

900087c4 <SDMMC_GetCmdResp2>:
  * @brief  Checks for error conditions for R2 (CID or CSD) response.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp2(SDMMC_TypeDef *SDMMCx)
{
900087c4:	b480      	push	{r7}
900087c6:	b085      	sub	sp, #20
900087c8:	af00      	add	r7, sp, #0
900087ca:	6078      	str	r0, [r7, #4]
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
900087cc:	4b1f      	ldr	r3, [pc, #124]	@ (9000884c <SDMMC_GetCmdResp2+0x88>)
900087ce:	681b      	ldr	r3, [r3, #0]
900087d0:	4a1f      	ldr	r2, [pc, #124]	@ (90008850 <SDMMC_GetCmdResp2+0x8c>)
900087d2:	fba2 2303 	umull	r2, r3, r2, r3
900087d6:	0a5b      	lsrs	r3, r3, #9
900087d8:	f241 3288 	movw	r2, #5000	@ 0x1388
900087dc:	fb02 f303 	mul.w	r3, r2, r3
900087e0:	60fb      	str	r3, [r7, #12]

  do
  {
    if (count-- == 0U)
900087e2:	68fb      	ldr	r3, [r7, #12]
900087e4:	1e5a      	subs	r2, r3, #1
900087e6:	60fa      	str	r2, [r7, #12]
900087e8:	2b00      	cmp	r3, #0
900087ea:	d102      	bne.n	900087f2 <SDMMC_GetCmdResp2+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
900087ec:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
900087f0:	e026      	b.n	90008840 <SDMMC_GetCmdResp2+0x7c>
    }
    sta_reg = SDMMCx->STA;
900087f2:	687b      	ldr	r3, [r7, #4]
900087f4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
900087f6:	60bb      	str	r3, [r7, #8]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
900087f8:	68bb      	ldr	r3, [r7, #8]
900087fa:	f003 0345 	and.w	r3, r3, #69	@ 0x45
900087fe:	2b00      	cmp	r3, #0
90008800:	d0ef      	beq.n	900087e2 <SDMMC_GetCmdResp2+0x1e>
           ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
90008802:	68bb      	ldr	r3, [r7, #8]
90008804:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
90008808:	2b00      	cmp	r3, #0
9000880a:	d1ea      	bne.n	900087e2 <SDMMC_GetCmdResp2+0x1e>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
9000880c:	687b      	ldr	r3, [r7, #4]
9000880e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90008810:	f003 0304 	and.w	r3, r3, #4
90008814:	2b00      	cmp	r3, #0
90008816:	d004      	beq.n	90008822 <SDMMC_GetCmdResp2+0x5e>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
90008818:	687b      	ldr	r3, [r7, #4]
9000881a:	2204      	movs	r2, #4
9000881c:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
9000881e:	2304      	movs	r3, #4
90008820:	e00e      	b.n	90008840 <SDMMC_GetCmdResp2+0x7c>
  }
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
90008822:	687b      	ldr	r3, [r7, #4]
90008824:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90008826:	f003 0301 	and.w	r3, r3, #1
9000882a:	2b00      	cmp	r3, #0
9000882c:	d004      	beq.n	90008838 <SDMMC_GetCmdResp2+0x74>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
9000882e:	687b      	ldr	r3, [r7, #4]
90008830:	2201      	movs	r2, #1
90008832:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
90008834:	2301      	movs	r3, #1
90008836:	e003      	b.n	90008840 <SDMMC_GetCmdResp2+0x7c>
  }
  else
  {
    /* No error flag set */
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
90008838:	687b      	ldr	r3, [r7, #4]
9000883a:	4a06      	ldr	r2, [pc, #24]	@ (90008854 <SDMMC_GetCmdResp2+0x90>)
9000883c:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  return SDMMC_ERROR_NONE;
9000883e:	2300      	movs	r3, #0
}
90008840:	4618      	mov	r0, r3
90008842:	3714      	adds	r7, #20
90008844:	46bd      	mov	sp, r7
90008846:	f85d 7b04 	ldr.w	r7, [sp], #4
9000884a:	4770      	bx	lr
9000884c:	24000074 	.word	0x24000074
90008850:	10624dd3 	.word	0x10624dd3
90008854:	002000c5 	.word	0x002000c5

90008858 <SDMMC_GetCmdResp3>:
  * @brief  Checks for error conditions for R3 (OCR) response.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp3(SDMMC_TypeDef *SDMMCx)
{
90008858:	b480      	push	{r7}
9000885a:	b085      	sub	sp, #20
9000885c:	af00      	add	r7, sp, #0
9000885e:	6078      	str	r0, [r7, #4]
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
90008860:	4b1a      	ldr	r3, [pc, #104]	@ (900088cc <SDMMC_GetCmdResp3+0x74>)
90008862:	681b      	ldr	r3, [r3, #0]
90008864:	4a1a      	ldr	r2, [pc, #104]	@ (900088d0 <SDMMC_GetCmdResp3+0x78>)
90008866:	fba2 2303 	umull	r2, r3, r2, r3
9000886a:	0a5b      	lsrs	r3, r3, #9
9000886c:	f241 3288 	movw	r2, #5000	@ 0x1388
90008870:	fb02 f303 	mul.w	r3, r2, r3
90008874:	60fb      	str	r3, [r7, #12]

  do
  {
    if (count-- == 0U)
90008876:	68fb      	ldr	r3, [r7, #12]
90008878:	1e5a      	subs	r2, r3, #1
9000887a:	60fa      	str	r2, [r7, #12]
9000887c:	2b00      	cmp	r3, #0
9000887e:	d102      	bne.n	90008886 <SDMMC_GetCmdResp3+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
90008880:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
90008884:	e01b      	b.n	900088be <SDMMC_GetCmdResp3+0x66>
    }
    sta_reg = SDMMCx->STA;
90008886:	687b      	ldr	r3, [r7, #4]
90008888:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
9000888a:	60bb      	str	r3, [r7, #8]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
9000888c:	68bb      	ldr	r3, [r7, #8]
9000888e:	f003 0345 	and.w	r3, r3, #69	@ 0x45
90008892:	2b00      	cmp	r3, #0
90008894:	d0ef      	beq.n	90008876 <SDMMC_GetCmdResp3+0x1e>
           ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
90008896:	68bb      	ldr	r3, [r7, #8]
90008898:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
9000889c:	2b00      	cmp	r3, #0
9000889e:	d1ea      	bne.n	90008876 <SDMMC_GetCmdResp3+0x1e>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
900088a0:	687b      	ldr	r3, [r7, #4]
900088a2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
900088a4:	f003 0304 	and.w	r3, r3, #4
900088a8:	2b00      	cmp	r3, #0
900088aa:	d004      	beq.n	900088b6 <SDMMC_GetCmdResp3+0x5e>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
900088ac:	687b      	ldr	r3, [r7, #4]
900088ae:	2204      	movs	r2, #4
900088b0:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
900088b2:	2304      	movs	r3, #4
900088b4:	e003      	b.n	900088be <SDMMC_GetCmdResp3+0x66>
  }
  else
  {
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
900088b6:	687b      	ldr	r3, [r7, #4]
900088b8:	4a06      	ldr	r2, [pc, #24]	@ (900088d4 <SDMMC_GetCmdResp3+0x7c>)
900088ba:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  return SDMMC_ERROR_NONE;
900088bc:	2300      	movs	r3, #0
}
900088be:	4618      	mov	r0, r3
900088c0:	3714      	adds	r7, #20
900088c2:	46bd      	mov	sp, r7
900088c4:	f85d 7b04 	ldr.w	r7, [sp], #4
900088c8:	4770      	bx	lr
900088ca:	bf00      	nop
900088cc:	24000074 	.word	0x24000074
900088d0:	10624dd3 	.word	0x10624dd3
900088d4:	002000c5 	.word	0x002000c5

900088d8 <SDMMC_GetCmdResp6>:
  * @param  pRCA: Pointer to the variable that will contain the SD card relative
  *         address RCA
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp6(SDMMC_TypeDef *SDMMCx, uint8_t SD_CMD, uint16_t *pRCA)
{
900088d8:	b580      	push	{r7, lr}
900088da:	b088      	sub	sp, #32
900088dc:	af00      	add	r7, sp, #0
900088de:	60f8      	str	r0, [r7, #12]
900088e0:	460b      	mov	r3, r1
900088e2:	607a      	str	r2, [r7, #4]
900088e4:	72fb      	strb	r3, [r7, #11]
  uint32_t response_r1;
  uint32_t sta_reg;

  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
900088e6:	4b35      	ldr	r3, [pc, #212]	@ (900089bc <SDMMC_GetCmdResp6+0xe4>)
900088e8:	681b      	ldr	r3, [r3, #0]
900088ea:	4a35      	ldr	r2, [pc, #212]	@ (900089c0 <SDMMC_GetCmdResp6+0xe8>)
900088ec:	fba2 2303 	umull	r2, r3, r2, r3
900088f0:	0a5b      	lsrs	r3, r3, #9
900088f2:	f241 3288 	movw	r2, #5000	@ 0x1388
900088f6:	fb02 f303 	mul.w	r3, r2, r3
900088fa:	61fb      	str	r3, [r7, #28]

  do
  {
    if (count-- == 0U)
900088fc:	69fb      	ldr	r3, [r7, #28]
900088fe:	1e5a      	subs	r2, r3, #1
90008900:	61fa      	str	r2, [r7, #28]
90008902:	2b00      	cmp	r3, #0
90008904:	d102      	bne.n	9000890c <SDMMC_GetCmdResp6+0x34>
    {
      return SDMMC_ERROR_TIMEOUT;
90008906:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
9000890a:	e052      	b.n	900089b2 <SDMMC_GetCmdResp6+0xda>
    }
    sta_reg = SDMMCx->STA;
9000890c:	68fb      	ldr	r3, [r7, #12]
9000890e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90008910:	61bb      	str	r3, [r7, #24]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
90008912:	69bb      	ldr	r3, [r7, #24]
90008914:	f003 0345 	and.w	r3, r3, #69	@ 0x45
90008918:	2b00      	cmp	r3, #0
9000891a:	d0ef      	beq.n	900088fc <SDMMC_GetCmdResp6+0x24>
           ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
9000891c:	69bb      	ldr	r3, [r7, #24]
9000891e:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
90008922:	2b00      	cmp	r3, #0
90008924:	d1ea      	bne.n	900088fc <SDMMC_GetCmdResp6+0x24>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
90008926:	68fb      	ldr	r3, [r7, #12]
90008928:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
9000892a:	f003 0304 	and.w	r3, r3, #4
9000892e:	2b00      	cmp	r3, #0
90008930:	d004      	beq.n	9000893c <SDMMC_GetCmdResp6+0x64>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
90008932:	68fb      	ldr	r3, [r7, #12]
90008934:	2204      	movs	r2, #4
90008936:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
90008938:	2304      	movs	r3, #4
9000893a:	e03a      	b.n	900089b2 <SDMMC_GetCmdResp6+0xda>
  }
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
9000893c:	68fb      	ldr	r3, [r7, #12]
9000893e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90008940:	f003 0301 	and.w	r3, r3, #1
90008944:	2b00      	cmp	r3, #0
90008946:	d004      	beq.n	90008952 <SDMMC_GetCmdResp6+0x7a>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
90008948:	68fb      	ldr	r3, [r7, #12]
9000894a:	2201      	movs	r2, #1
9000894c:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
9000894e:	2301      	movs	r3, #1
90008950:	e02f      	b.n	900089b2 <SDMMC_GetCmdResp6+0xda>
  {
    /* Nothing to do */
  }

  /* Check response received is of desired command */
  if (SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
90008952:	68f8      	ldr	r0, [r7, #12]
90008954:	f7ff fb7c 	bl	90008050 <SDMMC_GetCommandResponse>
90008958:	4603      	mov	r3, r0
9000895a:	461a      	mov	r2, r3
9000895c:	7afb      	ldrb	r3, [r7, #11]
9000895e:	4293      	cmp	r3, r2
90008960:	d001      	beq.n	90008966 <SDMMC_GetCmdResp6+0x8e>
  {
    return SDMMC_ERROR_CMD_CRC_FAIL;
90008962:	2301      	movs	r3, #1
90008964:	e025      	b.n	900089b2 <SDMMC_GetCmdResp6+0xda>
  }

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
90008966:	68fb      	ldr	r3, [r7, #12]
90008968:	4a16      	ldr	r2, [pc, #88]	@ (900089c4 <SDMMC_GetCmdResp6+0xec>)
9000896a:	639a      	str	r2, [r3, #56]	@ 0x38

  /* We have received response, retrieve it.  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);
9000896c:	2100      	movs	r1, #0
9000896e:	68f8      	ldr	r0, [r7, #12]
90008970:	f7ff fb7b 	bl	9000806a <SDMMC_GetResponse>
90008974:	6178      	str	r0, [r7, #20]

  if ((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD |
90008976:	697b      	ldr	r3, [r7, #20]
90008978:	f403 4360 	and.w	r3, r3, #57344	@ 0xe000
9000897c:	2b00      	cmp	r3, #0
9000897e:	d106      	bne.n	9000898e <SDMMC_GetCmdResp6+0xb6>
                      SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
  {
    *pRCA = (uint16_t)(response_r1 >> 16);
90008980:	697b      	ldr	r3, [r7, #20]
90008982:	0c1b      	lsrs	r3, r3, #16
90008984:	b29a      	uxth	r2, r3
90008986:	687b      	ldr	r3, [r7, #4]
90008988:	801a      	strh	r2, [r3, #0]

    return SDMMC_ERROR_NONE;
9000898a:	2300      	movs	r3, #0
9000898c:	e011      	b.n	900089b2 <SDMMC_GetCmdResp6+0xda>
  }
  else if ((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
9000898e:	697b      	ldr	r3, [r7, #20]
90008990:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
90008994:	2b00      	cmp	r3, #0
90008996:	d002      	beq.n	9000899e <SDMMC_GetCmdResp6+0xc6>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
90008998:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
9000899c:	e009      	b.n	900089b2 <SDMMC_GetCmdResp6+0xda>
  }
  else if ((response_r1 & SDMMC_R6_COM_CRC_FAILED) == SDMMC_R6_COM_CRC_FAILED)
9000899e:	697b      	ldr	r3, [r7, #20]
900089a0:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
900089a4:	2b00      	cmp	r3, #0
900089a6:	d002      	beq.n	900089ae <SDMMC_GetCmdResp6+0xd6>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
900089a8:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
900089ac:	e001      	b.n	900089b2 <SDMMC_GetCmdResp6+0xda>
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
900089ae:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
  }
}
900089b2:	4618      	mov	r0, r3
900089b4:	3720      	adds	r7, #32
900089b6:	46bd      	mov	sp, r7
900089b8:	bd80      	pop	{r7, pc}
900089ba:	bf00      	nop
900089bc:	24000074 	.word	0x24000074
900089c0:	10624dd3 	.word	0x10624dd3
900089c4:	002000c5 	.word	0x002000c5

900089c8 <SDMMC_GetCmdResp7>:
  * @brief  Checks for error conditions for R7 response.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp7(SDMMC_TypeDef *SDMMCx)
{
900089c8:	b480      	push	{r7}
900089ca:	b085      	sub	sp, #20
900089cc:	af00      	add	r7, sp, #0
900089ce:	6078      	str	r0, [r7, #4]
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
900089d0:	4b22      	ldr	r3, [pc, #136]	@ (90008a5c <SDMMC_GetCmdResp7+0x94>)
900089d2:	681b      	ldr	r3, [r3, #0]
900089d4:	4a22      	ldr	r2, [pc, #136]	@ (90008a60 <SDMMC_GetCmdResp7+0x98>)
900089d6:	fba2 2303 	umull	r2, r3, r2, r3
900089da:	0a5b      	lsrs	r3, r3, #9
900089dc:	f241 3288 	movw	r2, #5000	@ 0x1388
900089e0:	fb02 f303 	mul.w	r3, r2, r3
900089e4:	60fb      	str	r3, [r7, #12]

  do
  {
    if (count-- == 0U)
900089e6:	68fb      	ldr	r3, [r7, #12]
900089e8:	1e5a      	subs	r2, r3, #1
900089ea:	60fa      	str	r2, [r7, #12]
900089ec:	2b00      	cmp	r3, #0
900089ee:	d102      	bne.n	900089f6 <SDMMC_GetCmdResp7+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
900089f0:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
900089f4:	e02c      	b.n	90008a50 <SDMMC_GetCmdResp7+0x88>
    }
    sta_reg = SDMMCx->STA;
900089f6:	687b      	ldr	r3, [r7, #4]
900089f8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
900089fa:	60bb      	str	r3, [r7, #8]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
900089fc:	68bb      	ldr	r3, [r7, #8]
900089fe:	f003 0345 	and.w	r3, r3, #69	@ 0x45
90008a02:	2b00      	cmp	r3, #0
90008a04:	d0ef      	beq.n	900089e6 <SDMMC_GetCmdResp7+0x1e>
           ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
90008a06:	68bb      	ldr	r3, [r7, #8]
90008a08:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
90008a0c:	2b00      	cmp	r3, #0
90008a0e:	d1ea      	bne.n	900089e6 <SDMMC_GetCmdResp7+0x1e>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
90008a10:	687b      	ldr	r3, [r7, #4]
90008a12:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90008a14:	f003 0304 	and.w	r3, r3, #4
90008a18:	2b00      	cmp	r3, #0
90008a1a:	d004      	beq.n	90008a26 <SDMMC_GetCmdResp7+0x5e>
  {
    /* Card is not SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
90008a1c:	687b      	ldr	r3, [r7, #4]
90008a1e:	2204      	movs	r2, #4
90008a20:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
90008a22:	2304      	movs	r3, #4
90008a24:	e014      	b.n	90008a50 <SDMMC_GetCmdResp7+0x88>
  }

  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
90008a26:	687b      	ldr	r3, [r7, #4]
90008a28:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90008a2a:	f003 0301 	and.w	r3, r3, #1
90008a2e:	2b00      	cmp	r3, #0
90008a30:	d004      	beq.n	90008a3c <SDMMC_GetCmdResp7+0x74>
  {
    /* Card is not SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
90008a32:	687b      	ldr	r3, [r7, #4]
90008a34:	2201      	movs	r2, #1
90008a36:	639a      	str	r2, [r3, #56]	@ 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
90008a38:	2301      	movs	r3, #1
90008a3a:	e009      	b.n	90008a50 <SDMMC_GetCmdResp7+0x88>
  else
  {
    /* Nothing to do */
  }

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDREND))
90008a3c:	687b      	ldr	r3, [r7, #4]
90008a3e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90008a40:	f003 0340 	and.w	r3, r3, #64	@ 0x40
90008a44:	2b00      	cmp	r3, #0
90008a46:	d002      	beq.n	90008a4e <SDMMC_GetCmdResp7+0x86>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
90008a48:	687b      	ldr	r3, [r7, #4]
90008a4a:	2240      	movs	r2, #64	@ 0x40
90008a4c:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  return SDMMC_ERROR_NONE;
90008a4e:	2300      	movs	r3, #0

}
90008a50:	4618      	mov	r0, r3
90008a52:	3714      	adds	r7, #20
90008a54:	46bd      	mov	sp, r7
90008a56:	f85d 7b04 	ldr.w	r7, [sp], #4
90008a5a:	4770      	bx	lr
90008a5c:	24000074 	.word	0x24000074
90008a60:	10624dd3 	.word	0x10624dd3

90008a64 <SDMMC_GetCmdError>:
  * @brief  Checks for error conditions for CMD0.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
static uint32_t SDMMC_GetCmdError(SDMMC_TypeDef *SDMMCx)
{
90008a64:	b480      	push	{r7}
90008a66:	b085      	sub	sp, #20
90008a68:	af00      	add	r7, sp, #0
90008a6a:	6078      	str	r0, [r7, #4]
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
90008a6c:	4b11      	ldr	r3, [pc, #68]	@ (90008ab4 <SDMMC_GetCmdError+0x50>)
90008a6e:	681b      	ldr	r3, [r3, #0]
90008a70:	4a11      	ldr	r2, [pc, #68]	@ (90008ab8 <SDMMC_GetCmdError+0x54>)
90008a72:	fba2 2303 	umull	r2, r3, r2, r3
90008a76:	0a5b      	lsrs	r3, r3, #9
90008a78:	f241 3288 	movw	r2, #5000	@ 0x1388
90008a7c:	fb02 f303 	mul.w	r3, r2, r3
90008a80:	60fb      	str	r3, [r7, #12]

  do
  {
    if (count-- == 0U)
90008a82:	68fb      	ldr	r3, [r7, #12]
90008a84:	1e5a      	subs	r2, r3, #1
90008a86:	60fa      	str	r2, [r7, #12]
90008a88:	2b00      	cmp	r3, #0
90008a8a:	d102      	bne.n	90008a92 <SDMMC_GetCmdError+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
90008a8c:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
90008a90:	e009      	b.n	90008aa6 <SDMMC_GetCmdError+0x42>
    }

  } while (!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDSENT));
90008a92:	687b      	ldr	r3, [r7, #4]
90008a94:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
90008a96:	f003 0380 	and.w	r3, r3, #128	@ 0x80
90008a9a:	2b00      	cmp	r3, #0
90008a9c:	d0f1      	beq.n	90008a82 <SDMMC_GetCmdError+0x1e>

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
90008a9e:	687b      	ldr	r3, [r7, #4]
90008aa0:	4a06      	ldr	r2, [pc, #24]	@ (90008abc <SDMMC_GetCmdError+0x58>)
90008aa2:	639a      	str	r2, [r3, #56]	@ 0x38

  return SDMMC_ERROR_NONE;
90008aa4:	2300      	movs	r3, #0
}
90008aa6:	4618      	mov	r0, r3
90008aa8:	3714      	adds	r7, #20
90008aaa:	46bd      	mov	sp, r7
90008aac:	f85d 7b04 	ldr.w	r7, [sp], #4
90008ab0:	4770      	bx	lr
90008ab2:	bf00      	nop
90008ab4:	24000074 	.word	0x24000074
90008ab8:	10624dd3 	.word	0x10624dd3
90008abc:	002000c5 	.word	0x002000c5

90008ac0 <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
90008ac0:	b084      	sub	sp, #16
90008ac2:	b580      	push	{r7, lr}
90008ac4:	b084      	sub	sp, #16
90008ac6:	af00      	add	r7, sp, #0
90008ac8:	6078      	str	r0, [r7, #4]
90008aca:	f107 001c 	add.w	r0, r7, #28
90008ace:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret;
#if defined (USB_OTG_HS)
  if (USBx == USB_OTG_HS)
90008ad2:	687b      	ldr	r3, [r7, #4]
90008ad4:	4a2b      	ldr	r2, [pc, #172]	@ (90008b84 <USB_CoreInit+0xc4>)
90008ad6:	4293      	cmp	r3, r2
90008ad8:	d12f      	bne.n	90008b3a <USB_CoreInit+0x7a>
  {
    if (cfg.phy_itface == USB_OTG_HS_EMBEDDED_PHY)
90008ada:	f897 3021 	ldrb.w	r3, [r7, #33]	@ 0x21
90008ade:	2b03      	cmp	r3, #3
90008ae0:	d105      	bne.n	90008aee <USB_CoreInit+0x2e>
    {
      /* Init The UTMI Interface */
      USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS);
90008ae2:	687b      	ldr	r3, [r7, #4]
90008ae4:	68db      	ldr	r3, [r3, #12]
90008ae6:	f423 0280 	bic.w	r2, r3, #4194304	@ 0x400000
90008aea:	687b      	ldr	r3, [r7, #4]
90008aec:	60da      	str	r2, [r3, #12]
    }

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
90008aee:	6878      	ldr	r0, [r7, #4]
90008af0:	f001 fb92 	bl	9000a218 <USB_CoreReset>
90008af4:	4603      	mov	r3, r0
90008af6:	73fb      	strb	r3, [r7, #15]

    if (cfg.dma_enable == 1U)
90008af8:	7fbb      	ldrb	r3, [r7, #30]
90008afa:	2b01      	cmp	r3, #1
90008afc:	d139      	bne.n	90008b72 <USB_CoreInit+0xb2>
    {
      /* make sure to reserve 18 fifo Locations for DMA buffers */
      USBx->GDFIFOCFG &= ~(0xFFFFUL << 16);
90008afe:	687b      	ldr	r3, [r7, #4]
90008b00:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
90008b02:	b29a      	uxth	r2, r3
90008b04:	687b      	ldr	r3, [r7, #4]
90008b06:	65da      	str	r2, [r3, #92]	@ 0x5c
      USBx->GDFIFOCFG |= 0x3EEUL << 16;
90008b08:	687b      	ldr	r3, [r7, #4]
90008b0a:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
90008b0c:	4b1e      	ldr	r3, [pc, #120]	@ (90008b88 <USB_CoreInit+0xc8>)
90008b0e:	4313      	orrs	r3, r2
90008b10:	687a      	ldr	r2, [r7, #4]
90008b12:	65d3      	str	r3, [r2, #92]	@ 0x5c

      USBx->GAHBCFG &= ~(USB_OTG_GAHBCFG_HBSTLEN);
90008b14:	687b      	ldr	r3, [r7, #4]
90008b16:	689b      	ldr	r3, [r3, #8]
90008b18:	f023 021e 	bic.w	r2, r3, #30
90008b1c:	687b      	ldr	r3, [r7, #4]
90008b1e:	609a      	str	r2, [r3, #8]
      USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_INCR4;
90008b20:	687b      	ldr	r3, [r7, #4]
90008b22:	689b      	ldr	r3, [r3, #8]
90008b24:	f043 0206 	orr.w	r2, r3, #6
90008b28:	687b      	ldr	r3, [r7, #4]
90008b2a:	609a      	str	r2, [r3, #8]
      USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
90008b2c:	687b      	ldr	r3, [r7, #4]
90008b2e:	689b      	ldr	r3, [r3, #8]
90008b30:	f043 0220 	orr.w	r2, r3, #32
90008b34:	687b      	ldr	r3, [r7, #4]
90008b36:	609a      	str	r2, [r3, #8]
90008b38:	e01b      	b.n	90008b72 <USB_CoreInit+0xb2>
  }
  else
#endif /* defined (USB_OTG_HS) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
90008b3a:	687b      	ldr	r3, [r7, #4]
90008b3c:	68db      	ldr	r3, [r3, #12]
90008b3e:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
90008b42:	687b      	ldr	r3, [r7, #4]
90008b44:	60da      	str	r2, [r3, #12]

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
90008b46:	6878      	ldr	r0, [r7, #4]
90008b48:	f001 fb66 	bl	9000a218 <USB_CoreReset>
90008b4c:	4603      	mov	r3, r0
90008b4e:	73fb      	strb	r3, [r7, #15]

    if (cfg.battery_charging_enable == 0U)
90008b50:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
90008b54:	2b00      	cmp	r3, #0
90008b56:	d106      	bne.n	90008b66 <USB_CoreInit+0xa6>
    {
      /* Activate the USB Transceiver */
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
90008b58:	687b      	ldr	r3, [r7, #4]
90008b5a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90008b5c:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
90008b60:	687b      	ldr	r3, [r7, #4]
90008b62:	639a      	str	r2, [r3, #56]	@ 0x38
90008b64:	e005      	b.n	90008b72 <USB_CoreInit+0xb2>
    }
    else
    {
      /* Deactivate the USB Transceiver */
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
90008b66:	687b      	ldr	r3, [r7, #4]
90008b68:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90008b6a:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
90008b6e:	687b      	ldr	r3, [r7, #4]
90008b70:	639a      	str	r2, [r3, #56]	@ 0x38
    }
  }

  return ret;
90008b72:	7bfb      	ldrb	r3, [r7, #15]
}
90008b74:	4618      	mov	r0, r3
90008b76:	3710      	adds	r7, #16
90008b78:	46bd      	mov	sp, r7
90008b7a:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
90008b7e:	b004      	add	sp, #16
90008b80:	4770      	bx	lr
90008b82:	bf00      	nop
90008b84:	40040000 	.word	0x40040000
90008b88:	03ee0000 	.word	0x03ee0000

90008b8c <USB_SetTurnaroundTime>:
  * @param  hclk: AHB clock frequency
  * @retval USB turnaround time In PHY Clocks number
  */
HAL_StatusTypeDef USB_SetTurnaroundTime(USB_OTG_GlobalTypeDef *USBx,
                                        uint32_t hclk, uint8_t speed)
{
90008b8c:	b480      	push	{r7}
90008b8e:	b087      	sub	sp, #28
90008b90:	af00      	add	r7, sp, #0
90008b92:	60f8      	str	r0, [r7, #12]
90008b94:	60b9      	str	r1, [r7, #8]
90008b96:	4613      	mov	r3, r2
90008b98:	71fb      	strb	r3, [r7, #7]

  /* The USBTRD is configured according to the tables below, depending on AHB frequency
  used by application. In the low AHB frequency range it is used to stretch enough the USB response
  time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access
  latency to the Data FIFO */
  if (speed == USBD_FS_SPEED)
90008b9a:	79fb      	ldrb	r3, [r7, #7]
90008b9c:	2b02      	cmp	r3, #2
90008b9e:	d165      	bne.n	90008c6c <USB_SetTurnaroundTime+0xe0>
  {
    if ((hclk >= 14200000U) && (hclk < 15000000U))
90008ba0:	68bb      	ldr	r3, [r7, #8]
90008ba2:	4a41      	ldr	r2, [pc, #260]	@ (90008ca8 <USB_SetTurnaroundTime+0x11c>)
90008ba4:	4293      	cmp	r3, r2
90008ba6:	d906      	bls.n	90008bb6 <USB_SetTurnaroundTime+0x2a>
90008ba8:	68bb      	ldr	r3, [r7, #8]
90008baa:	4a40      	ldr	r2, [pc, #256]	@ (90008cac <USB_SetTurnaroundTime+0x120>)
90008bac:	4293      	cmp	r3, r2
90008bae:	d202      	bcs.n	90008bb6 <USB_SetTurnaroundTime+0x2a>
    {
      /* hclk Clock Range between 14.2-15 MHz */
      UsbTrd = 0xFU;
90008bb0:	230f      	movs	r3, #15
90008bb2:	617b      	str	r3, [r7, #20]
90008bb4:	e062      	b.n	90008c7c <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 15000000U) && (hclk < 16000000U))
90008bb6:	68bb      	ldr	r3, [r7, #8]
90008bb8:	4a3c      	ldr	r2, [pc, #240]	@ (90008cac <USB_SetTurnaroundTime+0x120>)
90008bba:	4293      	cmp	r3, r2
90008bbc:	d306      	bcc.n	90008bcc <USB_SetTurnaroundTime+0x40>
90008bbe:	68bb      	ldr	r3, [r7, #8]
90008bc0:	4a3b      	ldr	r2, [pc, #236]	@ (90008cb0 <USB_SetTurnaroundTime+0x124>)
90008bc2:	4293      	cmp	r3, r2
90008bc4:	d202      	bcs.n	90008bcc <USB_SetTurnaroundTime+0x40>
    {
      /* hclk Clock Range between 15-16 MHz */
      UsbTrd = 0xEU;
90008bc6:	230e      	movs	r3, #14
90008bc8:	617b      	str	r3, [r7, #20]
90008bca:	e057      	b.n	90008c7c <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 16000000U) && (hclk < 17200000U))
90008bcc:	68bb      	ldr	r3, [r7, #8]
90008bce:	4a38      	ldr	r2, [pc, #224]	@ (90008cb0 <USB_SetTurnaroundTime+0x124>)
90008bd0:	4293      	cmp	r3, r2
90008bd2:	d306      	bcc.n	90008be2 <USB_SetTurnaroundTime+0x56>
90008bd4:	68bb      	ldr	r3, [r7, #8]
90008bd6:	4a37      	ldr	r2, [pc, #220]	@ (90008cb4 <USB_SetTurnaroundTime+0x128>)
90008bd8:	4293      	cmp	r3, r2
90008bda:	d202      	bcs.n	90008be2 <USB_SetTurnaroundTime+0x56>
    {
      /* hclk Clock Range between 16-17.2 MHz */
      UsbTrd = 0xDU;
90008bdc:	230d      	movs	r3, #13
90008bde:	617b      	str	r3, [r7, #20]
90008be0:	e04c      	b.n	90008c7c <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 17200000U) && (hclk < 18500000U))
90008be2:	68bb      	ldr	r3, [r7, #8]
90008be4:	4a33      	ldr	r2, [pc, #204]	@ (90008cb4 <USB_SetTurnaroundTime+0x128>)
90008be6:	4293      	cmp	r3, r2
90008be8:	d306      	bcc.n	90008bf8 <USB_SetTurnaroundTime+0x6c>
90008bea:	68bb      	ldr	r3, [r7, #8]
90008bec:	4a32      	ldr	r2, [pc, #200]	@ (90008cb8 <USB_SetTurnaroundTime+0x12c>)
90008bee:	4293      	cmp	r3, r2
90008bf0:	d802      	bhi.n	90008bf8 <USB_SetTurnaroundTime+0x6c>
    {
      /* hclk Clock Range between 17.2-18.5 MHz */
      UsbTrd = 0xCU;
90008bf2:	230c      	movs	r3, #12
90008bf4:	617b      	str	r3, [r7, #20]
90008bf6:	e041      	b.n	90008c7c <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 18500000U) && (hclk < 20000000U))
90008bf8:	68bb      	ldr	r3, [r7, #8]
90008bfa:	4a2f      	ldr	r2, [pc, #188]	@ (90008cb8 <USB_SetTurnaroundTime+0x12c>)
90008bfc:	4293      	cmp	r3, r2
90008bfe:	d906      	bls.n	90008c0e <USB_SetTurnaroundTime+0x82>
90008c00:	68bb      	ldr	r3, [r7, #8]
90008c02:	4a2e      	ldr	r2, [pc, #184]	@ (90008cbc <USB_SetTurnaroundTime+0x130>)
90008c04:	4293      	cmp	r3, r2
90008c06:	d802      	bhi.n	90008c0e <USB_SetTurnaroundTime+0x82>
    {
      /* hclk Clock Range between 18.5-20 MHz */
      UsbTrd = 0xBU;
90008c08:	230b      	movs	r3, #11
90008c0a:	617b      	str	r3, [r7, #20]
90008c0c:	e036      	b.n	90008c7c <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 20000000U) && (hclk < 21800000U))
90008c0e:	68bb      	ldr	r3, [r7, #8]
90008c10:	4a2a      	ldr	r2, [pc, #168]	@ (90008cbc <USB_SetTurnaroundTime+0x130>)
90008c12:	4293      	cmp	r3, r2
90008c14:	d906      	bls.n	90008c24 <USB_SetTurnaroundTime+0x98>
90008c16:	68bb      	ldr	r3, [r7, #8]
90008c18:	4a29      	ldr	r2, [pc, #164]	@ (90008cc0 <USB_SetTurnaroundTime+0x134>)
90008c1a:	4293      	cmp	r3, r2
90008c1c:	d802      	bhi.n	90008c24 <USB_SetTurnaroundTime+0x98>
    {
      /* hclk Clock Range between 20-21.8 MHz */
      UsbTrd = 0xAU;
90008c1e:	230a      	movs	r3, #10
90008c20:	617b      	str	r3, [r7, #20]
90008c22:	e02b      	b.n	90008c7c <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 21800000U) && (hclk < 24000000U))
90008c24:	68bb      	ldr	r3, [r7, #8]
90008c26:	4a26      	ldr	r2, [pc, #152]	@ (90008cc0 <USB_SetTurnaroundTime+0x134>)
90008c28:	4293      	cmp	r3, r2
90008c2a:	d906      	bls.n	90008c3a <USB_SetTurnaroundTime+0xae>
90008c2c:	68bb      	ldr	r3, [r7, #8]
90008c2e:	4a25      	ldr	r2, [pc, #148]	@ (90008cc4 <USB_SetTurnaroundTime+0x138>)
90008c30:	4293      	cmp	r3, r2
90008c32:	d202      	bcs.n	90008c3a <USB_SetTurnaroundTime+0xae>
    {
      /* hclk Clock Range between 21.8-24 MHz */
      UsbTrd = 0x9U;
90008c34:	2309      	movs	r3, #9
90008c36:	617b      	str	r3, [r7, #20]
90008c38:	e020      	b.n	90008c7c <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 24000000U) && (hclk < 27700000U))
90008c3a:	68bb      	ldr	r3, [r7, #8]
90008c3c:	4a21      	ldr	r2, [pc, #132]	@ (90008cc4 <USB_SetTurnaroundTime+0x138>)
90008c3e:	4293      	cmp	r3, r2
90008c40:	d306      	bcc.n	90008c50 <USB_SetTurnaroundTime+0xc4>
90008c42:	68bb      	ldr	r3, [r7, #8]
90008c44:	4a20      	ldr	r2, [pc, #128]	@ (90008cc8 <USB_SetTurnaroundTime+0x13c>)
90008c46:	4293      	cmp	r3, r2
90008c48:	d802      	bhi.n	90008c50 <USB_SetTurnaroundTime+0xc4>
    {
      /* hclk Clock Range between 24-27.7 MHz */
      UsbTrd = 0x8U;
90008c4a:	2308      	movs	r3, #8
90008c4c:	617b      	str	r3, [r7, #20]
90008c4e:	e015      	b.n	90008c7c <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 27700000U) && (hclk < 32000000U))
90008c50:	68bb      	ldr	r3, [r7, #8]
90008c52:	4a1d      	ldr	r2, [pc, #116]	@ (90008cc8 <USB_SetTurnaroundTime+0x13c>)
90008c54:	4293      	cmp	r3, r2
90008c56:	d906      	bls.n	90008c66 <USB_SetTurnaroundTime+0xda>
90008c58:	68bb      	ldr	r3, [r7, #8]
90008c5a:	4a1c      	ldr	r2, [pc, #112]	@ (90008ccc <USB_SetTurnaroundTime+0x140>)
90008c5c:	4293      	cmp	r3, r2
90008c5e:	d202      	bcs.n	90008c66 <USB_SetTurnaroundTime+0xda>
    {
      /* hclk Clock Range between 27.7-32 MHz */
      UsbTrd = 0x7U;
90008c60:	2307      	movs	r3, #7
90008c62:	617b      	str	r3, [r7, #20]
90008c64:	e00a      	b.n	90008c7c <USB_SetTurnaroundTime+0xf0>
    }
    else /* if(hclk >= 32000000) */
    {
      /* hclk Clock Range between 32-200 MHz */
      UsbTrd = 0x6U;
90008c66:	2306      	movs	r3, #6
90008c68:	617b      	str	r3, [r7, #20]
90008c6a:	e007      	b.n	90008c7c <USB_SetTurnaroundTime+0xf0>
    }
  }
  else if (speed == USBD_HS_SPEED)
90008c6c:	79fb      	ldrb	r3, [r7, #7]
90008c6e:	2b00      	cmp	r3, #0
90008c70:	d102      	bne.n	90008c78 <USB_SetTurnaroundTime+0xec>
  {
    UsbTrd = USBD_HS_TRDT_VALUE;
90008c72:	2309      	movs	r3, #9
90008c74:	617b      	str	r3, [r7, #20]
90008c76:	e001      	b.n	90008c7c <USB_SetTurnaroundTime+0xf0>
  }
  else
  {
    UsbTrd = USBD_DEFAULT_TRDT_VALUE;
90008c78:	2309      	movs	r3, #9
90008c7a:	617b      	str	r3, [r7, #20]
  }

  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
90008c7c:	68fb      	ldr	r3, [r7, #12]
90008c7e:	68db      	ldr	r3, [r3, #12]
90008c80:	f423 5270 	bic.w	r2, r3, #15360	@ 0x3c00
90008c84:	68fb      	ldr	r3, [r7, #12]
90008c86:	60da      	str	r2, [r3, #12]
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
90008c88:	68fb      	ldr	r3, [r7, #12]
90008c8a:	68da      	ldr	r2, [r3, #12]
90008c8c:	697b      	ldr	r3, [r7, #20]
90008c8e:	029b      	lsls	r3, r3, #10
90008c90:	f403 5370 	and.w	r3, r3, #15360	@ 0x3c00
90008c94:	431a      	orrs	r2, r3
90008c96:	68fb      	ldr	r3, [r7, #12]
90008c98:	60da      	str	r2, [r3, #12]

  return HAL_OK;
90008c9a:	2300      	movs	r3, #0
}
90008c9c:	4618      	mov	r0, r3
90008c9e:	371c      	adds	r7, #28
90008ca0:	46bd      	mov	sp, r7
90008ca2:	f85d 7b04 	ldr.w	r7, [sp], #4
90008ca6:	4770      	bx	lr
90008ca8:	00d8acbf 	.word	0x00d8acbf
90008cac:	00e4e1c0 	.word	0x00e4e1c0
90008cb0:	00f42400 	.word	0x00f42400
90008cb4:	01067380 	.word	0x01067380
90008cb8:	011a499f 	.word	0x011a499f
90008cbc:	01312cff 	.word	0x01312cff
90008cc0:	014ca43f 	.word	0x014ca43f
90008cc4:	016e3600 	.word	0x016e3600
90008cc8:	01a6ab1f 	.word	0x01a6ab1f
90008ccc:	01e84800 	.word	0x01e84800

90008cd0 <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
90008cd0:	b480      	push	{r7}
90008cd2:	b083      	sub	sp, #12
90008cd4:	af00      	add	r7, sp, #0
90008cd6:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
90008cd8:	687b      	ldr	r3, [r7, #4]
90008cda:	689b      	ldr	r3, [r3, #8]
90008cdc:	f043 0201 	orr.w	r2, r3, #1
90008ce0:	687b      	ldr	r3, [r7, #4]
90008ce2:	609a      	str	r2, [r3, #8]
  return HAL_OK;
90008ce4:	2300      	movs	r3, #0
}
90008ce6:	4618      	mov	r0, r3
90008ce8:	370c      	adds	r7, #12
90008cea:	46bd      	mov	sp, r7
90008cec:	f85d 7b04 	ldr.w	r7, [sp], #4
90008cf0:	4770      	bx	lr

90008cf2 <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
90008cf2:	b480      	push	{r7}
90008cf4:	b083      	sub	sp, #12
90008cf6:	af00      	add	r7, sp, #0
90008cf8:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
90008cfa:	687b      	ldr	r3, [r7, #4]
90008cfc:	689b      	ldr	r3, [r3, #8]
90008cfe:	f023 0201 	bic.w	r2, r3, #1
90008d02:	687b      	ldr	r3, [r7, #4]
90008d04:	609a      	str	r2, [r3, #8]
  return HAL_OK;
90008d06:	2300      	movs	r3, #0
}
90008d08:	4618      	mov	r0, r3
90008d0a:	370c      	adds	r7, #12
90008d0c:	46bd      	mov	sp, r7
90008d0e:	f85d 7b04 	ldr.w	r7, [sp], #4
90008d12:	4770      	bx	lr

90008d14 <USB_SetCurrentMode>:
  *            @arg USB_DEVICE_MODE Peripheral mode
  *            @arg USB_HOST_MODE Host mode
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx, USB_OTG_ModeTypeDef mode)
{
90008d14:	b580      	push	{r7, lr}
90008d16:	b084      	sub	sp, #16
90008d18:	af00      	add	r7, sp, #0
90008d1a:	6078      	str	r0, [r7, #4]
90008d1c:	460b      	mov	r3, r1
90008d1e:	70fb      	strb	r3, [r7, #3]
  uint32_t ms = 0U;
90008d20:	2300      	movs	r3, #0
90008d22:	60fb      	str	r3, [r7, #12]

  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
90008d24:	687b      	ldr	r3, [r7, #4]
90008d26:	68db      	ldr	r3, [r3, #12]
90008d28:	f023 42c0 	bic.w	r2, r3, #1610612736	@ 0x60000000
90008d2c:	687b      	ldr	r3, [r7, #4]
90008d2e:	60da      	str	r2, [r3, #12]

  if (mode == USB_HOST_MODE)
90008d30:	78fb      	ldrb	r3, [r7, #3]
90008d32:	2b01      	cmp	r3, #1
90008d34:	d115      	bne.n	90008d62 <USB_SetCurrentMode+0x4e>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
90008d36:	687b      	ldr	r3, [r7, #4]
90008d38:	68db      	ldr	r3, [r3, #12]
90008d3a:	f043 5200 	orr.w	r2, r3, #536870912	@ 0x20000000
90008d3e:	687b      	ldr	r3, [r7, #4]
90008d40:	60da      	str	r2, [r3, #12]

    do
    {
      HAL_Delay(10U);
90008d42:	200a      	movs	r0, #10
90008d44:	f7f8 fcca 	bl	900016dc <HAL_Delay>
      ms += 10U;
90008d48:	68fb      	ldr	r3, [r7, #12]
90008d4a:	330a      	adds	r3, #10
90008d4c:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
90008d4e:	6878      	ldr	r0, [r7, #4]
90008d50:	f001 f9d2 	bl	9000a0f8 <USB_GetMode>
90008d54:	4603      	mov	r3, r0
90008d56:	2b01      	cmp	r3, #1
90008d58:	d01e      	beq.n	90008d98 <USB_SetCurrentMode+0x84>
90008d5a:	68fb      	ldr	r3, [r7, #12]
90008d5c:	2bc7      	cmp	r3, #199	@ 0xc7
90008d5e:	d9f0      	bls.n	90008d42 <USB_SetCurrentMode+0x2e>
90008d60:	e01a      	b.n	90008d98 <USB_SetCurrentMode+0x84>
  }
  else if (mode == USB_DEVICE_MODE)
90008d62:	78fb      	ldrb	r3, [r7, #3]
90008d64:	2b00      	cmp	r3, #0
90008d66:	d115      	bne.n	90008d94 <USB_SetCurrentMode+0x80>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
90008d68:	687b      	ldr	r3, [r7, #4]
90008d6a:	68db      	ldr	r3, [r3, #12]
90008d6c:	f043 4280 	orr.w	r2, r3, #1073741824	@ 0x40000000
90008d70:	687b      	ldr	r3, [r7, #4]
90008d72:	60da      	str	r2, [r3, #12]

    do
    {
      HAL_Delay(10U);
90008d74:	200a      	movs	r0, #10
90008d76:	f7f8 fcb1 	bl	900016dc <HAL_Delay>
      ms += 10U;
90008d7a:	68fb      	ldr	r3, [r7, #12]
90008d7c:	330a      	adds	r3, #10
90008d7e:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
90008d80:	6878      	ldr	r0, [r7, #4]
90008d82:	f001 f9b9 	bl	9000a0f8 <USB_GetMode>
90008d86:	4603      	mov	r3, r0
90008d88:	2b00      	cmp	r3, #0
90008d8a:	d005      	beq.n	90008d98 <USB_SetCurrentMode+0x84>
90008d8c:	68fb      	ldr	r3, [r7, #12]
90008d8e:	2bc7      	cmp	r3, #199	@ 0xc7
90008d90:	d9f0      	bls.n	90008d74 <USB_SetCurrentMode+0x60>
90008d92:	e001      	b.n	90008d98 <USB_SetCurrentMode+0x84>
  }
  else
  {
    return HAL_ERROR;
90008d94:	2301      	movs	r3, #1
90008d96:	e005      	b.n	90008da4 <USB_SetCurrentMode+0x90>
  }

  if (ms == HAL_USB_CURRENT_MODE_MAX_DELAY_MS)
90008d98:	68fb      	ldr	r3, [r7, #12]
90008d9a:	2bc8      	cmp	r3, #200	@ 0xc8
90008d9c:	d101      	bne.n	90008da2 <USB_SetCurrentMode+0x8e>
  {
    return HAL_ERROR;
90008d9e:	2301      	movs	r3, #1
90008da0:	e000      	b.n	90008da4 <USB_SetCurrentMode+0x90>
  }

  return HAL_OK;
90008da2:	2300      	movs	r3, #0
}
90008da4:	4618      	mov	r0, r3
90008da6:	3710      	adds	r7, #16
90008da8:	46bd      	mov	sp, r7
90008daa:	bd80      	pop	{r7, pc}

90008dac <USB_DevInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
90008dac:	b084      	sub	sp, #16
90008dae:	b580      	push	{r7, lr}
90008db0:	b086      	sub	sp, #24
90008db2:	af00      	add	r7, sp, #0
90008db4:	6078      	str	r0, [r7, #4]
90008db6:	f107 0024 	add.w	r0, r7, #36	@ 0x24
90008dba:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret = HAL_OK;
90008dbe:	2300      	movs	r3, #0
90008dc0:	75fb      	strb	r3, [r7, #23]
  uint32_t USBx_BASE = (uint32_t)USBx;
90008dc2:	687b      	ldr	r3, [r7, #4]
90008dc4:	60fb      	str	r3, [r7, #12]
  uint32_t i;

  for (i = 0U; i < 15U; i++)
90008dc6:	2300      	movs	r3, #0
90008dc8:	613b      	str	r3, [r7, #16]
90008dca:	e009      	b.n	90008de0 <USB_DevInit+0x34>
  {
    USBx->DIEPTXF[i] = 0U;
90008dcc:	687a      	ldr	r2, [r7, #4]
90008dce:	693b      	ldr	r3, [r7, #16]
90008dd0:	3340      	adds	r3, #64	@ 0x40
90008dd2:	009b      	lsls	r3, r3, #2
90008dd4:	4413      	add	r3, r2
90008dd6:	2200      	movs	r2, #0
90008dd8:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < 15U; i++)
90008dda:	693b      	ldr	r3, [r7, #16]
90008ddc:	3301      	adds	r3, #1
90008dde:	613b      	str	r3, [r7, #16]
90008de0:	693b      	ldr	r3, [r7, #16]
90008de2:	2b0e      	cmp	r3, #14
90008de4:	d9f2      	bls.n	90008dcc <USB_DevInit+0x20>
  }

  if ((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) == 0U)
90008de6:	687b      	ldr	r3, [r7, #4]
90008de8:	68db      	ldr	r3, [r3, #12]
90008dea:	f003 0340 	and.w	r3, r3, #64	@ 0x40
90008dee:	2b00      	cmp	r3, #0
90008df0:	d105      	bne.n	90008dfe <USB_DevInit+0x52>
  {
    /* Disable USB PHY pulldown resistors */
    USBx->GCCFG &= ~USB_OTG_GCCFG_PULLDOWNEN;
90008df2:	687b      	ldr	r3, [r7, #4]
90008df4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90008df6:	f023 7200 	bic.w	r2, r3, #33554432	@ 0x2000000
90008dfa:	687b      	ldr	r3, [r7, #4]
90008dfc:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  /* VBUS Sensing setup */
  if (cfg.vbus_sensing_enable == 0U)
90008dfe:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
90008e02:	2b00      	cmp	r3, #0
90008e04:	d12f      	bne.n	90008e66 <USB_DevInit+0xba>
  {
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
90008e06:	68fb      	ldr	r3, [r7, #12]
90008e08:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90008e0c:	685b      	ldr	r3, [r3, #4]
90008e0e:	68fa      	ldr	r2, [r7, #12]
90008e10:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
90008e14:	f043 0302 	orr.w	r3, r3, #2
90008e18:	6053      	str	r3, [r2, #4]

    /* Deactivate VBUS Sensing B */
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBDEN;
90008e1a:	687b      	ldr	r3, [r7, #4]
90008e1c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90008e1e:	f423 1200 	bic.w	r2, r3, #2097152	@ 0x200000
90008e22:	687b      	ldr	r3, [r7, #4]
90008e24:	639a      	str	r2, [r3, #56]	@ 0x38

    /* B-peripheral session valid override enable */
    if ((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) != 0U)
90008e26:	687b      	ldr	r3, [r7, #4]
90008e28:	68db      	ldr	r3, [r3, #12]
90008e2a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
90008e2e:	2b00      	cmp	r3, #0
90008e30:	d00c      	beq.n	90008e4c <USB_DevInit+0xa0>
    {
      USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
90008e32:	687b      	ldr	r3, [r7, #4]
90008e34:	681b      	ldr	r3, [r3, #0]
90008e36:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
90008e3a:	687b      	ldr	r3, [r7, #4]
90008e3c:	601a      	str	r2, [r3, #0]
      USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
90008e3e:	687b      	ldr	r3, [r7, #4]
90008e40:	681b      	ldr	r3, [r3, #0]
90008e42:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
90008e46:	687b      	ldr	r3, [r7, #4]
90008e48:	601a      	str	r2, [r3, #0]
90008e4a:	e031      	b.n	90008eb0 <USB_DevInit+0x104>
    }
    else
    {
      USBx->GCCFG |= USB_OTG_GCCFG_VBVALEXTOEN;
90008e4c:	687b      	ldr	r3, [r7, #4]
90008e4e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90008e50:	f043 7280 	orr.w	r2, r3, #16777216	@ 0x1000000
90008e54:	687b      	ldr	r3, [r7, #4]
90008e56:	639a      	str	r2, [r3, #56]	@ 0x38
      USBx->GCCFG |= USB_OTG_GCCFG_VBVALOVAL;
90008e58:	687b      	ldr	r3, [r7, #4]
90008e5a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90008e5c:	f443 0200 	orr.w	r2, r3, #8388608	@ 0x800000
90008e60:	687b      	ldr	r3, [r7, #4]
90008e62:	639a      	str	r2, [r3, #56]	@ 0x38
90008e64:	e024      	b.n	90008eb0 <USB_DevInit+0x104>
    }
  }
  else
  {
    /* B-peripheral session valid override disable */
    if ((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) != 0U)
90008e66:	687b      	ldr	r3, [r7, #4]
90008e68:	68db      	ldr	r3, [r3, #12]
90008e6a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
90008e6e:	2b00      	cmp	r3, #0
90008e70:	d00c      	beq.n	90008e8c <USB_DevInit+0xe0>
    {
      USBx->GOTGCTL &= ~USB_OTG_GOTGCTL_BVALOEN;
90008e72:	687b      	ldr	r3, [r7, #4]
90008e74:	681b      	ldr	r3, [r3, #0]
90008e76:	f023 0240 	bic.w	r2, r3, #64	@ 0x40
90008e7a:	687b      	ldr	r3, [r7, #4]
90008e7c:	601a      	str	r2, [r3, #0]
      USBx->GOTGCTL &= ~USB_OTG_GOTGCTL_BVALOVAL;
90008e7e:	687b      	ldr	r3, [r7, #4]
90008e80:	681b      	ldr	r3, [r3, #0]
90008e82:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
90008e86:	687b      	ldr	r3, [r7, #4]
90008e88:	601a      	str	r2, [r3, #0]
90008e8a:	e00b      	b.n	90008ea4 <USB_DevInit+0xf8>
    }
    else
    {
      USBx->GCCFG &= ~USB_OTG_GCCFG_VBVALEXTOEN;
90008e8c:	687b      	ldr	r3, [r7, #4]
90008e8e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90008e90:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
90008e94:	687b      	ldr	r3, [r7, #4]
90008e96:	639a      	str	r2, [r3, #56]	@ 0x38
      USBx->GCCFG &= ~USB_OTG_GCCFG_VBVALOVAL;
90008e98:	687b      	ldr	r3, [r7, #4]
90008e9a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90008e9c:	f423 0200 	bic.w	r2, r3, #8388608	@ 0x800000
90008ea0:	687b      	ldr	r3, [r7, #4]
90008ea2:	639a      	str	r2, [r3, #56]	@ 0x38
    }

    /* Enable HW VBUS sensing */
    USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
90008ea4:	687b      	ldr	r3, [r7, #4]
90008ea6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
90008ea8:	f443 1200 	orr.w	r2, r3, #2097152	@ 0x200000
90008eac:	687b      	ldr	r3, [r7, #4]
90008eae:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
90008eb0:	68fb      	ldr	r3, [r7, #12]
90008eb2:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
90008eb6:	461a      	mov	r2, r3
90008eb8:	2300      	movs	r3, #0
90008eba:	6013      	str	r3, [r2, #0]

  if ((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) == 0U)
90008ebc:	687b      	ldr	r3, [r7, #4]
90008ebe:	68db      	ldr	r3, [r3, #12]
90008ec0:	f003 0340 	and.w	r3, r3, #64	@ 0x40
90008ec4:	2b00      	cmp	r3, #0
90008ec6:	d10d      	bne.n	90008ee4 <USB_DevInit+0x138>
  {
    if (cfg.speed == USBD_HS_SPEED)
90008ec8:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
90008ecc:	2b00      	cmp	r3, #0
90008ece:	d104      	bne.n	90008eda <USB_DevInit+0x12e>
    {
      /* Set Core speed to High speed mode */
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH);
90008ed0:	2100      	movs	r1, #0
90008ed2:	6878      	ldr	r0, [r7, #4]
90008ed4:	f000 f968 	bl	900091a8 <USB_SetDevSpeed>
90008ed8:	e008      	b.n	90008eec <USB_DevInit+0x140>
    }
    else
    {
      /* Set Core speed to Full speed mode */
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH_IN_FULL);
90008eda:	2101      	movs	r1, #1
90008edc:	6878      	ldr	r0, [r7, #4]
90008ede:	f000 f963 	bl	900091a8 <USB_SetDevSpeed>
90008ee2:	e003      	b.n	90008eec <USB_DevInit+0x140>
    }
  }
  else
  {
    /* Set Core speed to Full speed mode */
    (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_FULL);
90008ee4:	2103      	movs	r1, #3
90008ee6:	6878      	ldr	r0, [r7, #4]
90008ee8:	f000 f95e 	bl	900091a8 <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
90008eec:	2110      	movs	r1, #16
90008eee:	6878      	ldr	r0, [r7, #4]
90008ef0:	f000 f8fa 	bl	900090e8 <USB_FlushTxFifo>
90008ef4:	4603      	mov	r3, r0
90008ef6:	2b00      	cmp	r3, #0
90008ef8:	d001      	beq.n	90008efe <USB_DevInit+0x152>
  {
    ret = HAL_ERROR;
90008efa:	2301      	movs	r3, #1
90008efc:	75fb      	strb	r3, [r7, #23]
  }

  if (USB_FlushRxFifo(USBx) != HAL_OK)
90008efe:	6878      	ldr	r0, [r7, #4]
90008f00:	f000 f924 	bl	9000914c <USB_FlushRxFifo>
90008f04:	4603      	mov	r3, r0
90008f06:	2b00      	cmp	r3, #0
90008f08:	d001      	beq.n	90008f0e <USB_DevInit+0x162>
  {
    ret = HAL_ERROR;
90008f0a:	2301      	movs	r3, #1
90008f0c:	75fb      	strb	r3, [r7, #23]
  }

  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
90008f0e:	68fb      	ldr	r3, [r7, #12]
90008f10:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90008f14:	461a      	mov	r2, r3
90008f16:	2300      	movs	r3, #0
90008f18:	6113      	str	r3, [r2, #16]
  USBx_DEVICE->DOEPMSK = 0U;
90008f1a:	68fb      	ldr	r3, [r7, #12]
90008f1c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90008f20:	461a      	mov	r2, r3
90008f22:	2300      	movs	r3, #0
90008f24:	6153      	str	r3, [r2, #20]
  USBx_DEVICE->DAINTMSK = 0U;
90008f26:	68fb      	ldr	r3, [r7, #12]
90008f28:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90008f2c:	461a      	mov	r2, r3
90008f2e:	2300      	movs	r3, #0
90008f30:	61d3      	str	r3, [r2, #28]

  for (i = 0U; i < cfg.dev_endpoints; i++)
90008f32:	2300      	movs	r3, #0
90008f34:	613b      	str	r3, [r7, #16]
90008f36:	e043      	b.n	90008fc0 <USB_DevInit+0x214>
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
90008f38:	693b      	ldr	r3, [r7, #16]
90008f3a:	015a      	lsls	r2, r3, #5
90008f3c:	68fb      	ldr	r3, [r7, #12]
90008f3e:	4413      	add	r3, r2
90008f40:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90008f44:	681b      	ldr	r3, [r3, #0]
90008f46:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
90008f4a:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
90008f4e:	d118      	bne.n	90008f82 <USB_DevInit+0x1d6>
    {
      if (i == 0U)
90008f50:	693b      	ldr	r3, [r7, #16]
90008f52:	2b00      	cmp	r3, #0
90008f54:	d10a      	bne.n	90008f6c <USB_DevInit+0x1c0>
      {
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
90008f56:	693b      	ldr	r3, [r7, #16]
90008f58:	015a      	lsls	r2, r3, #5
90008f5a:	68fb      	ldr	r3, [r7, #12]
90008f5c:	4413      	add	r3, r2
90008f5e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90008f62:	461a      	mov	r2, r3
90008f64:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
90008f68:	6013      	str	r3, [r2, #0]
90008f6a:	e013      	b.n	90008f94 <USB_DevInit+0x1e8>
      }
      else
      {
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
90008f6c:	693b      	ldr	r3, [r7, #16]
90008f6e:	015a      	lsls	r2, r3, #5
90008f70:	68fb      	ldr	r3, [r7, #12]
90008f72:	4413      	add	r3, r2
90008f74:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90008f78:	461a      	mov	r2, r3
90008f7a:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
90008f7e:	6013      	str	r3, [r2, #0]
90008f80:	e008      	b.n	90008f94 <USB_DevInit+0x1e8>
      }
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
90008f82:	693b      	ldr	r3, [r7, #16]
90008f84:	015a      	lsls	r2, r3, #5
90008f86:	68fb      	ldr	r3, [r7, #12]
90008f88:	4413      	add	r3, r2
90008f8a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90008f8e:	461a      	mov	r2, r3
90008f90:	2300      	movs	r3, #0
90008f92:	6013      	str	r3, [r2, #0]
    }

    USBx_INEP(i)->DIEPTSIZ = 0U;
90008f94:	693b      	ldr	r3, [r7, #16]
90008f96:	015a      	lsls	r2, r3, #5
90008f98:	68fb      	ldr	r3, [r7, #12]
90008f9a:	4413      	add	r3, r2
90008f9c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90008fa0:	461a      	mov	r2, r3
90008fa2:	2300      	movs	r3, #0
90008fa4:	6113      	str	r3, [r2, #16]
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
90008fa6:	693b      	ldr	r3, [r7, #16]
90008fa8:	015a      	lsls	r2, r3, #5
90008faa:	68fb      	ldr	r3, [r7, #12]
90008fac:	4413      	add	r3, r2
90008fae:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90008fb2:	461a      	mov	r2, r3
90008fb4:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
90008fb8:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
90008fba:	693b      	ldr	r3, [r7, #16]
90008fbc:	3301      	adds	r3, #1
90008fbe:	613b      	str	r3, [r7, #16]
90008fc0:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
90008fc4:	461a      	mov	r2, r3
90008fc6:	693b      	ldr	r3, [r7, #16]
90008fc8:	4293      	cmp	r3, r2
90008fca:	d3b5      	bcc.n	90008f38 <USB_DevInit+0x18c>
  }

  for (i = 0U; i < cfg.dev_endpoints; i++)
90008fcc:	2300      	movs	r3, #0
90008fce:	613b      	str	r3, [r7, #16]
90008fd0:	e043      	b.n	9000905a <USB_DevInit+0x2ae>
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
90008fd2:	693b      	ldr	r3, [r7, #16]
90008fd4:	015a      	lsls	r2, r3, #5
90008fd6:	68fb      	ldr	r3, [r7, #12]
90008fd8:	4413      	add	r3, r2
90008fda:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90008fde:	681b      	ldr	r3, [r3, #0]
90008fe0:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
90008fe4:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
90008fe8:	d118      	bne.n	9000901c <USB_DevInit+0x270>
    {
      if (i == 0U)
90008fea:	693b      	ldr	r3, [r7, #16]
90008fec:	2b00      	cmp	r3, #0
90008fee:	d10a      	bne.n	90009006 <USB_DevInit+0x25a>
      {
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
90008ff0:	693b      	ldr	r3, [r7, #16]
90008ff2:	015a      	lsls	r2, r3, #5
90008ff4:	68fb      	ldr	r3, [r7, #12]
90008ff6:	4413      	add	r3, r2
90008ff8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90008ffc:	461a      	mov	r2, r3
90008ffe:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
90009002:	6013      	str	r3, [r2, #0]
90009004:	e013      	b.n	9000902e <USB_DevInit+0x282>
      }
      else
      {
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
90009006:	693b      	ldr	r3, [r7, #16]
90009008:	015a      	lsls	r2, r3, #5
9000900a:	68fb      	ldr	r3, [r7, #12]
9000900c:	4413      	add	r3, r2
9000900e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009012:	461a      	mov	r2, r3
90009014:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
90009018:	6013      	str	r3, [r2, #0]
9000901a:	e008      	b.n	9000902e <USB_DevInit+0x282>
      }
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
9000901c:	693b      	ldr	r3, [r7, #16]
9000901e:	015a      	lsls	r2, r3, #5
90009020:	68fb      	ldr	r3, [r7, #12]
90009022:	4413      	add	r3, r2
90009024:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009028:	461a      	mov	r2, r3
9000902a:	2300      	movs	r3, #0
9000902c:	6013      	str	r3, [r2, #0]
    }

    USBx_OUTEP(i)->DOEPTSIZ = 0U;
9000902e:	693b      	ldr	r3, [r7, #16]
90009030:	015a      	lsls	r2, r3, #5
90009032:	68fb      	ldr	r3, [r7, #12]
90009034:	4413      	add	r3, r2
90009036:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
9000903a:	461a      	mov	r2, r3
9000903c:	2300      	movs	r3, #0
9000903e:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
90009040:	693b      	ldr	r3, [r7, #16]
90009042:	015a      	lsls	r2, r3, #5
90009044:	68fb      	ldr	r3, [r7, #12]
90009046:	4413      	add	r3, r2
90009048:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
9000904c:	461a      	mov	r2, r3
9000904e:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
90009052:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
90009054:	693b      	ldr	r3, [r7, #16]
90009056:	3301      	adds	r3, #1
90009058:	613b      	str	r3, [r7, #16]
9000905a:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
9000905e:	461a      	mov	r2, r3
90009060:	693b      	ldr	r3, [r7, #16]
90009062:	4293      	cmp	r3, r2
90009064:	d3b5      	bcc.n	90008fd2 <USB_DevInit+0x226>
  }

  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
90009066:	68fb      	ldr	r3, [r7, #12]
90009068:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
9000906c:	691b      	ldr	r3, [r3, #16]
9000906e:	68fa      	ldr	r2, [r7, #12]
90009070:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
90009074:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
90009078:	6113      	str	r3, [r2, #16]

  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
9000907a:	687b      	ldr	r3, [r7, #4]
9000907c:	2200      	movs	r2, #0
9000907e:	619a      	str	r2, [r3, #24]

  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
90009080:	687b      	ldr	r3, [r7, #4]
90009082:	f06f 4280 	mvn.w	r2, #1073741824	@ 0x40000000
90009086:	615a      	str	r2, [r3, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == 0U)
90009088:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
9000908c:	2b00      	cmp	r3, #0
9000908e:	d105      	bne.n	9000909c <USB_DevInit+0x2f0>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
90009090:	687b      	ldr	r3, [r7, #4]
90009092:	699b      	ldr	r3, [r3, #24]
90009094:	f043 0210 	orr.w	r2, r3, #16
90009098:	687b      	ldr	r3, [r7, #4]
9000909a:	619a      	str	r2, [r3, #24]
  }

  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
9000909c:	687b      	ldr	r3, [r7, #4]
9000909e:	699a      	ldr	r2, [r3, #24]
900090a0:	4b0f      	ldr	r3, [pc, #60]	@ (900090e0 <USB_DevInit+0x334>)
900090a2:	4313      	orrs	r3, r2
900090a4:	687a      	ldr	r2, [r7, #4]
900090a6:	6193      	str	r3, [r2, #24]
                   USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |
                   USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM |
                   USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM;

  if (cfg.Sof_enable != 0U)
900090a8:	f897 302a 	ldrb.w	r3, [r7, #42]	@ 0x2a
900090ac:	2b00      	cmp	r3, #0
900090ae:	d005      	beq.n	900090bc <USB_DevInit+0x310>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
900090b0:	687b      	ldr	r3, [r7, #4]
900090b2:	699b      	ldr	r3, [r3, #24]
900090b4:	f043 0208 	orr.w	r2, r3, #8
900090b8:	687b      	ldr	r3, [r7, #4]
900090ba:	619a      	str	r2, [r3, #24]
  }

  if (cfg.vbus_sensing_enable == 1U)
900090bc:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
900090c0:	2b01      	cmp	r3, #1
900090c2:	d105      	bne.n	900090d0 <USB_DevInit+0x324>
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
900090c4:	687b      	ldr	r3, [r7, #4]
900090c6:	699a      	ldr	r2, [r3, #24]
900090c8:	4b06      	ldr	r3, [pc, #24]	@ (900090e4 <USB_DevInit+0x338>)
900090ca:	4313      	orrs	r3, r2
900090cc:	687a      	ldr	r2, [r7, #4]
900090ce:	6193      	str	r3, [r2, #24]
  }

  return ret;
900090d0:	7dfb      	ldrb	r3, [r7, #23]
}
900090d2:	4618      	mov	r0, r3
900090d4:	3718      	adds	r7, #24
900090d6:	46bd      	mov	sp, r7
900090d8:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
900090dc:	b004      	add	sp, #16
900090de:	4770      	bx	lr
900090e0:	803c3800 	.word	0x803c3800
900090e4:	40000004 	.word	0x40000004

900090e8 <USB_FlushTxFifo>:
  *         This parameter can be a value from 1 to 15
            15 means Flush all Tx FIFOs
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushTxFifo(USB_OTG_GlobalTypeDef *USBx, uint32_t num)
{
900090e8:	b480      	push	{r7}
900090ea:	b085      	sub	sp, #20
900090ec:	af00      	add	r7, sp, #0
900090ee:	6078      	str	r0, [r7, #4]
900090f0:	6039      	str	r1, [r7, #0]
  __IO uint32_t count = 0U;
900090f2:	2300      	movs	r3, #0
900090f4:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
900090f6:	68fb      	ldr	r3, [r7, #12]
900090f8:	3301      	adds	r3, #1
900090fa:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
900090fc:	68fb      	ldr	r3, [r7, #12]
900090fe:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
90009102:	d901      	bls.n	90009108 <USB_FlushTxFifo+0x20>
    {
      return HAL_TIMEOUT;
90009104:	2303      	movs	r3, #3
90009106:	e01b      	b.n	90009140 <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
90009108:	687b      	ldr	r3, [r7, #4]
9000910a:	691b      	ldr	r3, [r3, #16]
9000910c:	2b00      	cmp	r3, #0
9000910e:	daf2      	bge.n	900090f6 <USB_FlushTxFifo+0xe>

  /* Flush TX Fifo */
  count = 0U;
90009110:	2300      	movs	r3, #0
90009112:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
90009114:	683b      	ldr	r3, [r7, #0]
90009116:	019b      	lsls	r3, r3, #6
90009118:	f043 0220 	orr.w	r2, r3, #32
9000911c:	687b      	ldr	r3, [r7, #4]
9000911e:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
90009120:	68fb      	ldr	r3, [r7, #12]
90009122:	3301      	adds	r3, #1
90009124:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
90009126:	68fb      	ldr	r3, [r7, #12]
90009128:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
9000912c:	d901      	bls.n	90009132 <USB_FlushTxFifo+0x4a>
    {
      return HAL_TIMEOUT;
9000912e:	2303      	movs	r3, #3
90009130:	e006      	b.n	90009140 <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
90009132:	687b      	ldr	r3, [r7, #4]
90009134:	691b      	ldr	r3, [r3, #16]
90009136:	f003 0320 	and.w	r3, r3, #32
9000913a:	2b20      	cmp	r3, #32
9000913c:	d0f0      	beq.n	90009120 <USB_FlushTxFifo+0x38>

  return HAL_OK;
9000913e:	2300      	movs	r3, #0
}
90009140:	4618      	mov	r0, r3
90009142:	3714      	adds	r7, #20
90009144:	46bd      	mov	sp, r7
90009146:	f85d 7b04 	ldr.w	r7, [sp], #4
9000914a:	4770      	bx	lr

9000914c <USB_FlushRxFifo>:
  * @brief  USB_FlushRxFifo  Flush Rx FIFO
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
9000914c:	b480      	push	{r7}
9000914e:	b085      	sub	sp, #20
90009150:	af00      	add	r7, sp, #0
90009152:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
90009154:	2300      	movs	r3, #0
90009156:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
90009158:	68fb      	ldr	r3, [r7, #12]
9000915a:	3301      	adds	r3, #1
9000915c:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
9000915e:	68fb      	ldr	r3, [r7, #12]
90009160:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
90009164:	d901      	bls.n	9000916a <USB_FlushRxFifo+0x1e>
    {
      return HAL_TIMEOUT;
90009166:	2303      	movs	r3, #3
90009168:	e018      	b.n	9000919c <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
9000916a:	687b      	ldr	r3, [r7, #4]
9000916c:	691b      	ldr	r3, [r3, #16]
9000916e:	2b00      	cmp	r3, #0
90009170:	daf2      	bge.n	90009158 <USB_FlushRxFifo+0xc>

  /* Flush RX Fifo */
  count = 0U;
90009172:	2300      	movs	r3, #0
90009174:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
90009176:	687b      	ldr	r3, [r7, #4]
90009178:	2210      	movs	r2, #16
9000917a:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
9000917c:	68fb      	ldr	r3, [r7, #12]
9000917e:	3301      	adds	r3, #1
90009180:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
90009182:	68fb      	ldr	r3, [r7, #12]
90009184:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
90009188:	d901      	bls.n	9000918e <USB_FlushRxFifo+0x42>
    {
      return HAL_TIMEOUT;
9000918a:	2303      	movs	r3, #3
9000918c:	e006      	b.n	9000919c <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
9000918e:	687b      	ldr	r3, [r7, #4]
90009190:	691b      	ldr	r3, [r3, #16]
90009192:	f003 0310 	and.w	r3, r3, #16
90009196:	2b10      	cmp	r3, #16
90009198:	d0f0      	beq.n	9000917c <USB_FlushRxFifo+0x30>

  return HAL_OK;
9000919a:	2300      	movs	r3, #0
}
9000919c:	4618      	mov	r0, r3
9000919e:	3714      	adds	r7, #20
900091a0:	46bd      	mov	sp, r7
900091a2:	f85d 7b04 	ldr.w	r7, [sp], #4
900091a6:	4770      	bx	lr

900091a8 <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_HIGH_IN_FULL: High speed core in Full Speed mode
  *            @arg USB_OTG_SPEED_FULL: Full speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(const USB_OTG_GlobalTypeDef *USBx, uint8_t speed)
{
900091a8:	b480      	push	{r7}
900091aa:	b085      	sub	sp, #20
900091ac:	af00      	add	r7, sp, #0
900091ae:	6078      	str	r0, [r7, #4]
900091b0:	460b      	mov	r3, r1
900091b2:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
900091b4:	687b      	ldr	r3, [r7, #4]
900091b6:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCFG |= speed;
900091b8:	68fb      	ldr	r3, [r7, #12]
900091ba:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
900091be:	681a      	ldr	r2, [r3, #0]
900091c0:	78fb      	ldrb	r3, [r7, #3]
900091c2:	68f9      	ldr	r1, [r7, #12]
900091c4:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
900091c8:	4313      	orrs	r3, r2
900091ca:	600b      	str	r3, [r1, #0]
  return HAL_OK;
900091cc:	2300      	movs	r3, #0
}
900091ce:	4618      	mov	r0, r3
900091d0:	3714      	adds	r7, #20
900091d2:	46bd      	mov	sp, r7
900091d4:	f85d 7b04 	ldr.w	r7, [sp], #4
900091d8:	4770      	bx	lr

900091da <USB_GetDevSpeed>:
  *          This parameter can be one of these values:
  *            @arg USBD_HS_SPEED: High speed mode
  *            @arg USBD_FS_SPEED: Full speed mode
  */
uint8_t USB_GetDevSpeed(const USB_OTG_GlobalTypeDef *USBx)
{
900091da:	b480      	push	{r7}
900091dc:	b087      	sub	sp, #28
900091de:	af00      	add	r7, sp, #0
900091e0:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
900091e2:	687b      	ldr	r3, [r7, #4]
900091e4:	613b      	str	r3, [r7, #16]
  uint8_t speed;
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
900091e6:	693b      	ldr	r3, [r7, #16]
900091e8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
900091ec:	689b      	ldr	r3, [r3, #8]
900091ee:	f003 0306 	and.w	r3, r3, #6
900091f2:	60fb      	str	r3, [r7, #12]

  if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
900091f4:	68fb      	ldr	r3, [r7, #12]
900091f6:	2b00      	cmp	r3, #0
900091f8:	d102      	bne.n	90009200 <USB_GetDevSpeed+0x26>
  {
    speed = USBD_HS_SPEED;
900091fa:	2300      	movs	r3, #0
900091fc:	75fb      	strb	r3, [r7, #23]
900091fe:	e00a      	b.n	90009216 <USB_GetDevSpeed+0x3c>
  }
  else if ((DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ) ||
90009200:	68fb      	ldr	r3, [r7, #12]
90009202:	2b02      	cmp	r3, #2
90009204:	d002      	beq.n	9000920c <USB_GetDevSpeed+0x32>
90009206:	68fb      	ldr	r3, [r7, #12]
90009208:	2b06      	cmp	r3, #6
9000920a:	d102      	bne.n	90009212 <USB_GetDevSpeed+0x38>
           (DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USBD_FS_SPEED;
9000920c:	2302      	movs	r3, #2
9000920e:	75fb      	strb	r3, [r7, #23]
90009210:	e001      	b.n	90009216 <USB_GetDevSpeed+0x3c>
  }
  else
  {
    speed = 0xFU;
90009212:	230f      	movs	r3, #15
90009214:	75fb      	strb	r3, [r7, #23]
  }

  return speed;
90009216:	7dfb      	ldrb	r3, [r7, #23]
}
90009218:	4618      	mov	r0, r3
9000921a:	371c      	adds	r7, #28
9000921c:	46bd      	mov	sp, r7
9000921e:	f85d 7b04 	ldr.w	r7, [sp], #4
90009222:	4770      	bx	lr

90009224 <USB_ActivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
90009224:	b480      	push	{r7}
90009226:	b085      	sub	sp, #20
90009228:	af00      	add	r7, sp, #0
9000922a:	6078      	str	r0, [r7, #4]
9000922c:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
9000922e:	687b      	ldr	r3, [r7, #4]
90009230:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
90009232:	683b      	ldr	r3, [r7, #0]
90009234:	781b      	ldrb	r3, [r3, #0]
90009236:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
90009238:	683b      	ldr	r3, [r7, #0]
9000923a:	785b      	ldrb	r3, [r3, #1]
9000923c:	2b01      	cmp	r3, #1
9000923e:	d139      	bne.n	900092b4 <USB_ActivateEndpoint+0x90>
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
90009240:	68fb      	ldr	r3, [r7, #12]
90009242:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90009246:	69da      	ldr	r2, [r3, #28]
90009248:	683b      	ldr	r3, [r7, #0]
9000924a:	781b      	ldrb	r3, [r3, #0]
9000924c:	f003 030f 	and.w	r3, r3, #15
90009250:	2101      	movs	r1, #1
90009252:	fa01 f303 	lsl.w	r3, r1, r3
90009256:	b29b      	uxth	r3, r3
90009258:	68f9      	ldr	r1, [r7, #12]
9000925a:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
9000925e:	4313      	orrs	r3, r2
90009260:	61cb      	str	r3, [r1, #28]

    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
90009262:	68bb      	ldr	r3, [r7, #8]
90009264:	015a      	lsls	r2, r3, #5
90009266:	68fb      	ldr	r3, [r7, #12]
90009268:	4413      	add	r3, r2
9000926a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
9000926e:	681b      	ldr	r3, [r3, #0]
90009270:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
90009274:	2b00      	cmp	r3, #0
90009276:	d153      	bne.n	90009320 <USB_ActivateEndpoint+0xfc>
    {
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
90009278:	68bb      	ldr	r3, [r7, #8]
9000927a:	015a      	lsls	r2, r3, #5
9000927c:	68fb      	ldr	r3, [r7, #12]
9000927e:	4413      	add	r3, r2
90009280:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009284:	681a      	ldr	r2, [r3, #0]
90009286:	683b      	ldr	r3, [r7, #0]
90009288:	689b      	ldr	r3, [r3, #8]
9000928a:	f3c3 010a 	ubfx	r1, r3, #0, #11
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
9000928e:	683b      	ldr	r3, [r7, #0]
90009290:	791b      	ldrb	r3, [r3, #4]
90009292:	049b      	lsls	r3, r3, #18
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
90009294:	4319      	orrs	r1, r3
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
90009296:	68bb      	ldr	r3, [r7, #8]
90009298:	059b      	lsls	r3, r3, #22
9000929a:	430b      	orrs	r3, r1
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
9000929c:	431a      	orrs	r2, r3
9000929e:	68bb      	ldr	r3, [r7, #8]
900092a0:	0159      	lsls	r1, r3, #5
900092a2:	68fb      	ldr	r3, [r7, #12]
900092a4:	440b      	add	r3, r1
900092a6:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
900092aa:	4619      	mov	r1, r3
900092ac:	4b20      	ldr	r3, [pc, #128]	@ (90009330 <USB_ActivateEndpoint+0x10c>)
900092ae:	4313      	orrs	r3, r2
900092b0:	600b      	str	r3, [r1, #0]
900092b2:	e035      	b.n	90009320 <USB_ActivateEndpoint+0xfc>
                                   USB_OTG_DIEPCTL_USBAEP;
    }
  }
  else
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
900092b4:	68fb      	ldr	r3, [r7, #12]
900092b6:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
900092ba:	69da      	ldr	r2, [r3, #28]
900092bc:	683b      	ldr	r3, [r7, #0]
900092be:	781b      	ldrb	r3, [r3, #0]
900092c0:	f003 030f 	and.w	r3, r3, #15
900092c4:	2101      	movs	r1, #1
900092c6:	fa01 f303 	lsl.w	r3, r1, r3
900092ca:	041b      	lsls	r3, r3, #16
900092cc:	68f9      	ldr	r1, [r7, #12]
900092ce:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
900092d2:	4313      	orrs	r3, r2
900092d4:	61cb      	str	r3, [r1, #28]

    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
900092d6:	68bb      	ldr	r3, [r7, #8]
900092d8:	015a      	lsls	r2, r3, #5
900092da:	68fb      	ldr	r3, [r7, #12]
900092dc:	4413      	add	r3, r2
900092de:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
900092e2:	681b      	ldr	r3, [r3, #0]
900092e4:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
900092e8:	2b00      	cmp	r3, #0
900092ea:	d119      	bne.n	90009320 <USB_ActivateEndpoint+0xfc>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
900092ec:	68bb      	ldr	r3, [r7, #8]
900092ee:	015a      	lsls	r2, r3, #5
900092f0:	68fb      	ldr	r3, [r7, #12]
900092f2:	4413      	add	r3, r2
900092f4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
900092f8:	681a      	ldr	r2, [r3, #0]
900092fa:	683b      	ldr	r3, [r7, #0]
900092fc:	689b      	ldr	r3, [r3, #8]
900092fe:	f3c3 010a 	ubfx	r1, r3, #0, #11
                                    ((uint32_t)ep->type << 18) |
90009302:	683b      	ldr	r3, [r7, #0]
90009304:	791b      	ldrb	r3, [r3, #4]
90009306:	049b      	lsls	r3, r3, #18
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
90009308:	430b      	orrs	r3, r1
9000930a:	431a      	orrs	r2, r3
9000930c:	68bb      	ldr	r3, [r7, #8]
9000930e:	0159      	lsls	r1, r3, #5
90009310:	68fb      	ldr	r3, [r7, #12]
90009312:	440b      	add	r3, r1
90009314:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009318:	4619      	mov	r1, r3
9000931a:	4b05      	ldr	r3, [pc, #20]	@ (90009330 <USB_ActivateEndpoint+0x10c>)
9000931c:	4313      	orrs	r3, r2
9000931e:	600b      	str	r3, [r1, #0]
                                    USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_USBAEP;
    }
  }
  return HAL_OK;
90009320:	2300      	movs	r3, #0
}
90009322:	4618      	mov	r0, r3
90009324:	3714      	adds	r7, #20
90009326:	46bd      	mov	sp, r7
90009328:	f85d 7b04 	ldr.w	r7, [sp], #4
9000932c:	4770      	bx	lr
9000932e:	bf00      	nop
90009330:	10008000 	.word	0x10008000

90009334 <USB_DeactivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
90009334:	b480      	push	{r7}
90009336:	b085      	sub	sp, #20
90009338:	af00      	add	r7, sp, #0
9000933a:	6078      	str	r0, [r7, #4]
9000933c:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
9000933e:	687b      	ldr	r3, [r7, #4]
90009340:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
90009342:	683b      	ldr	r3, [r7, #0]
90009344:	781b      	ldrb	r3, [r3, #0]
90009346:	60bb      	str	r3, [r7, #8]

  /* Read DEPCTLn register */
  if (ep->is_in == 1U)
90009348:	683b      	ldr	r3, [r7, #0]
9000934a:	785b      	ldrb	r3, [r3, #1]
9000934c:	2b01      	cmp	r3, #1
9000934e:	d161      	bne.n	90009414 <USB_DeactivateEndpoint+0xe0>
  {
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
90009350:	68bb      	ldr	r3, [r7, #8]
90009352:	015a      	lsls	r2, r3, #5
90009354:	68fb      	ldr	r3, [r7, #12]
90009356:	4413      	add	r3, r2
90009358:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
9000935c:	681b      	ldr	r3, [r3, #0]
9000935e:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
90009362:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
90009366:	d11f      	bne.n	900093a8 <USB_DeactivateEndpoint+0x74>
    {
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
90009368:	68bb      	ldr	r3, [r7, #8]
9000936a:	015a      	lsls	r2, r3, #5
9000936c:	68fb      	ldr	r3, [r7, #12]
9000936e:	4413      	add	r3, r2
90009370:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009374:	681b      	ldr	r3, [r3, #0]
90009376:	68ba      	ldr	r2, [r7, #8]
90009378:	0151      	lsls	r1, r2, #5
9000937a:	68fa      	ldr	r2, [r7, #12]
9000937c:	440a      	add	r2, r1
9000937e:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
90009382:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
90009386:	6013      	str	r3, [r2, #0]
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_EPDIS;
90009388:	68bb      	ldr	r3, [r7, #8]
9000938a:	015a      	lsls	r2, r3, #5
9000938c:	68fb      	ldr	r3, [r7, #12]
9000938e:	4413      	add	r3, r2
90009390:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009394:	681b      	ldr	r3, [r3, #0]
90009396:	68ba      	ldr	r2, [r7, #8]
90009398:	0151      	lsls	r1, r2, #5
9000939a:	68fa      	ldr	r2, [r7, #12]
9000939c:	440a      	add	r2, r1
9000939e:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
900093a2:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
900093a6:	6013      	str	r3, [r2, #0]
    }

    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
900093a8:	68fb      	ldr	r3, [r7, #12]
900093aa:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
900093ae:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
900093b0:	683b      	ldr	r3, [r7, #0]
900093b2:	781b      	ldrb	r3, [r3, #0]
900093b4:	f003 030f 	and.w	r3, r3, #15
900093b8:	2101      	movs	r1, #1
900093ba:	fa01 f303 	lsl.w	r3, r1, r3
900093be:	b29b      	uxth	r3, r3
900093c0:	43db      	mvns	r3, r3
900093c2:	68f9      	ldr	r1, [r7, #12]
900093c4:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
900093c8:	4013      	ands	r3, r2
900093ca:	63cb      	str	r3, [r1, #60]	@ 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
900093cc:	68fb      	ldr	r3, [r7, #12]
900093ce:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
900093d2:	69da      	ldr	r2, [r3, #28]
900093d4:	683b      	ldr	r3, [r7, #0]
900093d6:	781b      	ldrb	r3, [r3, #0]
900093d8:	f003 030f 	and.w	r3, r3, #15
900093dc:	2101      	movs	r1, #1
900093de:	fa01 f303 	lsl.w	r3, r1, r3
900093e2:	b29b      	uxth	r3, r3
900093e4:	43db      	mvns	r3, r3
900093e6:	68f9      	ldr	r1, [r7, #12]
900093e8:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
900093ec:	4013      	ands	r3, r2
900093ee:	61cb      	str	r3, [r1, #28]
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
900093f0:	68bb      	ldr	r3, [r7, #8]
900093f2:	015a      	lsls	r2, r3, #5
900093f4:	68fb      	ldr	r3, [r7, #12]
900093f6:	4413      	add	r3, r2
900093f8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
900093fc:	681a      	ldr	r2, [r3, #0]
900093fe:	68bb      	ldr	r3, [r7, #8]
90009400:	0159      	lsls	r1, r3, #5
90009402:	68fb      	ldr	r3, [r7, #12]
90009404:	440b      	add	r3, r1
90009406:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
9000940a:	4619      	mov	r1, r3
9000940c:	4b35      	ldr	r3, [pc, #212]	@ (900094e4 <USB_DeactivateEndpoint+0x1b0>)
9000940e:	4013      	ands	r3, r2
90009410:	600b      	str	r3, [r1, #0]
90009412:	e060      	b.n	900094d6 <USB_DeactivateEndpoint+0x1a2>
                                   USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                   USB_OTG_DIEPCTL_EPTYP);
  }
  else
  {
    if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
90009414:	68bb      	ldr	r3, [r7, #8]
90009416:	015a      	lsls	r2, r3, #5
90009418:	68fb      	ldr	r3, [r7, #12]
9000941a:	4413      	add	r3, r2
9000941c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009420:	681b      	ldr	r3, [r3, #0]
90009422:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
90009426:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
9000942a:	d11f      	bne.n	9000946c <USB_DeactivateEndpoint+0x138>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
9000942c:	68bb      	ldr	r3, [r7, #8]
9000942e:	015a      	lsls	r2, r3, #5
90009430:	68fb      	ldr	r3, [r7, #12]
90009432:	4413      	add	r3, r2
90009434:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009438:	681b      	ldr	r3, [r3, #0]
9000943a:	68ba      	ldr	r2, [r7, #8]
9000943c:	0151      	lsls	r1, r2, #5
9000943e:	68fa      	ldr	r2, [r7, #12]
90009440:	440a      	add	r2, r1
90009442:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
90009446:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
9000944a:	6013      	str	r3, [r2, #0]
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_EPDIS;
9000944c:	68bb      	ldr	r3, [r7, #8]
9000944e:	015a      	lsls	r2, r3, #5
90009450:	68fb      	ldr	r3, [r7, #12]
90009452:	4413      	add	r3, r2
90009454:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009458:	681b      	ldr	r3, [r3, #0]
9000945a:	68ba      	ldr	r2, [r7, #8]
9000945c:	0151      	lsls	r1, r2, #5
9000945e:	68fa      	ldr	r2, [r7, #12]
90009460:	440a      	add	r2, r1
90009462:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
90009466:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
9000946a:	6013      	str	r3, [r2, #0]
    }

    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
9000946c:	68fb      	ldr	r3, [r7, #12]
9000946e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90009472:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
90009474:	683b      	ldr	r3, [r7, #0]
90009476:	781b      	ldrb	r3, [r3, #0]
90009478:	f003 030f 	and.w	r3, r3, #15
9000947c:	2101      	movs	r1, #1
9000947e:	fa01 f303 	lsl.w	r3, r1, r3
90009482:	041b      	lsls	r3, r3, #16
90009484:	43db      	mvns	r3, r3
90009486:	68f9      	ldr	r1, [r7, #12]
90009488:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
9000948c:	4013      	ands	r3, r2
9000948e:	63cb      	str	r3, [r1, #60]	@ 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
90009490:	68fb      	ldr	r3, [r7, #12]
90009492:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90009496:	69da      	ldr	r2, [r3, #28]
90009498:	683b      	ldr	r3, [r7, #0]
9000949a:	781b      	ldrb	r3, [r3, #0]
9000949c:	f003 030f 	and.w	r3, r3, #15
900094a0:	2101      	movs	r1, #1
900094a2:	fa01 f303 	lsl.w	r3, r1, r3
900094a6:	041b      	lsls	r3, r3, #16
900094a8:	43db      	mvns	r3, r3
900094aa:	68f9      	ldr	r1, [r7, #12]
900094ac:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
900094b0:	4013      	ands	r3, r2
900094b2:	61cb      	str	r3, [r1, #28]
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
900094b4:	68bb      	ldr	r3, [r7, #8]
900094b6:	015a      	lsls	r2, r3, #5
900094b8:	68fb      	ldr	r3, [r7, #12]
900094ba:	4413      	add	r3, r2
900094bc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
900094c0:	681a      	ldr	r2, [r3, #0]
900094c2:	68bb      	ldr	r3, [r7, #8]
900094c4:	0159      	lsls	r1, r3, #5
900094c6:	68fb      	ldr	r3, [r7, #12]
900094c8:	440b      	add	r3, r1
900094ca:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
900094ce:	4619      	mov	r1, r3
900094d0:	4b05      	ldr	r3, [pc, #20]	@ (900094e8 <USB_DeactivateEndpoint+0x1b4>)
900094d2:	4013      	ands	r3, r2
900094d4:	600b      	str	r3, [r1, #0]
                                    USB_OTG_DOEPCTL_MPSIZ |
                                    USB_OTG_DOEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_EPTYP);
  }

  return HAL_OK;
900094d6:	2300      	movs	r3, #0
}
900094d8:	4618      	mov	r0, r3
900094da:	3714      	adds	r7, #20
900094dc:	46bd      	mov	sp, r7
900094de:	f85d 7b04 	ldr.w	r7, [sp], #4
900094e2:	4770      	bx	lr
900094e4:	ec337800 	.word	0xec337800
900094e8:	eff37800 	.word	0xeff37800

900094ec <USB_EPStartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep, uint8_t dma)
{
900094ec:	b580      	push	{r7, lr}
900094ee:	b08a      	sub	sp, #40	@ 0x28
900094f0:	af02      	add	r7, sp, #8
900094f2:	60f8      	str	r0, [r7, #12]
900094f4:	60b9      	str	r1, [r7, #8]
900094f6:	4613      	mov	r3, r2
900094f8:	71fb      	strb	r3, [r7, #7]
  uint32_t USBx_BASE = (uint32_t)USBx;
900094fa:	68fb      	ldr	r3, [r7, #12]
900094fc:	61fb      	str	r3, [r7, #28]
  uint32_t epnum = (uint32_t)ep->num;
900094fe:	68bb      	ldr	r3, [r7, #8]
90009500:	781b      	ldrb	r3, [r3, #0]
90009502:	61bb      	str	r3, [r7, #24]
  uint16_t pktcnt;

  /* IN endpoint */
  if (ep->is_in == 1U)
90009504:	68bb      	ldr	r3, [r7, #8]
90009506:	785b      	ldrb	r3, [r3, #1]
90009508:	2b01      	cmp	r3, #1
9000950a:	f040 8185 	bne.w	90009818 <USB_EPStartXfer+0x32c>
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
9000950e:	68bb      	ldr	r3, [r7, #8]
90009510:	691b      	ldr	r3, [r3, #16]
90009512:	2b00      	cmp	r3, #0
90009514:	d132      	bne.n	9000957c <USB_EPStartXfer+0x90>
    {
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
90009516:	69bb      	ldr	r3, [r7, #24]
90009518:	015a      	lsls	r2, r3, #5
9000951a:	69fb      	ldr	r3, [r7, #28]
9000951c:	4413      	add	r3, r2
9000951e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009522:	691a      	ldr	r2, [r3, #16]
90009524:	69bb      	ldr	r3, [r7, #24]
90009526:	0159      	lsls	r1, r3, #5
90009528:	69fb      	ldr	r3, [r7, #28]
9000952a:	440b      	add	r3, r1
9000952c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009530:	4619      	mov	r1, r3
90009532:	4ba7      	ldr	r3, [pc, #668]	@ (900097d0 <USB_EPStartXfer+0x2e4>)
90009534:	4013      	ands	r3, r2
90009536:	610b      	str	r3, [r1, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1UL << 19));
90009538:	69bb      	ldr	r3, [r7, #24]
9000953a:	015a      	lsls	r2, r3, #5
9000953c:	69fb      	ldr	r3, [r7, #28]
9000953e:	4413      	add	r3, r2
90009540:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009544:	691b      	ldr	r3, [r3, #16]
90009546:	69ba      	ldr	r2, [r7, #24]
90009548:	0151      	lsls	r1, r2, #5
9000954a:	69fa      	ldr	r2, [r7, #28]
9000954c:	440a      	add	r2, r1
9000954e:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
90009552:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
90009556:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
90009558:	69bb      	ldr	r3, [r7, #24]
9000955a:	015a      	lsls	r2, r3, #5
9000955c:	69fb      	ldr	r3, [r7, #28]
9000955e:	4413      	add	r3, r2
90009560:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009564:	691a      	ldr	r2, [r3, #16]
90009566:	69bb      	ldr	r3, [r7, #24]
90009568:	0159      	lsls	r1, r3, #5
9000956a:	69fb      	ldr	r3, [r7, #28]
9000956c:	440b      	add	r3, r1
9000956e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009572:	4619      	mov	r1, r3
90009574:	4b97      	ldr	r3, [pc, #604]	@ (900097d4 <USB_EPStartXfer+0x2e8>)
90009576:	4013      	ands	r3, r2
90009578:	610b      	str	r3, [r1, #16]
9000957a:	e097      	b.n	900096ac <USB_EPStartXfer+0x1c0>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
9000957c:	69bb      	ldr	r3, [r7, #24]
9000957e:	015a      	lsls	r2, r3, #5
90009580:	69fb      	ldr	r3, [r7, #28]
90009582:	4413      	add	r3, r2
90009584:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009588:	691a      	ldr	r2, [r3, #16]
9000958a:	69bb      	ldr	r3, [r7, #24]
9000958c:	0159      	lsls	r1, r3, #5
9000958e:	69fb      	ldr	r3, [r7, #28]
90009590:	440b      	add	r3, r1
90009592:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009596:	4619      	mov	r1, r3
90009598:	4b8e      	ldr	r3, [pc, #568]	@ (900097d4 <USB_EPStartXfer+0x2e8>)
9000959a:	4013      	ands	r3, r2
9000959c:	610b      	str	r3, [r1, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
9000959e:	69bb      	ldr	r3, [r7, #24]
900095a0:	015a      	lsls	r2, r3, #5
900095a2:	69fb      	ldr	r3, [r7, #28]
900095a4:	4413      	add	r3, r2
900095a6:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
900095aa:	691a      	ldr	r2, [r3, #16]
900095ac:	69bb      	ldr	r3, [r7, #24]
900095ae:	0159      	lsls	r1, r3, #5
900095b0:	69fb      	ldr	r3, [r7, #28]
900095b2:	440b      	add	r3, r1
900095b4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
900095b8:	4619      	mov	r1, r3
900095ba:	4b85      	ldr	r3, [pc, #532]	@ (900097d0 <USB_EPStartXfer+0x2e4>)
900095bc:	4013      	ands	r3, r2
900095be:	610b      	str	r3, [r1, #16]

      if (epnum == 0U)
900095c0:	69bb      	ldr	r3, [r7, #24]
900095c2:	2b00      	cmp	r3, #0
900095c4:	d11a      	bne.n	900095fc <USB_EPStartXfer+0x110>
      {
        if (ep->xfer_len > ep->maxpacket)
900095c6:	68bb      	ldr	r3, [r7, #8]
900095c8:	691a      	ldr	r2, [r3, #16]
900095ca:	68bb      	ldr	r3, [r7, #8]
900095cc:	689b      	ldr	r3, [r3, #8]
900095ce:	429a      	cmp	r2, r3
900095d0:	d903      	bls.n	900095da <USB_EPStartXfer+0xee>
        {
          ep->xfer_len = ep->maxpacket;
900095d2:	68bb      	ldr	r3, [r7, #8]
900095d4:	689a      	ldr	r2, [r3, #8]
900095d6:	68bb      	ldr	r3, [r7, #8]
900095d8:	611a      	str	r2, [r3, #16]
        }

        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1UL << 19));
900095da:	69bb      	ldr	r3, [r7, #24]
900095dc:	015a      	lsls	r2, r3, #5
900095de:	69fb      	ldr	r3, [r7, #28]
900095e0:	4413      	add	r3, r2
900095e2:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
900095e6:	691b      	ldr	r3, [r3, #16]
900095e8:	69ba      	ldr	r2, [r7, #24]
900095ea:	0151      	lsls	r1, r2, #5
900095ec:	69fa      	ldr	r2, [r7, #28]
900095ee:	440a      	add	r2, r1
900095f0:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
900095f4:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
900095f8:	6113      	str	r3, [r2, #16]
900095fa:	e044      	b.n	90009686 <USB_EPStartXfer+0x19a>
      }
      else
      {
        pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
900095fc:	68bb      	ldr	r3, [r7, #8]
900095fe:	691a      	ldr	r2, [r3, #16]
90009600:	68bb      	ldr	r3, [r7, #8]
90009602:	689b      	ldr	r3, [r3, #8]
90009604:	4413      	add	r3, r2
90009606:	1e5a      	subs	r2, r3, #1
90009608:	68bb      	ldr	r3, [r7, #8]
9000960a:	689b      	ldr	r3, [r3, #8]
9000960c:	fbb2 f3f3 	udiv	r3, r2, r3
90009610:	82fb      	strh	r3, [r7, #22]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19));
90009612:	69bb      	ldr	r3, [r7, #24]
90009614:	015a      	lsls	r2, r3, #5
90009616:	69fb      	ldr	r3, [r7, #28]
90009618:	4413      	add	r3, r2
9000961a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
9000961e:	691a      	ldr	r2, [r3, #16]
90009620:	8afb      	ldrh	r3, [r7, #22]
90009622:	04d9      	lsls	r1, r3, #19
90009624:	4b6c      	ldr	r3, [pc, #432]	@ (900097d8 <USB_EPStartXfer+0x2ec>)
90009626:	400b      	ands	r3, r1
90009628:	69b9      	ldr	r1, [r7, #24]
9000962a:	0148      	lsls	r0, r1, #5
9000962c:	69f9      	ldr	r1, [r7, #28]
9000962e:	4401      	add	r1, r0
90009630:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
90009634:	4313      	orrs	r3, r2
90009636:	610b      	str	r3, [r1, #16]

        if (ep->type == EP_TYPE_ISOC)
90009638:	68bb      	ldr	r3, [r7, #8]
9000963a:	791b      	ldrb	r3, [r3, #4]
9000963c:	2b01      	cmp	r3, #1
9000963e:	d122      	bne.n	90009686 <USB_EPStartXfer+0x19a>
        {
          USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
90009640:	69bb      	ldr	r3, [r7, #24]
90009642:	015a      	lsls	r2, r3, #5
90009644:	69fb      	ldr	r3, [r7, #28]
90009646:	4413      	add	r3, r2
90009648:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
9000964c:	691b      	ldr	r3, [r3, #16]
9000964e:	69ba      	ldr	r2, [r7, #24]
90009650:	0151      	lsls	r1, r2, #5
90009652:	69fa      	ldr	r2, [r7, #28]
90009654:	440a      	add	r2, r1
90009656:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
9000965a:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
9000965e:	6113      	str	r3, [r2, #16]
          USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & ((uint32_t)pktcnt << 29));
90009660:	69bb      	ldr	r3, [r7, #24]
90009662:	015a      	lsls	r2, r3, #5
90009664:	69fb      	ldr	r3, [r7, #28]
90009666:	4413      	add	r3, r2
90009668:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
9000966c:	691a      	ldr	r2, [r3, #16]
9000966e:	8afb      	ldrh	r3, [r7, #22]
90009670:	075b      	lsls	r3, r3, #29
90009672:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
90009676:	69b9      	ldr	r1, [r7, #24]
90009678:	0148      	lsls	r0, r1, #5
9000967a:	69f9      	ldr	r1, [r7, #28]
9000967c:	4401      	add	r1, r0
9000967e:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
90009682:	4313      	orrs	r3, r2
90009684:	610b      	str	r3, [r1, #16]
        }
      }

      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
90009686:	69bb      	ldr	r3, [r7, #24]
90009688:	015a      	lsls	r2, r3, #5
9000968a:	69fb      	ldr	r3, [r7, #28]
9000968c:	4413      	add	r3, r2
9000968e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009692:	691a      	ldr	r2, [r3, #16]
90009694:	68bb      	ldr	r3, [r7, #8]
90009696:	691b      	ldr	r3, [r3, #16]
90009698:	f3c3 0312 	ubfx	r3, r3, #0, #19
9000969c:	69b9      	ldr	r1, [r7, #24]
9000969e:	0148      	lsls	r0, r1, #5
900096a0:	69f9      	ldr	r1, [r7, #28]
900096a2:	4401      	add	r1, r0
900096a4:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
900096a8:	4313      	orrs	r3, r2
900096aa:	610b      	str	r3, [r1, #16]
    }

    if (dma == 1U)
900096ac:	79fb      	ldrb	r3, [r7, #7]
900096ae:	2b01      	cmp	r3, #1
900096b0:	d14b      	bne.n	9000974a <USB_EPStartXfer+0x25e>
    {
      if ((uint32_t)ep->dma_addr != 0U)
900096b2:	68bb      	ldr	r3, [r7, #8]
900096b4:	69db      	ldr	r3, [r3, #28]
900096b6:	2b00      	cmp	r3, #0
900096b8:	d009      	beq.n	900096ce <USB_EPStartXfer+0x1e2>
      {
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
900096ba:	69bb      	ldr	r3, [r7, #24]
900096bc:	015a      	lsls	r2, r3, #5
900096be:	69fb      	ldr	r3, [r7, #28]
900096c0:	4413      	add	r3, r2
900096c2:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
900096c6:	461a      	mov	r2, r3
900096c8:	68bb      	ldr	r3, [r7, #8]
900096ca:	69db      	ldr	r3, [r3, #28]
900096cc:	6153      	str	r3, [r2, #20]
      }

      if (ep->type == EP_TYPE_ISOC)
900096ce:	68bb      	ldr	r3, [r7, #8]
900096d0:	791b      	ldrb	r3, [r3, #4]
900096d2:	2b01      	cmp	r3, #1
900096d4:	d128      	bne.n	90009728 <USB_EPStartXfer+0x23c>
      {
        if ((USBx_DEVICE->DSTS & (1UL << 8)) == 0U)
900096d6:	69fb      	ldr	r3, [r7, #28]
900096d8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
900096dc:	689b      	ldr	r3, [r3, #8]
900096de:	f403 7380 	and.w	r3, r3, #256	@ 0x100
900096e2:	2b00      	cmp	r3, #0
900096e4:	d110      	bne.n	90009708 <USB_EPStartXfer+0x21c>
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
900096e6:	69bb      	ldr	r3, [r7, #24]
900096e8:	015a      	lsls	r2, r3, #5
900096ea:	69fb      	ldr	r3, [r7, #28]
900096ec:	4413      	add	r3, r2
900096ee:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
900096f2:	681b      	ldr	r3, [r3, #0]
900096f4:	69ba      	ldr	r2, [r7, #24]
900096f6:	0151      	lsls	r1, r2, #5
900096f8:	69fa      	ldr	r2, [r7, #28]
900096fa:	440a      	add	r2, r1
900096fc:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
90009700:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
90009704:	6013      	str	r3, [r2, #0]
90009706:	e00f      	b.n	90009728 <USB_EPStartXfer+0x23c>
        }
        else
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
90009708:	69bb      	ldr	r3, [r7, #24]
9000970a:	015a      	lsls	r2, r3, #5
9000970c:	69fb      	ldr	r3, [r7, #28]
9000970e:	4413      	add	r3, r2
90009710:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009714:	681b      	ldr	r3, [r3, #0]
90009716:	69ba      	ldr	r2, [r7, #24]
90009718:	0151      	lsls	r1, r2, #5
9000971a:	69fa      	ldr	r2, [r7, #28]
9000971c:	440a      	add	r2, r1
9000971e:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
90009722:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
90009726:	6013      	str	r3, [r2, #0]
        }
      }

      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
90009728:	69bb      	ldr	r3, [r7, #24]
9000972a:	015a      	lsls	r2, r3, #5
9000972c:	69fb      	ldr	r3, [r7, #28]
9000972e:	4413      	add	r3, r2
90009730:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009734:	681b      	ldr	r3, [r3, #0]
90009736:	69ba      	ldr	r2, [r7, #24]
90009738:	0151      	lsls	r1, r2, #5
9000973a:	69fa      	ldr	r2, [r7, #28]
9000973c:	440a      	add	r2, r1
9000973e:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
90009742:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
90009746:	6013      	str	r3, [r2, #0]
90009748:	e169      	b.n	90009a1e <USB_EPStartXfer+0x532>
    }
    else
    {
      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
9000974a:	69bb      	ldr	r3, [r7, #24]
9000974c:	015a      	lsls	r2, r3, #5
9000974e:	69fb      	ldr	r3, [r7, #28]
90009750:	4413      	add	r3, r2
90009752:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009756:	681b      	ldr	r3, [r3, #0]
90009758:	69ba      	ldr	r2, [r7, #24]
9000975a:	0151      	lsls	r1, r2, #5
9000975c:	69fa      	ldr	r2, [r7, #28]
9000975e:	440a      	add	r2, r1
90009760:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
90009764:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
90009768:	6013      	str	r3, [r2, #0]

      if (ep->type != EP_TYPE_ISOC)
9000976a:	68bb      	ldr	r3, [r7, #8]
9000976c:	791b      	ldrb	r3, [r3, #4]
9000976e:	2b01      	cmp	r3, #1
90009770:	d015      	beq.n	9000979e <USB_EPStartXfer+0x2b2>
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0U)
90009772:	68bb      	ldr	r3, [r7, #8]
90009774:	691b      	ldr	r3, [r3, #16]
90009776:	2b00      	cmp	r3, #0
90009778:	f000 8151 	beq.w	90009a1e <USB_EPStartXfer+0x532>
        {
          USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
9000977c:	69fb      	ldr	r3, [r7, #28]
9000977e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90009782:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
90009784:	68bb      	ldr	r3, [r7, #8]
90009786:	781b      	ldrb	r3, [r3, #0]
90009788:	f003 030f 	and.w	r3, r3, #15
9000978c:	2101      	movs	r1, #1
9000978e:	fa01 f303 	lsl.w	r3, r1, r3
90009792:	69f9      	ldr	r1, [r7, #28]
90009794:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
90009798:	4313      	orrs	r3, r2
9000979a:	634b      	str	r3, [r1, #52]	@ 0x34
9000979c:	e13f      	b.n	90009a1e <USB_EPStartXfer+0x532>
        }
      }
      else
      {
        if ((USBx_DEVICE->DSTS & (1UL << 8)) == 0U)
9000979e:	69fb      	ldr	r3, [r7, #28]
900097a0:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
900097a4:	689b      	ldr	r3, [r3, #8]
900097a6:	f403 7380 	and.w	r3, r3, #256	@ 0x100
900097aa:	2b00      	cmp	r3, #0
900097ac:	d116      	bne.n	900097dc <USB_EPStartXfer+0x2f0>
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
900097ae:	69bb      	ldr	r3, [r7, #24]
900097b0:	015a      	lsls	r2, r3, #5
900097b2:	69fb      	ldr	r3, [r7, #28]
900097b4:	4413      	add	r3, r2
900097b6:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
900097ba:	681b      	ldr	r3, [r3, #0]
900097bc:	69ba      	ldr	r2, [r7, #24]
900097be:	0151      	lsls	r1, r2, #5
900097c0:	69fa      	ldr	r2, [r7, #28]
900097c2:	440a      	add	r2, r1
900097c4:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
900097c8:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
900097cc:	6013      	str	r3, [r2, #0]
900097ce:	e015      	b.n	900097fc <USB_EPStartXfer+0x310>
900097d0:	e007ffff 	.word	0xe007ffff
900097d4:	fff80000 	.word	0xfff80000
900097d8:	1ff80000 	.word	0x1ff80000
        }
        else
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
900097dc:	69bb      	ldr	r3, [r7, #24]
900097de:	015a      	lsls	r2, r3, #5
900097e0:	69fb      	ldr	r3, [r7, #28]
900097e2:	4413      	add	r3, r2
900097e4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
900097e8:	681b      	ldr	r3, [r3, #0]
900097ea:	69ba      	ldr	r2, [r7, #24]
900097ec:	0151      	lsls	r1, r2, #5
900097ee:	69fa      	ldr	r2, [r7, #28]
900097f0:	440a      	add	r2, r1
900097f2:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
900097f6:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
900097fa:	6013      	str	r3, [r2, #0]
        }

        (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);
900097fc:	68bb      	ldr	r3, [r7, #8]
900097fe:	68d9      	ldr	r1, [r3, #12]
90009800:	68bb      	ldr	r3, [r7, #8]
90009802:	781a      	ldrb	r2, [r3, #0]
90009804:	68bb      	ldr	r3, [r7, #8]
90009806:	691b      	ldr	r3, [r3, #16]
90009808:	b298      	uxth	r0, r3
9000980a:	79fb      	ldrb	r3, [r7, #7]
9000980c:	9300      	str	r3, [sp, #0]
9000980e:	4603      	mov	r3, r0
90009810:	68f8      	ldr	r0, [r7, #12]
90009812:	f000 fae0 	bl	90009dd6 <USB_WritePacket>
90009816:	e102      	b.n	90009a1e <USB_EPStartXfer+0x532>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
90009818:	69bb      	ldr	r3, [r7, #24]
9000981a:	015a      	lsls	r2, r3, #5
9000981c:	69fb      	ldr	r3, [r7, #28]
9000981e:	4413      	add	r3, r2
90009820:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009824:	691a      	ldr	r2, [r3, #16]
90009826:	69bb      	ldr	r3, [r7, #24]
90009828:	0159      	lsls	r1, r3, #5
9000982a:	69fb      	ldr	r3, [r7, #28]
9000982c:	440b      	add	r3, r1
9000982e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009832:	4619      	mov	r1, r3
90009834:	4b7c      	ldr	r3, [pc, #496]	@ (90009a28 <USB_EPStartXfer+0x53c>)
90009836:	4013      	ands	r3, r2
90009838:	610b      	str	r3, [r1, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
9000983a:	69bb      	ldr	r3, [r7, #24]
9000983c:	015a      	lsls	r2, r3, #5
9000983e:	69fb      	ldr	r3, [r7, #28]
90009840:	4413      	add	r3, r2
90009842:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009846:	691a      	ldr	r2, [r3, #16]
90009848:	69bb      	ldr	r3, [r7, #24]
9000984a:	0159      	lsls	r1, r3, #5
9000984c:	69fb      	ldr	r3, [r7, #28]
9000984e:	440b      	add	r3, r1
90009850:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009854:	4619      	mov	r1, r3
90009856:	4b75      	ldr	r3, [pc, #468]	@ (90009a2c <USB_EPStartXfer+0x540>)
90009858:	4013      	ands	r3, r2
9000985a:	610b      	str	r3, [r1, #16]

    if (epnum == 0U)
9000985c:	69bb      	ldr	r3, [r7, #24]
9000985e:	2b00      	cmp	r3, #0
90009860:	d12f      	bne.n	900098c2 <USB_EPStartXfer+0x3d6>
    {
      if (ep->xfer_len > 0U)
90009862:	68bb      	ldr	r3, [r7, #8]
90009864:	691b      	ldr	r3, [r3, #16]
90009866:	2b00      	cmp	r3, #0
90009868:	d003      	beq.n	90009872 <USB_EPStartXfer+0x386>
      {
        ep->xfer_len = ep->maxpacket;
9000986a:	68bb      	ldr	r3, [r7, #8]
9000986c:	689a      	ldr	r2, [r3, #8]
9000986e:	68bb      	ldr	r3, [r7, #8]
90009870:	611a      	str	r2, [r3, #16]
      }

      /* Store transfer size, for EP0 this is equal to endpoint max packet size */
      ep->xfer_size = ep->maxpacket;
90009872:	68bb      	ldr	r3, [r7, #8]
90009874:	689a      	ldr	r2, [r3, #8]
90009876:	68bb      	ldr	r3, [r7, #8]
90009878:	621a      	str	r2, [r3, #32]

      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size);
9000987a:	69bb      	ldr	r3, [r7, #24]
9000987c:	015a      	lsls	r2, r3, #5
9000987e:	69fb      	ldr	r3, [r7, #28]
90009880:	4413      	add	r3, r2
90009882:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009886:	691a      	ldr	r2, [r3, #16]
90009888:	68bb      	ldr	r3, [r7, #8]
9000988a:	6a1b      	ldr	r3, [r3, #32]
9000988c:	f3c3 0312 	ubfx	r3, r3, #0, #19
90009890:	69b9      	ldr	r1, [r7, #24]
90009892:	0148      	lsls	r0, r1, #5
90009894:	69f9      	ldr	r1, [r7, #28]
90009896:	4401      	add	r1, r0
90009898:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
9000989c:	4313      	orrs	r3, r2
9000989e:	610b      	str	r3, [r1, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1UL << 19));
900098a0:	69bb      	ldr	r3, [r7, #24]
900098a2:	015a      	lsls	r2, r3, #5
900098a4:	69fb      	ldr	r3, [r7, #28]
900098a6:	4413      	add	r3, r2
900098a8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
900098ac:	691b      	ldr	r3, [r3, #16]
900098ae:	69ba      	ldr	r2, [r7, #24]
900098b0:	0151      	lsls	r1, r2, #5
900098b2:	69fa      	ldr	r2, [r7, #28]
900098b4:	440a      	add	r2, r1
900098b6:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
900098ba:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
900098be:	6113      	str	r3, [r2, #16]
900098c0:	e05f      	b.n	90009982 <USB_EPStartXfer+0x496>
    }
    else
    {
      if (ep->xfer_len == 0U)
900098c2:	68bb      	ldr	r3, [r7, #8]
900098c4:	691b      	ldr	r3, [r3, #16]
900098c6:	2b00      	cmp	r3, #0
900098c8:	d123      	bne.n	90009912 <USB_EPStartXfer+0x426>
      {
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
900098ca:	69bb      	ldr	r3, [r7, #24]
900098cc:	015a      	lsls	r2, r3, #5
900098ce:	69fb      	ldr	r3, [r7, #28]
900098d0:	4413      	add	r3, r2
900098d2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
900098d6:	691a      	ldr	r2, [r3, #16]
900098d8:	68bb      	ldr	r3, [r7, #8]
900098da:	689b      	ldr	r3, [r3, #8]
900098dc:	f3c3 0312 	ubfx	r3, r3, #0, #19
900098e0:	69b9      	ldr	r1, [r7, #24]
900098e2:	0148      	lsls	r0, r1, #5
900098e4:	69f9      	ldr	r1, [r7, #28]
900098e6:	4401      	add	r1, r0
900098e8:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
900098ec:	4313      	orrs	r3, r2
900098ee:	610b      	str	r3, [r1, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1UL << 19));
900098f0:	69bb      	ldr	r3, [r7, #24]
900098f2:	015a      	lsls	r2, r3, #5
900098f4:	69fb      	ldr	r3, [r7, #28]
900098f6:	4413      	add	r3, r2
900098f8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
900098fc:	691b      	ldr	r3, [r3, #16]
900098fe:	69ba      	ldr	r2, [r7, #24]
90009900:	0151      	lsls	r1, r2, #5
90009902:	69fa      	ldr	r2, [r7, #28]
90009904:	440a      	add	r2, r1
90009906:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
9000990a:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
9000990e:	6113      	str	r3, [r2, #16]
90009910:	e037      	b.n	90009982 <USB_EPStartXfer+0x496>
      }
      else
      {
        pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
90009912:	68bb      	ldr	r3, [r7, #8]
90009914:	691a      	ldr	r2, [r3, #16]
90009916:	68bb      	ldr	r3, [r7, #8]
90009918:	689b      	ldr	r3, [r3, #8]
9000991a:	4413      	add	r3, r2
9000991c:	1e5a      	subs	r2, r3, #1
9000991e:	68bb      	ldr	r3, [r7, #8]
90009920:	689b      	ldr	r3, [r3, #8]
90009922:	fbb2 f3f3 	udiv	r3, r2, r3
90009926:	82fb      	strh	r3, [r7, #22]
        ep->xfer_size = ep->maxpacket * pktcnt;
90009928:	68bb      	ldr	r3, [r7, #8]
9000992a:	689b      	ldr	r3, [r3, #8]
9000992c:	8afa      	ldrh	r2, [r7, #22]
9000992e:	fb03 f202 	mul.w	r2, r3, r2
90009932:	68bb      	ldr	r3, [r7, #8]
90009934:	621a      	str	r2, [r3, #32]

        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
90009936:	69bb      	ldr	r3, [r7, #24]
90009938:	015a      	lsls	r2, r3, #5
9000993a:	69fb      	ldr	r3, [r7, #28]
9000993c:	4413      	add	r3, r2
9000993e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009942:	691a      	ldr	r2, [r3, #16]
90009944:	8afb      	ldrh	r3, [r7, #22]
90009946:	04d9      	lsls	r1, r3, #19
90009948:	4b39      	ldr	r3, [pc, #228]	@ (90009a30 <USB_EPStartXfer+0x544>)
9000994a:	400b      	ands	r3, r1
9000994c:	69b9      	ldr	r1, [r7, #24]
9000994e:	0148      	lsls	r0, r1, #5
90009950:	69f9      	ldr	r1, [r7, #28]
90009952:	4401      	add	r1, r0
90009954:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
90009958:	4313      	orrs	r3, r2
9000995a:	610b      	str	r3, [r1, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size;
9000995c:	69bb      	ldr	r3, [r7, #24]
9000995e:	015a      	lsls	r2, r3, #5
90009960:	69fb      	ldr	r3, [r7, #28]
90009962:	4413      	add	r3, r2
90009964:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009968:	691a      	ldr	r2, [r3, #16]
9000996a:	68bb      	ldr	r3, [r7, #8]
9000996c:	6a1b      	ldr	r3, [r3, #32]
9000996e:	f3c3 0312 	ubfx	r3, r3, #0, #19
90009972:	69b9      	ldr	r1, [r7, #24]
90009974:	0148      	lsls	r0, r1, #5
90009976:	69f9      	ldr	r1, [r7, #28]
90009978:	4401      	add	r1, r0
9000997a:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
9000997e:	4313      	orrs	r3, r2
90009980:	610b      	str	r3, [r1, #16]
      }
    }

    if (dma == 1U)
90009982:	79fb      	ldrb	r3, [r7, #7]
90009984:	2b01      	cmp	r3, #1
90009986:	d10d      	bne.n	900099a4 <USB_EPStartXfer+0x4b8>
    {
      if ((uint32_t)ep->xfer_buff != 0U)
90009988:	68bb      	ldr	r3, [r7, #8]
9000998a:	68db      	ldr	r3, [r3, #12]
9000998c:	2b00      	cmp	r3, #0
9000998e:	d009      	beq.n	900099a4 <USB_EPStartXfer+0x4b8>
      {
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
90009990:	68bb      	ldr	r3, [r7, #8]
90009992:	68d9      	ldr	r1, [r3, #12]
90009994:	69bb      	ldr	r3, [r7, #24]
90009996:	015a      	lsls	r2, r3, #5
90009998:	69fb      	ldr	r3, [r7, #28]
9000999a:	4413      	add	r3, r2
9000999c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
900099a0:	460a      	mov	r2, r1
900099a2:	615a      	str	r2, [r3, #20]
      }
    }

    if (ep->type == EP_TYPE_ISOC)
900099a4:	68bb      	ldr	r3, [r7, #8]
900099a6:	791b      	ldrb	r3, [r3, #4]
900099a8:	2b01      	cmp	r3, #1
900099aa:	d128      	bne.n	900099fe <USB_EPStartXfer+0x512>
    {
      if ((USBx_DEVICE->DSTS & (1UL << 8)) == 0U)
900099ac:	69fb      	ldr	r3, [r7, #28]
900099ae:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
900099b2:	689b      	ldr	r3, [r3, #8]
900099b4:	f403 7380 	and.w	r3, r3, #256	@ 0x100
900099b8:	2b00      	cmp	r3, #0
900099ba:	d110      	bne.n	900099de <USB_EPStartXfer+0x4f2>
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
900099bc:	69bb      	ldr	r3, [r7, #24]
900099be:	015a      	lsls	r2, r3, #5
900099c0:	69fb      	ldr	r3, [r7, #28]
900099c2:	4413      	add	r3, r2
900099c4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
900099c8:	681b      	ldr	r3, [r3, #0]
900099ca:	69ba      	ldr	r2, [r7, #24]
900099cc:	0151      	lsls	r1, r2, #5
900099ce:	69fa      	ldr	r2, [r7, #28]
900099d0:	440a      	add	r2, r1
900099d2:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
900099d6:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
900099da:	6013      	str	r3, [r2, #0]
900099dc:	e00f      	b.n	900099fe <USB_EPStartXfer+0x512>
      }
      else
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
900099de:	69bb      	ldr	r3, [r7, #24]
900099e0:	015a      	lsls	r2, r3, #5
900099e2:	69fb      	ldr	r3, [r7, #28]
900099e4:	4413      	add	r3, r2
900099e6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
900099ea:	681b      	ldr	r3, [r3, #0]
900099ec:	69ba      	ldr	r2, [r7, #24]
900099ee:	0151      	lsls	r1, r2, #5
900099f0:	69fa      	ldr	r2, [r7, #28]
900099f2:	440a      	add	r2, r1
900099f4:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
900099f8:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
900099fc:	6013      	str	r3, [r2, #0]
      }
    }
    /* EP enable */
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
900099fe:	69bb      	ldr	r3, [r7, #24]
90009a00:	015a      	lsls	r2, r3, #5
90009a02:	69fb      	ldr	r3, [r7, #28]
90009a04:	4413      	add	r3, r2
90009a06:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009a0a:	681b      	ldr	r3, [r3, #0]
90009a0c:	69ba      	ldr	r2, [r7, #24]
90009a0e:	0151      	lsls	r1, r2, #5
90009a10:	69fa      	ldr	r2, [r7, #28]
90009a12:	440a      	add	r2, r1
90009a14:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
90009a18:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
90009a1c:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
90009a1e:	2300      	movs	r3, #0
}
90009a20:	4618      	mov	r0, r3
90009a22:	3720      	adds	r7, #32
90009a24:	46bd      	mov	sp, r7
90009a26:	bd80      	pop	{r7, pc}
90009a28:	fff80000 	.word	0xfff80000
90009a2c:	e007ffff 	.word	0xe007ffff
90009a30:	1ff80000 	.word	0x1ff80000

90009a34 <USB_EPStopXfer>:
   * @param  USBx  usb device instance
   * @param  ep pointer to endpoint structure
   * @retval HAL status
   */
HAL_StatusTypeDef USB_EPStopXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
90009a34:	b480      	push	{r7}
90009a36:	b089      	sub	sp, #36	@ 0x24
90009a38:	af00      	add	r7, sp, #0
90009a3a:	6078      	str	r0, [r7, #4]
90009a3c:	6039      	str	r1, [r7, #0]
  __IO uint32_t count = 0U;
90009a3e:	2300      	movs	r3, #0
90009a40:	613b      	str	r3, [r7, #16]
  __IO uint32_t RegVal;
  HAL_StatusTypeDef ret = HAL_OK;
90009a42:	2300      	movs	r3, #0
90009a44:	77fb      	strb	r3, [r7, #31]
  uint32_t USBx_BASE = (uint32_t)USBx;
90009a46:	687b      	ldr	r3, [r7, #4]
90009a48:	61bb      	str	r3, [r7, #24]
  uint32_t dma_enable = (USBx->GAHBCFG & USB_OTG_GAHBCFG_DMAEN) >> 0x5U;
90009a4a:	687b      	ldr	r3, [r7, #4]
90009a4c:	689b      	ldr	r3, [r3, #8]
90009a4e:	095b      	lsrs	r3, r3, #5
90009a50:	f003 0301 	and.w	r3, r3, #1
90009a54:	617b      	str	r3, [r7, #20]

  /* IN endpoint */
  if (ep->is_in == 1U)
90009a56:	683b      	ldr	r3, [r7, #0]
90009a58:	785b      	ldrb	r3, [r3, #1]
90009a5a:	2b01      	cmp	r3, #1
90009a5c:	d149      	bne.n	90009af2 <USB_EPStopXfer+0xbe>
  {
    /* EP enable, IN data in FIFO */
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
90009a5e:	683b      	ldr	r3, [r7, #0]
90009a60:	781b      	ldrb	r3, [r3, #0]
90009a62:	015a      	lsls	r2, r3, #5
90009a64:	69bb      	ldr	r3, [r7, #24]
90009a66:	4413      	add	r3, r2
90009a68:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009a6c:	681b      	ldr	r3, [r3, #0]
90009a6e:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
90009a72:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
90009a76:	f040 80d3 	bne.w	90009c20 <USB_EPStopXfer+0x1ec>
    {
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_SNAK);
90009a7a:	683b      	ldr	r3, [r7, #0]
90009a7c:	781b      	ldrb	r3, [r3, #0]
90009a7e:	015a      	lsls	r2, r3, #5
90009a80:	69bb      	ldr	r3, [r7, #24]
90009a82:	4413      	add	r3, r2
90009a84:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009a88:	681b      	ldr	r3, [r3, #0]
90009a8a:	683a      	ldr	r2, [r7, #0]
90009a8c:	7812      	ldrb	r2, [r2, #0]
90009a8e:	0151      	lsls	r1, r2, #5
90009a90:	69ba      	ldr	r2, [r7, #24]
90009a92:	440a      	add	r2, r1
90009a94:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
90009a98:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
90009a9c:	6013      	str	r3, [r2, #0]
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_EPDIS);
90009a9e:	683b      	ldr	r3, [r7, #0]
90009aa0:	781b      	ldrb	r3, [r3, #0]
90009aa2:	015a      	lsls	r2, r3, #5
90009aa4:	69bb      	ldr	r3, [r7, #24]
90009aa6:	4413      	add	r3, r2
90009aa8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009aac:	681b      	ldr	r3, [r3, #0]
90009aae:	683a      	ldr	r2, [r7, #0]
90009ab0:	7812      	ldrb	r2, [r2, #0]
90009ab2:	0151      	lsls	r1, r2, #5
90009ab4:	69ba      	ldr	r2, [r7, #24]
90009ab6:	440a      	add	r2, r1
90009ab8:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
90009abc:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
90009ac0:	6013      	str	r3, [r2, #0]

      do
      {
        count++;
90009ac2:	693b      	ldr	r3, [r7, #16]
90009ac4:	3301      	adds	r3, #1
90009ac6:	613b      	str	r3, [r7, #16]

        if (count > 0xF0000U)
90009ac8:	693b      	ldr	r3, [r7, #16]
90009aca:	f5b3 2f70 	cmp.w	r3, #983040	@ 0xf0000
90009ace:	d902      	bls.n	90009ad6 <USB_EPStopXfer+0xa2>
        {
          ret = HAL_ERROR;
90009ad0:	2301      	movs	r3, #1
90009ad2:	77fb      	strb	r3, [r7, #31]
          break;
90009ad4:	e0a4      	b.n	90009c20 <USB_EPStopXfer+0x1ec>
        }
      } while (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA);
90009ad6:	683b      	ldr	r3, [r7, #0]
90009ad8:	781b      	ldrb	r3, [r3, #0]
90009ada:	015a      	lsls	r2, r3, #5
90009adc:	69bb      	ldr	r3, [r7, #24]
90009ade:	4413      	add	r3, r2
90009ae0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009ae4:	681b      	ldr	r3, [r3, #0]
90009ae6:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
90009aea:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
90009aee:	d0e8      	beq.n	90009ac2 <USB_EPStopXfer+0x8e>
90009af0:	e096      	b.n	90009c20 <USB_EPStopXfer+0x1ec>
    }
  }
  else /* OUT endpoint */
  {
    USBx->GINTMSK &= ~USB_OTG_GINTMSK_GONAKEFFM;
90009af2:	687b      	ldr	r3, [r7, #4]
90009af4:	699b      	ldr	r3, [r3, #24]
90009af6:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
90009afa:	687b      	ldr	r3, [r7, #4]
90009afc:	619a      	str	r2, [r3, #24]

    if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == 0U)
90009afe:	687b      	ldr	r3, [r7, #4]
90009b00:	695b      	ldr	r3, [r3, #20]
90009b02:	f003 0380 	and.w	r3, r3, #128	@ 0x80
90009b06:	2b00      	cmp	r3, #0
90009b08:	d109      	bne.n	90009b1e <USB_EPStopXfer+0xea>
    {
      USBx_DEVICE->DCTL |= USB_OTG_DCTL_SGONAK;
90009b0a:	69bb      	ldr	r3, [r7, #24]
90009b0c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90009b10:	685b      	ldr	r3, [r3, #4]
90009b12:	69ba      	ldr	r2, [r7, #24]
90009b14:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
90009b18:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
90009b1c:	6053      	str	r3, [r2, #4]
    }

    if (dma_enable == 0U)
90009b1e:	697b      	ldr	r3, [r7, #20]
90009b20:	2b00      	cmp	r3, #0
90009b22:	d113      	bne.n	90009b4c <USB_EPStopXfer+0x118>
    {
      do
      {
        count++;
90009b24:	693b      	ldr	r3, [r7, #16]
90009b26:	3301      	adds	r3, #1
90009b28:	613b      	str	r3, [r7, #16]

        if (count > 0xF0000U)
90009b2a:	693b      	ldr	r3, [r7, #16]
90009b2c:	f5b3 2f70 	cmp.w	r3, #983040	@ 0xf0000
90009b30:	d902      	bls.n	90009b38 <USB_EPStopXfer+0x104>
        {
          ret = HAL_ERROR;
90009b32:	2301      	movs	r3, #1
90009b34:	77fb      	strb	r3, [r7, #31]
          break;
90009b36:	e005      	b.n	90009b44 <USB_EPStopXfer+0x110>
        }
      } while (((USBx->GINTSTS & USB_OTG_GINTSTS_RXFLVL) & USB_OTG_GINTSTS_RXFLVL) != USB_OTG_GINTSTS_RXFLVL);
90009b38:	687b      	ldr	r3, [r7, #4]
90009b3a:	695b      	ldr	r3, [r3, #20]
90009b3c:	f003 0310 	and.w	r3, r3, #16
90009b40:	2b10      	cmp	r3, #16
90009b42:	d1ef      	bne.n	90009b24 <USB_EPStopXfer+0xf0>

      /* POP the RX status register to generate the NAK Effective interrupt */
      RegVal = USBx->GRXSTSP;
90009b44:	687b      	ldr	r3, [r7, #4]
90009b46:	6a1b      	ldr	r3, [r3, #32]
90009b48:	60fb      	str	r3, [r7, #12]
      UNUSED(RegVal);
90009b4a:	68fb      	ldr	r3, [r7, #12]
    }

    /* Wait for Global NAK effective to be set */
    count = 0U;
90009b4c:	2300      	movs	r3, #0
90009b4e:	613b      	str	r3, [r7, #16]

    do
    {
      count++;
90009b50:	693b      	ldr	r3, [r7, #16]
90009b52:	3301      	adds	r3, #1
90009b54:	613b      	str	r3, [r7, #16]

      if (count > 0xF0000U)
90009b56:	693b      	ldr	r3, [r7, #16]
90009b58:	f5b3 2f70 	cmp.w	r3, #983040	@ 0xf0000
90009b5c:	d902      	bls.n	90009b64 <USB_EPStopXfer+0x130>
      {
        ret = HAL_ERROR;
90009b5e:	2301      	movs	r3, #1
90009b60:	77fb      	strb	r3, [r7, #31]
        break;
90009b62:	e005      	b.n	90009b70 <USB_EPStopXfer+0x13c>
      }
    } while (((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF)
90009b64:	687b      	ldr	r3, [r7, #4]
90009b66:	695b      	ldr	r3, [r3, #20]
              & USB_OTG_GINTSTS_BOUTNAKEFF) != USB_OTG_GINTSTS_BOUTNAKEFF);
90009b68:	f003 0380 	and.w	r3, r3, #128	@ 0x80
90009b6c:	2b80      	cmp	r3, #128	@ 0x80
90009b6e:	d1ef      	bne.n	90009b50 <USB_EPStopXfer+0x11c>

    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_SNAK);
90009b70:	683b      	ldr	r3, [r7, #0]
90009b72:	781b      	ldrb	r3, [r3, #0]
90009b74:	015a      	lsls	r2, r3, #5
90009b76:	69bb      	ldr	r3, [r7, #24]
90009b78:	4413      	add	r3, r2
90009b7a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009b7e:	681b      	ldr	r3, [r3, #0]
90009b80:	683a      	ldr	r2, [r7, #0]
90009b82:	7812      	ldrb	r2, [r2, #0]
90009b84:	0151      	lsls	r1, r2, #5
90009b86:	69ba      	ldr	r2, [r7, #24]
90009b88:	440a      	add	r2, r1
90009b8a:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
90009b8e:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
90009b92:	6013      	str	r3, [r2, #0]
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_EPDIS);
90009b94:	683b      	ldr	r3, [r7, #0]
90009b96:	781b      	ldrb	r3, [r3, #0]
90009b98:	015a      	lsls	r2, r3, #5
90009b9a:	69bb      	ldr	r3, [r7, #24]
90009b9c:	4413      	add	r3, r2
90009b9e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009ba2:	681b      	ldr	r3, [r3, #0]
90009ba4:	683a      	ldr	r2, [r7, #0]
90009ba6:	7812      	ldrb	r2, [r2, #0]
90009ba8:	0151      	lsls	r1, r2, #5
90009baa:	69ba      	ldr	r2, [r7, #24]
90009bac:	440a      	add	r2, r1
90009bae:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
90009bb2:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
90009bb6:	6013      	str	r3, [r2, #0]

    /* Wait for EP disable to take effect */
    count = 0U;
90009bb8:	2300      	movs	r3, #0
90009bba:	613b      	str	r3, [r7, #16]

    do
    {
      count++;
90009bbc:	693b      	ldr	r3, [r7, #16]
90009bbe:	3301      	adds	r3, #1
90009bc0:	613b      	str	r3, [r7, #16]

      if (count > 0xF0000U)
90009bc2:	693b      	ldr	r3, [r7, #16]
90009bc4:	f5b3 2f70 	cmp.w	r3, #983040	@ 0xf0000
90009bc8:	d902      	bls.n	90009bd0 <USB_EPStopXfer+0x19c>
      {
        ret = HAL_ERROR;
90009bca:	2301      	movs	r3, #1
90009bcc:	77fb      	strb	r3, [r7, #31]
        break;
90009bce:	e00b      	b.n	90009be8 <USB_EPStopXfer+0x1b4>
      }
    } while (((USBx_OUTEP(ep->num)->DOEPINT & USB_OTG_DOEPINT_EPDISD)
90009bd0:	683b      	ldr	r3, [r7, #0]
90009bd2:	781b      	ldrb	r3, [r3, #0]
90009bd4:	015a      	lsls	r2, r3, #5
90009bd6:	69bb      	ldr	r3, [r7, #24]
90009bd8:	4413      	add	r3, r2
90009bda:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009bde:	689b      	ldr	r3, [r3, #8]
              & USB_OTG_DOEPINT_EPDISD) != USB_OTG_DOEPINT_EPDISD);
90009be0:	f003 0302 	and.w	r3, r3, #2
90009be4:	2b02      	cmp	r3, #2
90009be6:	d1e9      	bne.n	90009bbc <USB_EPStopXfer+0x188>

    /* Clear OUT EP disable interrupt */
    USBx_OUTEP(ep->num)->DOEPINT |= USB_OTG_DOEPINT_EPDISD;
90009be8:	683b      	ldr	r3, [r7, #0]
90009bea:	781b      	ldrb	r3, [r3, #0]
90009bec:	015a      	lsls	r2, r3, #5
90009bee:	69bb      	ldr	r3, [r7, #24]
90009bf0:	4413      	add	r3, r2
90009bf2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009bf6:	689b      	ldr	r3, [r3, #8]
90009bf8:	683a      	ldr	r2, [r7, #0]
90009bfa:	7812      	ldrb	r2, [r2, #0]
90009bfc:	0151      	lsls	r1, r2, #5
90009bfe:	69ba      	ldr	r2, [r7, #24]
90009c00:	440a      	add	r2, r1
90009c02:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
90009c06:	f043 0302 	orr.w	r3, r3, #2
90009c0a:	6093      	str	r3, [r2, #8]

    /* Clear Global OUT NAK */
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
90009c0c:	69bb      	ldr	r3, [r7, #24]
90009c0e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90009c12:	685b      	ldr	r3, [r3, #4]
90009c14:	69ba      	ldr	r2, [r7, #24]
90009c16:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
90009c1a:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
90009c1e:	6053      	str	r3, [r2, #4]
  }

  return ret;
90009c20:	7ffb      	ldrb	r3, [r7, #31]
}
90009c22:	4618      	mov	r0, r3
90009c24:	3724      	adds	r7, #36	@ 0x24
90009c26:	46bd      	mov	sp, r7
90009c28:	f85d 7b04 	ldr.w	r7, [sp], #4
90009c2c:	4770      	bx	lr

90009c2e <USB_EPSetStall>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
90009c2e:	b480      	push	{r7}
90009c30:	b085      	sub	sp, #20
90009c32:	af00      	add	r7, sp, #0
90009c34:	6078      	str	r0, [r7, #4]
90009c36:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
90009c38:	687b      	ldr	r3, [r7, #4]
90009c3a:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
90009c3c:	683b      	ldr	r3, [r7, #0]
90009c3e:	781b      	ldrb	r3, [r3, #0]
90009c40:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
90009c42:	683b      	ldr	r3, [r7, #0]
90009c44:	785b      	ldrb	r3, [r3, #1]
90009c46:	2b01      	cmp	r3, #1
90009c48:	d12c      	bne.n	90009ca4 <USB_EPSetStall+0x76>
  {
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
90009c4a:	68bb      	ldr	r3, [r7, #8]
90009c4c:	015a      	lsls	r2, r3, #5
90009c4e:	68fb      	ldr	r3, [r7, #12]
90009c50:	4413      	add	r3, r2
90009c52:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009c56:	681b      	ldr	r3, [r3, #0]
90009c58:	2b00      	cmp	r3, #0
90009c5a:	db12      	blt.n	90009c82 <USB_EPSetStall+0x54>
90009c5c:	68bb      	ldr	r3, [r7, #8]
90009c5e:	2b00      	cmp	r3, #0
90009c60:	d00f      	beq.n	90009c82 <USB_EPSetStall+0x54>
    {
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
90009c62:	68bb      	ldr	r3, [r7, #8]
90009c64:	015a      	lsls	r2, r3, #5
90009c66:	68fb      	ldr	r3, [r7, #12]
90009c68:	4413      	add	r3, r2
90009c6a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009c6e:	681b      	ldr	r3, [r3, #0]
90009c70:	68ba      	ldr	r2, [r7, #8]
90009c72:	0151      	lsls	r1, r2, #5
90009c74:	68fa      	ldr	r2, [r7, #12]
90009c76:	440a      	add	r2, r1
90009c78:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
90009c7c:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
90009c80:	6013      	str	r3, [r2, #0]
    }
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
90009c82:	68bb      	ldr	r3, [r7, #8]
90009c84:	015a      	lsls	r2, r3, #5
90009c86:	68fb      	ldr	r3, [r7, #12]
90009c88:	4413      	add	r3, r2
90009c8a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009c8e:	681b      	ldr	r3, [r3, #0]
90009c90:	68ba      	ldr	r2, [r7, #8]
90009c92:	0151      	lsls	r1, r2, #5
90009c94:	68fa      	ldr	r2, [r7, #12]
90009c96:	440a      	add	r2, r1
90009c98:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
90009c9c:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
90009ca0:	6013      	str	r3, [r2, #0]
90009ca2:	e02b      	b.n	90009cfc <USB_EPSetStall+0xce>
  }
  else
  {
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
90009ca4:	68bb      	ldr	r3, [r7, #8]
90009ca6:	015a      	lsls	r2, r3, #5
90009ca8:	68fb      	ldr	r3, [r7, #12]
90009caa:	4413      	add	r3, r2
90009cac:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009cb0:	681b      	ldr	r3, [r3, #0]
90009cb2:	2b00      	cmp	r3, #0
90009cb4:	db12      	blt.n	90009cdc <USB_EPSetStall+0xae>
90009cb6:	68bb      	ldr	r3, [r7, #8]
90009cb8:	2b00      	cmp	r3, #0
90009cba:	d00f      	beq.n	90009cdc <USB_EPSetStall+0xae>
    {
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
90009cbc:	68bb      	ldr	r3, [r7, #8]
90009cbe:	015a      	lsls	r2, r3, #5
90009cc0:	68fb      	ldr	r3, [r7, #12]
90009cc2:	4413      	add	r3, r2
90009cc4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009cc8:	681b      	ldr	r3, [r3, #0]
90009cca:	68ba      	ldr	r2, [r7, #8]
90009ccc:	0151      	lsls	r1, r2, #5
90009cce:	68fa      	ldr	r2, [r7, #12]
90009cd0:	440a      	add	r2, r1
90009cd2:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
90009cd6:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
90009cda:	6013      	str	r3, [r2, #0]
    }
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
90009cdc:	68bb      	ldr	r3, [r7, #8]
90009cde:	015a      	lsls	r2, r3, #5
90009ce0:	68fb      	ldr	r3, [r7, #12]
90009ce2:	4413      	add	r3, r2
90009ce4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009ce8:	681b      	ldr	r3, [r3, #0]
90009cea:	68ba      	ldr	r2, [r7, #8]
90009cec:	0151      	lsls	r1, r2, #5
90009cee:	68fa      	ldr	r2, [r7, #12]
90009cf0:	440a      	add	r2, r1
90009cf2:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
90009cf6:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
90009cfa:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
90009cfc:	2300      	movs	r3, #0
}
90009cfe:	4618      	mov	r0, r3
90009d00:	3714      	adds	r7, #20
90009d02:	46bd      	mov	sp, r7
90009d04:	f85d 7b04 	ldr.w	r7, [sp], #4
90009d08:	4770      	bx	lr

90009d0a <USB_EPClearStall>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
90009d0a:	b480      	push	{r7}
90009d0c:	b085      	sub	sp, #20
90009d0e:	af00      	add	r7, sp, #0
90009d10:	6078      	str	r0, [r7, #4]
90009d12:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
90009d14:	687b      	ldr	r3, [r7, #4]
90009d16:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
90009d18:	683b      	ldr	r3, [r7, #0]
90009d1a:	781b      	ldrb	r3, [r3, #0]
90009d1c:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
90009d1e:	683b      	ldr	r3, [r7, #0]
90009d20:	785b      	ldrb	r3, [r3, #1]
90009d22:	2b01      	cmp	r3, #1
90009d24:	d128      	bne.n	90009d78 <USB_EPClearStall+0x6e>
  {
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
90009d26:	68bb      	ldr	r3, [r7, #8]
90009d28:	015a      	lsls	r2, r3, #5
90009d2a:	68fb      	ldr	r3, [r7, #12]
90009d2c:	4413      	add	r3, r2
90009d2e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009d32:	681b      	ldr	r3, [r3, #0]
90009d34:	68ba      	ldr	r2, [r7, #8]
90009d36:	0151      	lsls	r1, r2, #5
90009d38:	68fa      	ldr	r2, [r7, #12]
90009d3a:	440a      	add	r2, r1
90009d3c:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
90009d40:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
90009d44:	6013      	str	r3, [r2, #0]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
90009d46:	683b      	ldr	r3, [r7, #0]
90009d48:	791b      	ldrb	r3, [r3, #4]
90009d4a:	2b03      	cmp	r3, #3
90009d4c:	d003      	beq.n	90009d56 <USB_EPClearStall+0x4c>
90009d4e:	683b      	ldr	r3, [r7, #0]
90009d50:	791b      	ldrb	r3, [r3, #4]
90009d52:	2b02      	cmp	r3, #2
90009d54:	d138      	bne.n	90009dc8 <USB_EPClearStall+0xbe>
    {
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
90009d56:	68bb      	ldr	r3, [r7, #8]
90009d58:	015a      	lsls	r2, r3, #5
90009d5a:	68fb      	ldr	r3, [r7, #12]
90009d5c:	4413      	add	r3, r2
90009d5e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
90009d62:	681b      	ldr	r3, [r3, #0]
90009d64:	68ba      	ldr	r2, [r7, #8]
90009d66:	0151      	lsls	r1, r2, #5
90009d68:	68fa      	ldr	r2, [r7, #12]
90009d6a:	440a      	add	r2, r1
90009d6c:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
90009d70:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
90009d74:	6013      	str	r3, [r2, #0]
90009d76:	e027      	b.n	90009dc8 <USB_EPClearStall+0xbe>
    }
  }
  else
  {
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
90009d78:	68bb      	ldr	r3, [r7, #8]
90009d7a:	015a      	lsls	r2, r3, #5
90009d7c:	68fb      	ldr	r3, [r7, #12]
90009d7e:	4413      	add	r3, r2
90009d80:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009d84:	681b      	ldr	r3, [r3, #0]
90009d86:	68ba      	ldr	r2, [r7, #8]
90009d88:	0151      	lsls	r1, r2, #5
90009d8a:	68fa      	ldr	r2, [r7, #12]
90009d8c:	440a      	add	r2, r1
90009d8e:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
90009d92:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
90009d96:	6013      	str	r3, [r2, #0]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
90009d98:	683b      	ldr	r3, [r7, #0]
90009d9a:	791b      	ldrb	r3, [r3, #4]
90009d9c:	2b03      	cmp	r3, #3
90009d9e:	d003      	beq.n	90009da8 <USB_EPClearStall+0x9e>
90009da0:	683b      	ldr	r3, [r7, #0]
90009da2:	791b      	ldrb	r3, [r3, #4]
90009da4:	2b02      	cmp	r3, #2
90009da6:	d10f      	bne.n	90009dc8 <USB_EPClearStall+0xbe>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
90009da8:	68bb      	ldr	r3, [r7, #8]
90009daa:	015a      	lsls	r2, r3, #5
90009dac:	68fb      	ldr	r3, [r7, #12]
90009dae:	4413      	add	r3, r2
90009db0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
90009db4:	681b      	ldr	r3, [r3, #0]
90009db6:	68ba      	ldr	r2, [r7, #8]
90009db8:	0151      	lsls	r1, r2, #5
90009dba:	68fa      	ldr	r2, [r7, #12]
90009dbc:	440a      	add	r2, r1
90009dbe:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
90009dc2:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
90009dc6:	6013      	str	r3, [r2, #0]
    }
  }
  return HAL_OK;
90009dc8:	2300      	movs	r3, #0
}
90009dca:	4618      	mov	r0, r3
90009dcc:	3714      	adds	r7, #20
90009dce:	46bd      	mov	sp, r7
90009dd0:	f85d 7b04 	ldr.w	r7, [sp], #4
90009dd4:	4770      	bx	lr

90009dd6 <USB_WritePacket>:
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *src,
                                  uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
90009dd6:	b480      	push	{r7}
90009dd8:	b089      	sub	sp, #36	@ 0x24
90009dda:	af00      	add	r7, sp, #0
90009ddc:	60f8      	str	r0, [r7, #12]
90009dde:	60b9      	str	r1, [r7, #8]
90009de0:	4611      	mov	r1, r2
90009de2:	461a      	mov	r2, r3
90009de4:	460b      	mov	r3, r1
90009de6:	71fb      	strb	r3, [r7, #7]
90009de8:	4613      	mov	r3, r2
90009dea:	80bb      	strh	r3, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
90009dec:	68fb      	ldr	r3, [r7, #12]
90009dee:	617b      	str	r3, [r7, #20]
  uint8_t *pSrc = src;
90009df0:	68bb      	ldr	r3, [r7, #8]
90009df2:	61fb      	str	r3, [r7, #28]
  uint32_t count32b;
  uint32_t i;

  if (dma == 0U)
90009df4:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
90009df8:	2b00      	cmp	r3, #0
90009dfa:	d123      	bne.n	90009e44 <USB_WritePacket+0x6e>
  {
    count32b = ((uint32_t)len + 3U) / 4U;
90009dfc:	88bb      	ldrh	r3, [r7, #4]
90009dfe:	3303      	adds	r3, #3
90009e00:	089b      	lsrs	r3, r3, #2
90009e02:	613b      	str	r3, [r7, #16]
    for (i = 0U; i < count32b; i++)
90009e04:	2300      	movs	r3, #0
90009e06:	61bb      	str	r3, [r7, #24]
90009e08:	e018      	b.n	90009e3c <USB_WritePacket+0x66>
    {
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
90009e0a:	79fb      	ldrb	r3, [r7, #7]
90009e0c:	031a      	lsls	r2, r3, #12
90009e0e:	697b      	ldr	r3, [r7, #20]
90009e10:	4413      	add	r3, r2
90009e12:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
90009e16:	461a      	mov	r2, r3
90009e18:	69fb      	ldr	r3, [r7, #28]
90009e1a:	681b      	ldr	r3, [r3, #0]
90009e1c:	6013      	str	r3, [r2, #0]
      pSrc++;
90009e1e:	69fb      	ldr	r3, [r7, #28]
90009e20:	3301      	adds	r3, #1
90009e22:	61fb      	str	r3, [r7, #28]
      pSrc++;
90009e24:	69fb      	ldr	r3, [r7, #28]
90009e26:	3301      	adds	r3, #1
90009e28:	61fb      	str	r3, [r7, #28]
      pSrc++;
90009e2a:	69fb      	ldr	r3, [r7, #28]
90009e2c:	3301      	adds	r3, #1
90009e2e:	61fb      	str	r3, [r7, #28]
      pSrc++;
90009e30:	69fb      	ldr	r3, [r7, #28]
90009e32:	3301      	adds	r3, #1
90009e34:	61fb      	str	r3, [r7, #28]
    for (i = 0U; i < count32b; i++)
90009e36:	69bb      	ldr	r3, [r7, #24]
90009e38:	3301      	adds	r3, #1
90009e3a:	61bb      	str	r3, [r7, #24]
90009e3c:	69ba      	ldr	r2, [r7, #24]
90009e3e:	693b      	ldr	r3, [r7, #16]
90009e40:	429a      	cmp	r2, r3
90009e42:	d3e2      	bcc.n	90009e0a <USB_WritePacket+0x34>
    }
  }

  return HAL_OK;
90009e44:	2300      	movs	r3, #0
}
90009e46:	4618      	mov	r0, r3
90009e48:	3724      	adds	r7, #36	@ 0x24
90009e4a:	46bd      	mov	sp, r7
90009e4c:	f85d 7b04 	ldr.w	r7, [sp], #4
90009e50:	4770      	bx	lr

90009e52 <USB_ReadPacket>:
  * @param  dest  source pointer
  * @param  len  Number of bytes to read
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
90009e52:	b480      	push	{r7}
90009e54:	b08b      	sub	sp, #44	@ 0x2c
90009e56:	af00      	add	r7, sp, #0
90009e58:	60f8      	str	r0, [r7, #12]
90009e5a:	60b9      	str	r1, [r7, #8]
90009e5c:	4613      	mov	r3, r2
90009e5e:	80fb      	strh	r3, [r7, #6]
  uint32_t USBx_BASE = (uint32_t)USBx;
90009e60:	68fb      	ldr	r3, [r7, #12]
90009e62:	61bb      	str	r3, [r7, #24]
  uint8_t *pDest = dest;
90009e64:	68bb      	ldr	r3, [r7, #8]
90009e66:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pData;
  uint32_t i;
  uint32_t count32b = (uint32_t)len >> 2U;
90009e68:	88fb      	ldrh	r3, [r7, #6]
90009e6a:	089b      	lsrs	r3, r3, #2
90009e6c:	b29b      	uxth	r3, r3
90009e6e:	617b      	str	r3, [r7, #20]
  uint16_t remaining_bytes = len % 4U;
90009e70:	88fb      	ldrh	r3, [r7, #6]
90009e72:	f003 0303 	and.w	r3, r3, #3
90009e76:	83fb      	strh	r3, [r7, #30]

  for (i = 0U; i < count32b; i++)
90009e78:	2300      	movs	r3, #0
90009e7a:	623b      	str	r3, [r7, #32]
90009e7c:	e014      	b.n	90009ea8 <USB_ReadPacket+0x56>
  {
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
90009e7e:	69bb      	ldr	r3, [r7, #24]
90009e80:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
90009e84:	681a      	ldr	r2, [r3, #0]
90009e86:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
90009e88:	601a      	str	r2, [r3, #0]
    pDest++;
90009e8a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
90009e8c:	3301      	adds	r3, #1
90009e8e:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
90009e90:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
90009e92:	3301      	adds	r3, #1
90009e94:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
90009e96:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
90009e98:	3301      	adds	r3, #1
90009e9a:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
90009e9c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
90009e9e:	3301      	adds	r3, #1
90009ea0:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 0U; i < count32b; i++)
90009ea2:	6a3b      	ldr	r3, [r7, #32]
90009ea4:	3301      	adds	r3, #1
90009ea6:	623b      	str	r3, [r7, #32]
90009ea8:	6a3a      	ldr	r2, [r7, #32]
90009eaa:	697b      	ldr	r3, [r7, #20]
90009eac:	429a      	cmp	r2, r3
90009eae:	d3e6      	bcc.n	90009e7e <USB_ReadPacket+0x2c>
  }

  /* When Number of data is not word aligned, read the remaining byte */
  if (remaining_bytes != 0U)
90009eb0:	8bfb      	ldrh	r3, [r7, #30]
90009eb2:	2b00      	cmp	r3, #0
90009eb4:	d01e      	beq.n	90009ef4 <USB_ReadPacket+0xa2>
  {
    i = 0U;
90009eb6:	2300      	movs	r3, #0
90009eb8:	623b      	str	r3, [r7, #32]
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
90009eba:	69bb      	ldr	r3, [r7, #24]
90009ebc:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
90009ec0:	461a      	mov	r2, r3
90009ec2:	f107 0310 	add.w	r3, r7, #16
90009ec6:	6812      	ldr	r2, [r2, #0]
90009ec8:	601a      	str	r2, [r3, #0]

    do
    {
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
90009eca:	693a      	ldr	r2, [r7, #16]
90009ecc:	6a3b      	ldr	r3, [r7, #32]
90009ece:	b2db      	uxtb	r3, r3
90009ed0:	00db      	lsls	r3, r3, #3
90009ed2:	fa22 f303 	lsr.w	r3, r2, r3
90009ed6:	b2da      	uxtb	r2, r3
90009ed8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
90009eda:	701a      	strb	r2, [r3, #0]
      i++;
90009edc:	6a3b      	ldr	r3, [r7, #32]
90009ede:	3301      	adds	r3, #1
90009ee0:	623b      	str	r3, [r7, #32]
      pDest++;
90009ee2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
90009ee4:	3301      	adds	r3, #1
90009ee6:	627b      	str	r3, [r7, #36]	@ 0x24
      remaining_bytes--;
90009ee8:	8bfb      	ldrh	r3, [r7, #30]
90009eea:	3b01      	subs	r3, #1
90009eec:	83fb      	strh	r3, [r7, #30]
    } while (remaining_bytes != 0U);
90009eee:	8bfb      	ldrh	r3, [r7, #30]
90009ef0:	2b00      	cmp	r3, #0
90009ef2:	d1ea      	bne.n	90009eca <USB_ReadPacket+0x78>
  }

  return ((void *)pDest);
90009ef4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
90009ef6:	4618      	mov	r0, r3
90009ef8:	372c      	adds	r7, #44	@ 0x2c
90009efa:	46bd      	mov	sp, r7
90009efc:	f85d 7b04 	ldr.w	r7, [sp], #4
90009f00:	4770      	bx	lr

90009f02 <USB_SetDevAddress>:
  * @param  address  new device address to be assigned
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetDevAddress(const USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
90009f02:	b480      	push	{r7}
90009f04:	b085      	sub	sp, #20
90009f06:	af00      	add	r7, sp, #0
90009f08:	6078      	str	r0, [r7, #4]
90009f0a:	460b      	mov	r3, r1
90009f0c:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
90009f0e:	687b      	ldr	r3, [r7, #4]
90009f10:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
90009f12:	68fb      	ldr	r3, [r7, #12]
90009f14:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90009f18:	681b      	ldr	r3, [r3, #0]
90009f1a:	68fa      	ldr	r2, [r7, #12]
90009f1c:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
90009f20:	f423 63fe 	bic.w	r3, r3, #2032	@ 0x7f0
90009f24:	6013      	str	r3, [r2, #0]
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
90009f26:	68fb      	ldr	r3, [r7, #12]
90009f28:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90009f2c:	681a      	ldr	r2, [r3, #0]
90009f2e:	78fb      	ldrb	r3, [r7, #3]
90009f30:	011b      	lsls	r3, r3, #4
90009f32:	f403 63fe 	and.w	r3, r3, #2032	@ 0x7f0
90009f36:	68f9      	ldr	r1, [r7, #12]
90009f38:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
90009f3c:	4313      	orrs	r3, r2
90009f3e:	600b      	str	r3, [r1, #0]

  return HAL_OK;
90009f40:	2300      	movs	r3, #0
}
90009f42:	4618      	mov	r0, r3
90009f44:	3714      	adds	r7, #20
90009f46:	46bd      	mov	sp, r7
90009f48:	f85d 7b04 	ldr.w	r7, [sp], #4
90009f4c:	4770      	bx	lr

90009f4e <USB_DevConnect>:
  * @brief  USB_DevConnect : Connect the USB device by enabling Rpu
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevConnect(const USB_OTG_GlobalTypeDef *USBx)
{
90009f4e:	b480      	push	{r7}
90009f50:	b085      	sub	sp, #20
90009f52:	af00      	add	r7, sp, #0
90009f54:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
90009f56:	687b      	ldr	r3, [r7, #4]
90009f58:	60fb      	str	r3, [r7, #12]

  /* In case phy is stopped, ensure to ungate and restore the phy CLK */
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
90009f5a:	68fb      	ldr	r3, [r7, #12]
90009f5c:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
90009f60:	681b      	ldr	r3, [r3, #0]
90009f62:	68fa      	ldr	r2, [r7, #12]
90009f64:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
90009f68:	f023 0303 	bic.w	r3, r3, #3
90009f6c:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
90009f6e:	68fb      	ldr	r3, [r7, #12]
90009f70:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90009f74:	685b      	ldr	r3, [r3, #4]
90009f76:	68fa      	ldr	r2, [r7, #12]
90009f78:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
90009f7c:	f023 0302 	bic.w	r3, r3, #2
90009f80:	6053      	str	r3, [r2, #4]

  return HAL_OK;
90009f82:	2300      	movs	r3, #0
}
90009f84:	4618      	mov	r0, r3
90009f86:	3714      	adds	r7, #20
90009f88:	46bd      	mov	sp, r7
90009f8a:	f85d 7b04 	ldr.w	r7, [sp], #4
90009f8e:	4770      	bx	lr

90009f90 <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling Rpu
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevDisconnect(const USB_OTG_GlobalTypeDef *USBx)
{
90009f90:	b480      	push	{r7}
90009f92:	b085      	sub	sp, #20
90009f94:	af00      	add	r7, sp, #0
90009f96:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
90009f98:	687b      	ldr	r3, [r7, #4]
90009f9a:	60fb      	str	r3, [r7, #12]

  /* In case phy is stopped, ensure to ungate and restore the phy CLK */
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
90009f9c:	68fb      	ldr	r3, [r7, #12]
90009f9e:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
90009fa2:	681b      	ldr	r3, [r3, #0]
90009fa4:	68fa      	ldr	r2, [r7, #12]
90009fa6:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
90009faa:	f023 0303 	bic.w	r3, r3, #3
90009fae:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
90009fb0:	68fb      	ldr	r3, [r7, #12]
90009fb2:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
90009fb6:	685b      	ldr	r3, [r3, #4]
90009fb8:	68fa      	ldr	r2, [r7, #12]
90009fba:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
90009fbe:	f043 0302 	orr.w	r3, r3, #2
90009fc2:	6053      	str	r3, [r2, #4]

  return HAL_OK;
90009fc4:	2300      	movs	r3, #0
}
90009fc6:	4618      	mov	r0, r3
90009fc8:	3714      	adds	r7, #20
90009fca:	46bd      	mov	sp, r7
90009fcc:	f85d 7b04 	ldr.w	r7, [sp], #4
90009fd0:	4770      	bx	lr

90009fd2 <USB_ReadInterrupts>:
  * @brief  USB_ReadInterrupts: return the global USB interrupt status
  * @param  USBx  Selected device
  * @retval USB Global Interrupt status
  */
uint32_t USB_ReadInterrupts(USB_OTG_GlobalTypeDef const *USBx)
{
90009fd2:	b480      	push	{r7}
90009fd4:	b085      	sub	sp, #20
90009fd6:	af00      	add	r7, sp, #0
90009fd8:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;

  tmpreg = USBx->GINTSTS;
90009fda:	687b      	ldr	r3, [r7, #4]
90009fdc:	695b      	ldr	r3, [r3, #20]
90009fde:	60fb      	str	r3, [r7, #12]
  tmpreg &= USBx->GINTMSK;
90009fe0:	687b      	ldr	r3, [r7, #4]
90009fe2:	699b      	ldr	r3, [r3, #24]
90009fe4:	68fa      	ldr	r2, [r7, #12]
90009fe6:	4013      	ands	r3, r2
90009fe8:	60fb      	str	r3, [r7, #12]

  return tmpreg;
90009fea:	68fb      	ldr	r3, [r7, #12]
}
90009fec:	4618      	mov	r0, r3
90009fee:	3714      	adds	r7, #20
90009ff0:	46bd      	mov	sp, r7
90009ff2:	f85d 7b04 	ldr.w	r7, [sp], #4
90009ff6:	4770      	bx	lr

90009ff8 <USB_ReadDevAllOutEpInterrupt>:
  * @brief  USB_ReadDevAllOutEpInterrupt: return the USB device OUT endpoints interrupt status
  * @param  USBx  Selected device
  * @retval USB Device OUT EP interrupt status
  */
uint32_t USB_ReadDevAllOutEpInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
90009ff8:	b480      	push	{r7}
90009ffa:	b085      	sub	sp, #20
90009ffc:	af00      	add	r7, sp, #0
90009ffe:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
9000a000:	687b      	ldr	r3, [r7, #4]
9000a002:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
9000a004:	68fb      	ldr	r3, [r7, #12]
9000a006:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
9000a00a:	699b      	ldr	r3, [r3, #24]
9000a00c:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DAINTMSK;
9000a00e:	68fb      	ldr	r3, [r7, #12]
9000a010:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
9000a014:	69db      	ldr	r3, [r3, #28]
9000a016:	68ba      	ldr	r2, [r7, #8]
9000a018:	4013      	ands	r3, r2
9000a01a:	60bb      	str	r3, [r7, #8]

  return ((tmpreg & 0xffff0000U) >> 16);
9000a01c:	68bb      	ldr	r3, [r7, #8]
9000a01e:	0c1b      	lsrs	r3, r3, #16
}
9000a020:	4618      	mov	r0, r3
9000a022:	3714      	adds	r7, #20
9000a024:	46bd      	mov	sp, r7
9000a026:	f85d 7b04 	ldr.w	r7, [sp], #4
9000a02a:	4770      	bx	lr

9000a02c <USB_ReadDevAllInEpInterrupt>:
  * @brief  USB_ReadDevAllInEpInterrupt: return the USB device IN endpoints interrupt status
  * @param  USBx  Selected device
  * @retval USB Device IN EP interrupt status
  */
uint32_t USB_ReadDevAllInEpInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
9000a02c:	b480      	push	{r7}
9000a02e:	b085      	sub	sp, #20
9000a030:	af00      	add	r7, sp, #0
9000a032:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
9000a034:	687b      	ldr	r3, [r7, #4]
9000a036:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
9000a038:	68fb      	ldr	r3, [r7, #12]
9000a03a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
9000a03e:	699b      	ldr	r3, [r3, #24]
9000a040:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DAINTMSK;
9000a042:	68fb      	ldr	r3, [r7, #12]
9000a044:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
9000a048:	69db      	ldr	r3, [r3, #28]
9000a04a:	68ba      	ldr	r2, [r7, #8]
9000a04c:	4013      	ands	r3, r2
9000a04e:	60bb      	str	r3, [r7, #8]

  return ((tmpreg & 0xFFFFU));
9000a050:	68bb      	ldr	r3, [r7, #8]
9000a052:	b29b      	uxth	r3, r3
}
9000a054:	4618      	mov	r0, r3
9000a056:	3714      	adds	r7, #20
9000a058:	46bd      	mov	sp, r7
9000a05a:	f85d 7b04 	ldr.w	r7, [sp], #4
9000a05e:	4770      	bx	lr

9000a060 <USB_ReadDevOutEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt(const USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
9000a060:	b480      	push	{r7}
9000a062:	b085      	sub	sp, #20
9000a064:	af00      	add	r7, sp, #0
9000a066:	6078      	str	r0, [r7, #4]
9000a068:	460b      	mov	r3, r1
9000a06a:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
9000a06c:	687b      	ldr	r3, [r7, #4]
9000a06e:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
9000a070:	78fb      	ldrb	r3, [r7, #3]
9000a072:	015a      	lsls	r2, r3, #5
9000a074:	68fb      	ldr	r3, [r7, #12]
9000a076:	4413      	add	r3, r2
9000a078:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
9000a07c:	689b      	ldr	r3, [r3, #8]
9000a07e:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DOEPMSK;
9000a080:	68fb      	ldr	r3, [r7, #12]
9000a082:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
9000a086:	695b      	ldr	r3, [r3, #20]
9000a088:	68ba      	ldr	r2, [r7, #8]
9000a08a:	4013      	ands	r3, r2
9000a08c:	60bb      	str	r3, [r7, #8]

  return tmpreg;
9000a08e:	68bb      	ldr	r3, [r7, #8]
}
9000a090:	4618      	mov	r0, r3
9000a092:	3714      	adds	r7, #20
9000a094:	46bd      	mov	sp, r7
9000a096:	f85d 7b04 	ldr.w	r7, [sp], #4
9000a09a:	4770      	bx	lr

9000a09c <USB_ReadDevInEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device IN EP Interrupt register
  */
uint32_t USB_ReadDevInEPInterrupt(const USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
9000a09c:	b480      	push	{r7}
9000a09e:	b087      	sub	sp, #28
9000a0a0:	af00      	add	r7, sp, #0
9000a0a2:	6078      	str	r0, [r7, #4]
9000a0a4:	460b      	mov	r3, r1
9000a0a6:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
9000a0a8:	687b      	ldr	r3, [r7, #4]
9000a0aa:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg;
  uint32_t msk;
  uint32_t emp;

  msk = USBx_DEVICE->DIEPMSK;
9000a0ac:	697b      	ldr	r3, [r7, #20]
9000a0ae:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
9000a0b2:	691b      	ldr	r3, [r3, #16]
9000a0b4:	613b      	str	r3, [r7, #16]
  emp = USBx_DEVICE->DIEPEMPMSK;
9000a0b6:	697b      	ldr	r3, [r7, #20]
9000a0b8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
9000a0bc:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
9000a0be:	60fb      	str	r3, [r7, #12]
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
9000a0c0:	78fb      	ldrb	r3, [r7, #3]
9000a0c2:	f003 030f 	and.w	r3, r3, #15
9000a0c6:	68fa      	ldr	r2, [r7, #12]
9000a0c8:	fa22 f303 	lsr.w	r3, r2, r3
9000a0cc:	01db      	lsls	r3, r3, #7
9000a0ce:	b2db      	uxtb	r3, r3
9000a0d0:	693a      	ldr	r2, [r7, #16]
9000a0d2:	4313      	orrs	r3, r2
9000a0d4:	613b      	str	r3, [r7, #16]
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
9000a0d6:	78fb      	ldrb	r3, [r7, #3]
9000a0d8:	015a      	lsls	r2, r3, #5
9000a0da:	697b      	ldr	r3, [r7, #20]
9000a0dc:	4413      	add	r3, r2
9000a0de:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
9000a0e2:	689b      	ldr	r3, [r3, #8]
9000a0e4:	693a      	ldr	r2, [r7, #16]
9000a0e6:	4013      	ands	r3, r2
9000a0e8:	60bb      	str	r3, [r7, #8]

  return tmpreg;
9000a0ea:	68bb      	ldr	r3, [r7, #8]
}
9000a0ec:	4618      	mov	r0, r3
9000a0ee:	371c      	adds	r7, #28
9000a0f0:	46bd      	mov	sp, r7
9000a0f2:	f85d 7b04 	ldr.w	r7, [sp], #4
9000a0f6:	4770      	bx	lr

9000a0f8 <USB_GetMode>:
  *          This parameter can be one of these values:
  *           1 : Host
  *           0 : Device
  */
uint32_t USB_GetMode(const USB_OTG_GlobalTypeDef *USBx)
{
9000a0f8:	b480      	push	{r7}
9000a0fa:	b083      	sub	sp, #12
9000a0fc:	af00      	add	r7, sp, #0
9000a0fe:	6078      	str	r0, [r7, #4]
  return ((USBx->GINTSTS) & 0x1U);
9000a100:	687b      	ldr	r3, [r7, #4]
9000a102:	695b      	ldr	r3, [r3, #20]
9000a104:	f003 0301 	and.w	r3, r3, #1
}
9000a108:	4618      	mov	r0, r3
9000a10a:	370c      	adds	r7, #12
9000a10c:	46bd      	mov	sp, r7
9000a10e:	f85d 7b04 	ldr.w	r7, [sp], #4
9000a112:	4770      	bx	lr

9000a114 <USB_ActivateSetup>:
  * @brief  Activate EP0 for Setup transactions
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateSetup(const USB_OTG_GlobalTypeDef *USBx)
{
9000a114:	b480      	push	{r7}
9000a116:	b085      	sub	sp, #20
9000a118:	af00      	add	r7, sp, #0
9000a11a:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
9000a11c:	687b      	ldr	r3, [r7, #4]
9000a11e:	60fb      	str	r3, [r7, #12]

  /* Set the MPS of the IN EP0 to 64 bytes */
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
9000a120:	68fb      	ldr	r3, [r7, #12]
9000a122:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
9000a126:	681a      	ldr	r2, [r3, #0]
9000a128:	68fb      	ldr	r3, [r7, #12]
9000a12a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
9000a12e:	4619      	mov	r1, r3
9000a130:	4b09      	ldr	r3, [pc, #36]	@ (9000a158 <USB_ActivateSetup+0x44>)
9000a132:	4013      	ands	r3, r2
9000a134:	600b      	str	r3, [r1, #0]

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
9000a136:	68fb      	ldr	r3, [r7, #12]
9000a138:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
9000a13c:	685b      	ldr	r3, [r3, #4]
9000a13e:	68fa      	ldr	r2, [r7, #12]
9000a140:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
9000a144:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
9000a148:	6053      	str	r3, [r2, #4]

  return HAL_OK;
9000a14a:	2300      	movs	r3, #0
}
9000a14c:	4618      	mov	r0, r3
9000a14e:	3714      	adds	r7, #20
9000a150:	46bd      	mov	sp, r7
9000a152:	f85d 7b04 	ldr.w	r7, [sp], #4
9000a156:	4770      	bx	lr
9000a158:	fffff800 	.word	0xfffff800

9000a15c <USB_EP0_OutStart>:
  *           1 : DMA feature used
  * @param  psetup  pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(const USB_OTG_GlobalTypeDef *USBx, uint8_t dma, const uint8_t *psetup)
{
9000a15c:	b480      	push	{r7}
9000a15e:	b087      	sub	sp, #28
9000a160:	af00      	add	r7, sp, #0
9000a162:	60f8      	str	r0, [r7, #12]
9000a164:	460b      	mov	r3, r1
9000a166:	607a      	str	r2, [r7, #4]
9000a168:	72fb      	strb	r3, [r7, #11]
  uint32_t USBx_BASE = (uint32_t)USBx;
9000a16a:	68fb      	ldr	r3, [r7, #12]
9000a16c:	617b      	str	r3, [r7, #20]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
9000a16e:	68fb      	ldr	r3, [r7, #12]
9000a170:	333c      	adds	r3, #60	@ 0x3c
9000a172:	3304      	adds	r3, #4
9000a174:	681b      	ldr	r3, [r3, #0]
9000a176:	613b      	str	r3, [r7, #16]

  if (gSNPSiD > USB_OTG_CORE_ID_300A)
9000a178:	693b      	ldr	r3, [r7, #16]
9000a17a:	4a26      	ldr	r2, [pc, #152]	@ (9000a214 <USB_EP0_OutStart+0xb8>)
9000a17c:	4293      	cmp	r3, r2
9000a17e:	d90a      	bls.n	9000a196 <USB_EP0_OutStart+0x3a>
  {
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
9000a180:	697b      	ldr	r3, [r7, #20]
9000a182:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
9000a186:	681b      	ldr	r3, [r3, #0]
9000a188:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
9000a18c:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
9000a190:	d101      	bne.n	9000a196 <USB_EP0_OutStart+0x3a>
    {
      return HAL_OK;
9000a192:	2300      	movs	r3, #0
9000a194:	e037      	b.n	9000a206 <USB_EP0_OutStart+0xaa>
    }
  }

  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
9000a196:	697b      	ldr	r3, [r7, #20]
9000a198:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
9000a19c:	461a      	mov	r2, r3
9000a19e:	2300      	movs	r3, #0
9000a1a0:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1UL << 19));
9000a1a2:	697b      	ldr	r3, [r7, #20]
9000a1a4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
9000a1a8:	691b      	ldr	r3, [r3, #16]
9000a1aa:	697a      	ldr	r2, [r7, #20]
9000a1ac:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
9000a1b0:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
9000a1b4:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
9000a1b6:	697b      	ldr	r3, [r7, #20]
9000a1b8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
9000a1bc:	691b      	ldr	r3, [r3, #16]
9000a1be:	697a      	ldr	r2, [r7, #20]
9000a1c0:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
9000a1c4:	f043 0318 	orr.w	r3, r3, #24
9000a1c8:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
9000a1ca:	697b      	ldr	r3, [r7, #20]
9000a1cc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
9000a1d0:	691b      	ldr	r3, [r3, #16]
9000a1d2:	697a      	ldr	r2, [r7, #20]
9000a1d4:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
9000a1d8:	f043 43c0 	orr.w	r3, r3, #1610612736	@ 0x60000000
9000a1dc:	6113      	str	r3, [r2, #16]

  if (dma == 1U)
9000a1de:	7afb      	ldrb	r3, [r7, #11]
9000a1e0:	2b01      	cmp	r3, #1
9000a1e2:	d10f      	bne.n	9000a204 <USB_EP0_OutStart+0xa8>
  {
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
9000a1e4:	697b      	ldr	r3, [r7, #20]
9000a1e6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
9000a1ea:	461a      	mov	r2, r3
9000a1ec:	687b      	ldr	r3, [r7, #4]
9000a1ee:	6153      	str	r3, [r2, #20]
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;
9000a1f0:	697b      	ldr	r3, [r7, #20]
9000a1f2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
9000a1f6:	681b      	ldr	r3, [r3, #0]
9000a1f8:	697a      	ldr	r2, [r7, #20]
9000a1fa:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
9000a1fe:	f043 2380 	orr.w	r3, r3, #2147516416	@ 0x80008000
9000a202:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
9000a204:	2300      	movs	r3, #0
}
9000a206:	4618      	mov	r0, r3
9000a208:	371c      	adds	r7, #28
9000a20a:	46bd      	mov	sp, r7
9000a20c:	f85d 7b04 	ldr.w	r7, [sp], #4
9000a210:	4770      	bx	lr
9000a212:	bf00      	nop
9000a214:	4f54300a 	.word	0x4f54300a

9000a218 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
9000a218:	b480      	push	{r7}
9000a21a:	b085      	sub	sp, #20
9000a21c:	af00      	add	r7, sp, #0
9000a21e:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
9000a220:	2300      	movs	r3, #0
9000a222:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
9000a224:	68fb      	ldr	r3, [r7, #12]
9000a226:	3301      	adds	r3, #1
9000a228:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
9000a22a:	68fb      	ldr	r3, [r7, #12]
9000a22c:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
9000a230:	d901      	bls.n	9000a236 <USB_CoreReset+0x1e>
    {
      return HAL_TIMEOUT;
9000a232:	2303      	movs	r3, #3
9000a234:	e022      	b.n	9000a27c <USB_CoreReset+0x64>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
9000a236:	687b      	ldr	r3, [r7, #4]
9000a238:	691b      	ldr	r3, [r3, #16]
9000a23a:	2b00      	cmp	r3, #0
9000a23c:	daf2      	bge.n	9000a224 <USB_CoreReset+0xc>

  count = 10U;
9000a23e:	230a      	movs	r3, #10
9000a240:	60fb      	str	r3, [r7, #12]

  /* few cycles before setting core reset */
  while (count > 0U)
9000a242:	e002      	b.n	9000a24a <USB_CoreReset+0x32>
  {
    count--;
9000a244:	68fb      	ldr	r3, [r7, #12]
9000a246:	3b01      	subs	r3, #1
9000a248:	60fb      	str	r3, [r7, #12]
  while (count > 0U)
9000a24a:	68fb      	ldr	r3, [r7, #12]
9000a24c:	2b00      	cmp	r3, #0
9000a24e:	d1f9      	bne.n	9000a244 <USB_CoreReset+0x2c>
  }

  /* Core Soft Reset */
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
9000a250:	687b      	ldr	r3, [r7, #4]
9000a252:	691b      	ldr	r3, [r3, #16]
9000a254:	f043 0201 	orr.w	r2, r3, #1
9000a258:	687b      	ldr	r3, [r7, #4]
9000a25a:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
9000a25c:	68fb      	ldr	r3, [r7, #12]
9000a25e:	3301      	adds	r3, #1
9000a260:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
9000a262:	68fb      	ldr	r3, [r7, #12]
9000a264:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
9000a268:	d901      	bls.n	9000a26e <USB_CoreReset+0x56>
    {
      return HAL_TIMEOUT;
9000a26a:	2303      	movs	r3, #3
9000a26c:	e006      	b.n	9000a27c <USB_CoreReset+0x64>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
9000a26e:	687b      	ldr	r3, [r7, #4]
9000a270:	691b      	ldr	r3, [r3, #16]
9000a272:	f003 0301 	and.w	r3, r3, #1
9000a276:	2b01      	cmp	r3, #1
9000a278:	d0f0      	beq.n	9000a25c <USB_CoreReset+0x44>

  return HAL_OK;
9000a27a:	2300      	movs	r3, #0
}
9000a27c:	4618      	mov	r0, r3
9000a27e:	3714      	adds	r7, #20
9000a280:	46bd      	mov	sp, r7
9000a282:	f85d 7b04 	ldr.w	r7, [sp], #4
9000a286:	4770      	bx	lr

9000a288 <USBD_Init>:
  * @param  id: Low level core index
  * @retval status: USBD Status
  */
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev,
                             USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
9000a288:	b580      	push	{r7, lr}
9000a28a:	b086      	sub	sp, #24
9000a28c:	af00      	add	r7, sp, #0
9000a28e:	60f8      	str	r0, [r7, #12]
9000a290:	60b9      	str	r1, [r7, #8]
9000a292:	4613      	mov	r3, r2
9000a294:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef ret;

  /* Check whether the USB Host handle is valid */
  if (pdev == NULL)
9000a296:	68fb      	ldr	r3, [r7, #12]
9000a298:	2b00      	cmp	r3, #0
9000a29a:	d101      	bne.n	9000a2a0 <USBD_Init+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Device handle");
#endif /* (USBD_DEBUG_LEVEL > 1U) */
    return USBD_FAIL;
9000a29c:	2303      	movs	r3, #3
9000a29e:	e01f      	b.n	9000a2e0 <USBD_Init+0x58>
    pdev->NumClasses = 0;
    pdev->classId = 0;
  }
#else
  /* Unlink previous class*/
  pdev->pClass[0] = NULL;
9000a2a0:	68fb      	ldr	r3, [r7, #12]
9000a2a2:	2200      	movs	r2, #0
9000a2a4:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
  pdev->pUserData[0] = NULL;
9000a2a8:	68fb      	ldr	r3, [r7, #12]
9000a2aa:	2200      	movs	r2, #0
9000a2ac:	f8c3 22c4 	str.w	r2, [r3, #708]	@ 0x2c4
#endif /* USE_USBD_COMPOSITE */

  pdev->pConfDesc = NULL;
9000a2b0:	68fb      	ldr	r3, [r7, #12]
9000a2b2:	2200      	movs	r2, #0
9000a2b4:	f8c3 22d0 	str.w	r2, [r3, #720]	@ 0x2d0

  /* Assign USBD Descriptors */
  if (pdesc != NULL)
9000a2b8:	68bb      	ldr	r3, [r7, #8]
9000a2ba:	2b00      	cmp	r3, #0
9000a2bc:	d003      	beq.n	9000a2c6 <USBD_Init+0x3e>
  {
    pdev->pDesc = pdesc;
9000a2be:	68fb      	ldr	r3, [r7, #12]
9000a2c0:	68ba      	ldr	r2, [r7, #8]
9000a2c2:	f8c3 22b4 	str.w	r2, [r3, #692]	@ 0x2b4
  }

  /* Set Device initial State */
  pdev->dev_state = USBD_STATE_DEFAULT;
9000a2c6:	68fb      	ldr	r3, [r7, #12]
9000a2c8:	2201      	movs	r2, #1
9000a2ca:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  pdev->id = id;
9000a2ce:	68fb      	ldr	r3, [r7, #12]
9000a2d0:	79fa      	ldrb	r2, [r7, #7]
9000a2d2:	701a      	strb	r2, [r3, #0]

  /* Initialize low level driver */
  ret = USBD_LL_Init(pdev);
9000a2d4:	68f8      	ldr	r0, [r7, #12]
9000a2d6:	f7f6 fe4f 	bl	90000f78 <USBD_LL_Init>
9000a2da:	4603      	mov	r3, r0
9000a2dc:	75fb      	strb	r3, [r7, #23]

  return ret;
9000a2de:	7dfb      	ldrb	r3, [r7, #23]
}
9000a2e0:	4618      	mov	r0, r3
9000a2e2:	3718      	adds	r7, #24
9000a2e4:	46bd      	mov	sp, r7
9000a2e6:	bd80      	pop	{r7, pc}

9000a2e8 <USBD_RegisterClass>:
  * @param  pdev: Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
9000a2e8:	b580      	push	{r7, lr}
9000a2ea:	b084      	sub	sp, #16
9000a2ec:	af00      	add	r7, sp, #0
9000a2ee:	6078      	str	r0, [r7, #4]
9000a2f0:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
9000a2f2:	2300      	movs	r3, #0
9000a2f4:	81fb      	strh	r3, [r7, #14]

  if (pclass == NULL)
9000a2f6:	683b      	ldr	r3, [r7, #0]
9000a2f8:	2b00      	cmp	r3, #0
9000a2fa:	d101      	bne.n	9000a300 <USBD_RegisterClass+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Class handle");
#endif /* (USBD_DEBUG_LEVEL > 1U) */
    return USBD_FAIL;
9000a2fc:	2303      	movs	r3, #3
9000a2fe:	e025      	b.n	9000a34c <USBD_RegisterClass+0x64>
  }

  /* link the class to the USB Device handle */
  pdev->pClass[0] = pclass;
9000a300:	687b      	ldr	r3, [r7, #4]
9000a302:	683a      	ldr	r2, [r7, #0]
9000a304:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
  if (pdev->pClass[pdev->classId]->GetHSConfigDescriptor != NULL)
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetHSConfigDescriptor(&len);
  }
#else /* Default USE_USB_FS */
  if (pdev->pClass[pdev->classId]->GetFSConfigDescriptor != NULL)
9000a308:	687b      	ldr	r3, [r7, #4]
9000a30a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000a30e:	687b      	ldr	r3, [r7, #4]
9000a310:	32ae      	adds	r2, #174	@ 0xae
9000a312:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000a316:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000a318:	2b00      	cmp	r3, #0
9000a31a:	d00f      	beq.n	9000a33c <USBD_RegisterClass+0x54>
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetFSConfigDescriptor(&len);
9000a31c:	687b      	ldr	r3, [r7, #4]
9000a31e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000a322:	687b      	ldr	r3, [r7, #4]
9000a324:	32ae      	adds	r2, #174	@ 0xae
9000a326:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000a32a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000a32c:	f107 020e 	add.w	r2, r7, #14
9000a330:	4610      	mov	r0, r2
9000a332:	4798      	blx	r3
9000a334:	4602      	mov	r2, r0
9000a336:	687b      	ldr	r3, [r7, #4]
9000a338:	f8c3 22d0 	str.w	r2, [r3, #720]	@ 0x2d0
  }
#endif /* USE_USB_FS */

  /* Increment the NumClasses */
  pdev->NumClasses++;
9000a33c:	687b      	ldr	r3, [r7, #4]
9000a33e:	f8d3 32d8 	ldr.w	r3, [r3, #728]	@ 0x2d8
9000a342:	1c5a      	adds	r2, r3, #1
9000a344:	687b      	ldr	r3, [r7, #4]
9000a346:	f8c3 22d8 	str.w	r2, [r3, #728]	@ 0x2d8

  return USBD_OK;
9000a34a:	2300      	movs	r3, #0
}
9000a34c:	4618      	mov	r0, r3
9000a34e:	3710      	adds	r7, #16
9000a350:	46bd      	mov	sp, r7
9000a352:	bd80      	pop	{r7, pc}

9000a354 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_Start(USBD_HandleTypeDef *pdev)
{
9000a354:	b580      	push	{r7, lr}
9000a356:	b082      	sub	sp, #8
9000a358:	af00      	add	r7, sp, #0
9000a35a:	6078      	str	r0, [r7, #4]
#ifdef USE_USBD_COMPOSITE
  pdev->classId = 0U;
#endif /* USE_USBD_COMPOSITE */

  /* Start the low level driver  */
  return USBD_LL_Start(pdev);
9000a35c:	6878      	ldr	r0, [r7, #4]
9000a35e:	f7f6 fe59 	bl	90001014 <USBD_LL_Start>
9000a362:	4603      	mov	r3, r0
}
9000a364:	4618      	mov	r0, r3
9000a366:	3708      	adds	r7, #8
9000a368:	46bd      	mov	sp, r7
9000a36a:	bd80      	pop	{r7, pc}

9000a36c <USBD_RunTestMode>:
  *         Launch test mode process
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_RunTestMode(USBD_HandleTypeDef *pdev)
{
9000a36c:	b480      	push	{r7}
9000a36e:	b083      	sub	sp, #12
9000a370:	af00      	add	r7, sp, #0
9000a372:	6078      	str	r0, [r7, #4]
  return ret;
#else
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
9000a374:	2300      	movs	r3, #0
#endif /* USBD_HS_TESTMODE_ENABLE */
}
9000a376:	4618      	mov	r0, r3
9000a378:	370c      	adds	r7, #12
9000a37a:	46bd      	mov	sp, r7
9000a37c:	f85d 7b04 	ldr.w	r7, [sp], #4
9000a380:	4770      	bx	lr

9000a382 <USBD_SetClassConfig>:
  * @param  cfgidx: configuration index
  * @retval status
  */

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
9000a382:	b580      	push	{r7, lr}
9000a384:	b084      	sub	sp, #16
9000a386:	af00      	add	r7, sp, #0
9000a388:	6078      	str	r0, [r7, #4]
9000a38a:	460b      	mov	r3, r1
9000a38c:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef ret = USBD_OK;
9000a38e:	2300      	movs	r3, #0
9000a390:	73fb      	strb	r3, [r7, #15]
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
9000a392:	687b      	ldr	r3, [r7, #4]
9000a394:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
9000a398:	2b00      	cmp	r3, #0
9000a39a:	d009      	beq.n	9000a3b0 <USBD_SetClassConfig+0x2e>
  {
    /* Set configuration and Start the Class */
    ret = (USBD_StatusTypeDef)pdev->pClass[0]->Init(pdev, cfgidx);
9000a39c:	687b      	ldr	r3, [r7, #4]
9000a39e:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
9000a3a2:	681b      	ldr	r3, [r3, #0]
9000a3a4:	78fa      	ldrb	r2, [r7, #3]
9000a3a6:	4611      	mov	r1, r2
9000a3a8:	6878      	ldr	r0, [r7, #4]
9000a3aa:	4798      	blx	r3
9000a3ac:	4603      	mov	r3, r0
9000a3ae:	73fb      	strb	r3, [r7, #15]
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
9000a3b0:	7bfb      	ldrb	r3, [r7, #15]
}
9000a3b2:	4618      	mov	r0, r3
9000a3b4:	3710      	adds	r7, #16
9000a3b6:	46bd      	mov	sp, r7
9000a3b8:	bd80      	pop	{r7, pc}

9000a3ba <USBD_ClrClassConfig>:
  * @param  pdev: device instance
  * @param  cfgidx: configuration index
  * @retval status
  */
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
9000a3ba:	b580      	push	{r7, lr}
9000a3bc:	b084      	sub	sp, #16
9000a3be:	af00      	add	r7, sp, #0
9000a3c0:	6078      	str	r0, [r7, #4]
9000a3c2:	460b      	mov	r3, r1
9000a3c4:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef ret = USBD_OK;
9000a3c6:	2300      	movs	r3, #0
9000a3c8:	73fb      	strb	r3, [r7, #15]
      }
    }
  }
#else
  /* Clear configuration  and De-initialize the Class process */
  if (pdev->pClass[0]->DeInit(pdev, cfgidx) != 0U)
9000a3ca:	687b      	ldr	r3, [r7, #4]
9000a3cc:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
9000a3d0:	685b      	ldr	r3, [r3, #4]
9000a3d2:	78fa      	ldrb	r2, [r7, #3]
9000a3d4:	4611      	mov	r1, r2
9000a3d6:	6878      	ldr	r0, [r7, #4]
9000a3d8:	4798      	blx	r3
9000a3da:	4603      	mov	r3, r0
9000a3dc:	2b00      	cmp	r3, #0
9000a3de:	d001      	beq.n	9000a3e4 <USBD_ClrClassConfig+0x2a>
  {
    ret = USBD_FAIL;
9000a3e0:	2303      	movs	r3, #3
9000a3e2:	73fb      	strb	r3, [r7, #15]
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
9000a3e4:	7bfb      	ldrb	r3, [r7, #15]
}
9000a3e6:	4618      	mov	r0, r3
9000a3e8:	3710      	adds	r7, #16
9000a3ea:	46bd      	mov	sp, r7
9000a3ec:	bd80      	pop	{r7, pc}

9000a3ee <USBD_LL_SetupStage>:
  * @param  pdev: device instance
  * @param  psetup: setup packet buffer pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
9000a3ee:	b580      	push	{r7, lr}
9000a3f0:	b084      	sub	sp, #16
9000a3f2:	af00      	add	r7, sp, #0
9000a3f4:	6078      	str	r0, [r7, #4]
9000a3f6:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret;

  USBD_ParseSetupRequest(&pdev->request, psetup);
9000a3f8:	687b      	ldr	r3, [r7, #4]
9000a3fa:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
9000a3fe:	6839      	ldr	r1, [r7, #0]
9000a400:	4618      	mov	r0, r3
9000a402:	f001 f94c 	bl	9000b69e <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;
9000a406:	687b      	ldr	r3, [r7, #4]
9000a408:	2201      	movs	r2, #1
9000a40a:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  pdev->ep0_data_len = pdev->request.wLength;
9000a40e:	687b      	ldr	r3, [r7, #4]
9000a410:	f8b3 32b0 	ldrh.w	r3, [r3, #688]	@ 0x2b0
9000a414:	461a      	mov	r2, r3
9000a416:	687b      	ldr	r3, [r7, #4]
9000a418:	f8c3 2298 	str.w	r2, [r3, #664]	@ 0x298

  switch (pdev->request.bmRequest & 0x1FU)
9000a41c:	687b      	ldr	r3, [r7, #4]
9000a41e:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
9000a422:	f003 031f 	and.w	r3, r3, #31
9000a426:	2b02      	cmp	r3, #2
9000a428:	d01a      	beq.n	9000a460 <USBD_LL_SetupStage+0x72>
9000a42a:	2b02      	cmp	r3, #2
9000a42c:	d822      	bhi.n	9000a474 <USBD_LL_SetupStage+0x86>
9000a42e:	2b00      	cmp	r3, #0
9000a430:	d002      	beq.n	9000a438 <USBD_LL_SetupStage+0x4a>
9000a432:	2b01      	cmp	r3, #1
9000a434:	d00a      	beq.n	9000a44c <USBD_LL_SetupStage+0x5e>
9000a436:	e01d      	b.n	9000a474 <USBD_LL_SetupStage+0x86>
  {
    case USB_REQ_RECIPIENT_DEVICE:
      ret = USBD_StdDevReq(pdev, &pdev->request);
9000a438:	687b      	ldr	r3, [r7, #4]
9000a43a:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
9000a43e:	4619      	mov	r1, r3
9000a440:	6878      	ldr	r0, [r7, #4]
9000a442:	f000 fb77 	bl	9000ab34 <USBD_StdDevReq>
9000a446:	4603      	mov	r3, r0
9000a448:	73fb      	strb	r3, [r7, #15]
      break;
9000a44a:	e020      	b.n	9000a48e <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_INTERFACE:
      ret = USBD_StdItfReq(pdev, &pdev->request);
9000a44c:	687b      	ldr	r3, [r7, #4]
9000a44e:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
9000a452:	4619      	mov	r1, r3
9000a454:	6878      	ldr	r0, [r7, #4]
9000a456:	f000 fbdf 	bl	9000ac18 <USBD_StdItfReq>
9000a45a:	4603      	mov	r3, r0
9000a45c:	73fb      	strb	r3, [r7, #15]
      break;
9000a45e:	e016      	b.n	9000a48e <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_ENDPOINT:
      ret = USBD_StdEPReq(pdev, &pdev->request);
9000a460:	687b      	ldr	r3, [r7, #4]
9000a462:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
9000a466:	4619      	mov	r1, r3
9000a468:	6878      	ldr	r0, [r7, #4]
9000a46a:	f000 fc41 	bl	9000acf0 <USBD_StdEPReq>
9000a46e:	4603      	mov	r3, r0
9000a470:	73fb      	strb	r3, [r7, #15]
      break;
9000a472:	e00c      	b.n	9000a48e <USBD_LL_SetupStage+0xa0>

    default:
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
9000a474:	687b      	ldr	r3, [r7, #4]
9000a476:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
9000a47a:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
9000a47e:	b2db      	uxtb	r3, r3
9000a480:	4619      	mov	r1, r3
9000a482:	6878      	ldr	r0, [r7, #4]
9000a484:	f7f6 fe45 	bl	90001112 <USBD_LL_StallEP>
9000a488:	4603      	mov	r3, r0
9000a48a:	73fb      	strb	r3, [r7, #15]
      break;
9000a48c:	bf00      	nop
  }

  return ret;
9000a48e:	7bfb      	ldrb	r3, [r7, #15]
}
9000a490:	4618      	mov	r0, r3
9000a492:	3710      	adds	r7, #16
9000a494:	46bd      	mov	sp, r7
9000a496:	bd80      	pop	{r7, pc}

9000a498 <USBD_LL_DataOutStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
9000a498:	b580      	push	{r7, lr}
9000a49a:	b086      	sub	sp, #24
9000a49c:	af00      	add	r7, sp, #0
9000a49e:	60f8      	str	r0, [r7, #12]
9000a4a0:	460b      	mov	r3, r1
9000a4a2:	607a      	str	r2, [r7, #4]
9000a4a4:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret = USBD_OK;
9000a4a6:	2300      	movs	r3, #0
9000a4a8:	75fb      	strb	r3, [r7, #23]
  uint8_t idx;

  UNUSED(pdata);

  if (epnum == 0U)
9000a4aa:	7afb      	ldrb	r3, [r7, #11]
9000a4ac:	2b00      	cmp	r3, #0
9000a4ae:	d177      	bne.n	9000a5a0 <USBD_LL_DataOutStage+0x108>
  {
    pep = &pdev->ep_out[0];
9000a4b0:	68fb      	ldr	r3, [r7, #12]
9000a4b2:	f503 73aa 	add.w	r3, r3, #340	@ 0x154
9000a4b6:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
9000a4b8:	68fb      	ldr	r3, [r7, #12]
9000a4ba:	f8d3 3294 	ldr.w	r3, [r3, #660]	@ 0x294
9000a4be:	2b03      	cmp	r3, #3
9000a4c0:	f040 80a1 	bne.w	9000a606 <USBD_LL_DataOutStage+0x16e>
    {
      if (pep->rem_length > pep->maxpacket)
9000a4c4:	693b      	ldr	r3, [r7, #16]
9000a4c6:	685b      	ldr	r3, [r3, #4]
9000a4c8:	693a      	ldr	r2, [r7, #16]
9000a4ca:	8992      	ldrh	r2, [r2, #12]
9000a4cc:	4293      	cmp	r3, r2
9000a4ce:	d91c      	bls.n	9000a50a <USBD_LL_DataOutStage+0x72>
      {
        pep->rem_length -= pep->maxpacket;
9000a4d0:	693b      	ldr	r3, [r7, #16]
9000a4d2:	685b      	ldr	r3, [r3, #4]
9000a4d4:	693a      	ldr	r2, [r7, #16]
9000a4d6:	8992      	ldrh	r2, [r2, #12]
9000a4d8:	1a9a      	subs	r2, r3, r2
9000a4da:	693b      	ldr	r3, [r7, #16]
9000a4dc:	605a      	str	r2, [r3, #4]
        pep->pbuffer += pep->maxpacket;
9000a4de:	693b      	ldr	r3, [r7, #16]
9000a4e0:	691b      	ldr	r3, [r3, #16]
9000a4e2:	693a      	ldr	r2, [r7, #16]
9000a4e4:	8992      	ldrh	r2, [r2, #12]
9000a4e6:	441a      	add	r2, r3
9000a4e8:	693b      	ldr	r3, [r7, #16]
9000a4ea:	611a      	str	r2, [r3, #16]

        (void)USBD_CtlContinueRx(pdev, pep->pbuffer, MAX(pep->rem_length, pep->maxpacket));
9000a4ec:	693b      	ldr	r3, [r7, #16]
9000a4ee:	6919      	ldr	r1, [r3, #16]
9000a4f0:	693b      	ldr	r3, [r7, #16]
9000a4f2:	899b      	ldrh	r3, [r3, #12]
9000a4f4:	461a      	mov	r2, r3
9000a4f6:	693b      	ldr	r3, [r7, #16]
9000a4f8:	685b      	ldr	r3, [r3, #4]
9000a4fa:	4293      	cmp	r3, r2
9000a4fc:	bf38      	it	cc
9000a4fe:	4613      	movcc	r3, r2
9000a500:	461a      	mov	r2, r3
9000a502:	68f8      	ldr	r0, [r7, #12]
9000a504:	f001 f9b1 	bl	9000b86a <USBD_CtlContinueRx>
9000a508:	e07d      	b.n	9000a606 <USBD_LL_DataOutStage+0x16e>
      }
      else
      {
        /* Find the class ID relative to the current request */
        switch (pdev->request.bmRequest & 0x1FU)
9000a50a:	68fb      	ldr	r3, [r7, #12]
9000a50c:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
9000a510:	f003 031f 	and.w	r3, r3, #31
9000a514:	2b02      	cmp	r3, #2
9000a516:	d014      	beq.n	9000a542 <USBD_LL_DataOutStage+0xaa>
9000a518:	2b02      	cmp	r3, #2
9000a51a:	d81d      	bhi.n	9000a558 <USBD_LL_DataOutStage+0xc0>
9000a51c:	2b00      	cmp	r3, #0
9000a51e:	d002      	beq.n	9000a526 <USBD_LL_DataOutStage+0x8e>
9000a520:	2b01      	cmp	r3, #1
9000a522:	d003      	beq.n	9000a52c <USBD_LL_DataOutStage+0x94>
9000a524:	e018      	b.n	9000a558 <USBD_LL_DataOutStage+0xc0>
        {
          case USB_REQ_RECIPIENT_DEVICE:
            /* Device requests must be managed by the first instantiated class
               (or duplicated by all classes for simplicity) */
            idx = 0U;
9000a526:	2300      	movs	r3, #0
9000a528:	75bb      	strb	r3, [r7, #22]
            break;
9000a52a:	e018      	b.n	9000a55e <USBD_LL_DataOutStage+0xc6>

          case USB_REQ_RECIPIENT_INTERFACE:
            idx = USBD_CoreFindIF(pdev, LOBYTE(pdev->request.wIndex));
9000a52c:	68fb      	ldr	r3, [r7, #12]
9000a52e:	f8b3 32ae 	ldrh.w	r3, [r3, #686]	@ 0x2ae
9000a532:	b2db      	uxtb	r3, r3
9000a534:	4619      	mov	r1, r3
9000a536:	68f8      	ldr	r0, [r7, #12]
9000a538:	f000 fa6e 	bl	9000aa18 <USBD_CoreFindIF>
9000a53c:	4603      	mov	r3, r0
9000a53e:	75bb      	strb	r3, [r7, #22]
            break;
9000a540:	e00d      	b.n	9000a55e <USBD_LL_DataOutStage+0xc6>

          case USB_REQ_RECIPIENT_ENDPOINT:
            idx = USBD_CoreFindEP(pdev, LOBYTE(pdev->request.wIndex));
9000a542:	68fb      	ldr	r3, [r7, #12]
9000a544:	f8b3 32ae 	ldrh.w	r3, [r3, #686]	@ 0x2ae
9000a548:	b2db      	uxtb	r3, r3
9000a54a:	4619      	mov	r1, r3
9000a54c:	68f8      	ldr	r0, [r7, #12]
9000a54e:	f000 fa70 	bl	9000aa32 <USBD_CoreFindEP>
9000a552:	4603      	mov	r3, r0
9000a554:	75bb      	strb	r3, [r7, #22]
            break;
9000a556:	e002      	b.n	9000a55e <USBD_LL_DataOutStage+0xc6>

          default:
            /* Back to the first class in case of doubt */
            idx = 0U;
9000a558:	2300      	movs	r3, #0
9000a55a:	75bb      	strb	r3, [r7, #22]
            break;
9000a55c:	bf00      	nop
        }

        if (idx < USBD_MAX_SUPPORTED_CLASS)
9000a55e:	7dbb      	ldrb	r3, [r7, #22]
9000a560:	2b00      	cmp	r3, #0
9000a562:	d119      	bne.n	9000a598 <USBD_LL_DataOutStage+0x100>
        {
          /* Setup the class ID and route the request to the relative class function */
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
9000a564:	68fb      	ldr	r3, [r7, #12]
9000a566:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000a56a:	b2db      	uxtb	r3, r3
9000a56c:	2b03      	cmp	r3, #3
9000a56e:	d113      	bne.n	9000a598 <USBD_LL_DataOutStage+0x100>
          {
            if (pdev->pClass[idx]->EP0_RxReady != NULL)
9000a570:	7dba      	ldrb	r2, [r7, #22]
9000a572:	68fb      	ldr	r3, [r7, #12]
9000a574:	32ae      	adds	r2, #174	@ 0xae
9000a576:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000a57a:	691b      	ldr	r3, [r3, #16]
9000a57c:	2b00      	cmp	r3, #0
9000a57e:	d00b      	beq.n	9000a598 <USBD_LL_DataOutStage+0x100>
            {
              pdev->classId = idx;
9000a580:	7dba      	ldrb	r2, [r7, #22]
9000a582:	68fb      	ldr	r3, [r7, #12]
9000a584:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
              pdev->pClass[idx]->EP0_RxReady(pdev);
9000a588:	7dba      	ldrb	r2, [r7, #22]
9000a58a:	68fb      	ldr	r3, [r7, #12]
9000a58c:	32ae      	adds	r2, #174	@ 0xae
9000a58e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000a592:	691b      	ldr	r3, [r3, #16]
9000a594:	68f8      	ldr	r0, [r7, #12]
9000a596:	4798      	blx	r3
            }
          }
        }

        (void)USBD_CtlSendStatus(pdev);
9000a598:	68f8      	ldr	r0, [r7, #12]
9000a59a:	f001 f977 	bl	9000b88c <USBD_CtlSendStatus>
9000a59e:	e032      	b.n	9000a606 <USBD_LL_DataOutStage+0x16e>
    }
  }
  else
  {
    /* Get the class index relative to this interface */
    idx = USBD_CoreFindEP(pdev, (epnum & 0x7FU));
9000a5a0:	7afb      	ldrb	r3, [r7, #11]
9000a5a2:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
9000a5a6:	b2db      	uxtb	r3, r3
9000a5a8:	4619      	mov	r1, r3
9000a5aa:	68f8      	ldr	r0, [r7, #12]
9000a5ac:	f000 fa41 	bl	9000aa32 <USBD_CoreFindEP>
9000a5b0:	4603      	mov	r3, r0
9000a5b2:	75bb      	strb	r3, [r7, #22]

    if (((uint16_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
9000a5b4:	7dbb      	ldrb	r3, [r7, #22]
9000a5b6:	2bff      	cmp	r3, #255	@ 0xff
9000a5b8:	d025      	beq.n	9000a606 <USBD_LL_DataOutStage+0x16e>
9000a5ba:	7dbb      	ldrb	r3, [r7, #22]
9000a5bc:	2b00      	cmp	r3, #0
9000a5be:	d122      	bne.n	9000a606 <USBD_LL_DataOutStage+0x16e>
    {
      /* Call the class data out function to manage the request */
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
9000a5c0:	68fb      	ldr	r3, [r7, #12]
9000a5c2:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000a5c6:	b2db      	uxtb	r3, r3
9000a5c8:	2b03      	cmp	r3, #3
9000a5ca:	d117      	bne.n	9000a5fc <USBD_LL_DataOutStage+0x164>
      {
        if (pdev->pClass[idx]->DataOut != NULL)
9000a5cc:	7dba      	ldrb	r2, [r7, #22]
9000a5ce:	68fb      	ldr	r3, [r7, #12]
9000a5d0:	32ae      	adds	r2, #174	@ 0xae
9000a5d2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000a5d6:	699b      	ldr	r3, [r3, #24]
9000a5d8:	2b00      	cmp	r3, #0
9000a5da:	d00f      	beq.n	9000a5fc <USBD_LL_DataOutStage+0x164>
        {
          pdev->classId = idx;
9000a5dc:	7dba      	ldrb	r2, [r7, #22]
9000a5de:	68fb      	ldr	r3, [r7, #12]
9000a5e0:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataOut(pdev, epnum);
9000a5e4:	7dba      	ldrb	r2, [r7, #22]
9000a5e6:	68fb      	ldr	r3, [r7, #12]
9000a5e8:	32ae      	adds	r2, #174	@ 0xae
9000a5ea:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000a5ee:	699b      	ldr	r3, [r3, #24]
9000a5f0:	7afa      	ldrb	r2, [r7, #11]
9000a5f2:	4611      	mov	r1, r2
9000a5f4:	68f8      	ldr	r0, [r7, #12]
9000a5f6:	4798      	blx	r3
9000a5f8:	4603      	mov	r3, r0
9000a5fa:	75fb      	strb	r3, [r7, #23]
        }
      }
      if (ret != USBD_OK)
9000a5fc:	7dfb      	ldrb	r3, [r7, #23]
9000a5fe:	2b00      	cmp	r3, #0
9000a600:	d001      	beq.n	9000a606 <USBD_LL_DataOutStage+0x16e>
      {
        return ret;
9000a602:	7dfb      	ldrb	r3, [r7, #23]
9000a604:	e000      	b.n	9000a608 <USBD_LL_DataOutStage+0x170>
      }
    }
  }

  return USBD_OK;
9000a606:	2300      	movs	r3, #0
}
9000a608:	4618      	mov	r0, r3
9000a60a:	3718      	adds	r7, #24
9000a60c:	46bd      	mov	sp, r7
9000a60e:	bd80      	pop	{r7, pc}

9000a610 <USBD_LL_DataInStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
9000a610:	b580      	push	{r7, lr}
9000a612:	b086      	sub	sp, #24
9000a614:	af00      	add	r7, sp, #0
9000a616:	60f8      	str	r0, [r7, #12]
9000a618:	460b      	mov	r3, r1
9000a61a:	607a      	str	r2, [r7, #4]
9000a61c:	72fb      	strb	r3, [r7, #11]
  USBD_StatusTypeDef ret;
  uint8_t idx;

  UNUSED(pdata);

  if (epnum == 0U)
9000a61e:	7afb      	ldrb	r3, [r7, #11]
9000a620:	2b00      	cmp	r3, #0
9000a622:	d178      	bne.n	9000a716 <USBD_LL_DataInStage+0x106>
  {
    pep = &pdev->ep_in[0];
9000a624:	68fb      	ldr	r3, [r7, #12]
9000a626:	3314      	adds	r3, #20
9000a628:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
9000a62a:	68fb      	ldr	r3, [r7, #12]
9000a62c:	f8d3 3294 	ldr.w	r3, [r3, #660]	@ 0x294
9000a630:	2b02      	cmp	r3, #2
9000a632:	d163      	bne.n	9000a6fc <USBD_LL_DataInStage+0xec>
    {
      if (pep->rem_length > pep->maxpacket)
9000a634:	693b      	ldr	r3, [r7, #16]
9000a636:	685b      	ldr	r3, [r3, #4]
9000a638:	693a      	ldr	r2, [r7, #16]
9000a63a:	8992      	ldrh	r2, [r2, #12]
9000a63c:	4293      	cmp	r3, r2
9000a63e:	d91c      	bls.n	9000a67a <USBD_LL_DataInStage+0x6a>
      {
        pep->rem_length -= pep->maxpacket;
9000a640:	693b      	ldr	r3, [r7, #16]
9000a642:	685b      	ldr	r3, [r3, #4]
9000a644:	693a      	ldr	r2, [r7, #16]
9000a646:	8992      	ldrh	r2, [r2, #12]
9000a648:	1a9a      	subs	r2, r3, r2
9000a64a:	693b      	ldr	r3, [r7, #16]
9000a64c:	605a      	str	r2, [r3, #4]
        pep->pbuffer += pep->maxpacket;
9000a64e:	693b      	ldr	r3, [r7, #16]
9000a650:	691b      	ldr	r3, [r3, #16]
9000a652:	693a      	ldr	r2, [r7, #16]
9000a654:	8992      	ldrh	r2, [r2, #12]
9000a656:	441a      	add	r2, r3
9000a658:	693b      	ldr	r3, [r7, #16]
9000a65a:	611a      	str	r2, [r3, #16]

        (void)USBD_CtlContinueSendData(pdev, pep->pbuffer, pep->rem_length);
9000a65c:	693b      	ldr	r3, [r7, #16]
9000a65e:	6919      	ldr	r1, [r3, #16]
9000a660:	693b      	ldr	r3, [r7, #16]
9000a662:	685b      	ldr	r3, [r3, #4]
9000a664:	461a      	mov	r2, r3
9000a666:	68f8      	ldr	r0, [r7, #12]
9000a668:	f001 f8ee 	bl	9000b848 <USBD_CtlContinueSendData>

        /* Prepare endpoint for premature end of transfer */
        (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
9000a66c:	2300      	movs	r3, #0
9000a66e:	2200      	movs	r2, #0
9000a670:	2100      	movs	r1, #0
9000a672:	68f8      	ldr	r0, [r7, #12]
9000a674:	f7f6 fdf7 	bl	90001266 <USBD_LL_PrepareReceive>
9000a678:	e040      	b.n	9000a6fc <USBD_LL_DataInStage+0xec>
      }
      else
      {
        /* last packet is MPS multiple, so send ZLP packet */
        if ((pep->maxpacket == pep->rem_length) &&
9000a67a:	693b      	ldr	r3, [r7, #16]
9000a67c:	899b      	ldrh	r3, [r3, #12]
9000a67e:	461a      	mov	r2, r3
9000a680:	693b      	ldr	r3, [r7, #16]
9000a682:	685b      	ldr	r3, [r3, #4]
9000a684:	429a      	cmp	r2, r3
9000a686:	d11c      	bne.n	9000a6c2 <USBD_LL_DataInStage+0xb2>
            (pep->total_length >= pep->maxpacket) &&
9000a688:	693b      	ldr	r3, [r7, #16]
9000a68a:	681b      	ldr	r3, [r3, #0]
9000a68c:	693a      	ldr	r2, [r7, #16]
9000a68e:	8992      	ldrh	r2, [r2, #12]
        if ((pep->maxpacket == pep->rem_length) &&
9000a690:	4293      	cmp	r3, r2
9000a692:	d316      	bcc.n	9000a6c2 <USBD_LL_DataInStage+0xb2>
            (pep->total_length < pdev->ep0_data_len))
9000a694:	693b      	ldr	r3, [r7, #16]
9000a696:	681a      	ldr	r2, [r3, #0]
9000a698:	68fb      	ldr	r3, [r7, #12]
9000a69a:	f8d3 3298 	ldr.w	r3, [r3, #664]	@ 0x298
            (pep->total_length >= pep->maxpacket) &&
9000a69e:	429a      	cmp	r2, r3
9000a6a0:	d20f      	bcs.n	9000a6c2 <USBD_LL_DataInStage+0xb2>
        {
          (void)USBD_CtlContinueSendData(pdev, NULL, 0U);
9000a6a2:	2200      	movs	r2, #0
9000a6a4:	2100      	movs	r1, #0
9000a6a6:	68f8      	ldr	r0, [r7, #12]
9000a6a8:	f001 f8ce 	bl	9000b848 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
9000a6ac:	68fb      	ldr	r3, [r7, #12]
9000a6ae:	2200      	movs	r2, #0
9000a6b0:	f8c3 2298 	str.w	r2, [r3, #664]	@ 0x298

          /* Prepare endpoint for premature end of transfer */
          (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
9000a6b4:	2300      	movs	r3, #0
9000a6b6:	2200      	movs	r2, #0
9000a6b8:	2100      	movs	r1, #0
9000a6ba:	68f8      	ldr	r0, [r7, #12]
9000a6bc:	f7f6 fdd3 	bl	90001266 <USBD_LL_PrepareReceive>
9000a6c0:	e01c      	b.n	9000a6fc <USBD_LL_DataInStage+0xec>
        }
        else
        {
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
9000a6c2:	68fb      	ldr	r3, [r7, #12]
9000a6c4:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000a6c8:	b2db      	uxtb	r3, r3
9000a6ca:	2b03      	cmp	r3, #3
9000a6cc:	d10f      	bne.n	9000a6ee <USBD_LL_DataInStage+0xde>
          {
            if (pdev->pClass[0]->EP0_TxSent != NULL)
9000a6ce:	68fb      	ldr	r3, [r7, #12]
9000a6d0:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
9000a6d4:	68db      	ldr	r3, [r3, #12]
9000a6d6:	2b00      	cmp	r3, #0
9000a6d8:	d009      	beq.n	9000a6ee <USBD_LL_DataInStage+0xde>
            {
              pdev->classId = 0U;
9000a6da:	68fb      	ldr	r3, [r7, #12]
9000a6dc:	2200      	movs	r2, #0
9000a6de:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
              pdev->pClass[0]->EP0_TxSent(pdev);
9000a6e2:	68fb      	ldr	r3, [r7, #12]
9000a6e4:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
9000a6e8:	68db      	ldr	r3, [r3, #12]
9000a6ea:	68f8      	ldr	r0, [r7, #12]
9000a6ec:	4798      	blx	r3
            }
          }
          (void)USBD_LL_StallEP(pdev, 0x80U);
9000a6ee:	2180      	movs	r1, #128	@ 0x80
9000a6f0:	68f8      	ldr	r0, [r7, #12]
9000a6f2:	f7f6 fd0e 	bl	90001112 <USBD_LL_StallEP>
          (void)USBD_CtlReceiveStatus(pdev);
9000a6f6:	68f8      	ldr	r0, [r7, #12]
9000a6f8:	f001 f8db 	bl	9000b8b2 <USBD_CtlReceiveStatus>
        }
      }
    }

    if (pdev->dev_test_mode != 0U)
9000a6fc:	68fb      	ldr	r3, [r7, #12]
9000a6fe:	f893 32a0 	ldrb.w	r3, [r3, #672]	@ 0x2a0
9000a702:	2b00      	cmp	r3, #0
9000a704:	d03a      	beq.n	9000a77c <USBD_LL_DataInStage+0x16c>
    {
      (void)USBD_RunTestMode(pdev);
9000a706:	68f8      	ldr	r0, [r7, #12]
9000a708:	f7ff fe30 	bl	9000a36c <USBD_RunTestMode>
      pdev->dev_test_mode = 0U;
9000a70c:	68fb      	ldr	r3, [r7, #12]
9000a70e:	2200      	movs	r2, #0
9000a710:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
9000a714:	e032      	b.n	9000a77c <USBD_LL_DataInStage+0x16c>
    }
  }
  else
  {
    /* Get the class index relative to this interface */
    idx = USBD_CoreFindEP(pdev, ((uint8_t)epnum | 0x80U));
9000a716:	7afb      	ldrb	r3, [r7, #11]
9000a718:	f063 037f 	orn	r3, r3, #127	@ 0x7f
9000a71c:	b2db      	uxtb	r3, r3
9000a71e:	4619      	mov	r1, r3
9000a720:	68f8      	ldr	r0, [r7, #12]
9000a722:	f000 f986 	bl	9000aa32 <USBD_CoreFindEP>
9000a726:	4603      	mov	r3, r0
9000a728:	75fb      	strb	r3, [r7, #23]

    if (((uint16_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
9000a72a:	7dfb      	ldrb	r3, [r7, #23]
9000a72c:	2bff      	cmp	r3, #255	@ 0xff
9000a72e:	d025      	beq.n	9000a77c <USBD_LL_DataInStage+0x16c>
9000a730:	7dfb      	ldrb	r3, [r7, #23]
9000a732:	2b00      	cmp	r3, #0
9000a734:	d122      	bne.n	9000a77c <USBD_LL_DataInStage+0x16c>
    {
      /* Call the class data out function to manage the request */
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
9000a736:	68fb      	ldr	r3, [r7, #12]
9000a738:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000a73c:	b2db      	uxtb	r3, r3
9000a73e:	2b03      	cmp	r3, #3
9000a740:	d11c      	bne.n	9000a77c <USBD_LL_DataInStage+0x16c>
      {
        if (pdev->pClass[idx]->DataIn != NULL)
9000a742:	7dfa      	ldrb	r2, [r7, #23]
9000a744:	68fb      	ldr	r3, [r7, #12]
9000a746:	32ae      	adds	r2, #174	@ 0xae
9000a748:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000a74c:	695b      	ldr	r3, [r3, #20]
9000a74e:	2b00      	cmp	r3, #0
9000a750:	d014      	beq.n	9000a77c <USBD_LL_DataInStage+0x16c>
        {
          pdev->classId = idx;
9000a752:	7dfa      	ldrb	r2, [r7, #23]
9000a754:	68fb      	ldr	r3, [r7, #12]
9000a756:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataIn(pdev, epnum);
9000a75a:	7dfa      	ldrb	r2, [r7, #23]
9000a75c:	68fb      	ldr	r3, [r7, #12]
9000a75e:	32ae      	adds	r2, #174	@ 0xae
9000a760:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000a764:	695b      	ldr	r3, [r3, #20]
9000a766:	7afa      	ldrb	r2, [r7, #11]
9000a768:	4611      	mov	r1, r2
9000a76a:	68f8      	ldr	r0, [r7, #12]
9000a76c:	4798      	blx	r3
9000a76e:	4603      	mov	r3, r0
9000a770:	75bb      	strb	r3, [r7, #22]

          if (ret != USBD_OK)
9000a772:	7dbb      	ldrb	r3, [r7, #22]
9000a774:	2b00      	cmp	r3, #0
9000a776:	d001      	beq.n	9000a77c <USBD_LL_DataInStage+0x16c>
          {
            return ret;
9000a778:	7dbb      	ldrb	r3, [r7, #22]
9000a77a:	e000      	b.n	9000a77e <USBD_LL_DataInStage+0x16e>
        }
      }
    }
  }

  return USBD_OK;
9000a77c:	2300      	movs	r3, #0
}
9000a77e:	4618      	mov	r0, r3
9000a780:	3718      	adds	r7, #24
9000a782:	46bd      	mov	sp, r7
9000a784:	bd80      	pop	{r7, pc}

9000a786 <USBD_LL_Reset>:
  *         Handle Reset event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
9000a786:	b580      	push	{r7, lr}
9000a788:	b084      	sub	sp, #16
9000a78a:	af00      	add	r7, sp, #0
9000a78c:	6078      	str	r0, [r7, #4]
  USBD_StatusTypeDef ret = USBD_OK;
9000a78e:	2300      	movs	r3, #0
9000a790:	73fb      	strb	r3, [r7, #15]

  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
9000a792:	687b      	ldr	r3, [r7, #4]
9000a794:	2201      	movs	r2, #1
9000a796:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  pdev->ep0_state = USBD_EP0_IDLE;
9000a79a:	687b      	ldr	r3, [r7, #4]
9000a79c:	2200      	movs	r2, #0
9000a79e:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  pdev->dev_config = 0U;
9000a7a2:	687b      	ldr	r3, [r7, #4]
9000a7a4:	2200      	movs	r2, #0
9000a7a6:	605a      	str	r2, [r3, #4]
  pdev->dev_remote_wakeup = 0U;
9000a7a8:	687b      	ldr	r3, [r7, #4]
9000a7aa:	2200      	movs	r2, #0
9000a7ac:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
  pdev->dev_test_mode = 0U;
9000a7b0:	687b      	ldr	r3, [r7, #4]
9000a7b2:	2200      	movs	r2, #0
9000a7b4:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
      }
    }
  }
#else

  if (pdev->pClass[0] != NULL)
9000a7b8:	687b      	ldr	r3, [r7, #4]
9000a7ba:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
9000a7be:	2b00      	cmp	r3, #0
9000a7c0:	d014      	beq.n	9000a7ec <USBD_LL_Reset+0x66>
  {
    if (pdev->pClass[0]->DeInit != NULL)
9000a7c2:	687b      	ldr	r3, [r7, #4]
9000a7c4:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
9000a7c8:	685b      	ldr	r3, [r3, #4]
9000a7ca:	2b00      	cmp	r3, #0
9000a7cc:	d00e      	beq.n	9000a7ec <USBD_LL_Reset+0x66>
    {
      if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != USBD_OK)
9000a7ce:	687b      	ldr	r3, [r7, #4]
9000a7d0:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
9000a7d4:	685b      	ldr	r3, [r3, #4]
9000a7d6:	687a      	ldr	r2, [r7, #4]
9000a7d8:	6852      	ldr	r2, [r2, #4]
9000a7da:	b2d2      	uxtb	r2, r2
9000a7dc:	4611      	mov	r1, r2
9000a7de:	6878      	ldr	r0, [r7, #4]
9000a7e0:	4798      	blx	r3
9000a7e2:	4603      	mov	r3, r0
9000a7e4:	2b00      	cmp	r3, #0
9000a7e6:	d001      	beq.n	9000a7ec <USBD_LL_Reset+0x66>
      {
        ret = USBD_FAIL;
9000a7e8:	2303      	movs	r3, #3
9000a7ea:	73fb      	strb	r3, [r7, #15]
    }
  }
#endif /* USE_USBD_COMPOSITE */

  /* Open EP0 OUT */
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
9000a7ec:	2340      	movs	r3, #64	@ 0x40
9000a7ee:	2200      	movs	r2, #0
9000a7f0:	2100      	movs	r1, #0
9000a7f2:	6878      	ldr	r0, [r7, #4]
9000a7f4:	f7f6 fc29 	bl	9000104a <USBD_LL_OpenEP>
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
9000a7f8:	687b      	ldr	r3, [r7, #4]
9000a7fa:	2201      	movs	r2, #1
9000a7fc:	f883 2163 	strb.w	r2, [r3, #355]	@ 0x163

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
9000a800:	687b      	ldr	r3, [r7, #4]
9000a802:	2240      	movs	r2, #64	@ 0x40
9000a804:	f8a3 2160 	strh.w	r2, [r3, #352]	@ 0x160

  /* Open EP0 IN */
  (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
9000a808:	2340      	movs	r3, #64	@ 0x40
9000a80a:	2200      	movs	r2, #0
9000a80c:	2180      	movs	r1, #128	@ 0x80
9000a80e:	6878      	ldr	r0, [r7, #4]
9000a810:	f7f6 fc1b 	bl	9000104a <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
9000a814:	687b      	ldr	r3, [r7, #4]
9000a816:	2201      	movs	r2, #1
9000a818:	f883 2023 	strb.w	r2, [r3, #35]	@ 0x23

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
9000a81c:	687b      	ldr	r3, [r7, #4]
9000a81e:	2240      	movs	r2, #64	@ 0x40
9000a820:	841a      	strh	r2, [r3, #32]

  return ret;
9000a822:	7bfb      	ldrb	r3, [r7, #15]
}
9000a824:	4618      	mov	r0, r3
9000a826:	3710      	adds	r7, #16
9000a828:	46bd      	mov	sp, r7
9000a82a:	bd80      	pop	{r7, pc}

9000a82c <USBD_LL_SetSpeed>:
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
9000a82c:	b480      	push	{r7}
9000a82e:	b083      	sub	sp, #12
9000a830:	af00      	add	r7, sp, #0
9000a832:	6078      	str	r0, [r7, #4]
9000a834:	460b      	mov	r3, r1
9000a836:	70fb      	strb	r3, [r7, #3]
  pdev->dev_speed = speed;
9000a838:	687b      	ldr	r3, [r7, #4]
9000a83a:	78fa      	ldrb	r2, [r7, #3]
9000a83c:	741a      	strb	r2, [r3, #16]

  return USBD_OK;
9000a83e:	2300      	movs	r3, #0
}
9000a840:	4618      	mov	r0, r3
9000a842:	370c      	adds	r7, #12
9000a844:	46bd      	mov	sp, r7
9000a846:	f85d 7b04 	ldr.w	r7, [sp], #4
9000a84a:	4770      	bx	lr

9000a84c <USBD_LL_Suspend>:
  *         Handle Suspend event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
9000a84c:	b480      	push	{r7}
9000a84e:	b083      	sub	sp, #12
9000a850:	af00      	add	r7, sp, #0
9000a852:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state != USBD_STATE_SUSPENDED)
9000a854:	687b      	ldr	r3, [r7, #4]
9000a856:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000a85a:	b2db      	uxtb	r3, r3
9000a85c:	2b04      	cmp	r3, #4
9000a85e:	d006      	beq.n	9000a86e <USBD_LL_Suspend+0x22>
  {
    pdev->dev_old_state = pdev->dev_state;
9000a860:	687b      	ldr	r3, [r7, #4]
9000a862:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000a866:	b2da      	uxtb	r2, r3
9000a868:	687b      	ldr	r3, [r7, #4]
9000a86a:	f883 229d 	strb.w	r2, [r3, #669]	@ 0x29d
  }

  pdev->dev_state = USBD_STATE_SUSPENDED;
9000a86e:	687b      	ldr	r3, [r7, #4]
9000a870:	2204      	movs	r2, #4
9000a872:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c

  return USBD_OK;
9000a876:	2300      	movs	r3, #0
}
9000a878:	4618      	mov	r0, r3
9000a87a:	370c      	adds	r7, #12
9000a87c:	46bd      	mov	sp, r7
9000a87e:	f85d 7b04 	ldr.w	r7, [sp], #4
9000a882:	4770      	bx	lr

9000a884 <USBD_LL_Resume>:
  *         Handle Resume event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
9000a884:	b480      	push	{r7}
9000a886:	b083      	sub	sp, #12
9000a888:	af00      	add	r7, sp, #0
9000a88a:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
9000a88c:	687b      	ldr	r3, [r7, #4]
9000a88e:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000a892:	b2db      	uxtb	r3, r3
9000a894:	2b04      	cmp	r3, #4
9000a896:	d106      	bne.n	9000a8a6 <USBD_LL_Resume+0x22>
  {
    pdev->dev_state = pdev->dev_old_state;
9000a898:	687b      	ldr	r3, [r7, #4]
9000a89a:	f893 329d 	ldrb.w	r3, [r3, #669]	@ 0x29d
9000a89e:	b2da      	uxtb	r2, r3
9000a8a0:	687b      	ldr	r3, [r7, #4]
9000a8a2:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  }

  return USBD_OK;
9000a8a6:	2300      	movs	r3, #0
}
9000a8a8:	4618      	mov	r0, r3
9000a8aa:	370c      	adds	r7, #12
9000a8ac:	46bd      	mov	sp, r7
9000a8ae:	f85d 7b04 	ldr.w	r7, [sp], #4
9000a8b2:	4770      	bx	lr

9000a8b4 <USBD_LL_SOF>:
  *         Handle SOF event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
9000a8b4:	b580      	push	{r7, lr}
9000a8b6:	b082      	sub	sp, #8
9000a8b8:	af00      	add	r7, sp, #0
9000a8ba:	6078      	str	r0, [r7, #4]
  /* The SOF event can be distributed for all classes that support it */
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
9000a8bc:	687b      	ldr	r3, [r7, #4]
9000a8be:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000a8c2:	b2db      	uxtb	r3, r3
9000a8c4:	2b03      	cmp	r3, #3
9000a8c6:	d110      	bne.n	9000a8ea <USBD_LL_SOF+0x36>
          }
        }
      }
    }
#else
    if (pdev->pClass[0] != NULL)
9000a8c8:	687b      	ldr	r3, [r7, #4]
9000a8ca:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
9000a8ce:	2b00      	cmp	r3, #0
9000a8d0:	d00b      	beq.n	9000a8ea <USBD_LL_SOF+0x36>
    {
      if (pdev->pClass[0]->SOF != NULL)
9000a8d2:	687b      	ldr	r3, [r7, #4]
9000a8d4:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
9000a8d8:	69db      	ldr	r3, [r3, #28]
9000a8da:	2b00      	cmp	r3, #0
9000a8dc:	d005      	beq.n	9000a8ea <USBD_LL_SOF+0x36>
      {
        (void)pdev->pClass[0]->SOF(pdev);
9000a8de:	687b      	ldr	r3, [r7, #4]
9000a8e0:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
9000a8e4:	69db      	ldr	r3, [r3, #28]
9000a8e6:	6878      	ldr	r0, [r7, #4]
9000a8e8:	4798      	blx	r3
      }
    }
#endif /* USE_USBD_COMPOSITE */
  }

  return USBD_OK;
9000a8ea:	2300      	movs	r3, #0
}
9000a8ec:	4618      	mov	r0, r3
9000a8ee:	3708      	adds	r7, #8
9000a8f0:	46bd      	mov	sp, r7
9000a8f2:	bd80      	pop	{r7, pc}

9000a8f4 <USBD_LL_IsoINIncomplete>:
  * @param  epnum: Endpoint number
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef *pdev,
                                           uint8_t epnum)
{
9000a8f4:	b580      	push	{r7, lr}
9000a8f6:	b082      	sub	sp, #8
9000a8f8:	af00      	add	r7, sp, #0
9000a8fa:	6078      	str	r0, [r7, #4]
9000a8fc:	460b      	mov	r3, r1
9000a8fe:	70fb      	strb	r3, [r7, #3]
  if (pdev->pClass[pdev->classId] == NULL)
9000a900:	687b      	ldr	r3, [r7, #4]
9000a902:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000a906:	687b      	ldr	r3, [r7, #4]
9000a908:	32ae      	adds	r2, #174	@ 0xae
9000a90a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000a90e:	2b00      	cmp	r3, #0
9000a910:	d101      	bne.n	9000a916 <USBD_LL_IsoINIncomplete+0x22>
  {
    return USBD_FAIL;
9000a912:	2303      	movs	r3, #3
9000a914:	e01c      	b.n	9000a950 <USBD_LL_IsoINIncomplete+0x5c>
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
9000a916:	687b      	ldr	r3, [r7, #4]
9000a918:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000a91c:	b2db      	uxtb	r3, r3
9000a91e:	2b03      	cmp	r3, #3
9000a920:	d115      	bne.n	9000a94e <USBD_LL_IsoINIncomplete+0x5a>
  {
    if (pdev->pClass[pdev->classId]->IsoINIncomplete != NULL)
9000a922:	687b      	ldr	r3, [r7, #4]
9000a924:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000a928:	687b      	ldr	r3, [r7, #4]
9000a92a:	32ae      	adds	r2, #174	@ 0xae
9000a92c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000a930:	6a1b      	ldr	r3, [r3, #32]
9000a932:	2b00      	cmp	r3, #0
9000a934:	d00b      	beq.n	9000a94e <USBD_LL_IsoINIncomplete+0x5a>
    {
      (void)pdev->pClass[pdev->classId]->IsoINIncomplete(pdev, epnum);
9000a936:	687b      	ldr	r3, [r7, #4]
9000a938:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000a93c:	687b      	ldr	r3, [r7, #4]
9000a93e:	32ae      	adds	r2, #174	@ 0xae
9000a940:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000a944:	6a1b      	ldr	r3, [r3, #32]
9000a946:	78fa      	ldrb	r2, [r7, #3]
9000a948:	4611      	mov	r1, r2
9000a94a:	6878      	ldr	r0, [r7, #4]
9000a94c:	4798      	blx	r3
    }
  }

  return USBD_OK;
9000a94e:	2300      	movs	r3, #0
}
9000a950:	4618      	mov	r0, r3
9000a952:	3708      	adds	r7, #8
9000a954:	46bd      	mov	sp, r7
9000a956:	bd80      	pop	{r7, pc}

9000a958 <USBD_LL_IsoOUTIncomplete>:
  * @param  epnum: Endpoint number
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef *pdev,
                                            uint8_t epnum)
{
9000a958:	b580      	push	{r7, lr}
9000a95a:	b082      	sub	sp, #8
9000a95c:	af00      	add	r7, sp, #0
9000a95e:	6078      	str	r0, [r7, #4]
9000a960:	460b      	mov	r3, r1
9000a962:	70fb      	strb	r3, [r7, #3]
  if (pdev->pClass[pdev->classId] == NULL)
9000a964:	687b      	ldr	r3, [r7, #4]
9000a966:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000a96a:	687b      	ldr	r3, [r7, #4]
9000a96c:	32ae      	adds	r2, #174	@ 0xae
9000a96e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000a972:	2b00      	cmp	r3, #0
9000a974:	d101      	bne.n	9000a97a <USBD_LL_IsoOUTIncomplete+0x22>
  {
    return USBD_FAIL;
9000a976:	2303      	movs	r3, #3
9000a978:	e01c      	b.n	9000a9b4 <USBD_LL_IsoOUTIncomplete+0x5c>
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
9000a97a:	687b      	ldr	r3, [r7, #4]
9000a97c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000a980:	b2db      	uxtb	r3, r3
9000a982:	2b03      	cmp	r3, #3
9000a984:	d115      	bne.n	9000a9b2 <USBD_LL_IsoOUTIncomplete+0x5a>
  {
    if (pdev->pClass[pdev->classId]->IsoOUTIncomplete != NULL)
9000a986:	687b      	ldr	r3, [r7, #4]
9000a988:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000a98c:	687b      	ldr	r3, [r7, #4]
9000a98e:	32ae      	adds	r2, #174	@ 0xae
9000a990:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000a994:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
9000a996:	2b00      	cmp	r3, #0
9000a998:	d00b      	beq.n	9000a9b2 <USBD_LL_IsoOUTIncomplete+0x5a>
    {
      (void)pdev->pClass[pdev->classId]->IsoOUTIncomplete(pdev, epnum);
9000a99a:	687b      	ldr	r3, [r7, #4]
9000a99c:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000a9a0:	687b      	ldr	r3, [r7, #4]
9000a9a2:	32ae      	adds	r2, #174	@ 0xae
9000a9a4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000a9a8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
9000a9aa:	78fa      	ldrb	r2, [r7, #3]
9000a9ac:	4611      	mov	r1, r2
9000a9ae:	6878      	ldr	r0, [r7, #4]
9000a9b0:	4798      	blx	r3
    }
  }

  return USBD_OK;
9000a9b2:	2300      	movs	r3, #0
}
9000a9b4:	4618      	mov	r0, r3
9000a9b6:	3708      	adds	r7, #8
9000a9b8:	46bd      	mov	sp, r7
9000a9ba:	bd80      	pop	{r7, pc}

9000a9bc <USBD_LL_DevConnected>:
  *         Handle device connection event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef *pdev)
{
9000a9bc:	b480      	push	{r7}
9000a9be:	b083      	sub	sp, #12
9000a9c0:	af00      	add	r7, sp, #0
9000a9c2:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
9000a9c4:	2300      	movs	r3, #0
}
9000a9c6:	4618      	mov	r0, r3
9000a9c8:	370c      	adds	r7, #12
9000a9ca:	46bd      	mov	sp, r7
9000a9cc:	f85d 7b04 	ldr.w	r7, [sp], #4
9000a9d0:	4770      	bx	lr

9000a9d2 <USBD_LL_DevDisconnected>:
  *         Handle device disconnection event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef *pdev)
{
9000a9d2:	b580      	push	{r7, lr}
9000a9d4:	b084      	sub	sp, #16
9000a9d6:	af00      	add	r7, sp, #0
9000a9d8:	6078      	str	r0, [r7, #4]
  USBD_StatusTypeDef   ret = USBD_OK;
9000a9da:	2300      	movs	r3, #0
9000a9dc:	73fb      	strb	r3, [r7, #15]

  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
9000a9de:	687b      	ldr	r3, [r7, #4]
9000a9e0:	2201      	movs	r2, #1
9000a9e2:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
9000a9e6:	687b      	ldr	r3, [r7, #4]
9000a9e8:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
9000a9ec:	2b00      	cmp	r3, #0
9000a9ee:	d00e      	beq.n	9000aa0e <USBD_LL_DevDisconnected+0x3c>
  {
    if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != 0U)
9000a9f0:	687b      	ldr	r3, [r7, #4]
9000a9f2:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
9000a9f6:	685b      	ldr	r3, [r3, #4]
9000a9f8:	687a      	ldr	r2, [r7, #4]
9000a9fa:	6852      	ldr	r2, [r2, #4]
9000a9fc:	b2d2      	uxtb	r2, r2
9000a9fe:	4611      	mov	r1, r2
9000aa00:	6878      	ldr	r0, [r7, #4]
9000aa02:	4798      	blx	r3
9000aa04:	4603      	mov	r3, r0
9000aa06:	2b00      	cmp	r3, #0
9000aa08:	d001      	beq.n	9000aa0e <USBD_LL_DevDisconnected+0x3c>
    {
      ret = USBD_FAIL;
9000aa0a:	2303      	movs	r3, #3
9000aa0c:	73fb      	strb	r3, [r7, #15]
    }
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
9000aa0e:	7bfb      	ldrb	r3, [r7, #15]
}
9000aa10:	4618      	mov	r0, r3
9000aa12:	3710      	adds	r7, #16
9000aa14:	46bd      	mov	sp, r7
9000aa16:	bd80      	pop	{r7, pc}

9000aa18 <USBD_CoreFindIF>:
  * @param  pdev: device instance
  * @param  index : selected interface number
  * @retval index of the class using the selected interface number. OxFF if no class found.
  */
uint8_t USBD_CoreFindIF(USBD_HandleTypeDef *pdev, uint8_t index)
{
9000aa18:	b480      	push	{r7}
9000aa1a:	b083      	sub	sp, #12
9000aa1c:	af00      	add	r7, sp, #0
9000aa1e:	6078      	str	r0, [r7, #4]
9000aa20:	460b      	mov	r3, r1
9000aa22:	70fb      	strb	r3, [r7, #3]
  return 0xFFU;
#else
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
9000aa24:	2300      	movs	r3, #0
#endif /* USE_USBD_COMPOSITE */
}
9000aa26:	4618      	mov	r0, r3
9000aa28:	370c      	adds	r7, #12
9000aa2a:	46bd      	mov	sp, r7
9000aa2c:	f85d 7b04 	ldr.w	r7, [sp], #4
9000aa30:	4770      	bx	lr

9000aa32 <USBD_CoreFindEP>:
  * @param  pdev: device instance
  * @param  index : selected endpoint number
  * @retval index of the class using the selected endpoint number. 0xFF if no class found.
  */
uint8_t USBD_CoreFindEP(USBD_HandleTypeDef *pdev, uint8_t index)
{
9000aa32:	b480      	push	{r7}
9000aa34:	b083      	sub	sp, #12
9000aa36:	af00      	add	r7, sp, #0
9000aa38:	6078      	str	r0, [r7, #4]
9000aa3a:	460b      	mov	r3, r1
9000aa3c:	70fb      	strb	r3, [r7, #3]
  return 0xFFU;
#else
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
9000aa3e:	2300      	movs	r3, #0
#endif /* USE_USBD_COMPOSITE */
}
9000aa40:	4618      	mov	r0, r3
9000aa42:	370c      	adds	r7, #12
9000aa44:	46bd      	mov	sp, r7
9000aa46:	f85d 7b04 	ldr.w	r7, [sp], #4
9000aa4a:	4770      	bx	lr

9000aa4c <USBD_GetEpDesc>:
  * @param  pConfDesc:  pointer to Bos descriptor
  * @param  EpAddr:  endpoint address
  * @retval pointer to video endpoint descriptor
  */
void *USBD_GetEpDesc(uint8_t *pConfDesc, uint8_t EpAddr)
{
9000aa4c:	b580      	push	{r7, lr}
9000aa4e:	b086      	sub	sp, #24
9000aa50:	af00      	add	r7, sp, #0
9000aa52:	6078      	str	r0, [r7, #4]
9000aa54:	460b      	mov	r3, r1
9000aa56:	70fb      	strb	r3, [r7, #3]
  USBD_DescHeaderTypeDef *pdesc = (USBD_DescHeaderTypeDef *)(void *)pConfDesc;
9000aa58:	687b      	ldr	r3, [r7, #4]
9000aa5a:	617b      	str	r3, [r7, #20]
  USBD_ConfigDescTypeDef *desc = (USBD_ConfigDescTypeDef *)(void *)pConfDesc;
9000aa5c:	687b      	ldr	r3, [r7, #4]
9000aa5e:	60fb      	str	r3, [r7, #12]
  USBD_EpDescTypeDef *pEpDesc = NULL;
9000aa60:	2300      	movs	r3, #0
9000aa62:	613b      	str	r3, [r7, #16]
  uint16_t ptr;

  if (desc->wTotalLength > desc->bLength)
9000aa64:	68fb      	ldr	r3, [r7, #12]
9000aa66:	885b      	ldrh	r3, [r3, #2]
9000aa68:	b29b      	uxth	r3, r3
9000aa6a:	68fa      	ldr	r2, [r7, #12]
9000aa6c:	7812      	ldrb	r2, [r2, #0]
9000aa6e:	4293      	cmp	r3, r2
9000aa70:	d91f      	bls.n	9000aab2 <USBD_GetEpDesc+0x66>
  {
    ptr = desc->bLength;
9000aa72:	68fb      	ldr	r3, [r7, #12]
9000aa74:	781b      	ldrb	r3, [r3, #0]
9000aa76:	817b      	strh	r3, [r7, #10]

    while (ptr < desc->wTotalLength)
9000aa78:	e013      	b.n	9000aaa2 <USBD_GetEpDesc+0x56>
    {
      pdesc = USBD_GetNextDesc((uint8_t *)pdesc, &ptr);
9000aa7a:	f107 030a 	add.w	r3, r7, #10
9000aa7e:	4619      	mov	r1, r3
9000aa80:	6978      	ldr	r0, [r7, #20]
9000aa82:	f000 f81b 	bl	9000aabc <USBD_GetNextDesc>
9000aa86:	6178      	str	r0, [r7, #20]

      if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
9000aa88:	697b      	ldr	r3, [r7, #20]
9000aa8a:	785b      	ldrb	r3, [r3, #1]
9000aa8c:	2b05      	cmp	r3, #5
9000aa8e:	d108      	bne.n	9000aaa2 <USBD_GetEpDesc+0x56>
      {
        pEpDesc = (USBD_EpDescTypeDef *)(void *)pdesc;
9000aa90:	697b      	ldr	r3, [r7, #20]
9000aa92:	613b      	str	r3, [r7, #16]

        if (pEpDesc->bEndpointAddress == EpAddr)
9000aa94:	693b      	ldr	r3, [r7, #16]
9000aa96:	789b      	ldrb	r3, [r3, #2]
9000aa98:	78fa      	ldrb	r2, [r7, #3]
9000aa9a:	429a      	cmp	r2, r3
9000aa9c:	d008      	beq.n	9000aab0 <USBD_GetEpDesc+0x64>
        {
          break;
        }
        else
        {
          pEpDesc = NULL;
9000aa9e:	2300      	movs	r3, #0
9000aaa0:	613b      	str	r3, [r7, #16]
    while (ptr < desc->wTotalLength)
9000aaa2:	68fb      	ldr	r3, [r7, #12]
9000aaa4:	885b      	ldrh	r3, [r3, #2]
9000aaa6:	b29a      	uxth	r2, r3
9000aaa8:	897b      	ldrh	r3, [r7, #10]
9000aaaa:	429a      	cmp	r2, r3
9000aaac:	d8e5      	bhi.n	9000aa7a <USBD_GetEpDesc+0x2e>
9000aaae:	e000      	b.n	9000aab2 <USBD_GetEpDesc+0x66>
          break;
9000aab0:	bf00      	nop
        }
      }
    }
  }

  return (void *)pEpDesc;
9000aab2:	693b      	ldr	r3, [r7, #16]
}
9000aab4:	4618      	mov	r0, r3
9000aab6:	3718      	adds	r7, #24
9000aab8:	46bd      	mov	sp, r7
9000aaba:	bd80      	pop	{r7, pc}

9000aabc <USBD_GetNextDesc>:
  * @param  buf: Buffer where the descriptor is available
  * @param  ptr: data pointer inside the descriptor
  * @retval next header
  */
USBD_DescHeaderTypeDef *USBD_GetNextDesc(uint8_t *pbuf, uint16_t *ptr)
{
9000aabc:	b480      	push	{r7}
9000aabe:	b085      	sub	sp, #20
9000aac0:	af00      	add	r7, sp, #0
9000aac2:	6078      	str	r0, [r7, #4]
9000aac4:	6039      	str	r1, [r7, #0]
  USBD_DescHeaderTypeDef *pnext = (USBD_DescHeaderTypeDef *)(void *)pbuf;
9000aac6:	687b      	ldr	r3, [r7, #4]
9000aac8:	60fb      	str	r3, [r7, #12]

  *ptr += pnext->bLength;
9000aaca:	683b      	ldr	r3, [r7, #0]
9000aacc:	881b      	ldrh	r3, [r3, #0]
9000aace:	68fa      	ldr	r2, [r7, #12]
9000aad0:	7812      	ldrb	r2, [r2, #0]
9000aad2:	4413      	add	r3, r2
9000aad4:	b29a      	uxth	r2, r3
9000aad6:	683b      	ldr	r3, [r7, #0]
9000aad8:	801a      	strh	r2, [r3, #0]
  pnext = (USBD_DescHeaderTypeDef *)(void *)(pbuf + pnext->bLength);
9000aada:	68fb      	ldr	r3, [r7, #12]
9000aadc:	781b      	ldrb	r3, [r3, #0]
9000aade:	461a      	mov	r2, r3
9000aae0:	687b      	ldr	r3, [r7, #4]
9000aae2:	4413      	add	r3, r2
9000aae4:	60fb      	str	r3, [r7, #12]

  return (pnext);
9000aae6:	68fb      	ldr	r3, [r7, #12]
}
9000aae8:	4618      	mov	r0, r3
9000aaea:	3714      	adds	r7, #20
9000aaec:	46bd      	mov	sp, r7
9000aaee:	f85d 7b04 	ldr.w	r7, [sp], #4
9000aaf2:	4770      	bx	lr

9000aaf4 <SWAPBYTE>:

/** @defgroup USBD_DEF_Exported_Macros
  * @{
  */
__STATIC_INLINE uint16_t SWAPBYTE(uint8_t *addr)
{
9000aaf4:	b480      	push	{r7}
9000aaf6:	b087      	sub	sp, #28
9000aaf8:	af00      	add	r7, sp, #0
9000aafa:	6078      	str	r0, [r7, #4]
  uint16_t _SwapVal;
  uint16_t _Byte1;
  uint16_t _Byte2;
  uint8_t *_pbuff = addr;
9000aafc:	687b      	ldr	r3, [r7, #4]
9000aafe:	617b      	str	r3, [r7, #20]

  _Byte1 = *(uint8_t *)_pbuff;
9000ab00:	697b      	ldr	r3, [r7, #20]
9000ab02:	781b      	ldrb	r3, [r3, #0]
9000ab04:	827b      	strh	r3, [r7, #18]
  _pbuff++;
9000ab06:	697b      	ldr	r3, [r7, #20]
9000ab08:	3301      	adds	r3, #1
9000ab0a:	617b      	str	r3, [r7, #20]
  _Byte2 = *(uint8_t *)_pbuff;
9000ab0c:	697b      	ldr	r3, [r7, #20]
9000ab0e:	781b      	ldrb	r3, [r3, #0]
9000ab10:	823b      	strh	r3, [r7, #16]

  _SwapVal = (_Byte2 << 8) | _Byte1;
9000ab12:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
9000ab16:	021b      	lsls	r3, r3, #8
9000ab18:	b21a      	sxth	r2, r3
9000ab1a:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
9000ab1e:	4313      	orrs	r3, r2
9000ab20:	b21b      	sxth	r3, r3
9000ab22:	81fb      	strh	r3, [r7, #14]

  return _SwapVal;
9000ab24:	89fb      	ldrh	r3, [r7, #14]
}
9000ab26:	4618      	mov	r0, r3
9000ab28:	371c      	adds	r7, #28
9000ab2a:	46bd      	mov	sp, r7
9000ab2c:	f85d 7b04 	ldr.w	r7, [sp], #4
9000ab30:	4770      	bx	lr
	...

9000ab34 <USBD_StdDevReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdDevReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
9000ab34:	b580      	push	{r7, lr}
9000ab36:	b084      	sub	sp, #16
9000ab38:	af00      	add	r7, sp, #0
9000ab3a:	6078      	str	r0, [r7, #4]
9000ab3c:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
9000ab3e:	2300      	movs	r3, #0
9000ab40:	73fb      	strb	r3, [r7, #15]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
9000ab42:	683b      	ldr	r3, [r7, #0]
9000ab44:	781b      	ldrb	r3, [r3, #0]
9000ab46:	f003 0360 	and.w	r3, r3, #96	@ 0x60
9000ab4a:	2b40      	cmp	r3, #64	@ 0x40
9000ab4c:	d005      	beq.n	9000ab5a <USBD_StdDevReq+0x26>
9000ab4e:	2b40      	cmp	r3, #64	@ 0x40
9000ab50:	d857      	bhi.n	9000ac02 <USBD_StdDevReq+0xce>
9000ab52:	2b00      	cmp	r3, #0
9000ab54:	d00f      	beq.n	9000ab76 <USBD_StdDevReq+0x42>
9000ab56:	2b20      	cmp	r3, #32
9000ab58:	d153      	bne.n	9000ac02 <USBD_StdDevReq+0xce>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      ret = (USBD_StatusTypeDef)pdev->pClass[pdev->classId]->Setup(pdev, req);
9000ab5a:	687b      	ldr	r3, [r7, #4]
9000ab5c:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000ab60:	687b      	ldr	r3, [r7, #4]
9000ab62:	32ae      	adds	r2, #174	@ 0xae
9000ab64:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000ab68:	689b      	ldr	r3, [r3, #8]
9000ab6a:	6839      	ldr	r1, [r7, #0]
9000ab6c:	6878      	ldr	r0, [r7, #4]
9000ab6e:	4798      	blx	r3
9000ab70:	4603      	mov	r3, r0
9000ab72:	73fb      	strb	r3, [r7, #15]
      break;
9000ab74:	e04a      	b.n	9000ac0c <USBD_StdDevReq+0xd8>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
9000ab76:	683b      	ldr	r3, [r7, #0]
9000ab78:	785b      	ldrb	r3, [r3, #1]
9000ab7a:	2b09      	cmp	r3, #9
9000ab7c:	d83b      	bhi.n	9000abf6 <USBD_StdDevReq+0xc2>
9000ab7e:	a201      	add	r2, pc, #4	@ (adr r2, 9000ab84 <USBD_StdDevReq+0x50>)
9000ab80:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
9000ab84:	9000abd9 	.word	0x9000abd9
9000ab88:	9000abed 	.word	0x9000abed
9000ab8c:	9000abf7 	.word	0x9000abf7
9000ab90:	9000abe3 	.word	0x9000abe3
9000ab94:	9000abf7 	.word	0x9000abf7
9000ab98:	9000abb7 	.word	0x9000abb7
9000ab9c:	9000abad 	.word	0x9000abad
9000aba0:	9000abf7 	.word	0x9000abf7
9000aba4:	9000abcf 	.word	0x9000abcf
9000aba8:	9000abc1 	.word	0x9000abc1
      {
        case USB_REQ_GET_DESCRIPTOR:
          USBD_GetDescriptor(pdev, req);
9000abac:	6839      	ldr	r1, [r7, #0]
9000abae:	6878      	ldr	r0, [r7, #4]
9000abb0:	f000 fa3e 	bl	9000b030 <USBD_GetDescriptor>
          break;
9000abb4:	e024      	b.n	9000ac00 <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_ADDRESS:
          USBD_SetAddress(pdev, req);
9000abb6:	6839      	ldr	r1, [r7, #0]
9000abb8:	6878      	ldr	r0, [r7, #4]
9000abba:	f000 fbcd 	bl	9000b358 <USBD_SetAddress>
          break;
9000abbe:	e01f      	b.n	9000ac00 <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_CONFIGURATION:
          ret = USBD_SetConfig(pdev, req);
9000abc0:	6839      	ldr	r1, [r7, #0]
9000abc2:	6878      	ldr	r0, [r7, #4]
9000abc4:	f000 fc0c 	bl	9000b3e0 <USBD_SetConfig>
9000abc8:	4603      	mov	r3, r0
9000abca:	73fb      	strb	r3, [r7, #15]
          break;
9000abcc:	e018      	b.n	9000ac00 <USBD_StdDevReq+0xcc>

        case USB_REQ_GET_CONFIGURATION:
          USBD_GetConfig(pdev, req);
9000abce:	6839      	ldr	r1, [r7, #0]
9000abd0:	6878      	ldr	r0, [r7, #4]
9000abd2:	f000 fcaf 	bl	9000b534 <USBD_GetConfig>
          break;
9000abd6:	e013      	b.n	9000ac00 <USBD_StdDevReq+0xcc>

        case USB_REQ_GET_STATUS:
          USBD_GetStatus(pdev, req);
9000abd8:	6839      	ldr	r1, [r7, #0]
9000abda:	6878      	ldr	r0, [r7, #4]
9000abdc:	f000 fce0 	bl	9000b5a0 <USBD_GetStatus>
          break;
9000abe0:	e00e      	b.n	9000ac00 <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_FEATURE:
          USBD_SetFeature(pdev, req);
9000abe2:	6839      	ldr	r1, [r7, #0]
9000abe4:	6878      	ldr	r0, [r7, #4]
9000abe6:	f000 fd0f 	bl	9000b608 <USBD_SetFeature>
          break;
9000abea:	e009      	b.n	9000ac00 <USBD_StdDevReq+0xcc>

        case USB_REQ_CLEAR_FEATURE:
          USBD_ClrFeature(pdev, req);
9000abec:	6839      	ldr	r1, [r7, #0]
9000abee:	6878      	ldr	r0, [r7, #4]
9000abf0:	f000 fd33 	bl	9000b65a <USBD_ClrFeature>
          break;
9000abf4:	e004      	b.n	9000ac00 <USBD_StdDevReq+0xcc>

        default:
          USBD_CtlError(pdev, req);
9000abf6:	6839      	ldr	r1, [r7, #0]
9000abf8:	6878      	ldr	r0, [r7, #4]
9000abfa:	f000 fd8a 	bl	9000b712 <USBD_CtlError>
          break;
9000abfe:	bf00      	nop
      }
      break;
9000ac00:	e004      	b.n	9000ac0c <USBD_StdDevReq+0xd8>

    default:
      USBD_CtlError(pdev, req);
9000ac02:	6839      	ldr	r1, [r7, #0]
9000ac04:	6878      	ldr	r0, [r7, #4]
9000ac06:	f000 fd84 	bl	9000b712 <USBD_CtlError>
      break;
9000ac0a:	bf00      	nop
  }

  return ret;
9000ac0c:	7bfb      	ldrb	r3, [r7, #15]
}
9000ac0e:	4618      	mov	r0, r3
9000ac10:	3710      	adds	r7, #16
9000ac12:	46bd      	mov	sp, r7
9000ac14:	bd80      	pop	{r7, pc}
9000ac16:	bf00      	nop

9000ac18 <USBD_StdItfReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdItfReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
9000ac18:	b580      	push	{r7, lr}
9000ac1a:	b084      	sub	sp, #16
9000ac1c:	af00      	add	r7, sp, #0
9000ac1e:	6078      	str	r0, [r7, #4]
9000ac20:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
9000ac22:	2300      	movs	r3, #0
9000ac24:	73fb      	strb	r3, [r7, #15]
  uint8_t idx;

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
9000ac26:	683b      	ldr	r3, [r7, #0]
9000ac28:	781b      	ldrb	r3, [r3, #0]
9000ac2a:	f003 0360 	and.w	r3, r3, #96	@ 0x60
9000ac2e:	2b40      	cmp	r3, #64	@ 0x40
9000ac30:	d005      	beq.n	9000ac3e <USBD_StdItfReq+0x26>
9000ac32:	2b40      	cmp	r3, #64	@ 0x40
9000ac34:	d852      	bhi.n	9000acdc <USBD_StdItfReq+0xc4>
9000ac36:	2b00      	cmp	r3, #0
9000ac38:	d001      	beq.n	9000ac3e <USBD_StdItfReq+0x26>
9000ac3a:	2b20      	cmp	r3, #32
9000ac3c:	d14e      	bne.n	9000acdc <USBD_StdItfReq+0xc4>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
    case USB_REQ_TYPE_STANDARD:
      switch (pdev->dev_state)
9000ac3e:	687b      	ldr	r3, [r7, #4]
9000ac40:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000ac44:	b2db      	uxtb	r3, r3
9000ac46:	3b01      	subs	r3, #1
9000ac48:	2b02      	cmp	r3, #2
9000ac4a:	d840      	bhi.n	9000acce <USBD_StdItfReq+0xb6>
      {
        case USBD_STATE_DEFAULT:
        case USBD_STATE_ADDRESSED:
        case USBD_STATE_CONFIGURED:

          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
9000ac4c:	683b      	ldr	r3, [r7, #0]
9000ac4e:	889b      	ldrh	r3, [r3, #4]
9000ac50:	b2db      	uxtb	r3, r3
9000ac52:	2b01      	cmp	r3, #1
9000ac54:	d836      	bhi.n	9000acc4 <USBD_StdItfReq+0xac>
          {
            /* Get the class index relative to this interface */
            idx = USBD_CoreFindIF(pdev, LOBYTE(req->wIndex));
9000ac56:	683b      	ldr	r3, [r7, #0]
9000ac58:	889b      	ldrh	r3, [r3, #4]
9000ac5a:	b2db      	uxtb	r3, r3
9000ac5c:	4619      	mov	r1, r3
9000ac5e:	6878      	ldr	r0, [r7, #4]
9000ac60:	f7ff feda 	bl	9000aa18 <USBD_CoreFindIF>
9000ac64:	4603      	mov	r3, r0
9000ac66:	73bb      	strb	r3, [r7, #14]
            if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
9000ac68:	7bbb      	ldrb	r3, [r7, #14]
9000ac6a:	2bff      	cmp	r3, #255	@ 0xff
9000ac6c:	d01d      	beq.n	9000acaa <USBD_StdItfReq+0x92>
9000ac6e:	7bbb      	ldrb	r3, [r7, #14]
9000ac70:	2b00      	cmp	r3, #0
9000ac72:	d11a      	bne.n	9000acaa <USBD_StdItfReq+0x92>
            {
              /* Call the class data out function to manage the request */
              if (pdev->pClass[idx]->Setup != NULL)
9000ac74:	7bba      	ldrb	r2, [r7, #14]
9000ac76:	687b      	ldr	r3, [r7, #4]
9000ac78:	32ae      	adds	r2, #174	@ 0xae
9000ac7a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000ac7e:	689b      	ldr	r3, [r3, #8]
9000ac80:	2b00      	cmp	r3, #0
9000ac82:	d00f      	beq.n	9000aca4 <USBD_StdItfReq+0x8c>
              {
                pdev->classId = idx;
9000ac84:	7bba      	ldrb	r2, [r7, #14]
9000ac86:	687b      	ldr	r3, [r7, #4]
9000ac88:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
                ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
9000ac8c:	7bba      	ldrb	r2, [r7, #14]
9000ac8e:	687b      	ldr	r3, [r7, #4]
9000ac90:	32ae      	adds	r2, #174	@ 0xae
9000ac92:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000ac96:	689b      	ldr	r3, [r3, #8]
9000ac98:	6839      	ldr	r1, [r7, #0]
9000ac9a:	6878      	ldr	r0, [r7, #4]
9000ac9c:	4798      	blx	r3
9000ac9e:	4603      	mov	r3, r0
9000aca0:	73fb      	strb	r3, [r7, #15]
              if (pdev->pClass[idx]->Setup != NULL)
9000aca2:	e004      	b.n	9000acae <USBD_StdItfReq+0x96>
              }
              else
              {
                /* should never reach this condition */
                ret = USBD_FAIL;
9000aca4:	2303      	movs	r3, #3
9000aca6:	73fb      	strb	r3, [r7, #15]
              if (pdev->pClass[idx]->Setup != NULL)
9000aca8:	e001      	b.n	9000acae <USBD_StdItfReq+0x96>
              }
            }
            else
            {
              /* No relative interface found */
              ret = USBD_FAIL;
9000acaa:	2303      	movs	r3, #3
9000acac:	73fb      	strb	r3, [r7, #15]
            }

            if ((req->wLength == 0U) && (ret == USBD_OK))
9000acae:	683b      	ldr	r3, [r7, #0]
9000acb0:	88db      	ldrh	r3, [r3, #6]
9000acb2:	2b00      	cmp	r3, #0
9000acb4:	d110      	bne.n	9000acd8 <USBD_StdItfReq+0xc0>
9000acb6:	7bfb      	ldrb	r3, [r7, #15]
9000acb8:	2b00      	cmp	r3, #0
9000acba:	d10d      	bne.n	9000acd8 <USBD_StdItfReq+0xc0>
            {
              (void)USBD_CtlSendStatus(pdev);
9000acbc:	6878      	ldr	r0, [r7, #4]
9000acbe:	f000 fde5 	bl	9000b88c <USBD_CtlSendStatus>
          }
          else
          {
            USBD_CtlError(pdev, req);
          }
          break;
9000acc2:	e009      	b.n	9000acd8 <USBD_StdItfReq+0xc0>
            USBD_CtlError(pdev, req);
9000acc4:	6839      	ldr	r1, [r7, #0]
9000acc6:	6878      	ldr	r0, [r7, #4]
9000acc8:	f000 fd23 	bl	9000b712 <USBD_CtlError>
          break;
9000accc:	e004      	b.n	9000acd8 <USBD_StdItfReq+0xc0>

        default:
          USBD_CtlError(pdev, req);
9000acce:	6839      	ldr	r1, [r7, #0]
9000acd0:	6878      	ldr	r0, [r7, #4]
9000acd2:	f000 fd1e 	bl	9000b712 <USBD_CtlError>
          break;
9000acd6:	e000      	b.n	9000acda <USBD_StdItfReq+0xc2>
          break;
9000acd8:	bf00      	nop
      }
      break;
9000acda:	e004      	b.n	9000ace6 <USBD_StdItfReq+0xce>

    default:
      USBD_CtlError(pdev, req);
9000acdc:	6839      	ldr	r1, [r7, #0]
9000acde:	6878      	ldr	r0, [r7, #4]
9000ace0:	f000 fd17 	bl	9000b712 <USBD_CtlError>
      break;
9000ace4:	bf00      	nop
  }

  return ret;
9000ace6:	7bfb      	ldrb	r3, [r7, #15]
}
9000ace8:	4618      	mov	r0, r3
9000acea:	3710      	adds	r7, #16
9000acec:	46bd      	mov	sp, r7
9000acee:	bd80      	pop	{r7, pc}

9000acf0 <USBD_StdEPReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdEPReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
9000acf0:	b580      	push	{r7, lr}
9000acf2:	b084      	sub	sp, #16
9000acf4:	af00      	add	r7, sp, #0
9000acf6:	6078      	str	r0, [r7, #4]
9000acf8:	6039      	str	r1, [r7, #0]
  USBD_EndpointTypeDef *pep;
  uint8_t ep_addr;
  uint8_t idx;
  USBD_StatusTypeDef ret = USBD_OK;
9000acfa:	2300      	movs	r3, #0
9000acfc:	73fb      	strb	r3, [r7, #15]

  ep_addr = LOBYTE(req->wIndex);
9000acfe:	683b      	ldr	r3, [r7, #0]
9000ad00:	889b      	ldrh	r3, [r3, #4]
9000ad02:	73bb      	strb	r3, [r7, #14]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
9000ad04:	683b      	ldr	r3, [r7, #0]
9000ad06:	781b      	ldrb	r3, [r3, #0]
9000ad08:	f003 0360 	and.w	r3, r3, #96	@ 0x60
9000ad0c:	2b40      	cmp	r3, #64	@ 0x40
9000ad0e:	d007      	beq.n	9000ad20 <USBD_StdEPReq+0x30>
9000ad10:	2b40      	cmp	r3, #64	@ 0x40
9000ad12:	f200 8181 	bhi.w	9000b018 <USBD_StdEPReq+0x328>
9000ad16:	2b00      	cmp	r3, #0
9000ad18:	d02a      	beq.n	9000ad70 <USBD_StdEPReq+0x80>
9000ad1a:	2b20      	cmp	r3, #32
9000ad1c:	f040 817c 	bne.w	9000b018 <USBD_StdEPReq+0x328>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      /* Get the class index relative to this endpoint */
      idx = USBD_CoreFindEP(pdev, ep_addr);
9000ad20:	7bbb      	ldrb	r3, [r7, #14]
9000ad22:	4619      	mov	r1, r3
9000ad24:	6878      	ldr	r0, [r7, #4]
9000ad26:	f7ff fe84 	bl	9000aa32 <USBD_CoreFindEP>
9000ad2a:	4603      	mov	r3, r0
9000ad2c:	737b      	strb	r3, [r7, #13]
      if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
9000ad2e:	7b7b      	ldrb	r3, [r7, #13]
9000ad30:	2bff      	cmp	r3, #255	@ 0xff
9000ad32:	f000 8176 	beq.w	9000b022 <USBD_StdEPReq+0x332>
9000ad36:	7b7b      	ldrb	r3, [r7, #13]
9000ad38:	2b00      	cmp	r3, #0
9000ad3a:	f040 8172 	bne.w	9000b022 <USBD_StdEPReq+0x332>
      {
        pdev->classId = idx;
9000ad3e:	7b7a      	ldrb	r2, [r7, #13]
9000ad40:	687b      	ldr	r3, [r7, #4]
9000ad42:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
        /* Call the class data out function to manage the request */
        if (pdev->pClass[idx]->Setup != NULL)
9000ad46:	7b7a      	ldrb	r2, [r7, #13]
9000ad48:	687b      	ldr	r3, [r7, #4]
9000ad4a:	32ae      	adds	r2, #174	@ 0xae
9000ad4c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000ad50:	689b      	ldr	r3, [r3, #8]
9000ad52:	2b00      	cmp	r3, #0
9000ad54:	f000 8165 	beq.w	9000b022 <USBD_StdEPReq+0x332>
        {
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->Setup(pdev, req);
9000ad58:	7b7a      	ldrb	r2, [r7, #13]
9000ad5a:	687b      	ldr	r3, [r7, #4]
9000ad5c:	32ae      	adds	r2, #174	@ 0xae
9000ad5e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000ad62:	689b      	ldr	r3, [r3, #8]
9000ad64:	6839      	ldr	r1, [r7, #0]
9000ad66:	6878      	ldr	r0, [r7, #4]
9000ad68:	4798      	blx	r3
9000ad6a:	4603      	mov	r3, r0
9000ad6c:	73fb      	strb	r3, [r7, #15]
        }
      }
      break;
9000ad6e:	e158      	b.n	9000b022 <USBD_StdEPReq+0x332>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
9000ad70:	683b      	ldr	r3, [r7, #0]
9000ad72:	785b      	ldrb	r3, [r3, #1]
9000ad74:	2b03      	cmp	r3, #3
9000ad76:	d008      	beq.n	9000ad8a <USBD_StdEPReq+0x9a>
9000ad78:	2b03      	cmp	r3, #3
9000ad7a:	f300 8147 	bgt.w	9000b00c <USBD_StdEPReq+0x31c>
9000ad7e:	2b00      	cmp	r3, #0
9000ad80:	f000 809b 	beq.w	9000aeba <USBD_StdEPReq+0x1ca>
9000ad84:	2b01      	cmp	r3, #1
9000ad86:	d03c      	beq.n	9000ae02 <USBD_StdEPReq+0x112>
9000ad88:	e140      	b.n	9000b00c <USBD_StdEPReq+0x31c>
      {
        case USB_REQ_SET_FEATURE:
          switch (pdev->dev_state)
9000ad8a:	687b      	ldr	r3, [r7, #4]
9000ad8c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000ad90:	b2db      	uxtb	r3, r3
9000ad92:	2b02      	cmp	r3, #2
9000ad94:	d002      	beq.n	9000ad9c <USBD_StdEPReq+0xac>
9000ad96:	2b03      	cmp	r3, #3
9000ad98:	d016      	beq.n	9000adc8 <USBD_StdEPReq+0xd8>
9000ad9a:	e02c      	b.n	9000adf6 <USBD_StdEPReq+0x106>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
9000ad9c:	7bbb      	ldrb	r3, [r7, #14]
9000ad9e:	2b00      	cmp	r3, #0
9000ada0:	d00d      	beq.n	9000adbe <USBD_StdEPReq+0xce>
9000ada2:	7bbb      	ldrb	r3, [r7, #14]
9000ada4:	2b80      	cmp	r3, #128	@ 0x80
9000ada6:	d00a      	beq.n	9000adbe <USBD_StdEPReq+0xce>
              {
                (void)USBD_LL_StallEP(pdev, ep_addr);
9000ada8:	7bbb      	ldrb	r3, [r7, #14]
9000adaa:	4619      	mov	r1, r3
9000adac:	6878      	ldr	r0, [r7, #4]
9000adae:	f7f6 f9b0 	bl	90001112 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
9000adb2:	2180      	movs	r1, #128	@ 0x80
9000adb4:	6878      	ldr	r0, [r7, #4]
9000adb6:	f7f6 f9ac 	bl	90001112 <USBD_LL_StallEP>
9000adba:	bf00      	nop
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
9000adbc:	e020      	b.n	9000ae00 <USBD_StdEPReq+0x110>
                USBD_CtlError(pdev, req);
9000adbe:	6839      	ldr	r1, [r7, #0]
9000adc0:	6878      	ldr	r0, [r7, #4]
9000adc2:	f000 fca6 	bl	9000b712 <USBD_CtlError>
              break;
9000adc6:	e01b      	b.n	9000ae00 <USBD_StdEPReq+0x110>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
9000adc8:	683b      	ldr	r3, [r7, #0]
9000adca:	885b      	ldrh	r3, [r3, #2]
9000adcc:	2b00      	cmp	r3, #0
9000adce:	d10e      	bne.n	9000adee <USBD_StdEPReq+0xfe>
              {
                if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
9000add0:	7bbb      	ldrb	r3, [r7, #14]
9000add2:	2b00      	cmp	r3, #0
9000add4:	d00b      	beq.n	9000adee <USBD_StdEPReq+0xfe>
9000add6:	7bbb      	ldrb	r3, [r7, #14]
9000add8:	2b80      	cmp	r3, #128	@ 0x80
9000adda:	d008      	beq.n	9000adee <USBD_StdEPReq+0xfe>
9000addc:	683b      	ldr	r3, [r7, #0]
9000adde:	88db      	ldrh	r3, [r3, #6]
9000ade0:	2b00      	cmp	r3, #0
9000ade2:	d104      	bne.n	9000adee <USBD_StdEPReq+0xfe>
                {
                  (void)USBD_LL_StallEP(pdev, ep_addr);
9000ade4:	7bbb      	ldrb	r3, [r7, #14]
9000ade6:	4619      	mov	r1, r3
9000ade8:	6878      	ldr	r0, [r7, #4]
9000adea:	f7f6 f992 	bl	90001112 <USBD_LL_StallEP>
                }
              }
              (void)USBD_CtlSendStatus(pdev);
9000adee:	6878      	ldr	r0, [r7, #4]
9000adf0:	f000 fd4c 	bl	9000b88c <USBD_CtlSendStatus>

              break;
9000adf4:	e004      	b.n	9000ae00 <USBD_StdEPReq+0x110>

            default:
              USBD_CtlError(pdev, req);
9000adf6:	6839      	ldr	r1, [r7, #0]
9000adf8:	6878      	ldr	r0, [r7, #4]
9000adfa:	f000 fc8a 	bl	9000b712 <USBD_CtlError>
              break;
9000adfe:	bf00      	nop
          }
          break;
9000ae00:	e109      	b.n	9000b016 <USBD_StdEPReq+0x326>

        case USB_REQ_CLEAR_FEATURE:

          switch (pdev->dev_state)
9000ae02:	687b      	ldr	r3, [r7, #4]
9000ae04:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000ae08:	b2db      	uxtb	r3, r3
9000ae0a:	2b02      	cmp	r3, #2
9000ae0c:	d002      	beq.n	9000ae14 <USBD_StdEPReq+0x124>
9000ae0e:	2b03      	cmp	r3, #3
9000ae10:	d016      	beq.n	9000ae40 <USBD_StdEPReq+0x150>
9000ae12:	e04b      	b.n	9000aeac <USBD_StdEPReq+0x1bc>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
9000ae14:	7bbb      	ldrb	r3, [r7, #14]
9000ae16:	2b00      	cmp	r3, #0
9000ae18:	d00d      	beq.n	9000ae36 <USBD_StdEPReq+0x146>
9000ae1a:	7bbb      	ldrb	r3, [r7, #14]
9000ae1c:	2b80      	cmp	r3, #128	@ 0x80
9000ae1e:	d00a      	beq.n	9000ae36 <USBD_StdEPReq+0x146>
              {
                (void)USBD_LL_StallEP(pdev, ep_addr);
9000ae20:	7bbb      	ldrb	r3, [r7, #14]
9000ae22:	4619      	mov	r1, r3
9000ae24:	6878      	ldr	r0, [r7, #4]
9000ae26:	f7f6 f974 	bl	90001112 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
9000ae2a:	2180      	movs	r1, #128	@ 0x80
9000ae2c:	6878      	ldr	r0, [r7, #4]
9000ae2e:	f7f6 f970 	bl	90001112 <USBD_LL_StallEP>
9000ae32:	bf00      	nop
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
9000ae34:	e040      	b.n	9000aeb8 <USBD_StdEPReq+0x1c8>
                USBD_CtlError(pdev, req);
9000ae36:	6839      	ldr	r1, [r7, #0]
9000ae38:	6878      	ldr	r0, [r7, #4]
9000ae3a:	f000 fc6a 	bl	9000b712 <USBD_CtlError>
              break;
9000ae3e:	e03b      	b.n	9000aeb8 <USBD_StdEPReq+0x1c8>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
9000ae40:	683b      	ldr	r3, [r7, #0]
9000ae42:	885b      	ldrh	r3, [r3, #2]
9000ae44:	2b00      	cmp	r3, #0
9000ae46:	d136      	bne.n	9000aeb6 <USBD_StdEPReq+0x1c6>
              {
                if ((ep_addr & 0x7FU) != 0x00U)
9000ae48:	7bbb      	ldrb	r3, [r7, #14]
9000ae4a:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
9000ae4e:	2b00      	cmp	r3, #0
9000ae50:	d004      	beq.n	9000ae5c <USBD_StdEPReq+0x16c>
                {
                  (void)USBD_LL_ClearStallEP(pdev, ep_addr);
9000ae52:	7bbb      	ldrb	r3, [r7, #14]
9000ae54:	4619      	mov	r1, r3
9000ae56:	6878      	ldr	r0, [r7, #4]
9000ae58:	f7f6 f97a 	bl	90001150 <USBD_LL_ClearStallEP>
                }
                (void)USBD_CtlSendStatus(pdev);
9000ae5c:	6878      	ldr	r0, [r7, #4]
9000ae5e:	f000 fd15 	bl	9000b88c <USBD_CtlSendStatus>

                /* Get the class index relative to this interface */
                idx = USBD_CoreFindEP(pdev, ep_addr);
9000ae62:	7bbb      	ldrb	r3, [r7, #14]
9000ae64:	4619      	mov	r1, r3
9000ae66:	6878      	ldr	r0, [r7, #4]
9000ae68:	f7ff fde3 	bl	9000aa32 <USBD_CoreFindEP>
9000ae6c:	4603      	mov	r3, r0
9000ae6e:	737b      	strb	r3, [r7, #13]
                if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
9000ae70:	7b7b      	ldrb	r3, [r7, #13]
9000ae72:	2bff      	cmp	r3, #255	@ 0xff
9000ae74:	d01f      	beq.n	9000aeb6 <USBD_StdEPReq+0x1c6>
9000ae76:	7b7b      	ldrb	r3, [r7, #13]
9000ae78:	2b00      	cmp	r3, #0
9000ae7a:	d11c      	bne.n	9000aeb6 <USBD_StdEPReq+0x1c6>
                {
                  pdev->classId = idx;
9000ae7c:	7b7a      	ldrb	r2, [r7, #13]
9000ae7e:	687b      	ldr	r3, [r7, #4]
9000ae80:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
                  /* Call the class data out function to manage the request */
                  if (pdev->pClass[idx]->Setup != NULL)
9000ae84:	7b7a      	ldrb	r2, [r7, #13]
9000ae86:	687b      	ldr	r3, [r7, #4]
9000ae88:	32ae      	adds	r2, #174	@ 0xae
9000ae8a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000ae8e:	689b      	ldr	r3, [r3, #8]
9000ae90:	2b00      	cmp	r3, #0
9000ae92:	d010      	beq.n	9000aeb6 <USBD_StdEPReq+0x1c6>
                  {
                    ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
9000ae94:	7b7a      	ldrb	r2, [r7, #13]
9000ae96:	687b      	ldr	r3, [r7, #4]
9000ae98:	32ae      	adds	r2, #174	@ 0xae
9000ae9a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000ae9e:	689b      	ldr	r3, [r3, #8]
9000aea0:	6839      	ldr	r1, [r7, #0]
9000aea2:	6878      	ldr	r0, [r7, #4]
9000aea4:	4798      	blx	r3
9000aea6:	4603      	mov	r3, r0
9000aea8:	73fb      	strb	r3, [r7, #15]
                  }
                }
              }
              break;
9000aeaa:	e004      	b.n	9000aeb6 <USBD_StdEPReq+0x1c6>

            default:
              USBD_CtlError(pdev, req);
9000aeac:	6839      	ldr	r1, [r7, #0]
9000aeae:	6878      	ldr	r0, [r7, #4]
9000aeb0:	f000 fc2f 	bl	9000b712 <USBD_CtlError>
              break;
9000aeb4:	e000      	b.n	9000aeb8 <USBD_StdEPReq+0x1c8>
              break;
9000aeb6:	bf00      	nop
          }
          break;
9000aeb8:	e0ad      	b.n	9000b016 <USBD_StdEPReq+0x326>

        case USB_REQ_GET_STATUS:
          switch (pdev->dev_state)
9000aeba:	687b      	ldr	r3, [r7, #4]
9000aebc:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000aec0:	b2db      	uxtb	r3, r3
9000aec2:	2b02      	cmp	r3, #2
9000aec4:	d002      	beq.n	9000aecc <USBD_StdEPReq+0x1dc>
9000aec6:	2b03      	cmp	r3, #3
9000aec8:	d033      	beq.n	9000af32 <USBD_StdEPReq+0x242>
9000aeca:	e099      	b.n	9000b000 <USBD_StdEPReq+0x310>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
9000aecc:	7bbb      	ldrb	r3, [r7, #14]
9000aece:	2b00      	cmp	r3, #0
9000aed0:	d007      	beq.n	9000aee2 <USBD_StdEPReq+0x1f2>
9000aed2:	7bbb      	ldrb	r3, [r7, #14]
9000aed4:	2b80      	cmp	r3, #128	@ 0x80
9000aed6:	d004      	beq.n	9000aee2 <USBD_StdEPReq+0x1f2>
              {
                USBD_CtlError(pdev, req);
9000aed8:	6839      	ldr	r1, [r7, #0]
9000aeda:	6878      	ldr	r0, [r7, #4]
9000aedc:	f000 fc19 	bl	9000b712 <USBD_CtlError>
                break;
9000aee0:	e093      	b.n	9000b00a <USBD_StdEPReq+0x31a>
              }
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
9000aee2:	f997 300e 	ldrsb.w	r3, [r7, #14]
9000aee6:	2b00      	cmp	r3, #0
9000aee8:	da0b      	bge.n	9000af02 <USBD_StdEPReq+0x212>
9000aeea:	7bbb      	ldrb	r3, [r7, #14]
9000aeec:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
9000aef0:	4613      	mov	r3, r2
9000aef2:	009b      	lsls	r3, r3, #2
9000aef4:	4413      	add	r3, r2
9000aef6:	009b      	lsls	r3, r3, #2
9000aef8:	3310      	adds	r3, #16
9000aefa:	687a      	ldr	r2, [r7, #4]
9000aefc:	4413      	add	r3, r2
9000aefe:	3304      	adds	r3, #4
9000af00:	e00b      	b.n	9000af1a <USBD_StdEPReq+0x22a>
                    &pdev->ep_out[ep_addr & 0x7FU];
9000af02:	7bbb      	ldrb	r3, [r7, #14]
9000af04:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
9000af08:	4613      	mov	r3, r2
9000af0a:	009b      	lsls	r3, r3, #2
9000af0c:	4413      	add	r3, r2
9000af0e:	009b      	lsls	r3, r3, #2
9000af10:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
9000af14:	687a      	ldr	r2, [r7, #4]
9000af16:	4413      	add	r3, r2
9000af18:	3304      	adds	r3, #4
9000af1a:	60bb      	str	r3, [r7, #8]

              pep->status = 0x0000U;
9000af1c:	68bb      	ldr	r3, [r7, #8]
9000af1e:	2200      	movs	r2, #0
9000af20:	739a      	strb	r2, [r3, #14]

              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
9000af22:	68bb      	ldr	r3, [r7, #8]
9000af24:	330e      	adds	r3, #14
9000af26:	2202      	movs	r2, #2
9000af28:	4619      	mov	r1, r3
9000af2a:	6878      	ldr	r0, [r7, #4]
9000af2c:	f000 fc6e 	bl	9000b80c <USBD_CtlSendData>
              break;
9000af30:	e06b      	b.n	9000b00a <USBD_StdEPReq+0x31a>

            case USBD_STATE_CONFIGURED:
              if ((ep_addr & 0x80U) == 0x80U)
9000af32:	f997 300e 	ldrsb.w	r3, [r7, #14]
9000af36:	2b00      	cmp	r3, #0
9000af38:	da11      	bge.n	9000af5e <USBD_StdEPReq+0x26e>
              {
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
9000af3a:	7bbb      	ldrb	r3, [r7, #14]
9000af3c:	f003 020f 	and.w	r2, r3, #15
9000af40:	6879      	ldr	r1, [r7, #4]
9000af42:	4613      	mov	r3, r2
9000af44:	009b      	lsls	r3, r3, #2
9000af46:	4413      	add	r3, r2
9000af48:	009b      	lsls	r3, r3, #2
9000af4a:	440b      	add	r3, r1
9000af4c:	3323      	adds	r3, #35	@ 0x23
9000af4e:	781b      	ldrb	r3, [r3, #0]
9000af50:	2b00      	cmp	r3, #0
9000af52:	d117      	bne.n	9000af84 <USBD_StdEPReq+0x294>
                {
                  USBD_CtlError(pdev, req);
9000af54:	6839      	ldr	r1, [r7, #0]
9000af56:	6878      	ldr	r0, [r7, #4]
9000af58:	f000 fbdb 	bl	9000b712 <USBD_CtlError>
                  break;
9000af5c:	e055      	b.n	9000b00a <USBD_StdEPReq+0x31a>
                }
              }
              else
              {
                if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
9000af5e:	7bbb      	ldrb	r3, [r7, #14]
9000af60:	f003 020f 	and.w	r2, r3, #15
9000af64:	6879      	ldr	r1, [r7, #4]
9000af66:	4613      	mov	r3, r2
9000af68:	009b      	lsls	r3, r3, #2
9000af6a:	4413      	add	r3, r2
9000af6c:	009b      	lsls	r3, r3, #2
9000af6e:	440b      	add	r3, r1
9000af70:	f203 1363 	addw	r3, r3, #355	@ 0x163
9000af74:	781b      	ldrb	r3, [r3, #0]
9000af76:	2b00      	cmp	r3, #0
9000af78:	d104      	bne.n	9000af84 <USBD_StdEPReq+0x294>
                {
                  USBD_CtlError(pdev, req);
9000af7a:	6839      	ldr	r1, [r7, #0]
9000af7c:	6878      	ldr	r0, [r7, #4]
9000af7e:	f000 fbc8 	bl	9000b712 <USBD_CtlError>
                  break;
9000af82:	e042      	b.n	9000b00a <USBD_StdEPReq+0x31a>
                }
              }

              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
9000af84:	f997 300e 	ldrsb.w	r3, [r7, #14]
9000af88:	2b00      	cmp	r3, #0
9000af8a:	da0b      	bge.n	9000afa4 <USBD_StdEPReq+0x2b4>
9000af8c:	7bbb      	ldrb	r3, [r7, #14]
9000af8e:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
9000af92:	4613      	mov	r3, r2
9000af94:	009b      	lsls	r3, r3, #2
9000af96:	4413      	add	r3, r2
9000af98:	009b      	lsls	r3, r3, #2
9000af9a:	3310      	adds	r3, #16
9000af9c:	687a      	ldr	r2, [r7, #4]
9000af9e:	4413      	add	r3, r2
9000afa0:	3304      	adds	r3, #4
9000afa2:	e00b      	b.n	9000afbc <USBD_StdEPReq+0x2cc>
                    &pdev->ep_out[ep_addr & 0x7FU];
9000afa4:	7bbb      	ldrb	r3, [r7, #14]
9000afa6:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
9000afaa:	4613      	mov	r3, r2
9000afac:	009b      	lsls	r3, r3, #2
9000afae:	4413      	add	r3, r2
9000afb0:	009b      	lsls	r3, r3, #2
9000afb2:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
9000afb6:	687a      	ldr	r2, [r7, #4]
9000afb8:	4413      	add	r3, r2
9000afba:	3304      	adds	r3, #4
9000afbc:	60bb      	str	r3, [r7, #8]

              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
9000afbe:	7bbb      	ldrb	r3, [r7, #14]
9000afc0:	2b00      	cmp	r3, #0
9000afc2:	d002      	beq.n	9000afca <USBD_StdEPReq+0x2da>
9000afc4:	7bbb      	ldrb	r3, [r7, #14]
9000afc6:	2b80      	cmp	r3, #128	@ 0x80
9000afc8:	d103      	bne.n	9000afd2 <USBD_StdEPReq+0x2e2>
              {
                pep->status = 0x0000U;
9000afca:	68bb      	ldr	r3, [r7, #8]
9000afcc:	2200      	movs	r2, #0
9000afce:	739a      	strb	r2, [r3, #14]
9000afd0:	e00e      	b.n	9000aff0 <USBD_StdEPReq+0x300>
              }
              else if (USBD_LL_IsStallEP(pdev, ep_addr) != 0U)
9000afd2:	7bbb      	ldrb	r3, [r7, #14]
9000afd4:	4619      	mov	r1, r3
9000afd6:	6878      	ldr	r0, [r7, #4]
9000afd8:	f7f6 f8d9 	bl	9000118e <USBD_LL_IsStallEP>
9000afdc:	4603      	mov	r3, r0
9000afde:	2b00      	cmp	r3, #0
9000afe0:	d003      	beq.n	9000afea <USBD_StdEPReq+0x2fa>
              {
                pep->status = 0x0001U;
9000afe2:	68bb      	ldr	r3, [r7, #8]
9000afe4:	2201      	movs	r2, #1
9000afe6:	739a      	strb	r2, [r3, #14]
9000afe8:	e002      	b.n	9000aff0 <USBD_StdEPReq+0x300>
              }
              else
              {
                pep->status = 0x0000U;
9000afea:	68bb      	ldr	r3, [r7, #8]
9000afec:	2200      	movs	r2, #0
9000afee:	739a      	strb	r2, [r3, #14]
              }

              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
9000aff0:	68bb      	ldr	r3, [r7, #8]
9000aff2:	330e      	adds	r3, #14
9000aff4:	2202      	movs	r2, #2
9000aff6:	4619      	mov	r1, r3
9000aff8:	6878      	ldr	r0, [r7, #4]
9000affa:	f000 fc07 	bl	9000b80c <USBD_CtlSendData>
              break;
9000affe:	e004      	b.n	9000b00a <USBD_StdEPReq+0x31a>

            default:
              USBD_CtlError(pdev, req);
9000b000:	6839      	ldr	r1, [r7, #0]
9000b002:	6878      	ldr	r0, [r7, #4]
9000b004:	f000 fb85 	bl	9000b712 <USBD_CtlError>
              break;
9000b008:	bf00      	nop
          }
          break;
9000b00a:	e004      	b.n	9000b016 <USBD_StdEPReq+0x326>

        default:
          USBD_CtlError(pdev, req);
9000b00c:	6839      	ldr	r1, [r7, #0]
9000b00e:	6878      	ldr	r0, [r7, #4]
9000b010:	f000 fb7f 	bl	9000b712 <USBD_CtlError>
          break;
9000b014:	bf00      	nop
      }
      break;
9000b016:	e005      	b.n	9000b024 <USBD_StdEPReq+0x334>

    default:
      USBD_CtlError(pdev, req);
9000b018:	6839      	ldr	r1, [r7, #0]
9000b01a:	6878      	ldr	r0, [r7, #4]
9000b01c:	f000 fb79 	bl	9000b712 <USBD_CtlError>
      break;
9000b020:	e000      	b.n	9000b024 <USBD_StdEPReq+0x334>
      break;
9000b022:	bf00      	nop
  }

  return ret;
9000b024:	7bfb      	ldrb	r3, [r7, #15]
}
9000b026:	4618      	mov	r0, r3
9000b028:	3710      	adds	r7, #16
9000b02a:	46bd      	mov	sp, r7
9000b02c:	bd80      	pop	{r7, pc}
	...

9000b030 <USBD_GetDescriptor>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetDescriptor(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
9000b030:	b580      	push	{r7, lr}
9000b032:	b084      	sub	sp, #16
9000b034:	af00      	add	r7, sp, #0
9000b036:	6078      	str	r0, [r7, #4]
9000b038:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
9000b03a:	2300      	movs	r3, #0
9000b03c:	813b      	strh	r3, [r7, #8]
  uint8_t *pbuf = NULL;
9000b03e:	2300      	movs	r3, #0
9000b040:	60fb      	str	r3, [r7, #12]
  uint8_t err = 0U;
9000b042:	2300      	movs	r3, #0
9000b044:	72fb      	strb	r3, [r7, #11]

  switch (req->wValue >> 8)
9000b046:	683b      	ldr	r3, [r7, #0]
9000b048:	885b      	ldrh	r3, [r3, #2]
9000b04a:	0a1b      	lsrs	r3, r3, #8
9000b04c:	b29b      	uxth	r3, r3
9000b04e:	3b01      	subs	r3, #1
9000b050:	2b0e      	cmp	r3, #14
9000b052:	f200 8152 	bhi.w	9000b2fa <USBD_GetDescriptor+0x2ca>
9000b056:	a201      	add	r2, pc, #4	@ (adr r2, 9000b05c <USBD_GetDescriptor+0x2c>)
9000b058:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
9000b05c:	9000b0cd 	.word	0x9000b0cd
9000b060:	9000b0e5 	.word	0x9000b0e5
9000b064:	9000b125 	.word	0x9000b125
9000b068:	9000b2fb 	.word	0x9000b2fb
9000b06c:	9000b2fb 	.word	0x9000b2fb
9000b070:	9000b29b 	.word	0x9000b29b
9000b074:	9000b2c7 	.word	0x9000b2c7
9000b078:	9000b2fb 	.word	0x9000b2fb
9000b07c:	9000b2fb 	.word	0x9000b2fb
9000b080:	9000b2fb 	.word	0x9000b2fb
9000b084:	9000b2fb 	.word	0x9000b2fb
9000b088:	9000b2fb 	.word	0x9000b2fb
9000b08c:	9000b2fb 	.word	0x9000b2fb
9000b090:	9000b2fb 	.word	0x9000b2fb
9000b094:	9000b099 	.word	0x9000b099
  {
#if ((USBD_LPM_ENABLED == 1U) || (USBD_CLASS_BOS_ENABLED == 1U))
    case USB_DESC_TYPE_BOS:
      if (pdev->pDesc->GetBOSDescriptor != NULL)
9000b098:	687b      	ldr	r3, [r7, #4]
9000b09a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
9000b09e:	69db      	ldr	r3, [r3, #28]
9000b0a0:	2b00      	cmp	r3, #0
9000b0a2:	d00b      	beq.n	9000b0bc <USBD_GetDescriptor+0x8c>
      {
        pbuf = pdev->pDesc->GetBOSDescriptor(pdev->dev_speed, &len);
9000b0a4:	687b      	ldr	r3, [r7, #4]
9000b0a6:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
9000b0aa:	69db      	ldr	r3, [r3, #28]
9000b0ac:	687a      	ldr	r2, [r7, #4]
9000b0ae:	7c12      	ldrb	r2, [r2, #16]
9000b0b0:	f107 0108 	add.w	r1, r7, #8
9000b0b4:	4610      	mov	r0, r2
9000b0b6:	4798      	blx	r3
9000b0b8:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
9000b0ba:	e126      	b.n	9000b30a <USBD_GetDescriptor+0x2da>
        USBD_CtlError(pdev, req);
9000b0bc:	6839      	ldr	r1, [r7, #0]
9000b0be:	6878      	ldr	r0, [r7, #4]
9000b0c0:	f000 fb27 	bl	9000b712 <USBD_CtlError>
        err++;
9000b0c4:	7afb      	ldrb	r3, [r7, #11]
9000b0c6:	3301      	adds	r3, #1
9000b0c8:	72fb      	strb	r3, [r7, #11]
      break;
9000b0ca:	e11e      	b.n	9000b30a <USBD_GetDescriptor+0x2da>
#endif /* (USBD_LPM_ENABLED == 1U) || (USBD_CLASS_BOS_ENABLED == 1U) */
    case USB_DESC_TYPE_DEVICE:
      pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
9000b0cc:	687b      	ldr	r3, [r7, #4]
9000b0ce:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
9000b0d2:	681b      	ldr	r3, [r3, #0]
9000b0d4:	687a      	ldr	r2, [r7, #4]
9000b0d6:	7c12      	ldrb	r2, [r2, #16]
9000b0d8:	f107 0108 	add.w	r1, r7, #8
9000b0dc:	4610      	mov	r0, r2
9000b0de:	4798      	blx	r3
9000b0e0:	60f8      	str	r0, [r7, #12]
      break;
9000b0e2:	e112      	b.n	9000b30a <USBD_GetDescriptor+0x2da>

    case USB_DESC_TYPE_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
9000b0e4:	687b      	ldr	r3, [r7, #4]
9000b0e6:	7c1b      	ldrb	r3, [r3, #16]
9000b0e8:	2b00      	cmp	r3, #0
9000b0ea:	d10d      	bne.n	9000b108 <USBD_GetDescriptor+0xd8>
          pbuf = (uint8_t *)USBD_CMPSIT.GetHSConfigDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetHSConfigDescriptor(&len);
9000b0ec:	687b      	ldr	r3, [r7, #4]
9000b0ee:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
9000b0f2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
9000b0f4:	f107 0208 	add.w	r2, r7, #8
9000b0f8:	4610      	mov	r0, r2
9000b0fa:	4798      	blx	r3
9000b0fc:	60f8      	str	r0, [r7, #12]
        }
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
9000b0fe:	68fb      	ldr	r3, [r7, #12]
9000b100:	3301      	adds	r3, #1
9000b102:	2202      	movs	r2, #2
9000b104:	701a      	strb	r2, [r3, #0]
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
        }
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
      }
      break;
9000b106:	e100      	b.n	9000b30a <USBD_GetDescriptor+0x2da>
          pbuf = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
9000b108:	687b      	ldr	r3, [r7, #4]
9000b10a:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
9000b10e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
9000b110:	f107 0208 	add.w	r2, r7, #8
9000b114:	4610      	mov	r0, r2
9000b116:	4798      	blx	r3
9000b118:	60f8      	str	r0, [r7, #12]
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
9000b11a:	68fb      	ldr	r3, [r7, #12]
9000b11c:	3301      	adds	r3, #1
9000b11e:	2202      	movs	r2, #2
9000b120:	701a      	strb	r2, [r3, #0]
      break;
9000b122:	e0f2      	b.n	9000b30a <USBD_GetDescriptor+0x2da>

    case USB_DESC_TYPE_STRING:
      switch ((uint8_t)(req->wValue))
9000b124:	683b      	ldr	r3, [r7, #0]
9000b126:	885b      	ldrh	r3, [r3, #2]
9000b128:	b2db      	uxtb	r3, r3
9000b12a:	2b05      	cmp	r3, #5
9000b12c:	f200 80ac 	bhi.w	9000b288 <USBD_GetDescriptor+0x258>
9000b130:	a201      	add	r2, pc, #4	@ (adr r2, 9000b138 <USBD_GetDescriptor+0x108>)
9000b132:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
9000b136:	bf00      	nop
9000b138:	9000b151 	.word	0x9000b151
9000b13c:	9000b185 	.word	0x9000b185
9000b140:	9000b1b9 	.word	0x9000b1b9
9000b144:	9000b1ed 	.word	0x9000b1ed
9000b148:	9000b221 	.word	0x9000b221
9000b14c:	9000b255 	.word	0x9000b255
      {
        case USBD_IDX_LANGID_STR:
          if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
9000b150:	687b      	ldr	r3, [r7, #4]
9000b152:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
9000b156:	685b      	ldr	r3, [r3, #4]
9000b158:	2b00      	cmp	r3, #0
9000b15a:	d00b      	beq.n	9000b174 <USBD_GetDescriptor+0x144>
          {
            pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);
9000b15c:	687b      	ldr	r3, [r7, #4]
9000b15e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
9000b162:	685b      	ldr	r3, [r3, #4]
9000b164:	687a      	ldr	r2, [r7, #4]
9000b166:	7c12      	ldrb	r2, [r2, #16]
9000b168:	f107 0108 	add.w	r1, r7, #8
9000b16c:	4610      	mov	r0, r2
9000b16e:	4798      	blx	r3
9000b170:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
9000b172:	e091      	b.n	9000b298 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
9000b174:	6839      	ldr	r1, [r7, #0]
9000b176:	6878      	ldr	r0, [r7, #4]
9000b178:	f000 facb 	bl	9000b712 <USBD_CtlError>
            err++;
9000b17c:	7afb      	ldrb	r3, [r7, #11]
9000b17e:	3301      	adds	r3, #1
9000b180:	72fb      	strb	r3, [r7, #11]
          break;
9000b182:	e089      	b.n	9000b298 <USBD_GetDescriptor+0x268>

        case USBD_IDX_MFC_STR:
          if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
9000b184:	687b      	ldr	r3, [r7, #4]
9000b186:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
9000b18a:	689b      	ldr	r3, [r3, #8]
9000b18c:	2b00      	cmp	r3, #0
9000b18e:	d00b      	beq.n	9000b1a8 <USBD_GetDescriptor+0x178>
          {
            pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
9000b190:	687b      	ldr	r3, [r7, #4]
9000b192:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
9000b196:	689b      	ldr	r3, [r3, #8]
9000b198:	687a      	ldr	r2, [r7, #4]
9000b19a:	7c12      	ldrb	r2, [r2, #16]
9000b19c:	f107 0108 	add.w	r1, r7, #8
9000b1a0:	4610      	mov	r0, r2
9000b1a2:	4798      	blx	r3
9000b1a4:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
9000b1a6:	e077      	b.n	9000b298 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
9000b1a8:	6839      	ldr	r1, [r7, #0]
9000b1aa:	6878      	ldr	r0, [r7, #4]
9000b1ac:	f000 fab1 	bl	9000b712 <USBD_CtlError>
            err++;
9000b1b0:	7afb      	ldrb	r3, [r7, #11]
9000b1b2:	3301      	adds	r3, #1
9000b1b4:	72fb      	strb	r3, [r7, #11]
          break;
9000b1b6:	e06f      	b.n	9000b298 <USBD_GetDescriptor+0x268>

        case USBD_IDX_PRODUCT_STR:
          if (pdev->pDesc->GetProductStrDescriptor != NULL)
9000b1b8:	687b      	ldr	r3, [r7, #4]
9000b1ba:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
9000b1be:	68db      	ldr	r3, [r3, #12]
9000b1c0:	2b00      	cmp	r3, #0
9000b1c2:	d00b      	beq.n	9000b1dc <USBD_GetDescriptor+0x1ac>
          {
            pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
9000b1c4:	687b      	ldr	r3, [r7, #4]
9000b1c6:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
9000b1ca:	68db      	ldr	r3, [r3, #12]
9000b1cc:	687a      	ldr	r2, [r7, #4]
9000b1ce:	7c12      	ldrb	r2, [r2, #16]
9000b1d0:	f107 0108 	add.w	r1, r7, #8
9000b1d4:	4610      	mov	r0, r2
9000b1d6:	4798      	blx	r3
9000b1d8:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
9000b1da:	e05d      	b.n	9000b298 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
9000b1dc:	6839      	ldr	r1, [r7, #0]
9000b1de:	6878      	ldr	r0, [r7, #4]
9000b1e0:	f000 fa97 	bl	9000b712 <USBD_CtlError>
            err++;
9000b1e4:	7afb      	ldrb	r3, [r7, #11]
9000b1e6:	3301      	adds	r3, #1
9000b1e8:	72fb      	strb	r3, [r7, #11]
          break;
9000b1ea:	e055      	b.n	9000b298 <USBD_GetDescriptor+0x268>

        case USBD_IDX_SERIAL_STR:
          if (pdev->pDesc->GetSerialStrDescriptor != NULL)
9000b1ec:	687b      	ldr	r3, [r7, #4]
9000b1ee:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
9000b1f2:	691b      	ldr	r3, [r3, #16]
9000b1f4:	2b00      	cmp	r3, #0
9000b1f6:	d00b      	beq.n	9000b210 <USBD_GetDescriptor+0x1e0>
          {
            pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
9000b1f8:	687b      	ldr	r3, [r7, #4]
9000b1fa:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
9000b1fe:	691b      	ldr	r3, [r3, #16]
9000b200:	687a      	ldr	r2, [r7, #4]
9000b202:	7c12      	ldrb	r2, [r2, #16]
9000b204:	f107 0108 	add.w	r1, r7, #8
9000b208:	4610      	mov	r0, r2
9000b20a:	4798      	blx	r3
9000b20c:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
9000b20e:	e043      	b.n	9000b298 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
9000b210:	6839      	ldr	r1, [r7, #0]
9000b212:	6878      	ldr	r0, [r7, #4]
9000b214:	f000 fa7d 	bl	9000b712 <USBD_CtlError>
            err++;
9000b218:	7afb      	ldrb	r3, [r7, #11]
9000b21a:	3301      	adds	r3, #1
9000b21c:	72fb      	strb	r3, [r7, #11]
          break;
9000b21e:	e03b      	b.n	9000b298 <USBD_GetDescriptor+0x268>

        case USBD_IDX_CONFIG_STR:
          if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
9000b220:	687b      	ldr	r3, [r7, #4]
9000b222:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
9000b226:	695b      	ldr	r3, [r3, #20]
9000b228:	2b00      	cmp	r3, #0
9000b22a:	d00b      	beq.n	9000b244 <USBD_GetDescriptor+0x214>
          {
            pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
9000b22c:	687b      	ldr	r3, [r7, #4]
9000b22e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
9000b232:	695b      	ldr	r3, [r3, #20]
9000b234:	687a      	ldr	r2, [r7, #4]
9000b236:	7c12      	ldrb	r2, [r2, #16]
9000b238:	f107 0108 	add.w	r1, r7, #8
9000b23c:	4610      	mov	r0, r2
9000b23e:	4798      	blx	r3
9000b240:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
9000b242:	e029      	b.n	9000b298 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
9000b244:	6839      	ldr	r1, [r7, #0]
9000b246:	6878      	ldr	r0, [r7, #4]
9000b248:	f000 fa63 	bl	9000b712 <USBD_CtlError>
            err++;
9000b24c:	7afb      	ldrb	r3, [r7, #11]
9000b24e:	3301      	adds	r3, #1
9000b250:	72fb      	strb	r3, [r7, #11]
          break;
9000b252:	e021      	b.n	9000b298 <USBD_GetDescriptor+0x268>

        case USBD_IDX_INTERFACE_STR:
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
9000b254:	687b      	ldr	r3, [r7, #4]
9000b256:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
9000b25a:	699b      	ldr	r3, [r3, #24]
9000b25c:	2b00      	cmp	r3, #0
9000b25e:	d00b      	beq.n	9000b278 <USBD_GetDescriptor+0x248>
          {
            pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
9000b260:	687b      	ldr	r3, [r7, #4]
9000b262:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
9000b266:	699b      	ldr	r3, [r3, #24]
9000b268:	687a      	ldr	r2, [r7, #4]
9000b26a:	7c12      	ldrb	r2, [r2, #16]
9000b26c:	f107 0108 	add.w	r1, r7, #8
9000b270:	4610      	mov	r0, r2
9000b272:	4798      	blx	r3
9000b274:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
9000b276:	e00f      	b.n	9000b298 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
9000b278:	6839      	ldr	r1, [r7, #0]
9000b27a:	6878      	ldr	r0, [r7, #4]
9000b27c:	f000 fa49 	bl	9000b712 <USBD_CtlError>
            err++;
9000b280:	7afb      	ldrb	r3, [r7, #11]
9000b282:	3301      	adds	r3, #1
9000b284:	72fb      	strb	r3, [r7, #11]
          break;
9000b286:	e007      	b.n	9000b298 <USBD_GetDescriptor+0x268>
            err++;
          }
#endif /* USBD_SUPPORT_USER_STRING_DESC  */

#if ((USBD_CLASS_USER_STRING_DESC == 0U) && (USBD_SUPPORT_USER_STRING_DESC == 0U))
          USBD_CtlError(pdev, req);
9000b288:	6839      	ldr	r1, [r7, #0]
9000b28a:	6878      	ldr	r0, [r7, #4]
9000b28c:	f000 fa41 	bl	9000b712 <USBD_CtlError>
          err++;
9000b290:	7afb      	ldrb	r3, [r7, #11]
9000b292:	3301      	adds	r3, #1
9000b294:	72fb      	strb	r3, [r7, #11]
#endif /* (USBD_CLASS_USER_STRING_DESC == 0U) && (USBD_SUPPORT_USER_STRING_DESC == 0U) */
          break;
9000b296:	bf00      	nop
      }
      break;
9000b298:	e037      	b.n	9000b30a <USBD_GetDescriptor+0x2da>

    case USB_DESC_TYPE_DEVICE_QUALIFIER:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
9000b29a:	687b      	ldr	r3, [r7, #4]
9000b29c:	7c1b      	ldrb	r3, [r3, #16]
9000b29e:	2b00      	cmp	r3, #0
9000b2a0:	d109      	bne.n	9000b2b6 <USBD_GetDescriptor+0x286>
          pbuf = (uint8_t *)USBD_CMPSIT.GetDeviceQualifierDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetDeviceQualifierDescriptor(&len);
9000b2a2:	687b      	ldr	r3, [r7, #4]
9000b2a4:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
9000b2a8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
9000b2aa:	f107 0208 	add.w	r2, r7, #8
9000b2ae:	4610      	mov	r0, r2
9000b2b0:	4798      	blx	r3
9000b2b2:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
9000b2b4:	e029      	b.n	9000b30a <USBD_GetDescriptor+0x2da>
        USBD_CtlError(pdev, req);
9000b2b6:	6839      	ldr	r1, [r7, #0]
9000b2b8:	6878      	ldr	r0, [r7, #4]
9000b2ba:	f000 fa2a 	bl	9000b712 <USBD_CtlError>
        err++;
9000b2be:	7afb      	ldrb	r3, [r7, #11]
9000b2c0:	3301      	adds	r3, #1
9000b2c2:	72fb      	strb	r3, [r7, #11]
      break;
9000b2c4:	e021      	b.n	9000b30a <USBD_GetDescriptor+0x2da>

    case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
9000b2c6:	687b      	ldr	r3, [r7, #4]
9000b2c8:	7c1b      	ldrb	r3, [r3, #16]
9000b2ca:	2b00      	cmp	r3, #0
9000b2cc:	d10d      	bne.n	9000b2ea <USBD_GetDescriptor+0x2ba>
          pbuf = (uint8_t *)USBD_CMPSIT.GetOtherSpeedConfigDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetOtherSpeedConfigDescriptor(&len);
9000b2ce:	687b      	ldr	r3, [r7, #4]
9000b2d0:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
9000b2d4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
9000b2d6:	f107 0208 	add.w	r2, r7, #8
9000b2da:	4610      	mov	r0, r2
9000b2dc:	4798      	blx	r3
9000b2de:	60f8      	str	r0, [r7, #12]
        }
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
9000b2e0:	68fb      	ldr	r3, [r7, #12]
9000b2e2:	3301      	adds	r3, #1
9000b2e4:	2207      	movs	r2, #7
9000b2e6:	701a      	strb	r2, [r3, #0]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
9000b2e8:	e00f      	b.n	9000b30a <USBD_GetDescriptor+0x2da>
        USBD_CtlError(pdev, req);
9000b2ea:	6839      	ldr	r1, [r7, #0]
9000b2ec:	6878      	ldr	r0, [r7, #4]
9000b2ee:	f000 fa10 	bl	9000b712 <USBD_CtlError>
        err++;
9000b2f2:	7afb      	ldrb	r3, [r7, #11]
9000b2f4:	3301      	adds	r3, #1
9000b2f6:	72fb      	strb	r3, [r7, #11]
      break;
9000b2f8:	e007      	b.n	9000b30a <USBD_GetDescriptor+0x2da>

    default:
      USBD_CtlError(pdev, req);
9000b2fa:	6839      	ldr	r1, [r7, #0]
9000b2fc:	6878      	ldr	r0, [r7, #4]
9000b2fe:	f000 fa08 	bl	9000b712 <USBD_CtlError>
      err++;
9000b302:	7afb      	ldrb	r3, [r7, #11]
9000b304:	3301      	adds	r3, #1
9000b306:	72fb      	strb	r3, [r7, #11]
      break;
9000b308:	bf00      	nop
  }

  if (err != 0U)
9000b30a:	7afb      	ldrb	r3, [r7, #11]
9000b30c:	2b00      	cmp	r3, #0
9000b30e:	d11e      	bne.n	9000b34e <USBD_GetDescriptor+0x31e>
  {
    return;
  }

  if (req->wLength != 0U)
9000b310:	683b      	ldr	r3, [r7, #0]
9000b312:	88db      	ldrh	r3, [r3, #6]
9000b314:	2b00      	cmp	r3, #0
9000b316:	d016      	beq.n	9000b346 <USBD_GetDescriptor+0x316>
  {
    if (len != 0U)
9000b318:	893b      	ldrh	r3, [r7, #8]
9000b31a:	2b00      	cmp	r3, #0
9000b31c:	d00e      	beq.n	9000b33c <USBD_GetDescriptor+0x30c>
    {
      len = MIN(len, req->wLength);
9000b31e:	683b      	ldr	r3, [r7, #0]
9000b320:	88da      	ldrh	r2, [r3, #6]
9000b322:	893b      	ldrh	r3, [r7, #8]
9000b324:	4293      	cmp	r3, r2
9000b326:	bf28      	it	cs
9000b328:	4613      	movcs	r3, r2
9000b32a:	b29b      	uxth	r3, r3
9000b32c:	813b      	strh	r3, [r7, #8]
      (void)USBD_CtlSendData(pdev, pbuf, len);
9000b32e:	893b      	ldrh	r3, [r7, #8]
9000b330:	461a      	mov	r2, r3
9000b332:	68f9      	ldr	r1, [r7, #12]
9000b334:	6878      	ldr	r0, [r7, #4]
9000b336:	f000 fa69 	bl	9000b80c <USBD_CtlSendData>
9000b33a:	e009      	b.n	9000b350 <USBD_GetDescriptor+0x320>
    }
    else
    {
      USBD_CtlError(pdev, req);
9000b33c:	6839      	ldr	r1, [r7, #0]
9000b33e:	6878      	ldr	r0, [r7, #4]
9000b340:	f000 f9e7 	bl	9000b712 <USBD_CtlError>
9000b344:	e004      	b.n	9000b350 <USBD_GetDescriptor+0x320>
    }
  }
  else
  {
    (void)USBD_CtlSendStatus(pdev);
9000b346:	6878      	ldr	r0, [r7, #4]
9000b348:	f000 faa0 	bl	9000b88c <USBD_CtlSendStatus>
9000b34c:	e000      	b.n	9000b350 <USBD_GetDescriptor+0x320>
    return;
9000b34e:	bf00      	nop
  }
}
9000b350:	3710      	adds	r7, #16
9000b352:	46bd      	mov	sp, r7
9000b354:	bd80      	pop	{r7, pc}
9000b356:	bf00      	nop

9000b358 <USBD_SetAddress>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_SetAddress(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
9000b358:	b580      	push	{r7, lr}
9000b35a:	b084      	sub	sp, #16
9000b35c:	af00      	add	r7, sp, #0
9000b35e:	6078      	str	r0, [r7, #4]
9000b360:	6039      	str	r1, [r7, #0]
  uint8_t  dev_addr;

  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
9000b362:	683b      	ldr	r3, [r7, #0]
9000b364:	889b      	ldrh	r3, [r3, #4]
9000b366:	2b00      	cmp	r3, #0
9000b368:	d131      	bne.n	9000b3ce <USBD_SetAddress+0x76>
9000b36a:	683b      	ldr	r3, [r7, #0]
9000b36c:	88db      	ldrh	r3, [r3, #6]
9000b36e:	2b00      	cmp	r3, #0
9000b370:	d12d      	bne.n	9000b3ce <USBD_SetAddress+0x76>
9000b372:	683b      	ldr	r3, [r7, #0]
9000b374:	885b      	ldrh	r3, [r3, #2]
9000b376:	2b7f      	cmp	r3, #127	@ 0x7f
9000b378:	d829      	bhi.n	9000b3ce <USBD_SetAddress+0x76>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
9000b37a:	683b      	ldr	r3, [r7, #0]
9000b37c:	885b      	ldrh	r3, [r3, #2]
9000b37e:	b2db      	uxtb	r3, r3
9000b380:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
9000b384:	73fb      	strb	r3, [r7, #15]

    if (pdev->dev_state == USBD_STATE_CONFIGURED)
9000b386:	687b      	ldr	r3, [r7, #4]
9000b388:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000b38c:	b2db      	uxtb	r3, r3
9000b38e:	2b03      	cmp	r3, #3
9000b390:	d104      	bne.n	9000b39c <USBD_SetAddress+0x44>
    {
      USBD_CtlError(pdev, req);
9000b392:	6839      	ldr	r1, [r7, #0]
9000b394:	6878      	ldr	r0, [r7, #4]
9000b396:	f000 f9bc 	bl	9000b712 <USBD_CtlError>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
9000b39a:	e01d      	b.n	9000b3d8 <USBD_SetAddress+0x80>
    }
    else
    {
      pdev->dev_address = dev_addr;
9000b39c:	687b      	ldr	r3, [r7, #4]
9000b39e:	7bfa      	ldrb	r2, [r7, #15]
9000b3a0:	f883 229e 	strb.w	r2, [r3, #670]	@ 0x29e
      (void)USBD_LL_SetUSBAddress(pdev, dev_addr);
9000b3a4:	7bfb      	ldrb	r3, [r7, #15]
9000b3a6:	4619      	mov	r1, r3
9000b3a8:	6878      	ldr	r0, [r7, #4]
9000b3aa:	f7f5 ff1c 	bl	900011e6 <USBD_LL_SetUSBAddress>
      (void)USBD_CtlSendStatus(pdev);
9000b3ae:	6878      	ldr	r0, [r7, #4]
9000b3b0:	f000 fa6c 	bl	9000b88c <USBD_CtlSendStatus>

      if (dev_addr != 0U)
9000b3b4:	7bfb      	ldrb	r3, [r7, #15]
9000b3b6:	2b00      	cmp	r3, #0
9000b3b8:	d004      	beq.n	9000b3c4 <USBD_SetAddress+0x6c>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
9000b3ba:	687b      	ldr	r3, [r7, #4]
9000b3bc:	2202      	movs	r2, #2
9000b3be:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
9000b3c2:	e009      	b.n	9000b3d8 <USBD_SetAddress+0x80>
      }
      else
      {
        pdev->dev_state = USBD_STATE_DEFAULT;
9000b3c4:	687b      	ldr	r3, [r7, #4]
9000b3c6:	2201      	movs	r2, #1
9000b3c8:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
9000b3cc:	e004      	b.n	9000b3d8 <USBD_SetAddress+0x80>
      }
    }
  }
  else
  {
    USBD_CtlError(pdev, req);
9000b3ce:	6839      	ldr	r1, [r7, #0]
9000b3d0:	6878      	ldr	r0, [r7, #4]
9000b3d2:	f000 f99e 	bl	9000b712 <USBD_CtlError>
  }
}
9000b3d6:	bf00      	nop
9000b3d8:	bf00      	nop
9000b3da:	3710      	adds	r7, #16
9000b3dc:	46bd      	mov	sp, r7
9000b3de:	bd80      	pop	{r7, pc}

9000b3e0 <USBD_SetConfig>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static USBD_StatusTypeDef USBD_SetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
9000b3e0:	b580      	push	{r7, lr}
9000b3e2:	b084      	sub	sp, #16
9000b3e4:	af00      	add	r7, sp, #0
9000b3e6:	6078      	str	r0, [r7, #4]
9000b3e8:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
9000b3ea:	2300      	movs	r3, #0
9000b3ec:	73fb      	strb	r3, [r7, #15]
  static uint8_t cfgidx;

  cfgidx = (uint8_t)(req->wValue);
9000b3ee:	683b      	ldr	r3, [r7, #0]
9000b3f0:	885b      	ldrh	r3, [r3, #2]
9000b3f2:	b2da      	uxtb	r2, r3
9000b3f4:	4b4e      	ldr	r3, [pc, #312]	@ (9000b530 <USBD_SetConfig+0x150>)
9000b3f6:	701a      	strb	r2, [r3, #0]

  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
9000b3f8:	4b4d      	ldr	r3, [pc, #308]	@ (9000b530 <USBD_SetConfig+0x150>)
9000b3fa:	781b      	ldrb	r3, [r3, #0]
9000b3fc:	2b01      	cmp	r3, #1
9000b3fe:	d905      	bls.n	9000b40c <USBD_SetConfig+0x2c>
  {
    USBD_CtlError(pdev, req);
9000b400:	6839      	ldr	r1, [r7, #0]
9000b402:	6878      	ldr	r0, [r7, #4]
9000b404:	f000 f985 	bl	9000b712 <USBD_CtlError>
    return USBD_FAIL;
9000b408:	2303      	movs	r3, #3
9000b40a:	e08c      	b.n	9000b526 <USBD_SetConfig+0x146>
  }

  switch (pdev->dev_state)
9000b40c:	687b      	ldr	r3, [r7, #4]
9000b40e:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000b412:	b2db      	uxtb	r3, r3
9000b414:	2b02      	cmp	r3, #2
9000b416:	d002      	beq.n	9000b41e <USBD_SetConfig+0x3e>
9000b418:	2b03      	cmp	r3, #3
9000b41a:	d029      	beq.n	9000b470 <USBD_SetConfig+0x90>
9000b41c:	e075      	b.n	9000b50a <USBD_SetConfig+0x12a>
  {
    case USBD_STATE_ADDRESSED:
      if (cfgidx != 0U)
9000b41e:	4b44      	ldr	r3, [pc, #272]	@ (9000b530 <USBD_SetConfig+0x150>)
9000b420:	781b      	ldrb	r3, [r3, #0]
9000b422:	2b00      	cmp	r3, #0
9000b424:	d020      	beq.n	9000b468 <USBD_SetConfig+0x88>
      {
        pdev->dev_config = cfgidx;
9000b426:	4b42      	ldr	r3, [pc, #264]	@ (9000b530 <USBD_SetConfig+0x150>)
9000b428:	781b      	ldrb	r3, [r3, #0]
9000b42a:	461a      	mov	r2, r3
9000b42c:	687b      	ldr	r3, [r7, #4]
9000b42e:	605a      	str	r2, [r3, #4]

        ret = USBD_SetClassConfig(pdev, cfgidx);
9000b430:	4b3f      	ldr	r3, [pc, #252]	@ (9000b530 <USBD_SetConfig+0x150>)
9000b432:	781b      	ldrb	r3, [r3, #0]
9000b434:	4619      	mov	r1, r3
9000b436:	6878      	ldr	r0, [r7, #4]
9000b438:	f7fe ffa3 	bl	9000a382 <USBD_SetClassConfig>
9000b43c:	4603      	mov	r3, r0
9000b43e:	73fb      	strb	r3, [r7, #15]

        if (ret != USBD_OK)
9000b440:	7bfb      	ldrb	r3, [r7, #15]
9000b442:	2b00      	cmp	r3, #0
9000b444:	d008      	beq.n	9000b458 <USBD_SetConfig+0x78>
        {
          USBD_CtlError(pdev, req);
9000b446:	6839      	ldr	r1, [r7, #0]
9000b448:	6878      	ldr	r0, [r7, #4]
9000b44a:	f000 f962 	bl	9000b712 <USBD_CtlError>
          pdev->dev_state = USBD_STATE_ADDRESSED;
9000b44e:	687b      	ldr	r3, [r7, #4]
9000b450:	2202      	movs	r2, #2
9000b452:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      }
      else
      {
        (void)USBD_CtlSendStatus(pdev);
      }
      break;
9000b456:	e065      	b.n	9000b524 <USBD_SetConfig+0x144>
          (void)USBD_CtlSendStatus(pdev);
9000b458:	6878      	ldr	r0, [r7, #4]
9000b45a:	f000 fa17 	bl	9000b88c <USBD_CtlSendStatus>
          pdev->dev_state = USBD_STATE_CONFIGURED;
9000b45e:	687b      	ldr	r3, [r7, #4]
9000b460:	2203      	movs	r2, #3
9000b462:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      break;
9000b466:	e05d      	b.n	9000b524 <USBD_SetConfig+0x144>
        (void)USBD_CtlSendStatus(pdev);
9000b468:	6878      	ldr	r0, [r7, #4]
9000b46a:	f000 fa0f 	bl	9000b88c <USBD_CtlSendStatus>
      break;
9000b46e:	e059      	b.n	9000b524 <USBD_SetConfig+0x144>

    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0U)
9000b470:	4b2f      	ldr	r3, [pc, #188]	@ (9000b530 <USBD_SetConfig+0x150>)
9000b472:	781b      	ldrb	r3, [r3, #0]
9000b474:	2b00      	cmp	r3, #0
9000b476:	d112      	bne.n	9000b49e <USBD_SetConfig+0xbe>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
9000b478:	687b      	ldr	r3, [r7, #4]
9000b47a:	2202      	movs	r2, #2
9000b47c:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
        pdev->dev_config = cfgidx;
9000b480:	4b2b      	ldr	r3, [pc, #172]	@ (9000b530 <USBD_SetConfig+0x150>)
9000b482:	781b      	ldrb	r3, [r3, #0]
9000b484:	461a      	mov	r2, r3
9000b486:	687b      	ldr	r3, [r7, #4]
9000b488:	605a      	str	r2, [r3, #4]
        (void)USBD_ClrClassConfig(pdev, cfgidx);
9000b48a:	4b29      	ldr	r3, [pc, #164]	@ (9000b530 <USBD_SetConfig+0x150>)
9000b48c:	781b      	ldrb	r3, [r3, #0]
9000b48e:	4619      	mov	r1, r3
9000b490:	6878      	ldr	r0, [r7, #4]
9000b492:	f7fe ff92 	bl	9000a3ba <USBD_ClrClassConfig>
        (void)USBD_CtlSendStatus(pdev);
9000b496:	6878      	ldr	r0, [r7, #4]
9000b498:	f000 f9f8 	bl	9000b88c <USBD_CtlSendStatus>
      }
      else
      {
        (void)USBD_CtlSendStatus(pdev);
      }
      break;
9000b49c:	e042      	b.n	9000b524 <USBD_SetConfig+0x144>
      else if (cfgidx != pdev->dev_config)
9000b49e:	4b24      	ldr	r3, [pc, #144]	@ (9000b530 <USBD_SetConfig+0x150>)
9000b4a0:	781b      	ldrb	r3, [r3, #0]
9000b4a2:	461a      	mov	r2, r3
9000b4a4:	687b      	ldr	r3, [r7, #4]
9000b4a6:	685b      	ldr	r3, [r3, #4]
9000b4a8:	429a      	cmp	r2, r3
9000b4aa:	d02a      	beq.n	9000b502 <USBD_SetConfig+0x122>
        (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
9000b4ac:	687b      	ldr	r3, [r7, #4]
9000b4ae:	685b      	ldr	r3, [r3, #4]
9000b4b0:	b2db      	uxtb	r3, r3
9000b4b2:	4619      	mov	r1, r3
9000b4b4:	6878      	ldr	r0, [r7, #4]
9000b4b6:	f7fe ff80 	bl	9000a3ba <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
9000b4ba:	4b1d      	ldr	r3, [pc, #116]	@ (9000b530 <USBD_SetConfig+0x150>)
9000b4bc:	781b      	ldrb	r3, [r3, #0]
9000b4be:	461a      	mov	r2, r3
9000b4c0:	687b      	ldr	r3, [r7, #4]
9000b4c2:	605a      	str	r2, [r3, #4]
        ret = USBD_SetClassConfig(pdev, cfgidx);
9000b4c4:	4b1a      	ldr	r3, [pc, #104]	@ (9000b530 <USBD_SetConfig+0x150>)
9000b4c6:	781b      	ldrb	r3, [r3, #0]
9000b4c8:	4619      	mov	r1, r3
9000b4ca:	6878      	ldr	r0, [r7, #4]
9000b4cc:	f7fe ff59 	bl	9000a382 <USBD_SetClassConfig>
9000b4d0:	4603      	mov	r3, r0
9000b4d2:	73fb      	strb	r3, [r7, #15]
        if (ret != USBD_OK)
9000b4d4:	7bfb      	ldrb	r3, [r7, #15]
9000b4d6:	2b00      	cmp	r3, #0
9000b4d8:	d00f      	beq.n	9000b4fa <USBD_SetConfig+0x11a>
          USBD_CtlError(pdev, req);
9000b4da:	6839      	ldr	r1, [r7, #0]
9000b4dc:	6878      	ldr	r0, [r7, #4]
9000b4de:	f000 f918 	bl	9000b712 <USBD_CtlError>
          (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
9000b4e2:	687b      	ldr	r3, [r7, #4]
9000b4e4:	685b      	ldr	r3, [r3, #4]
9000b4e6:	b2db      	uxtb	r3, r3
9000b4e8:	4619      	mov	r1, r3
9000b4ea:	6878      	ldr	r0, [r7, #4]
9000b4ec:	f7fe ff65 	bl	9000a3ba <USBD_ClrClassConfig>
          pdev->dev_state = USBD_STATE_ADDRESSED;
9000b4f0:	687b      	ldr	r3, [r7, #4]
9000b4f2:	2202      	movs	r2, #2
9000b4f4:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      break;
9000b4f8:	e014      	b.n	9000b524 <USBD_SetConfig+0x144>
          (void)USBD_CtlSendStatus(pdev);
9000b4fa:	6878      	ldr	r0, [r7, #4]
9000b4fc:	f000 f9c6 	bl	9000b88c <USBD_CtlSendStatus>
      break;
9000b500:	e010      	b.n	9000b524 <USBD_SetConfig+0x144>
        (void)USBD_CtlSendStatus(pdev);
9000b502:	6878      	ldr	r0, [r7, #4]
9000b504:	f000 f9c2 	bl	9000b88c <USBD_CtlSendStatus>
      break;
9000b508:	e00c      	b.n	9000b524 <USBD_SetConfig+0x144>

    default:
      USBD_CtlError(pdev, req);
9000b50a:	6839      	ldr	r1, [r7, #0]
9000b50c:	6878      	ldr	r0, [r7, #4]
9000b50e:	f000 f900 	bl	9000b712 <USBD_CtlError>
      (void)USBD_ClrClassConfig(pdev, cfgidx);
9000b512:	4b07      	ldr	r3, [pc, #28]	@ (9000b530 <USBD_SetConfig+0x150>)
9000b514:	781b      	ldrb	r3, [r3, #0]
9000b516:	4619      	mov	r1, r3
9000b518:	6878      	ldr	r0, [r7, #4]
9000b51a:	f7fe ff4e 	bl	9000a3ba <USBD_ClrClassConfig>
      ret = USBD_FAIL;
9000b51e:	2303      	movs	r3, #3
9000b520:	73fb      	strb	r3, [r7, #15]
      break;
9000b522:	bf00      	nop
  }

  return ret;
9000b524:	7bfb      	ldrb	r3, [r7, #15]
}
9000b526:	4618      	mov	r0, r3
9000b528:	3710      	adds	r7, #16
9000b52a:	46bd      	mov	sp, r7
9000b52c:	bd80      	pop	{r7, pc}
9000b52e:	bf00      	nop
9000b530:	24000e18 	.word	0x24000e18

9000b534 <USBD_GetConfig>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
9000b534:	b580      	push	{r7, lr}
9000b536:	b082      	sub	sp, #8
9000b538:	af00      	add	r7, sp, #0
9000b53a:	6078      	str	r0, [r7, #4]
9000b53c:	6039      	str	r1, [r7, #0]
  if (req->wLength != 1U)
9000b53e:	683b      	ldr	r3, [r7, #0]
9000b540:	88db      	ldrh	r3, [r3, #6]
9000b542:	2b01      	cmp	r3, #1
9000b544:	d004      	beq.n	9000b550 <USBD_GetConfig+0x1c>
  {
    USBD_CtlError(pdev, req);
9000b546:	6839      	ldr	r1, [r7, #0]
9000b548:	6878      	ldr	r0, [r7, #4]
9000b54a:	f000 f8e2 	bl	9000b712 <USBD_CtlError>
      default:
        USBD_CtlError(pdev, req);
        break;
    }
  }
}
9000b54e:	e023      	b.n	9000b598 <USBD_GetConfig+0x64>
    switch (pdev->dev_state)
9000b550:	687b      	ldr	r3, [r7, #4]
9000b552:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000b556:	b2db      	uxtb	r3, r3
9000b558:	2b02      	cmp	r3, #2
9000b55a:	dc02      	bgt.n	9000b562 <USBD_GetConfig+0x2e>
9000b55c:	2b00      	cmp	r3, #0
9000b55e:	dc03      	bgt.n	9000b568 <USBD_GetConfig+0x34>
9000b560:	e015      	b.n	9000b58e <USBD_GetConfig+0x5a>
9000b562:	2b03      	cmp	r3, #3
9000b564:	d00b      	beq.n	9000b57e <USBD_GetConfig+0x4a>
9000b566:	e012      	b.n	9000b58e <USBD_GetConfig+0x5a>
        pdev->dev_default_config = 0U;
9000b568:	687b      	ldr	r3, [r7, #4]
9000b56a:	2200      	movs	r2, #0
9000b56c:	609a      	str	r2, [r3, #8]
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_default_config, 1U);
9000b56e:	687b      	ldr	r3, [r7, #4]
9000b570:	3308      	adds	r3, #8
9000b572:	2201      	movs	r2, #1
9000b574:	4619      	mov	r1, r3
9000b576:	6878      	ldr	r0, [r7, #4]
9000b578:	f000 f948 	bl	9000b80c <USBD_CtlSendData>
        break;
9000b57c:	e00c      	b.n	9000b598 <USBD_GetConfig+0x64>
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config, 1U);
9000b57e:	687b      	ldr	r3, [r7, #4]
9000b580:	3304      	adds	r3, #4
9000b582:	2201      	movs	r2, #1
9000b584:	4619      	mov	r1, r3
9000b586:	6878      	ldr	r0, [r7, #4]
9000b588:	f000 f940 	bl	9000b80c <USBD_CtlSendData>
        break;
9000b58c:	e004      	b.n	9000b598 <USBD_GetConfig+0x64>
        USBD_CtlError(pdev, req);
9000b58e:	6839      	ldr	r1, [r7, #0]
9000b590:	6878      	ldr	r0, [r7, #4]
9000b592:	f000 f8be 	bl	9000b712 <USBD_CtlError>
        break;
9000b596:	bf00      	nop
}
9000b598:	bf00      	nop
9000b59a:	3708      	adds	r7, #8
9000b59c:	46bd      	mov	sp, r7
9000b59e:	bd80      	pop	{r7, pc}

9000b5a0 <USBD_GetStatus>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetStatus(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
9000b5a0:	b580      	push	{r7, lr}
9000b5a2:	b082      	sub	sp, #8
9000b5a4:	af00      	add	r7, sp, #0
9000b5a6:	6078      	str	r0, [r7, #4]
9000b5a8:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
9000b5aa:	687b      	ldr	r3, [r7, #4]
9000b5ac:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000b5b0:	b2db      	uxtb	r3, r3
9000b5b2:	3b01      	subs	r3, #1
9000b5b4:	2b02      	cmp	r3, #2
9000b5b6:	d81e      	bhi.n	9000b5f6 <USBD_GetStatus+0x56>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wLength != 0x2U)
9000b5b8:	683b      	ldr	r3, [r7, #0]
9000b5ba:	88db      	ldrh	r3, [r3, #6]
9000b5bc:	2b02      	cmp	r3, #2
9000b5be:	d004      	beq.n	9000b5ca <USBD_GetStatus+0x2a>
      {
        USBD_CtlError(pdev, req);
9000b5c0:	6839      	ldr	r1, [r7, #0]
9000b5c2:	6878      	ldr	r0, [r7, #4]
9000b5c4:	f000 f8a5 	bl	9000b712 <USBD_CtlError>
        break;
9000b5c8:	e01a      	b.n	9000b600 <USBD_GetStatus+0x60>
      }

#if (USBD_SELF_POWERED == 1U)
      pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
9000b5ca:	687b      	ldr	r3, [r7, #4]
9000b5cc:	2201      	movs	r2, #1
9000b5ce:	60da      	str	r2, [r3, #12]
#else
      pdev->dev_config_status = 0U;
#endif /* USBD_SELF_POWERED */

      if (pdev->dev_remote_wakeup != 0U)
9000b5d0:	687b      	ldr	r3, [r7, #4]
9000b5d2:	f8d3 32a4 	ldr.w	r3, [r3, #676]	@ 0x2a4
9000b5d6:	2b00      	cmp	r3, #0
9000b5d8:	d005      	beq.n	9000b5e6 <USBD_GetStatus+0x46>
      {
        pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
9000b5da:	687b      	ldr	r3, [r7, #4]
9000b5dc:	68db      	ldr	r3, [r3, #12]
9000b5de:	f043 0202 	orr.w	r2, r3, #2
9000b5e2:	687b      	ldr	r3, [r7, #4]
9000b5e4:	60da      	str	r2, [r3, #12]
      }

      (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config_status, 2U);
9000b5e6:	687b      	ldr	r3, [r7, #4]
9000b5e8:	330c      	adds	r3, #12
9000b5ea:	2202      	movs	r2, #2
9000b5ec:	4619      	mov	r1, r3
9000b5ee:	6878      	ldr	r0, [r7, #4]
9000b5f0:	f000 f90c 	bl	9000b80c <USBD_CtlSendData>
      break;
9000b5f4:	e004      	b.n	9000b600 <USBD_GetStatus+0x60>

    default:
      USBD_CtlError(pdev, req);
9000b5f6:	6839      	ldr	r1, [r7, #0]
9000b5f8:	6878      	ldr	r0, [r7, #4]
9000b5fa:	f000 f88a 	bl	9000b712 <USBD_CtlError>
      break;
9000b5fe:	bf00      	nop
  }
}
9000b600:	bf00      	nop
9000b602:	3708      	adds	r7, #8
9000b604:	46bd      	mov	sp, r7
9000b606:	bd80      	pop	{r7, pc}

9000b608 <USBD_SetFeature>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_SetFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
9000b608:	b580      	push	{r7, lr}
9000b60a:	b082      	sub	sp, #8
9000b60c:	af00      	add	r7, sp, #0
9000b60e:	6078      	str	r0, [r7, #4]
9000b610:	6039      	str	r1, [r7, #0]
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
9000b612:	683b      	ldr	r3, [r7, #0]
9000b614:	885b      	ldrh	r3, [r3, #2]
9000b616:	2b01      	cmp	r3, #1
9000b618:	d107      	bne.n	9000b62a <USBD_SetFeature+0x22>
  {
    pdev->dev_remote_wakeup = 1U;
9000b61a:	687b      	ldr	r3, [r7, #4]
9000b61c:	2201      	movs	r2, #1
9000b61e:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
    (void)USBD_CtlSendStatus(pdev);
9000b622:	6878      	ldr	r0, [r7, #4]
9000b624:	f000 f932 	bl	9000b88c <USBD_CtlSendStatus>
  }
  else
  {
    USBD_CtlError(pdev, req);
  }
}
9000b628:	e013      	b.n	9000b652 <USBD_SetFeature+0x4a>
  else if (req->wValue == USB_FEATURE_TEST_MODE)
9000b62a:	683b      	ldr	r3, [r7, #0]
9000b62c:	885b      	ldrh	r3, [r3, #2]
9000b62e:	2b02      	cmp	r3, #2
9000b630:	d10b      	bne.n	9000b64a <USBD_SetFeature+0x42>
    pdev->dev_test_mode = (uint8_t)(req->wIndex >> 8);
9000b632:	683b      	ldr	r3, [r7, #0]
9000b634:	889b      	ldrh	r3, [r3, #4]
9000b636:	0a1b      	lsrs	r3, r3, #8
9000b638:	b29b      	uxth	r3, r3
9000b63a:	b2da      	uxtb	r2, r3
9000b63c:	687b      	ldr	r3, [r7, #4]
9000b63e:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
    (void)USBD_CtlSendStatus(pdev);
9000b642:	6878      	ldr	r0, [r7, #4]
9000b644:	f000 f922 	bl	9000b88c <USBD_CtlSendStatus>
}
9000b648:	e003      	b.n	9000b652 <USBD_SetFeature+0x4a>
    USBD_CtlError(pdev, req);
9000b64a:	6839      	ldr	r1, [r7, #0]
9000b64c:	6878      	ldr	r0, [r7, #4]
9000b64e:	f000 f860 	bl	9000b712 <USBD_CtlError>
}
9000b652:	bf00      	nop
9000b654:	3708      	adds	r7, #8
9000b656:	46bd      	mov	sp, r7
9000b658:	bd80      	pop	{r7, pc}

9000b65a <USBD_ClrFeature>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_ClrFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
9000b65a:	b580      	push	{r7, lr}
9000b65c:	b082      	sub	sp, #8
9000b65e:	af00      	add	r7, sp, #0
9000b660:	6078      	str	r0, [r7, #4]
9000b662:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
9000b664:	687b      	ldr	r3, [r7, #4]
9000b666:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000b66a:	b2db      	uxtb	r3, r3
9000b66c:	3b01      	subs	r3, #1
9000b66e:	2b02      	cmp	r3, #2
9000b670:	d80b      	bhi.n	9000b68a <USBD_ClrFeature+0x30>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
9000b672:	683b      	ldr	r3, [r7, #0]
9000b674:	885b      	ldrh	r3, [r3, #2]
9000b676:	2b01      	cmp	r3, #1
9000b678:	d10c      	bne.n	9000b694 <USBD_ClrFeature+0x3a>
      {
        pdev->dev_remote_wakeup = 0U;
9000b67a:	687b      	ldr	r3, [r7, #4]
9000b67c:	2200      	movs	r2, #0
9000b67e:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
        (void)USBD_CtlSendStatus(pdev);
9000b682:	6878      	ldr	r0, [r7, #4]
9000b684:	f000 f902 	bl	9000b88c <USBD_CtlSendStatus>
      }
      break;
9000b688:	e004      	b.n	9000b694 <USBD_ClrFeature+0x3a>

    default:
      USBD_CtlError(pdev, req);
9000b68a:	6839      	ldr	r1, [r7, #0]
9000b68c:	6878      	ldr	r0, [r7, #4]
9000b68e:	f000 f840 	bl	9000b712 <USBD_CtlError>
      break;
9000b692:	e000      	b.n	9000b696 <USBD_ClrFeature+0x3c>
      break;
9000b694:	bf00      	nop
  }
}
9000b696:	bf00      	nop
9000b698:	3708      	adds	r7, #8
9000b69a:	46bd      	mov	sp, r7
9000b69c:	bd80      	pop	{r7, pc}

9000b69e <USBD_ParseSetupRequest>:
  * @param  req: usb request
  * @param  pdata: setup data pointer
  * @retval None
  */
void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
9000b69e:	b580      	push	{r7, lr}
9000b6a0:	b084      	sub	sp, #16
9000b6a2:	af00      	add	r7, sp, #0
9000b6a4:	6078      	str	r0, [r7, #4]
9000b6a6:	6039      	str	r1, [r7, #0]
  uint8_t *pbuff = pdata;
9000b6a8:	683b      	ldr	r3, [r7, #0]
9000b6aa:	60fb      	str	r3, [r7, #12]

  req->bmRequest = *(uint8_t *)(pbuff);
9000b6ac:	68fb      	ldr	r3, [r7, #12]
9000b6ae:	781a      	ldrb	r2, [r3, #0]
9000b6b0:	687b      	ldr	r3, [r7, #4]
9000b6b2:	701a      	strb	r2, [r3, #0]

  pbuff++;
9000b6b4:	68fb      	ldr	r3, [r7, #12]
9000b6b6:	3301      	adds	r3, #1
9000b6b8:	60fb      	str	r3, [r7, #12]
  req->bRequest = *(uint8_t *)(pbuff);
9000b6ba:	68fb      	ldr	r3, [r7, #12]
9000b6bc:	781a      	ldrb	r2, [r3, #0]
9000b6be:	687b      	ldr	r3, [r7, #4]
9000b6c0:	705a      	strb	r2, [r3, #1]

  pbuff++;
9000b6c2:	68fb      	ldr	r3, [r7, #12]
9000b6c4:	3301      	adds	r3, #1
9000b6c6:	60fb      	str	r3, [r7, #12]
  req->wValue = SWAPBYTE(pbuff);
9000b6c8:	68f8      	ldr	r0, [r7, #12]
9000b6ca:	f7ff fa13 	bl	9000aaf4 <SWAPBYTE>
9000b6ce:	4603      	mov	r3, r0
9000b6d0:	461a      	mov	r2, r3
9000b6d2:	687b      	ldr	r3, [r7, #4]
9000b6d4:	805a      	strh	r2, [r3, #2]

  pbuff++;
9000b6d6:	68fb      	ldr	r3, [r7, #12]
9000b6d8:	3301      	adds	r3, #1
9000b6da:	60fb      	str	r3, [r7, #12]
  pbuff++;
9000b6dc:	68fb      	ldr	r3, [r7, #12]
9000b6de:	3301      	adds	r3, #1
9000b6e0:	60fb      	str	r3, [r7, #12]
  req->wIndex = SWAPBYTE(pbuff);
9000b6e2:	68f8      	ldr	r0, [r7, #12]
9000b6e4:	f7ff fa06 	bl	9000aaf4 <SWAPBYTE>
9000b6e8:	4603      	mov	r3, r0
9000b6ea:	461a      	mov	r2, r3
9000b6ec:	687b      	ldr	r3, [r7, #4]
9000b6ee:	809a      	strh	r2, [r3, #4]

  pbuff++;
9000b6f0:	68fb      	ldr	r3, [r7, #12]
9000b6f2:	3301      	adds	r3, #1
9000b6f4:	60fb      	str	r3, [r7, #12]
  pbuff++;
9000b6f6:	68fb      	ldr	r3, [r7, #12]
9000b6f8:	3301      	adds	r3, #1
9000b6fa:	60fb      	str	r3, [r7, #12]
  req->wLength = SWAPBYTE(pbuff);
9000b6fc:	68f8      	ldr	r0, [r7, #12]
9000b6fe:	f7ff f9f9 	bl	9000aaf4 <SWAPBYTE>
9000b702:	4603      	mov	r3, r0
9000b704:	461a      	mov	r2, r3
9000b706:	687b      	ldr	r3, [r7, #4]
9000b708:	80da      	strh	r2, [r3, #6]
}
9000b70a:	bf00      	nop
9000b70c:	3710      	adds	r7, #16
9000b70e:	46bd      	mov	sp, r7
9000b710:	bd80      	pop	{r7, pc}

9000b712 <USBD_CtlError>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
void USBD_CtlError(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
9000b712:	b580      	push	{r7, lr}
9000b714:	b082      	sub	sp, #8
9000b716:	af00      	add	r7, sp, #0
9000b718:	6078      	str	r0, [r7, #4]
9000b71a:	6039      	str	r1, [r7, #0]
  UNUSED(req);

  (void)USBD_LL_StallEP(pdev, 0x80U);
9000b71c:	2180      	movs	r1, #128	@ 0x80
9000b71e:	6878      	ldr	r0, [r7, #4]
9000b720:	f7f5 fcf7 	bl	90001112 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
9000b724:	2100      	movs	r1, #0
9000b726:	6878      	ldr	r0, [r7, #4]
9000b728:	f7f5 fcf3 	bl	90001112 <USBD_LL_StallEP>
}
9000b72c:	bf00      	nop
9000b72e:	3708      	adds	r7, #8
9000b730:	46bd      	mov	sp, r7
9000b732:	bd80      	pop	{r7, pc}

9000b734 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
9000b734:	b580      	push	{r7, lr}
9000b736:	b086      	sub	sp, #24
9000b738:	af00      	add	r7, sp, #0
9000b73a:	60f8      	str	r0, [r7, #12]
9000b73c:	60b9      	str	r1, [r7, #8]
9000b73e:	607a      	str	r2, [r7, #4]
  uint8_t idx = 0U;
9000b740:	2300      	movs	r3, #0
9000b742:	75fb      	strb	r3, [r7, #23]
  uint8_t *pdesc;

  if (desc == NULL)
9000b744:	68fb      	ldr	r3, [r7, #12]
9000b746:	2b00      	cmp	r3, #0
9000b748:	d042      	beq.n	9000b7d0 <USBD_GetString+0x9c>
  {
    return;
  }

  pdesc = desc;
9000b74a:	68fb      	ldr	r3, [r7, #12]
9000b74c:	613b      	str	r3, [r7, #16]
  *len = MIN(USBD_MAX_STR_DESC_SIZ, ((uint16_t)USBD_GetLen(pdesc) * 2U) + 2U);
9000b74e:	6938      	ldr	r0, [r7, #16]
9000b750:	f000 f842 	bl	9000b7d8 <USBD_GetLen>
9000b754:	4603      	mov	r3, r0
9000b756:	3301      	adds	r3, #1
9000b758:	005b      	lsls	r3, r3, #1
9000b75a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
9000b75e:	d808      	bhi.n	9000b772 <USBD_GetString+0x3e>
9000b760:	6938      	ldr	r0, [r7, #16]
9000b762:	f000 f839 	bl	9000b7d8 <USBD_GetLen>
9000b766:	4603      	mov	r3, r0
9000b768:	3301      	adds	r3, #1
9000b76a:	b29b      	uxth	r3, r3
9000b76c:	005b      	lsls	r3, r3, #1
9000b76e:	b29a      	uxth	r2, r3
9000b770:	e001      	b.n	9000b776 <USBD_GetString+0x42>
9000b772:	f44f 7200 	mov.w	r2, #512	@ 0x200
9000b776:	687b      	ldr	r3, [r7, #4]
9000b778:	801a      	strh	r2, [r3, #0]

  unicode[idx] = *(uint8_t *)len;
9000b77a:	7dfb      	ldrb	r3, [r7, #23]
9000b77c:	68ba      	ldr	r2, [r7, #8]
9000b77e:	4413      	add	r3, r2
9000b780:	687a      	ldr	r2, [r7, #4]
9000b782:	7812      	ldrb	r2, [r2, #0]
9000b784:	701a      	strb	r2, [r3, #0]
  idx++;
9000b786:	7dfb      	ldrb	r3, [r7, #23]
9000b788:	3301      	adds	r3, #1
9000b78a:	75fb      	strb	r3, [r7, #23]
  unicode[idx] = USB_DESC_TYPE_STRING;
9000b78c:	7dfb      	ldrb	r3, [r7, #23]
9000b78e:	68ba      	ldr	r2, [r7, #8]
9000b790:	4413      	add	r3, r2
9000b792:	2203      	movs	r2, #3
9000b794:	701a      	strb	r2, [r3, #0]
  idx++;
9000b796:	7dfb      	ldrb	r3, [r7, #23]
9000b798:	3301      	adds	r3, #1
9000b79a:	75fb      	strb	r3, [r7, #23]

  while (*pdesc != (uint8_t)'\0')
9000b79c:	e013      	b.n	9000b7c6 <USBD_GetString+0x92>
  {
    unicode[idx] = *pdesc;
9000b79e:	7dfb      	ldrb	r3, [r7, #23]
9000b7a0:	68ba      	ldr	r2, [r7, #8]
9000b7a2:	4413      	add	r3, r2
9000b7a4:	693a      	ldr	r2, [r7, #16]
9000b7a6:	7812      	ldrb	r2, [r2, #0]
9000b7a8:	701a      	strb	r2, [r3, #0]
    pdesc++;
9000b7aa:	693b      	ldr	r3, [r7, #16]
9000b7ac:	3301      	adds	r3, #1
9000b7ae:	613b      	str	r3, [r7, #16]
    idx++;
9000b7b0:	7dfb      	ldrb	r3, [r7, #23]
9000b7b2:	3301      	adds	r3, #1
9000b7b4:	75fb      	strb	r3, [r7, #23]

    unicode[idx] = 0U;
9000b7b6:	7dfb      	ldrb	r3, [r7, #23]
9000b7b8:	68ba      	ldr	r2, [r7, #8]
9000b7ba:	4413      	add	r3, r2
9000b7bc:	2200      	movs	r2, #0
9000b7be:	701a      	strb	r2, [r3, #0]
    idx++;
9000b7c0:	7dfb      	ldrb	r3, [r7, #23]
9000b7c2:	3301      	adds	r3, #1
9000b7c4:	75fb      	strb	r3, [r7, #23]
  while (*pdesc != (uint8_t)'\0')
9000b7c6:	693b      	ldr	r3, [r7, #16]
9000b7c8:	781b      	ldrb	r3, [r3, #0]
9000b7ca:	2b00      	cmp	r3, #0
9000b7cc:	d1e7      	bne.n	9000b79e <USBD_GetString+0x6a>
9000b7ce:	e000      	b.n	9000b7d2 <USBD_GetString+0x9e>
    return;
9000b7d0:	bf00      	nop
  }
}
9000b7d2:	3718      	adds	r7, #24
9000b7d4:	46bd      	mov	sp, r7
9000b7d6:	bd80      	pop	{r7, pc}

9000b7d8 <USBD_GetLen>:
  *         return the string length
   * @param  buf : pointer to the ascii string buffer
  * @retval string length
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
9000b7d8:	b480      	push	{r7}
9000b7da:	b085      	sub	sp, #20
9000b7dc:	af00      	add	r7, sp, #0
9000b7de:	6078      	str	r0, [r7, #4]
  uint8_t  len = 0U;
9000b7e0:	2300      	movs	r3, #0
9000b7e2:	73fb      	strb	r3, [r7, #15]
  uint8_t *pbuff = buf;
9000b7e4:	687b      	ldr	r3, [r7, #4]
9000b7e6:	60bb      	str	r3, [r7, #8]

  while (*pbuff != (uint8_t)'\0')
9000b7e8:	e005      	b.n	9000b7f6 <USBD_GetLen+0x1e>
  {
    len++;
9000b7ea:	7bfb      	ldrb	r3, [r7, #15]
9000b7ec:	3301      	adds	r3, #1
9000b7ee:	73fb      	strb	r3, [r7, #15]
    pbuff++;
9000b7f0:	68bb      	ldr	r3, [r7, #8]
9000b7f2:	3301      	adds	r3, #1
9000b7f4:	60bb      	str	r3, [r7, #8]
  while (*pbuff != (uint8_t)'\0')
9000b7f6:	68bb      	ldr	r3, [r7, #8]
9000b7f8:	781b      	ldrb	r3, [r3, #0]
9000b7fa:	2b00      	cmp	r3, #0
9000b7fc:	d1f5      	bne.n	9000b7ea <USBD_GetLen+0x12>
  }

  return len;
9000b7fe:	7bfb      	ldrb	r3, [r7, #15]
}
9000b800:	4618      	mov	r0, r3
9000b802:	3714      	adds	r7, #20
9000b804:	46bd      	mov	sp, r7
9000b806:	f85d 7b04 	ldr.w	r7, [sp], #4
9000b80a:	4770      	bx	lr

9000b80c <USBD_CtlSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint32_t len)
{
9000b80c:	b580      	push	{r7, lr}
9000b80e:	b084      	sub	sp, #16
9000b810:	af00      	add	r7, sp, #0
9000b812:	60f8      	str	r0, [r7, #12]
9000b814:	60b9      	str	r1, [r7, #8]
9000b816:	607a      	str	r2, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
9000b818:	68fb      	ldr	r3, [r7, #12]
9000b81a:	2202      	movs	r2, #2
9000b81c:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  pdev->ep_in[0].total_length = len;
9000b820:	68fb      	ldr	r3, [r7, #12]
9000b822:	687a      	ldr	r2, [r7, #4]
9000b824:	615a      	str	r2, [r3, #20]
  pdev->ep_in[0].pbuffer = pbuf;
9000b826:	68fb      	ldr	r3, [r7, #12]
9000b828:	68ba      	ldr	r2, [r7, #8]
9000b82a:	625a      	str	r2, [r3, #36]	@ 0x24

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_in[0].rem_length = 0U;
#else
  pdev->ep_in[0].rem_length = len;
9000b82c:	68fb      	ldr	r3, [r7, #12]
9000b82e:	687a      	ldr	r2, [r7, #4]
9000b830:	619a      	str	r2, [r3, #24]
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
9000b832:	687b      	ldr	r3, [r7, #4]
9000b834:	68ba      	ldr	r2, [r7, #8]
9000b836:	2100      	movs	r1, #0
9000b838:	68f8      	ldr	r0, [r7, #12]
9000b83a:	f7f5 fcf3 	bl	90001224 <USBD_LL_Transmit>

  return USBD_OK;
9000b83e:	2300      	movs	r3, #0
}
9000b840:	4618      	mov	r0, r3
9000b842:	3710      	adds	r7, #16
9000b844:	46bd      	mov	sp, r7
9000b846:	bd80      	pop	{r7, pc}

9000b848 <USBD_CtlContinueSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint32_t len)
{
9000b848:	b580      	push	{r7, lr}
9000b84a:	b084      	sub	sp, #16
9000b84c:	af00      	add	r7, sp, #0
9000b84e:	60f8      	str	r0, [r7, #12]
9000b850:	60b9      	str	r1, [r7, #8]
9000b852:	607a      	str	r2, [r7, #4]
  /* Start the next transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
9000b854:	687b      	ldr	r3, [r7, #4]
9000b856:	68ba      	ldr	r2, [r7, #8]
9000b858:	2100      	movs	r1, #0
9000b85a:	68f8      	ldr	r0, [r7, #12]
9000b85c:	f7f5 fce2 	bl	90001224 <USBD_LL_Transmit>

  return USBD_OK;
9000b860:	2300      	movs	r3, #0
}
9000b862:	4618      	mov	r0, r3
9000b864:	3710      	adds	r7, #16
9000b866:	46bd      	mov	sp, r7
9000b868:	bd80      	pop	{r7, pc}

9000b86a <USBD_CtlContinueRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint32_t len)
{
9000b86a:	b580      	push	{r7, lr}
9000b86c:	b084      	sub	sp, #16
9000b86e:	af00      	add	r7, sp, #0
9000b870:	60f8      	str	r0, [r7, #12]
9000b872:	60b9      	str	r1, [r7, #8]
9000b874:	607a      	str	r2, [r7, #4]
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
9000b876:	687b      	ldr	r3, [r7, #4]
9000b878:	68ba      	ldr	r2, [r7, #8]
9000b87a:	2100      	movs	r1, #0
9000b87c:	68f8      	ldr	r0, [r7, #12]
9000b87e:	f7f5 fcf2 	bl	90001266 <USBD_LL_PrepareReceive>

  return USBD_OK;
9000b882:	2300      	movs	r3, #0
}
9000b884:	4618      	mov	r0, r3
9000b886:	3710      	adds	r7, #16
9000b888:	46bd      	mov	sp, r7
9000b88a:	bd80      	pop	{r7, pc}

9000b88c <USBD_CtlSendStatus>:
  *         send zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendStatus(USBD_HandleTypeDef *pdev)
{
9000b88c:	b580      	push	{r7, lr}
9000b88e:	b082      	sub	sp, #8
9000b890:	af00      	add	r7, sp, #0
9000b892:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
9000b894:	687b      	ldr	r3, [r7, #4]
9000b896:	2204      	movs	r2, #4
9000b898:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
9000b89c:	2300      	movs	r3, #0
9000b89e:	2200      	movs	r2, #0
9000b8a0:	2100      	movs	r1, #0
9000b8a2:	6878      	ldr	r0, [r7, #4]
9000b8a4:	f7f5 fcbe 	bl	90001224 <USBD_LL_Transmit>

  return USBD_OK;
9000b8a8:	2300      	movs	r3, #0
}
9000b8aa:	4618      	mov	r0, r3
9000b8ac:	3708      	adds	r7, #8
9000b8ae:	46bd      	mov	sp, r7
9000b8b0:	bd80      	pop	{r7, pc}

9000b8b2 <USBD_CtlReceiveStatus>:
  *         receive zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlReceiveStatus(USBD_HandleTypeDef *pdev)
{
9000b8b2:	b580      	push	{r7, lr}
9000b8b4:	b082      	sub	sp, #8
9000b8b6:	af00      	add	r7, sp, #0
9000b8b8:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
9000b8ba:	687b      	ldr	r3, [r7, #4]
9000b8bc:	2205      	movs	r2, #5
9000b8be:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
9000b8c2:	2300      	movs	r3, #0
9000b8c4:	2200      	movs	r2, #0
9000b8c6:	2100      	movs	r1, #0
9000b8c8:	6878      	ldr	r0, [r7, #4]
9000b8ca:	f7f5 fccc 	bl	90001266 <USBD_LL_PrepareReceive>

  return USBD_OK;
9000b8ce:	2300      	movs	r3, #0
}
9000b8d0:	4618      	mov	r0, r3
9000b8d2:	3708      	adds	r7, #8
9000b8d4:	46bd      	mov	sp, r7
9000b8d6:	bd80      	pop	{r7, pc}

9000b8d8 <USBD_MSC_Init>:
  * @param  pdev: device instance
  * @param  cfgidx: configuration index
  * @retval status
  */
uint8_t USBD_MSC_Init(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
9000b8d8:	b580      	push	{r7, lr}
9000b8da:	b084      	sub	sp, #16
9000b8dc:	af00      	add	r7, sp, #0
9000b8de:	6078      	str	r0, [r7, #4]
9000b8e0:	460b      	mov	r3, r1
9000b8e2:	70fb      	strb	r3, [r7, #3]
  UNUSED(cfgidx);
  USBD_MSC_BOT_HandleTypeDef *hmsc;

  hmsc = (USBD_MSC_BOT_HandleTypeDef *)USBD_malloc(sizeof(USBD_MSC_BOT_HandleTypeDef));
9000b8e4:	f44f 7021 	mov.w	r0, #644	@ 0x284
9000b8e8:	f7f5 fcf2 	bl	900012d0 <USBD_static_malloc>
9000b8ec:	60f8      	str	r0, [r7, #12]

  if (hmsc == NULL)
9000b8ee:	68fb      	ldr	r3, [r7, #12]
9000b8f0:	2b00      	cmp	r3, #0
9000b8f2:	d109      	bne.n	9000b908 <USBD_MSC_Init+0x30>
  {
    pdev->pClassDataCmsit[pdev->classId] = NULL;
9000b8f4:	687b      	ldr	r3, [r7, #4]
9000b8f6:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000b8fa:	687b      	ldr	r3, [r7, #4]
9000b8fc:	32b0      	adds	r2, #176	@ 0xb0
9000b8fe:	2100      	movs	r1, #0
9000b900:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    return (uint8_t)USBD_EMEM;
9000b904:	2302      	movs	r3, #2
9000b906:	e06e      	b.n	9000b9e6 <USBD_MSC_Init+0x10e>
  }

  pdev->pClassDataCmsit[pdev->classId] = (void *)hmsc;
9000b908:	687b      	ldr	r3, [r7, #4]
9000b90a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000b90e:	687b      	ldr	r3, [r7, #4]
9000b910:	32b0      	adds	r2, #176	@ 0xb0
9000b912:	68f9      	ldr	r1, [r7, #12]
9000b914:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  pdev->pClassData = pdev->pClassDataCmsit[pdev->classId];
9000b918:	687b      	ldr	r3, [r7, #4]
9000b91a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000b91e:	687b      	ldr	r3, [r7, #4]
9000b920:	32b0      	adds	r2, #176	@ 0xb0
9000b922:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
9000b926:	687b      	ldr	r3, [r7, #4]
9000b928:	f8c3 22bc 	str.w	r2, [r3, #700]	@ 0x2bc
  /* Get the Endpoints addresses allocated for this class instance */
  MSCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  MSCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (pdev->dev_speed == USBD_SPEED_HIGH)
9000b92c:	687b      	ldr	r3, [r7, #4]
9000b92e:	7c1b      	ldrb	r3, [r3, #16]
9000b930:	2b00      	cmp	r3, #0
9000b932:	d12b      	bne.n	9000b98c <USBD_MSC_Init+0xb4>
  {
    /* Open EP OUT */
    (void)USBD_LL_OpenEP(pdev, MSCOutEpAdd, USBD_EP_TYPE_BULK, MSC_MAX_HS_PACKET);
9000b934:	4b2e      	ldr	r3, [pc, #184]	@ (9000b9f0 <USBD_MSC_Init+0x118>)
9000b936:	7819      	ldrb	r1, [r3, #0]
9000b938:	f44f 7300 	mov.w	r3, #512	@ 0x200
9000b93c:	2202      	movs	r2, #2
9000b93e:	6878      	ldr	r0, [r7, #4]
9000b940:	f7f5 fb83 	bl	9000104a <USBD_LL_OpenEP>
    pdev->ep_out[MSCOutEpAdd & 0xFU].is_used = 1U;
9000b944:	4b2a      	ldr	r3, [pc, #168]	@ (9000b9f0 <USBD_MSC_Init+0x118>)
9000b946:	781b      	ldrb	r3, [r3, #0]
9000b948:	f003 020f 	and.w	r2, r3, #15
9000b94c:	6879      	ldr	r1, [r7, #4]
9000b94e:	4613      	mov	r3, r2
9000b950:	009b      	lsls	r3, r3, #2
9000b952:	4413      	add	r3, r2
9000b954:	009b      	lsls	r3, r3, #2
9000b956:	440b      	add	r3, r1
9000b958:	f203 1363 	addw	r3, r3, #355	@ 0x163
9000b95c:	2201      	movs	r2, #1
9000b95e:	701a      	strb	r2, [r3, #0]

    /* Open EP IN */
    (void)USBD_LL_OpenEP(pdev, MSCInEpAdd, USBD_EP_TYPE_BULK, MSC_MAX_HS_PACKET);
9000b960:	4b24      	ldr	r3, [pc, #144]	@ (9000b9f4 <USBD_MSC_Init+0x11c>)
9000b962:	7819      	ldrb	r1, [r3, #0]
9000b964:	f44f 7300 	mov.w	r3, #512	@ 0x200
9000b968:	2202      	movs	r2, #2
9000b96a:	6878      	ldr	r0, [r7, #4]
9000b96c:	f7f5 fb6d 	bl	9000104a <USBD_LL_OpenEP>
    pdev->ep_in[MSCInEpAdd & 0xFU].is_used = 1U;
9000b970:	4b20      	ldr	r3, [pc, #128]	@ (9000b9f4 <USBD_MSC_Init+0x11c>)
9000b972:	781b      	ldrb	r3, [r3, #0]
9000b974:	f003 020f 	and.w	r2, r3, #15
9000b978:	6879      	ldr	r1, [r7, #4]
9000b97a:	4613      	mov	r3, r2
9000b97c:	009b      	lsls	r3, r3, #2
9000b97e:	4413      	add	r3, r2
9000b980:	009b      	lsls	r3, r3, #2
9000b982:	440b      	add	r3, r1
9000b984:	3323      	adds	r3, #35	@ 0x23
9000b986:	2201      	movs	r2, #1
9000b988:	701a      	strb	r2, [r3, #0]
9000b98a:	e028      	b.n	9000b9de <USBD_MSC_Init+0x106>
  }
  else
  {
    /* Open EP OUT */
    (void)USBD_LL_OpenEP(pdev, MSCOutEpAdd, USBD_EP_TYPE_BULK, MSC_MAX_FS_PACKET);
9000b98c:	4b18      	ldr	r3, [pc, #96]	@ (9000b9f0 <USBD_MSC_Init+0x118>)
9000b98e:	7819      	ldrb	r1, [r3, #0]
9000b990:	2340      	movs	r3, #64	@ 0x40
9000b992:	2202      	movs	r2, #2
9000b994:	6878      	ldr	r0, [r7, #4]
9000b996:	f7f5 fb58 	bl	9000104a <USBD_LL_OpenEP>
    pdev->ep_out[MSCOutEpAdd & 0xFU].is_used = 1U;
9000b99a:	4b15      	ldr	r3, [pc, #84]	@ (9000b9f0 <USBD_MSC_Init+0x118>)
9000b99c:	781b      	ldrb	r3, [r3, #0]
9000b99e:	f003 020f 	and.w	r2, r3, #15
9000b9a2:	6879      	ldr	r1, [r7, #4]
9000b9a4:	4613      	mov	r3, r2
9000b9a6:	009b      	lsls	r3, r3, #2
9000b9a8:	4413      	add	r3, r2
9000b9aa:	009b      	lsls	r3, r3, #2
9000b9ac:	440b      	add	r3, r1
9000b9ae:	f203 1363 	addw	r3, r3, #355	@ 0x163
9000b9b2:	2201      	movs	r2, #1
9000b9b4:	701a      	strb	r2, [r3, #0]

    /* Open EP IN */
    (void)USBD_LL_OpenEP(pdev, MSCInEpAdd, USBD_EP_TYPE_BULK, MSC_MAX_FS_PACKET);
9000b9b6:	4b0f      	ldr	r3, [pc, #60]	@ (9000b9f4 <USBD_MSC_Init+0x11c>)
9000b9b8:	7819      	ldrb	r1, [r3, #0]
9000b9ba:	2340      	movs	r3, #64	@ 0x40
9000b9bc:	2202      	movs	r2, #2
9000b9be:	6878      	ldr	r0, [r7, #4]
9000b9c0:	f7f5 fb43 	bl	9000104a <USBD_LL_OpenEP>
    pdev->ep_in[MSCInEpAdd & 0xFU].is_used = 1U;
9000b9c4:	4b0b      	ldr	r3, [pc, #44]	@ (9000b9f4 <USBD_MSC_Init+0x11c>)
9000b9c6:	781b      	ldrb	r3, [r3, #0]
9000b9c8:	f003 020f 	and.w	r2, r3, #15
9000b9cc:	6879      	ldr	r1, [r7, #4]
9000b9ce:	4613      	mov	r3, r2
9000b9d0:	009b      	lsls	r3, r3, #2
9000b9d2:	4413      	add	r3, r2
9000b9d4:	009b      	lsls	r3, r3, #2
9000b9d6:	440b      	add	r3, r1
9000b9d8:	3323      	adds	r3, #35	@ 0x23
9000b9da:	2201      	movs	r2, #1
9000b9dc:	701a      	strb	r2, [r3, #0]
  }

  /* Init the BOT  layer */
  MSC_BOT_Init(pdev);
9000b9de:	6878      	ldr	r0, [r7, #4]
9000b9e0:	f000 fa30 	bl	9000be44 <MSC_BOT_Init>

  return (uint8_t)USBD_OK;
9000b9e4:	2300      	movs	r3, #0
}
9000b9e6:	4618      	mov	r0, r3
9000b9e8:	3710      	adds	r7, #16
9000b9ea:	46bd      	mov	sp, r7
9000b9ec:	bd80      	pop	{r7, pc}
9000b9ee:	bf00      	nop
9000b9f0:	240000e3 	.word	0x240000e3
9000b9f4:	240000e2 	.word	0x240000e2

9000b9f8 <USBD_MSC_DeInit>:
  * @param  pdev: device instance
  * @param  cfgidx: configuration index
  * @retval status
  */
uint8_t USBD_MSC_DeInit(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
9000b9f8:	b580      	push	{r7, lr}
9000b9fa:	b082      	sub	sp, #8
9000b9fc:	af00      	add	r7, sp, #0
9000b9fe:	6078      	str	r0, [r7, #4]
9000ba00:	460b      	mov	r3, r1
9000ba02:	70fb      	strb	r3, [r7, #3]
  MSCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  MSCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  /* Close MSC EPs */
  (void)USBD_LL_CloseEP(pdev, MSCOutEpAdd);
9000ba04:	4b26      	ldr	r3, [pc, #152]	@ (9000baa0 <USBD_MSC_DeInit+0xa8>)
9000ba06:	781b      	ldrb	r3, [r3, #0]
9000ba08:	4619      	mov	r1, r3
9000ba0a:	6878      	ldr	r0, [r7, #4]
9000ba0c:	f7f5 fb43 	bl	90001096 <USBD_LL_CloseEP>
  pdev->ep_out[MSCOutEpAdd & 0xFU].is_used = 0U;
9000ba10:	4b23      	ldr	r3, [pc, #140]	@ (9000baa0 <USBD_MSC_DeInit+0xa8>)
9000ba12:	781b      	ldrb	r3, [r3, #0]
9000ba14:	f003 020f 	and.w	r2, r3, #15
9000ba18:	6879      	ldr	r1, [r7, #4]
9000ba1a:	4613      	mov	r3, r2
9000ba1c:	009b      	lsls	r3, r3, #2
9000ba1e:	4413      	add	r3, r2
9000ba20:	009b      	lsls	r3, r3, #2
9000ba22:	440b      	add	r3, r1
9000ba24:	f203 1363 	addw	r3, r3, #355	@ 0x163
9000ba28:	2200      	movs	r2, #0
9000ba2a:	701a      	strb	r2, [r3, #0]

  /* Close EP IN */
  (void)USBD_LL_CloseEP(pdev, MSCInEpAdd);
9000ba2c:	4b1d      	ldr	r3, [pc, #116]	@ (9000baa4 <USBD_MSC_DeInit+0xac>)
9000ba2e:	781b      	ldrb	r3, [r3, #0]
9000ba30:	4619      	mov	r1, r3
9000ba32:	6878      	ldr	r0, [r7, #4]
9000ba34:	f7f5 fb2f 	bl	90001096 <USBD_LL_CloseEP>
  pdev->ep_in[MSCInEpAdd & 0xFU].is_used = 0U;
9000ba38:	4b1a      	ldr	r3, [pc, #104]	@ (9000baa4 <USBD_MSC_DeInit+0xac>)
9000ba3a:	781b      	ldrb	r3, [r3, #0]
9000ba3c:	f003 020f 	and.w	r2, r3, #15
9000ba40:	6879      	ldr	r1, [r7, #4]
9000ba42:	4613      	mov	r3, r2
9000ba44:	009b      	lsls	r3, r3, #2
9000ba46:	4413      	add	r3, r2
9000ba48:	009b      	lsls	r3, r3, #2
9000ba4a:	440b      	add	r3, r1
9000ba4c:	3323      	adds	r3, #35	@ 0x23
9000ba4e:	2200      	movs	r2, #0
9000ba50:	701a      	strb	r2, [r3, #0]

  /* Free MSC Class Resources */
  if (pdev->pClassDataCmsit[pdev->classId] != NULL)
9000ba52:	687b      	ldr	r3, [r7, #4]
9000ba54:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000ba58:	687b      	ldr	r3, [r7, #4]
9000ba5a:	32b0      	adds	r2, #176	@ 0xb0
9000ba5c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000ba60:	2b00      	cmp	r3, #0
9000ba62:	d018      	beq.n	9000ba96 <USBD_MSC_DeInit+0x9e>
  {
    /* De-Init the BOT layer */
    MSC_BOT_DeInit(pdev);
9000ba64:	6878      	ldr	r0, [r7, #4]
9000ba66:	f000 fa6b 	bl	9000bf40 <MSC_BOT_DeInit>

    (void)USBD_free(pdev->pClassDataCmsit[pdev->classId]);
9000ba6a:	687b      	ldr	r3, [r7, #4]
9000ba6c:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000ba70:	687b      	ldr	r3, [r7, #4]
9000ba72:	32b0      	adds	r2, #176	@ 0xb0
9000ba74:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000ba78:	4618      	mov	r0, r3
9000ba7a:	f7f5 fc37 	bl	900012ec <USBD_static_free>
    pdev->pClassDataCmsit[pdev->classId]  = NULL;
9000ba7e:	687b      	ldr	r3, [r7, #4]
9000ba80:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000ba84:	687b      	ldr	r3, [r7, #4]
9000ba86:	32b0      	adds	r2, #176	@ 0xb0
9000ba88:	2100      	movs	r1, #0
9000ba8a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    pdev->pClassData = NULL;
9000ba8e:	687b      	ldr	r3, [r7, #4]
9000ba90:	2200      	movs	r2, #0
9000ba92:	f8c3 22bc 	str.w	r2, [r3, #700]	@ 0x2bc
  }

  return (uint8_t)USBD_OK;
9000ba96:	2300      	movs	r3, #0
}
9000ba98:	4618      	mov	r0, r3
9000ba9a:	3708      	adds	r7, #8
9000ba9c:	46bd      	mov	sp, r7
9000ba9e:	bd80      	pop	{r7, pc}
9000baa0:	240000e3 	.word	0x240000e3
9000baa4:	240000e2 	.word	0x240000e2

9000baa8 <USBD_MSC_Setup>:
  * @param  pdev: device instance
  * @param  req: USB request
  * @retval status
  */
uint8_t USBD_MSC_Setup(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
9000baa8:	b580      	push	{r7, lr}
9000baaa:	b086      	sub	sp, #24
9000baac:	af00      	add	r7, sp, #0
9000baae:	6078      	str	r0, [r7, #4]
9000bab0:	6039      	str	r1, [r7, #0]
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000bab2:	687b      	ldr	r3, [r7, #4]
9000bab4:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000bab8:	687b      	ldr	r3, [r7, #4]
9000baba:	32b0      	adds	r2, #176	@ 0xb0
9000babc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000bac0:	613b      	str	r3, [r7, #16]
  USBD_StatusTypeDef ret = USBD_OK;
9000bac2:	2300      	movs	r3, #0
9000bac4:	75fb      	strb	r3, [r7, #23]
  uint32_t max_lun;
  uint16_t status_info = 0U;
9000bac6:	2300      	movs	r3, #0
9000bac8:	817b      	strh	r3, [r7, #10]
  /* Get the Endpoints addresses allocated for this class instance */
  MSCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  MSCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (hmsc == NULL)
9000baca:	693b      	ldr	r3, [r7, #16]
9000bacc:	2b00      	cmp	r3, #0
9000bace:	d101      	bne.n	9000bad4 <USBD_MSC_Setup+0x2c>
  {
    return (uint8_t)USBD_FAIL;
9000bad0:	2303      	movs	r3, #3
9000bad2:	e0e5      	b.n	9000bca0 <USBD_MSC_Setup+0x1f8>
  }

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
9000bad4:	683b      	ldr	r3, [r7, #0]
9000bad6:	781b      	ldrb	r3, [r3, #0]
9000bad8:	f003 0360 	and.w	r3, r3, #96	@ 0x60
9000badc:	2b00      	cmp	r3, #0
9000bade:	d058      	beq.n	9000bb92 <USBD_MSC_Setup+0xea>
9000bae0:	2b20      	cmp	r3, #32
9000bae2:	f040 80d5 	bne.w	9000bc90 <USBD_MSC_Setup+0x1e8>
  {
    /* Class request */
    case USB_REQ_TYPE_CLASS:
      switch (req->bRequest)
9000bae6:	683b      	ldr	r3, [r7, #0]
9000bae8:	785b      	ldrb	r3, [r3, #1]
9000baea:	2bfe      	cmp	r3, #254	@ 0xfe
9000baec:	d002      	beq.n	9000baf4 <USBD_MSC_Setup+0x4c>
9000baee:	2bff      	cmp	r3, #255	@ 0xff
9000baf0:	d02f      	beq.n	9000bb52 <USBD_MSC_Setup+0xaa>
9000baf2:	e046      	b.n	9000bb82 <USBD_MSC_Setup+0xda>
      {
        case BOT_GET_MAX_LUN:
          if ((req->wValue  == 0U) && (req->wLength == 1U) &&
9000baf4:	683b      	ldr	r3, [r7, #0]
9000baf6:	885b      	ldrh	r3, [r3, #2]
9000baf8:	2b00      	cmp	r3, #0
9000bafa:	d123      	bne.n	9000bb44 <USBD_MSC_Setup+0x9c>
9000bafc:	683b      	ldr	r3, [r7, #0]
9000bafe:	88db      	ldrh	r3, [r3, #6]
9000bb00:	2b01      	cmp	r3, #1
9000bb02:	d11f      	bne.n	9000bb44 <USBD_MSC_Setup+0x9c>
              ((req->bmRequest & 0x80U) == 0x80U))
9000bb04:	683b      	ldr	r3, [r7, #0]
9000bb06:	781b      	ldrb	r3, [r3, #0]
9000bb08:	b25b      	sxtb	r3, r3
          if ((req->wValue  == 0U) && (req->wLength == 1U) &&
9000bb0a:	2b00      	cmp	r3, #0
9000bb0c:	da1a      	bge.n	9000bb44 <USBD_MSC_Setup+0x9c>
          {
            max_lun = (uint32_t)((USBD_StorageTypeDef *)pdev->pUserData[pdev->classId])->GetMaxLun();
9000bb0e:	687b      	ldr	r3, [r7, #4]
9000bb10:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
9000bb14:	687a      	ldr	r2, [r7, #4]
9000bb16:	33b0      	adds	r3, #176	@ 0xb0
9000bb18:	009b      	lsls	r3, r3, #2
9000bb1a:	4413      	add	r3, r2
9000bb1c:	685b      	ldr	r3, [r3, #4]
9000bb1e:	699b      	ldr	r3, [r3, #24]
9000bb20:	4798      	blx	r3
9000bb22:	4603      	mov	r3, r0
9000bb24:	60fb      	str	r3, [r7, #12]
            hmsc->max_lun = (max_lun > MSC_BOT_MAX_LUN) ? MSC_BOT_MAX_LUN : max_lun;
9000bb26:	68fb      	ldr	r3, [r7, #12]
9000bb28:	2b02      	cmp	r3, #2
9000bb2a:	bf28      	it	cs
9000bb2c:	2302      	movcs	r3, #2
9000bb2e:	461a      	mov	r2, r3
9000bb30:	693b      	ldr	r3, [r7, #16]
9000bb32:	601a      	str	r2, [r3, #0]
            (void)USBD_CtlSendData(pdev, (uint8_t *)&hmsc->max_lun, 1U);
9000bb34:	693b      	ldr	r3, [r7, #16]
9000bb36:	2201      	movs	r2, #1
9000bb38:	4619      	mov	r1, r3
9000bb3a:	6878      	ldr	r0, [r7, #4]
9000bb3c:	f7ff fe66 	bl	9000b80c <USBD_CtlSendData>
9000bb40:	bf00      	nop
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
9000bb42:	e025      	b.n	9000bb90 <USBD_MSC_Setup+0xe8>
            USBD_CtlError(pdev, req);
9000bb44:	6839      	ldr	r1, [r7, #0]
9000bb46:	6878      	ldr	r0, [r7, #4]
9000bb48:	f7ff fde3 	bl	9000b712 <USBD_CtlError>
            ret = USBD_FAIL;
9000bb4c:	2303      	movs	r3, #3
9000bb4e:	75fb      	strb	r3, [r7, #23]
          break;
9000bb50:	e01e      	b.n	9000bb90 <USBD_MSC_Setup+0xe8>

        case BOT_RESET :
          if ((req->wValue  == 0U) && (req->wLength == 0U) &&
9000bb52:	683b      	ldr	r3, [r7, #0]
9000bb54:	885b      	ldrh	r3, [r3, #2]
9000bb56:	2b00      	cmp	r3, #0
9000bb58:	d10c      	bne.n	9000bb74 <USBD_MSC_Setup+0xcc>
9000bb5a:	683b      	ldr	r3, [r7, #0]
9000bb5c:	88db      	ldrh	r3, [r3, #6]
9000bb5e:	2b00      	cmp	r3, #0
9000bb60:	d108      	bne.n	9000bb74 <USBD_MSC_Setup+0xcc>
              ((req->bmRequest & 0x80U) != 0x80U))
9000bb62:	683b      	ldr	r3, [r7, #0]
9000bb64:	781b      	ldrb	r3, [r3, #0]
9000bb66:	b25b      	sxtb	r3, r3
          if ((req->wValue  == 0U) && (req->wLength == 0U) &&
9000bb68:	2b00      	cmp	r3, #0
9000bb6a:	db03      	blt.n	9000bb74 <USBD_MSC_Setup+0xcc>
          {
            MSC_BOT_Reset(pdev);
9000bb6c:	6878      	ldr	r0, [r7, #4]
9000bb6e:	f000 f9b3 	bl	9000bed8 <MSC_BOT_Reset>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
9000bb72:	e00d      	b.n	9000bb90 <USBD_MSC_Setup+0xe8>
            USBD_CtlError(pdev, req);
9000bb74:	6839      	ldr	r1, [r7, #0]
9000bb76:	6878      	ldr	r0, [r7, #4]
9000bb78:	f7ff fdcb 	bl	9000b712 <USBD_CtlError>
            ret = USBD_FAIL;
9000bb7c:	2303      	movs	r3, #3
9000bb7e:	75fb      	strb	r3, [r7, #23]
          break;
9000bb80:	e006      	b.n	9000bb90 <USBD_MSC_Setup+0xe8>

        default:
          USBD_CtlError(pdev, req);
9000bb82:	6839      	ldr	r1, [r7, #0]
9000bb84:	6878      	ldr	r0, [r7, #4]
9000bb86:	f7ff fdc4 	bl	9000b712 <USBD_CtlError>
          ret = USBD_FAIL;
9000bb8a:	2303      	movs	r3, #3
9000bb8c:	75fb      	strb	r3, [r7, #23]
          break;
9000bb8e:	bf00      	nop
      }
      break;
9000bb90:	e085      	b.n	9000bc9e <USBD_MSC_Setup+0x1f6>
    /* Interface & Endpoint request */
    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
9000bb92:	683b      	ldr	r3, [r7, #0]
9000bb94:	785b      	ldrb	r3, [r3, #1]
9000bb96:	2b0b      	cmp	r3, #11
9000bb98:	d871      	bhi.n	9000bc7e <USBD_MSC_Setup+0x1d6>
9000bb9a:	a201      	add	r2, pc, #4	@ (adr r2, 9000bba0 <USBD_MSC_Setup+0xf8>)
9000bb9c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
9000bba0:	9000bbd1 	.word	0x9000bbd1
9000bba4:	9000bc4d 	.word	0x9000bc4d
9000bba8:	9000bc7f 	.word	0x9000bc7f
9000bbac:	9000bc7f 	.word	0x9000bc7f
9000bbb0:	9000bc7f 	.word	0x9000bc7f
9000bbb4:	9000bc7f 	.word	0x9000bc7f
9000bbb8:	9000bc7f 	.word	0x9000bc7f
9000bbbc:	9000bc7f 	.word	0x9000bc7f
9000bbc0:	9000bc7f 	.word	0x9000bc7f
9000bbc4:	9000bc7f 	.word	0x9000bc7f
9000bbc8:	9000bbfb 	.word	0x9000bbfb
9000bbcc:	9000bc25 	.word	0x9000bc25
      {
        case USB_REQ_GET_STATUS:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
9000bbd0:	687b      	ldr	r3, [r7, #4]
9000bbd2:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000bbd6:	b2db      	uxtb	r3, r3
9000bbd8:	2b03      	cmp	r3, #3
9000bbda:	d107      	bne.n	9000bbec <USBD_MSC_Setup+0x144>
          {
            (void)USBD_CtlSendData(pdev, (uint8_t *)&status_info, 2U);
9000bbdc:	f107 030a 	add.w	r3, r7, #10
9000bbe0:	2202      	movs	r2, #2
9000bbe2:	4619      	mov	r1, r3
9000bbe4:	6878      	ldr	r0, [r7, #4]
9000bbe6:	f7ff fe11 	bl	9000b80c <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
9000bbea:	e050      	b.n	9000bc8e <USBD_MSC_Setup+0x1e6>
            USBD_CtlError(pdev, req);
9000bbec:	6839      	ldr	r1, [r7, #0]
9000bbee:	6878      	ldr	r0, [r7, #4]
9000bbf0:	f7ff fd8f 	bl	9000b712 <USBD_CtlError>
            ret = USBD_FAIL;
9000bbf4:	2303      	movs	r3, #3
9000bbf6:	75fb      	strb	r3, [r7, #23]
          break;
9000bbf8:	e049      	b.n	9000bc8e <USBD_MSC_Setup+0x1e6>

        case USB_REQ_GET_INTERFACE:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
9000bbfa:	687b      	ldr	r3, [r7, #4]
9000bbfc:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000bc00:	b2db      	uxtb	r3, r3
9000bc02:	2b03      	cmp	r3, #3
9000bc04:	d107      	bne.n	9000bc16 <USBD_MSC_Setup+0x16e>
          {
            (void)USBD_CtlSendData(pdev, (uint8_t *)&hmsc->interface, 1U);
9000bc06:	693b      	ldr	r3, [r7, #16]
9000bc08:	3304      	adds	r3, #4
9000bc0a:	2201      	movs	r2, #1
9000bc0c:	4619      	mov	r1, r3
9000bc0e:	6878      	ldr	r0, [r7, #4]
9000bc10:	f7ff fdfc 	bl	9000b80c <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
9000bc14:	e03b      	b.n	9000bc8e <USBD_MSC_Setup+0x1e6>
            USBD_CtlError(pdev, req);
9000bc16:	6839      	ldr	r1, [r7, #0]
9000bc18:	6878      	ldr	r0, [r7, #4]
9000bc1a:	f7ff fd7a 	bl	9000b712 <USBD_CtlError>
            ret = USBD_FAIL;
9000bc1e:	2303      	movs	r3, #3
9000bc20:	75fb      	strb	r3, [r7, #23]
          break;
9000bc22:	e034      	b.n	9000bc8e <USBD_MSC_Setup+0x1e6>

        case USB_REQ_SET_INTERFACE:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
9000bc24:	687b      	ldr	r3, [r7, #4]
9000bc26:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000bc2a:	b2db      	uxtb	r3, r3
9000bc2c:	2b03      	cmp	r3, #3
9000bc2e:	d106      	bne.n	9000bc3e <USBD_MSC_Setup+0x196>
          {
            hmsc->interface = (uint8_t)(req->wValue);
9000bc30:	683b      	ldr	r3, [r7, #0]
9000bc32:	885b      	ldrh	r3, [r3, #2]
9000bc34:	b2db      	uxtb	r3, r3
9000bc36:	461a      	mov	r2, r3
9000bc38:	693b      	ldr	r3, [r7, #16]
9000bc3a:	605a      	str	r2, [r3, #4]
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
9000bc3c:	e027      	b.n	9000bc8e <USBD_MSC_Setup+0x1e6>
            USBD_CtlError(pdev, req);
9000bc3e:	6839      	ldr	r1, [r7, #0]
9000bc40:	6878      	ldr	r0, [r7, #4]
9000bc42:	f7ff fd66 	bl	9000b712 <USBD_CtlError>
            ret = USBD_FAIL;
9000bc46:	2303      	movs	r3, #3
9000bc48:	75fb      	strb	r3, [r7, #23]
          break;
9000bc4a:	e020      	b.n	9000bc8e <USBD_MSC_Setup+0x1e6>

        case USB_REQ_CLEAR_FEATURE:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
9000bc4c:	687b      	ldr	r3, [r7, #4]
9000bc4e:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
9000bc52:	b2db      	uxtb	r3, r3
9000bc54:	2b03      	cmp	r3, #3
9000bc56:	d119      	bne.n	9000bc8c <USBD_MSC_Setup+0x1e4>
          {
            if (req->wValue == USB_FEATURE_EP_HALT)
9000bc58:	683b      	ldr	r3, [r7, #0]
9000bc5a:	885b      	ldrh	r3, [r3, #2]
9000bc5c:	2b00      	cmp	r3, #0
9000bc5e:	d115      	bne.n	9000bc8c <USBD_MSC_Setup+0x1e4>
            {
              /* Flush the FIFO */
              (void)USBD_LL_FlushEP(pdev, (uint8_t)req->wIndex);
9000bc60:	683b      	ldr	r3, [r7, #0]
9000bc62:	889b      	ldrh	r3, [r3, #4]
9000bc64:	b2db      	uxtb	r3, r3
9000bc66:	4619      	mov	r1, r3
9000bc68:	6878      	ldr	r0, [r7, #4]
9000bc6a:	f7f5 fa33 	bl	900010d4 <USBD_LL_FlushEP>

              /* Handle BOT error */
              MSC_BOT_CplClrFeature(pdev, (uint8_t)req->wIndex);
9000bc6e:	683b      	ldr	r3, [r7, #0]
9000bc70:	889b      	ldrh	r3, [r3, #4]
9000bc72:	b2db      	uxtb	r3, r3
9000bc74:	4619      	mov	r1, r3
9000bc76:	6878      	ldr	r0, [r7, #4]
9000bc78:	f000 fb30 	bl	9000c2dc <MSC_BOT_CplClrFeature>
            }
          }
          break;
9000bc7c:	e006      	b.n	9000bc8c <USBD_MSC_Setup+0x1e4>

        default:
          USBD_CtlError(pdev, req);
9000bc7e:	6839      	ldr	r1, [r7, #0]
9000bc80:	6878      	ldr	r0, [r7, #4]
9000bc82:	f7ff fd46 	bl	9000b712 <USBD_CtlError>
          ret = USBD_FAIL;
9000bc86:	2303      	movs	r3, #3
9000bc88:	75fb      	strb	r3, [r7, #23]
          break;
9000bc8a:	e000      	b.n	9000bc8e <USBD_MSC_Setup+0x1e6>
          break;
9000bc8c:	bf00      	nop
      }
      break;
9000bc8e:	e006      	b.n	9000bc9e <USBD_MSC_Setup+0x1f6>

    default:
      USBD_CtlError(pdev, req);
9000bc90:	6839      	ldr	r1, [r7, #0]
9000bc92:	6878      	ldr	r0, [r7, #4]
9000bc94:	f7ff fd3d 	bl	9000b712 <USBD_CtlError>
      ret = USBD_FAIL;
9000bc98:	2303      	movs	r3, #3
9000bc9a:	75fb      	strb	r3, [r7, #23]
      break;
9000bc9c:	bf00      	nop
  }

  return (uint8_t)ret;
9000bc9e:	7dfb      	ldrb	r3, [r7, #23]
}
9000bca0:	4618      	mov	r0, r3
9000bca2:	3718      	adds	r7, #24
9000bca4:	46bd      	mov	sp, r7
9000bca6:	bd80      	pop	{r7, pc}

9000bca8 <USBD_MSC_DataIn>:
  * @param  pdev: device instance
  * @param  epnum: endpoint index
  * @retval status
  */
uint8_t USBD_MSC_DataIn(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
9000bca8:	b580      	push	{r7, lr}
9000bcaa:	b082      	sub	sp, #8
9000bcac:	af00      	add	r7, sp, #0
9000bcae:	6078      	str	r0, [r7, #4]
9000bcb0:	460b      	mov	r3, r1
9000bcb2:	70fb      	strb	r3, [r7, #3]
  MSC_BOT_DataIn(pdev, epnum);
9000bcb4:	78fb      	ldrb	r3, [r7, #3]
9000bcb6:	4619      	mov	r1, r3
9000bcb8:	6878      	ldr	r0, [r7, #4]
9000bcba:	f000 f959 	bl	9000bf70 <MSC_BOT_DataIn>

  return (uint8_t)USBD_OK;
9000bcbe:	2300      	movs	r3, #0
}
9000bcc0:	4618      	mov	r0, r3
9000bcc2:	3708      	adds	r7, #8
9000bcc4:	46bd      	mov	sp, r7
9000bcc6:	bd80      	pop	{r7, pc}

9000bcc8 <USBD_MSC_DataOut>:
  * @param  pdev: device instance
  * @param  epnum: endpoint index
  * @retval status
  */
uint8_t USBD_MSC_DataOut(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
9000bcc8:	b580      	push	{r7, lr}
9000bcca:	b082      	sub	sp, #8
9000bccc:	af00      	add	r7, sp, #0
9000bcce:	6078      	str	r0, [r7, #4]
9000bcd0:	460b      	mov	r3, r1
9000bcd2:	70fb      	strb	r3, [r7, #3]
  MSC_BOT_DataOut(pdev, epnum);
9000bcd4:	78fb      	ldrb	r3, [r7, #3]
9000bcd6:	4619      	mov	r1, r3
9000bcd8:	6878      	ldr	r0, [r7, #4]
9000bcda:	f000 f983 	bl	9000bfe4 <MSC_BOT_DataOut>

  return (uint8_t)USBD_OK;
9000bcde:	2300      	movs	r3, #0
}
9000bce0:	4618      	mov	r0, r3
9000bce2:	3708      	adds	r7, #8
9000bce4:	46bd      	mov	sp, r7
9000bce6:	bd80      	pop	{r7, pc}

9000bce8 <USBD_MSC_GetHSCfgDesc>:
  *         return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
uint8_t *USBD_MSC_GetHSCfgDesc(uint16_t *length)
{
9000bce8:	b580      	push	{r7, lr}
9000bcea:	b084      	sub	sp, #16
9000bcec:	af00      	add	r7, sp, #0
9000bcee:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_MSC_CfgDesc, MSC_EPIN_ADDR);
9000bcf0:	2181      	movs	r1, #129	@ 0x81
9000bcf2:	4812      	ldr	r0, [pc, #72]	@ (9000bd3c <USBD_MSC_GetHSCfgDesc+0x54>)
9000bcf4:	f7fe feaa 	bl	9000aa4c <USBD_GetEpDesc>
9000bcf8:	60f8      	str	r0, [r7, #12]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_MSC_CfgDesc, MSC_EPOUT_ADDR);
9000bcfa:	2101      	movs	r1, #1
9000bcfc:	480f      	ldr	r0, [pc, #60]	@ (9000bd3c <USBD_MSC_GetHSCfgDesc+0x54>)
9000bcfe:	f7fe fea5 	bl	9000aa4c <USBD_GetEpDesc>
9000bd02:	60b8      	str	r0, [r7, #8]

  if (pEpInDesc != NULL)
9000bd04:	68fb      	ldr	r3, [r7, #12]
9000bd06:	2b00      	cmp	r3, #0
9000bd08:	d006      	beq.n	9000bd18 <USBD_MSC_GetHSCfgDesc+0x30>
  {
    pEpInDesc->wMaxPacketSize = MSC_MAX_HS_PACKET;
9000bd0a:	68fb      	ldr	r3, [r7, #12]
9000bd0c:	2200      	movs	r2, #0
9000bd0e:	711a      	strb	r2, [r3, #4]
9000bd10:	2200      	movs	r2, #0
9000bd12:	f042 0202 	orr.w	r2, r2, #2
9000bd16:	715a      	strb	r2, [r3, #5]
  }

  if (pEpOutDesc != NULL)
9000bd18:	68bb      	ldr	r3, [r7, #8]
9000bd1a:	2b00      	cmp	r3, #0
9000bd1c:	d006      	beq.n	9000bd2c <USBD_MSC_GetHSCfgDesc+0x44>
  {
    pEpOutDesc->wMaxPacketSize = MSC_MAX_HS_PACKET;
9000bd1e:	68bb      	ldr	r3, [r7, #8]
9000bd20:	2200      	movs	r2, #0
9000bd22:	711a      	strb	r2, [r3, #4]
9000bd24:	2200      	movs	r2, #0
9000bd26:	f042 0202 	orr.w	r2, r2, #2
9000bd2a:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_MSC_CfgDesc);
9000bd2c:	687b      	ldr	r3, [r7, #4]
9000bd2e:	2220      	movs	r2, #32
9000bd30:	801a      	strh	r2, [r3, #0]
  return USBD_MSC_CfgDesc;
9000bd32:	4b02      	ldr	r3, [pc, #8]	@ (9000bd3c <USBD_MSC_GetHSCfgDesc+0x54>)
}
9000bd34:	4618      	mov	r0, r3
9000bd36:	3710      	adds	r7, #16
9000bd38:	46bd      	mov	sp, r7
9000bd3a:	bd80      	pop	{r7, pc}
9000bd3c:	240000b8 	.word	0x240000b8

9000bd40 <USBD_MSC_GetFSCfgDesc>:
  *         return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
uint8_t *USBD_MSC_GetFSCfgDesc(uint16_t *length)
{
9000bd40:	b580      	push	{r7, lr}
9000bd42:	b084      	sub	sp, #16
9000bd44:	af00      	add	r7, sp, #0
9000bd46:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_MSC_CfgDesc, MSC_EPIN_ADDR);
9000bd48:	2181      	movs	r1, #129	@ 0x81
9000bd4a:	4812      	ldr	r0, [pc, #72]	@ (9000bd94 <USBD_MSC_GetFSCfgDesc+0x54>)
9000bd4c:	f7fe fe7e 	bl	9000aa4c <USBD_GetEpDesc>
9000bd50:	60f8      	str	r0, [r7, #12]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_MSC_CfgDesc, MSC_EPOUT_ADDR);
9000bd52:	2101      	movs	r1, #1
9000bd54:	480f      	ldr	r0, [pc, #60]	@ (9000bd94 <USBD_MSC_GetFSCfgDesc+0x54>)
9000bd56:	f7fe fe79 	bl	9000aa4c <USBD_GetEpDesc>
9000bd5a:	60b8      	str	r0, [r7, #8]

  if (pEpInDesc != NULL)
9000bd5c:	68fb      	ldr	r3, [r7, #12]
9000bd5e:	2b00      	cmp	r3, #0
9000bd60:	d006      	beq.n	9000bd70 <USBD_MSC_GetFSCfgDesc+0x30>
  {
    pEpInDesc->wMaxPacketSize = MSC_MAX_FS_PACKET;
9000bd62:	68fb      	ldr	r3, [r7, #12]
9000bd64:	2200      	movs	r2, #0
9000bd66:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
9000bd6a:	711a      	strb	r2, [r3, #4]
9000bd6c:	2200      	movs	r2, #0
9000bd6e:	715a      	strb	r2, [r3, #5]
  }

  if (pEpOutDesc != NULL)
9000bd70:	68bb      	ldr	r3, [r7, #8]
9000bd72:	2b00      	cmp	r3, #0
9000bd74:	d006      	beq.n	9000bd84 <USBD_MSC_GetFSCfgDesc+0x44>
  {
    pEpOutDesc->wMaxPacketSize = MSC_MAX_FS_PACKET;
9000bd76:	68bb      	ldr	r3, [r7, #8]
9000bd78:	2200      	movs	r2, #0
9000bd7a:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
9000bd7e:	711a      	strb	r2, [r3, #4]
9000bd80:	2200      	movs	r2, #0
9000bd82:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_MSC_CfgDesc);
9000bd84:	687b      	ldr	r3, [r7, #4]
9000bd86:	2220      	movs	r2, #32
9000bd88:	801a      	strh	r2, [r3, #0]
  return USBD_MSC_CfgDesc;
9000bd8a:	4b02      	ldr	r3, [pc, #8]	@ (9000bd94 <USBD_MSC_GetFSCfgDesc+0x54>)
}
9000bd8c:	4618      	mov	r0, r3
9000bd8e:	3710      	adds	r7, #16
9000bd90:	46bd      	mov	sp, r7
9000bd92:	bd80      	pop	{r7, pc}
9000bd94:	240000b8 	.word	0x240000b8

9000bd98 <USBD_MSC_GetOtherSpeedCfgDesc>:
  *         return other speed configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
uint8_t *USBD_MSC_GetOtherSpeedCfgDesc(uint16_t *length)
{
9000bd98:	b580      	push	{r7, lr}
9000bd9a:	b084      	sub	sp, #16
9000bd9c:	af00      	add	r7, sp, #0
9000bd9e:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_MSC_CfgDesc, MSC_EPIN_ADDR);
9000bda0:	2181      	movs	r1, #129	@ 0x81
9000bda2:	4812      	ldr	r0, [pc, #72]	@ (9000bdec <USBD_MSC_GetOtherSpeedCfgDesc+0x54>)
9000bda4:	f7fe fe52 	bl	9000aa4c <USBD_GetEpDesc>
9000bda8:	60f8      	str	r0, [r7, #12]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_MSC_CfgDesc, MSC_EPOUT_ADDR);
9000bdaa:	2101      	movs	r1, #1
9000bdac:	480f      	ldr	r0, [pc, #60]	@ (9000bdec <USBD_MSC_GetOtherSpeedCfgDesc+0x54>)
9000bdae:	f7fe fe4d 	bl	9000aa4c <USBD_GetEpDesc>
9000bdb2:	60b8      	str	r0, [r7, #8]

  if (pEpInDesc != NULL)
9000bdb4:	68fb      	ldr	r3, [r7, #12]
9000bdb6:	2b00      	cmp	r3, #0
9000bdb8:	d006      	beq.n	9000bdc8 <USBD_MSC_GetOtherSpeedCfgDesc+0x30>
  {
    pEpInDesc->wMaxPacketSize = MSC_MAX_FS_PACKET;
9000bdba:	68fb      	ldr	r3, [r7, #12]
9000bdbc:	2200      	movs	r2, #0
9000bdbe:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
9000bdc2:	711a      	strb	r2, [r3, #4]
9000bdc4:	2200      	movs	r2, #0
9000bdc6:	715a      	strb	r2, [r3, #5]
  }

  if (pEpOutDesc != NULL)
9000bdc8:	68bb      	ldr	r3, [r7, #8]
9000bdca:	2b00      	cmp	r3, #0
9000bdcc:	d006      	beq.n	9000bddc <USBD_MSC_GetOtherSpeedCfgDesc+0x44>
  {
    pEpOutDesc->wMaxPacketSize = MSC_MAX_FS_PACKET;
9000bdce:	68bb      	ldr	r3, [r7, #8]
9000bdd0:	2200      	movs	r2, #0
9000bdd2:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
9000bdd6:	711a      	strb	r2, [r3, #4]
9000bdd8:	2200      	movs	r2, #0
9000bdda:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_MSC_CfgDesc);
9000bddc:	687b      	ldr	r3, [r7, #4]
9000bdde:	2220      	movs	r2, #32
9000bde0:	801a      	strh	r2, [r3, #0]
  return USBD_MSC_CfgDesc;
9000bde2:	4b02      	ldr	r3, [pc, #8]	@ (9000bdec <USBD_MSC_GetOtherSpeedCfgDesc+0x54>)
}
9000bde4:	4618      	mov	r0, r3
9000bde6:	3710      	adds	r7, #16
9000bde8:	46bd      	mov	sp, r7
9000bdea:	bd80      	pop	{r7, pc}
9000bdec:	240000b8 	.word	0x240000b8

9000bdf0 <USBD_MSC_GetDeviceQualifierDescriptor>:
  *         return Device Qualifier descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
uint8_t *USBD_MSC_GetDeviceQualifierDescriptor(uint16_t *length)
{
9000bdf0:	b480      	push	{r7}
9000bdf2:	b083      	sub	sp, #12
9000bdf4:	af00      	add	r7, sp, #0
9000bdf6:	6078      	str	r0, [r7, #4]
  *length = (uint16_t)sizeof(USBD_MSC_DeviceQualifierDesc);
9000bdf8:	687b      	ldr	r3, [r7, #4]
9000bdfa:	220a      	movs	r2, #10
9000bdfc:	801a      	strh	r2, [r3, #0]

  return USBD_MSC_DeviceQualifierDesc;
9000bdfe:	4b03      	ldr	r3, [pc, #12]	@ (9000be0c <USBD_MSC_GetDeviceQualifierDescriptor+0x1c>)
}
9000be00:	4618      	mov	r0, r3
9000be02:	370c      	adds	r7, #12
9000be04:	46bd      	mov	sp, r7
9000be06:	f85d 7b04 	ldr.w	r7, [sp], #4
9000be0a:	4770      	bx	lr
9000be0c:	240000d8 	.word	0x240000d8

9000be10 <USBD_MSC_RegisterStorage>:
  * @brief  USBD_MSC_RegisterStorage
  * @param  fops: storage callback
  * @retval status
  */
uint8_t USBD_MSC_RegisterStorage(USBD_HandleTypeDef *pdev, USBD_StorageTypeDef *fops)
{
9000be10:	b480      	push	{r7}
9000be12:	b083      	sub	sp, #12
9000be14:	af00      	add	r7, sp, #0
9000be16:	6078      	str	r0, [r7, #4]
9000be18:	6039      	str	r1, [r7, #0]
  if (fops == NULL)
9000be1a:	683b      	ldr	r3, [r7, #0]
9000be1c:	2b00      	cmp	r3, #0
9000be1e:	d101      	bne.n	9000be24 <USBD_MSC_RegisterStorage+0x14>
  {
    return (uint8_t)USBD_FAIL;
9000be20:	2303      	movs	r3, #3
9000be22:	e009      	b.n	9000be38 <USBD_MSC_RegisterStorage+0x28>
  }

  pdev->pUserData[pdev->classId] = fops;
9000be24:	687b      	ldr	r3, [r7, #4]
9000be26:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
9000be2a:	687a      	ldr	r2, [r7, #4]
9000be2c:	33b0      	adds	r3, #176	@ 0xb0
9000be2e:	009b      	lsls	r3, r3, #2
9000be30:	4413      	add	r3, r2
9000be32:	683a      	ldr	r2, [r7, #0]
9000be34:	605a      	str	r2, [r3, #4]

  return (uint8_t)USBD_OK;
9000be36:	2300      	movs	r3, #0
}
9000be38:	4618      	mov	r0, r3
9000be3a:	370c      	adds	r7, #12
9000be3c:	46bd      	mov	sp, r7
9000be3e:	f85d 7b04 	ldr.w	r7, [sp], #4
9000be42:	4770      	bx	lr

9000be44 <MSC_BOT_Init>:
  *         Initialize the BOT Process
  * @param  pdev: device instance
  * @retval None
  */
void MSC_BOT_Init(USBD_HandleTypeDef *pdev)
{
9000be44:	b580      	push	{r7, lr}
9000be46:	b084      	sub	sp, #16
9000be48:	af00      	add	r7, sp, #0
9000be4a:	6078      	str	r0, [r7, #4]
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000be4c:	687b      	ldr	r3, [r7, #4]
9000be4e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000be52:	687b      	ldr	r3, [r7, #4]
9000be54:	32b0      	adds	r2, #176	@ 0xb0
9000be56:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000be5a:	60fb      	str	r3, [r7, #12]
  /* Get the Endpoints addresses allocated for this class instance */
  MSCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  MSCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (hmsc == NULL)
9000be5c:	68fb      	ldr	r3, [r7, #12]
9000be5e:	2b00      	cmp	r3, #0
9000be60:	d032      	beq.n	9000bec8 <MSC_BOT_Init+0x84>
  {
    return;
  }

  hmsc->bot_state = USBD_BOT_IDLE;
9000be62:	68fb      	ldr	r3, [r7, #12]
9000be64:	2200      	movs	r2, #0
9000be66:	721a      	strb	r2, [r3, #8]
  hmsc->bot_status = USBD_BOT_STATUS_NORMAL;
9000be68:	68fb      	ldr	r3, [r7, #12]
9000be6a:	2200      	movs	r2, #0
9000be6c:	725a      	strb	r2, [r3, #9]

  hmsc->scsi_sense_tail = 0U;
9000be6e:	68fb      	ldr	r3, [r7, #12]
9000be70:	2200      	movs	r2, #0
9000be72:	f883 2261 	strb.w	r2, [r3, #609]	@ 0x261
  hmsc->scsi_sense_head = 0U;
9000be76:	68fb      	ldr	r3, [r7, #12]
9000be78:	2200      	movs	r2, #0
9000be7a:	f883 2260 	strb.w	r2, [r3, #608]	@ 0x260
  hmsc->scsi_medium_state = SCSI_MEDIUM_UNLOCKED;
9000be7e:	68fb      	ldr	r3, [r7, #12]
9000be80:	2200      	movs	r2, #0
9000be82:	f883 2262 	strb.w	r2, [r3, #610]	@ 0x262

  ((USBD_StorageTypeDef *)pdev->pUserData[pdev->classId])->Init(0U);
9000be86:	687b      	ldr	r3, [r7, #4]
9000be88:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
9000be8c:	687a      	ldr	r2, [r7, #4]
9000be8e:	33b0      	adds	r3, #176	@ 0xb0
9000be90:	009b      	lsls	r3, r3, #2
9000be92:	4413      	add	r3, r2
9000be94:	685b      	ldr	r3, [r3, #4]
9000be96:	681b      	ldr	r3, [r3, #0]
9000be98:	2000      	movs	r0, #0
9000be9a:	4798      	blx	r3

  (void)USBD_LL_FlushEP(pdev, MSCOutEpAdd);
9000be9c:	4b0c      	ldr	r3, [pc, #48]	@ (9000bed0 <MSC_BOT_Init+0x8c>)
9000be9e:	781b      	ldrb	r3, [r3, #0]
9000bea0:	4619      	mov	r1, r3
9000bea2:	6878      	ldr	r0, [r7, #4]
9000bea4:	f7f5 f916 	bl	900010d4 <USBD_LL_FlushEP>
  (void)USBD_LL_FlushEP(pdev, MSCInEpAdd);
9000bea8:	4b0a      	ldr	r3, [pc, #40]	@ (9000bed4 <MSC_BOT_Init+0x90>)
9000beaa:	781b      	ldrb	r3, [r3, #0]
9000beac:	4619      	mov	r1, r3
9000beae:	6878      	ldr	r0, [r7, #4]
9000beb0:	f7f5 f910 	bl	900010d4 <USBD_LL_FlushEP>

  /* Prepare EP to Receive First BOT Cmd */
  (void)USBD_LL_PrepareReceive(pdev, MSCOutEpAdd, (uint8_t *)&hmsc->cbw,
9000beb4:	4b06      	ldr	r3, [pc, #24]	@ (9000bed0 <MSC_BOT_Init+0x8c>)
9000beb6:	7819      	ldrb	r1, [r3, #0]
9000beb8:	68fb      	ldr	r3, [r7, #12]
9000beba:	f503 7204 	add.w	r2, r3, #528	@ 0x210
9000bebe:	231f      	movs	r3, #31
9000bec0:	6878      	ldr	r0, [r7, #4]
9000bec2:	f7f5 f9d0 	bl	90001266 <USBD_LL_PrepareReceive>
9000bec6:	e000      	b.n	9000beca <MSC_BOT_Init+0x86>
    return;
9000bec8:	bf00      	nop
                               USBD_BOT_CBW_LENGTH);
}
9000beca:	3710      	adds	r7, #16
9000becc:	46bd      	mov	sp, r7
9000bece:	bd80      	pop	{r7, pc}
9000bed0:	240000e3 	.word	0x240000e3
9000bed4:	240000e2 	.word	0x240000e2

9000bed8 <MSC_BOT_Reset>:
  *         Reset the BOT Machine
  * @param  pdev: device instance
  * @retval  None
  */
void MSC_BOT_Reset(USBD_HandleTypeDef *pdev)
{
9000bed8:	b580      	push	{r7, lr}
9000beda:	b084      	sub	sp, #16
9000bedc:	af00      	add	r7, sp, #0
9000bede:	6078      	str	r0, [r7, #4]
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000bee0:	687b      	ldr	r3, [r7, #4]
9000bee2:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000bee6:	687b      	ldr	r3, [r7, #4]
9000bee8:	32b0      	adds	r2, #176	@ 0xb0
9000beea:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000beee:	60fb      	str	r3, [r7, #12]
  /* Get the Endpoints addresses allocated for this class instance */
  MSCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  MSCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (hmsc == NULL)
9000bef0:	68fb      	ldr	r3, [r7, #12]
9000bef2:	2b00      	cmp	r3, #0
9000bef4:	d01b      	beq.n	9000bf2e <MSC_BOT_Reset+0x56>
  {
    return;
  }

  hmsc->bot_state  = USBD_BOT_IDLE;
9000bef6:	68fb      	ldr	r3, [r7, #12]
9000bef8:	2200      	movs	r2, #0
9000befa:	721a      	strb	r2, [r3, #8]
  hmsc->bot_status = USBD_BOT_STATUS_RECOVERY;
9000befc:	68fb      	ldr	r3, [r7, #12]
9000befe:	2201      	movs	r2, #1
9000bf00:	725a      	strb	r2, [r3, #9]

  (void)USBD_LL_ClearStallEP(pdev, MSCInEpAdd);
9000bf02:	4b0d      	ldr	r3, [pc, #52]	@ (9000bf38 <MSC_BOT_Reset+0x60>)
9000bf04:	781b      	ldrb	r3, [r3, #0]
9000bf06:	4619      	mov	r1, r3
9000bf08:	6878      	ldr	r0, [r7, #4]
9000bf0a:	f7f5 f921 	bl	90001150 <USBD_LL_ClearStallEP>
  (void)USBD_LL_ClearStallEP(pdev, MSCOutEpAdd);
9000bf0e:	4b0b      	ldr	r3, [pc, #44]	@ (9000bf3c <MSC_BOT_Reset+0x64>)
9000bf10:	781b      	ldrb	r3, [r3, #0]
9000bf12:	4619      	mov	r1, r3
9000bf14:	6878      	ldr	r0, [r7, #4]
9000bf16:	f7f5 f91b 	bl	90001150 <USBD_LL_ClearStallEP>

  /* Prepare EP to Receive First BOT Cmd */
  (void)USBD_LL_PrepareReceive(pdev, MSCOutEpAdd, (uint8_t *)&hmsc->cbw,
9000bf1a:	4b08      	ldr	r3, [pc, #32]	@ (9000bf3c <MSC_BOT_Reset+0x64>)
9000bf1c:	7819      	ldrb	r1, [r3, #0]
9000bf1e:	68fb      	ldr	r3, [r7, #12]
9000bf20:	f503 7204 	add.w	r2, r3, #528	@ 0x210
9000bf24:	231f      	movs	r3, #31
9000bf26:	6878      	ldr	r0, [r7, #4]
9000bf28:	f7f5 f99d 	bl	90001266 <USBD_LL_PrepareReceive>
9000bf2c:	e000      	b.n	9000bf30 <MSC_BOT_Reset+0x58>
    return;
9000bf2e:	bf00      	nop
                               USBD_BOT_CBW_LENGTH);
}
9000bf30:	3710      	adds	r7, #16
9000bf32:	46bd      	mov	sp, r7
9000bf34:	bd80      	pop	{r7, pc}
9000bf36:	bf00      	nop
9000bf38:	240000e2 	.word	0x240000e2
9000bf3c:	240000e3 	.word	0x240000e3

9000bf40 <MSC_BOT_DeInit>:
  *         DeInitialize the BOT Machine
  * @param  pdev: device instance
  * @retval None
  */
void MSC_BOT_DeInit(USBD_HandleTypeDef  *pdev)
{
9000bf40:	b480      	push	{r7}
9000bf42:	b085      	sub	sp, #20
9000bf44:	af00      	add	r7, sp, #0
9000bf46:	6078      	str	r0, [r7, #4]
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000bf48:	687b      	ldr	r3, [r7, #4]
9000bf4a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000bf4e:	687b      	ldr	r3, [r7, #4]
9000bf50:	32b0      	adds	r2, #176	@ 0xb0
9000bf52:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000bf56:	60fb      	str	r3, [r7, #12]

  if (hmsc != NULL)
9000bf58:	68fb      	ldr	r3, [r7, #12]
9000bf5a:	2b00      	cmp	r3, #0
9000bf5c:	d002      	beq.n	9000bf64 <MSC_BOT_DeInit+0x24>
  {
    hmsc->bot_state = USBD_BOT_IDLE;
9000bf5e:	68fb      	ldr	r3, [r7, #12]
9000bf60:	2200      	movs	r2, #0
9000bf62:	721a      	strb	r2, [r3, #8]
  }
}
9000bf64:	bf00      	nop
9000bf66:	3714      	adds	r7, #20
9000bf68:	46bd      	mov	sp, r7
9000bf6a:	f85d 7b04 	ldr.w	r7, [sp], #4
9000bf6e:	4770      	bx	lr

9000bf70 <MSC_BOT_DataIn>:
  * @param  pdev: device instance
  * @param  epnum: endpoint index
  * @retval None
  */
void MSC_BOT_DataIn(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
9000bf70:	b580      	push	{r7, lr}
9000bf72:	b084      	sub	sp, #16
9000bf74:	af00      	add	r7, sp, #0
9000bf76:	6078      	str	r0, [r7, #4]
9000bf78:	460b      	mov	r3, r1
9000bf7a:	70fb      	strb	r3, [r7, #3]
  UNUSED(epnum);

  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000bf7c:	687b      	ldr	r3, [r7, #4]
9000bf7e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000bf82:	687b      	ldr	r3, [r7, #4]
9000bf84:	32b0      	adds	r2, #176	@ 0xb0
9000bf86:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000bf8a:	60fb      	str	r3, [r7, #12]

  if (hmsc == NULL)
9000bf8c:	68fb      	ldr	r3, [r7, #12]
9000bf8e:	2b00      	cmp	r3, #0
9000bf90:	d020      	beq.n	9000bfd4 <MSC_BOT_DataIn+0x64>
  {
    return;
  }

  switch (hmsc->bot_state)
9000bf92:	68fb      	ldr	r3, [r7, #12]
9000bf94:	7a1b      	ldrb	r3, [r3, #8]
9000bf96:	2b02      	cmp	r3, #2
9000bf98:	d005      	beq.n	9000bfa6 <MSC_BOT_DataIn+0x36>
9000bf9a:	2b02      	cmp	r3, #2
9000bf9c:	db1c      	blt.n	9000bfd8 <MSC_BOT_DataIn+0x68>
9000bf9e:	3b03      	subs	r3, #3
9000bfa0:	2b01      	cmp	r3, #1
9000bfa2:	d819      	bhi.n	9000bfd8 <MSC_BOT_DataIn+0x68>
9000bfa4:	e011      	b.n	9000bfca <MSC_BOT_DataIn+0x5a>
  {
    case USBD_BOT_DATA_IN:
      if (SCSI_ProcessCmd(pdev, hmsc->cbw.bLUN, &hmsc->cbw.CB[0]) < 0)
9000bfa6:	68fb      	ldr	r3, [r7, #12]
9000bfa8:	f893 121d 	ldrb.w	r1, [r3, #541]	@ 0x21d
9000bfac:	68fb      	ldr	r3, [r7, #12]
9000bfae:	f203 231f 	addw	r3, r3, #543	@ 0x21f
9000bfb2:	461a      	mov	r2, r3
9000bfb4:	6878      	ldr	r0, [r7, #4]
9000bfb6:	f000 f9cb 	bl	9000c350 <SCSI_ProcessCmd>
9000bfba:	4603      	mov	r3, r0
9000bfbc:	2b00      	cmp	r3, #0
9000bfbe:	da0d      	bge.n	9000bfdc <MSC_BOT_DataIn+0x6c>
      {
        MSC_BOT_SendCSW(pdev, USBD_CSW_CMD_FAILED);
9000bfc0:	2101      	movs	r1, #1
9000bfc2:	6878      	ldr	r0, [r7, #4]
9000bfc4:	f000 f90e 	bl	9000c1e4 <MSC_BOT_SendCSW>
      }
      break;
9000bfc8:	e008      	b.n	9000bfdc <MSC_BOT_DataIn+0x6c>

    case USBD_BOT_SEND_DATA:
    case USBD_BOT_LAST_DATA_IN:
      MSC_BOT_SendCSW(pdev, USBD_CSW_CMD_PASSED);
9000bfca:	2100      	movs	r1, #0
9000bfcc:	6878      	ldr	r0, [r7, #4]
9000bfce:	f000 f909 	bl	9000c1e4 <MSC_BOT_SendCSW>
      break;
9000bfd2:	e004      	b.n	9000bfde <MSC_BOT_DataIn+0x6e>
    return;
9000bfd4:	bf00      	nop
9000bfd6:	e002      	b.n	9000bfde <MSC_BOT_DataIn+0x6e>

    default:
      break;
9000bfd8:	bf00      	nop
9000bfda:	e000      	b.n	9000bfde <MSC_BOT_DataIn+0x6e>
      break;
9000bfdc:	bf00      	nop
  }
}
9000bfde:	3710      	adds	r7, #16
9000bfe0:	46bd      	mov	sp, r7
9000bfe2:	bd80      	pop	{r7, pc}

9000bfe4 <MSC_BOT_DataOut>:
  * @param  pdev: device instance
  * @param  epnum: endpoint index
  * @retval None
  */
void MSC_BOT_DataOut(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
9000bfe4:	b580      	push	{r7, lr}
9000bfe6:	b084      	sub	sp, #16
9000bfe8:	af00      	add	r7, sp, #0
9000bfea:	6078      	str	r0, [r7, #4]
9000bfec:	460b      	mov	r3, r1
9000bfee:	70fb      	strb	r3, [r7, #3]
  UNUSED(epnum);

  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000bff0:	687b      	ldr	r3, [r7, #4]
9000bff2:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000bff6:	687b      	ldr	r3, [r7, #4]
9000bff8:	32b0      	adds	r2, #176	@ 0xb0
9000bffa:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000bffe:	60fb      	str	r3, [r7, #12]

  if (hmsc == NULL)
9000c000:	68fb      	ldr	r3, [r7, #12]
9000c002:	2b00      	cmp	r3, #0
9000c004:	d01c      	beq.n	9000c040 <MSC_BOT_DataOut+0x5c>
  {
    return;
  }

  switch (hmsc->bot_state)
9000c006:	68fb      	ldr	r3, [r7, #12]
9000c008:	7a1b      	ldrb	r3, [r3, #8]
9000c00a:	2b00      	cmp	r3, #0
9000c00c:	d002      	beq.n	9000c014 <MSC_BOT_DataOut+0x30>
9000c00e:	2b01      	cmp	r3, #1
9000c010:	d004      	beq.n	9000c01c <MSC_BOT_DataOut+0x38>
        MSC_BOT_SendCSW(pdev, USBD_CSW_CMD_FAILED);
      }
      break;

    default:
      break;
9000c012:	e018      	b.n	9000c046 <MSC_BOT_DataOut+0x62>
      MSC_BOT_CBW_Decode(pdev);
9000c014:	6878      	ldr	r0, [r7, #4]
9000c016:	f000 f819 	bl	9000c04c <MSC_BOT_CBW_Decode>
      break;
9000c01a:	e014      	b.n	9000c046 <MSC_BOT_DataOut+0x62>
      if (SCSI_ProcessCmd(pdev, hmsc->cbw.bLUN, &hmsc->cbw.CB[0]) < 0)
9000c01c:	68fb      	ldr	r3, [r7, #12]
9000c01e:	f893 121d 	ldrb.w	r1, [r3, #541]	@ 0x21d
9000c022:	68fb      	ldr	r3, [r7, #12]
9000c024:	f203 231f 	addw	r3, r3, #543	@ 0x21f
9000c028:	461a      	mov	r2, r3
9000c02a:	6878      	ldr	r0, [r7, #4]
9000c02c:	f000 f990 	bl	9000c350 <SCSI_ProcessCmd>
9000c030:	4603      	mov	r3, r0
9000c032:	2b00      	cmp	r3, #0
9000c034:	da06      	bge.n	9000c044 <MSC_BOT_DataOut+0x60>
        MSC_BOT_SendCSW(pdev, USBD_CSW_CMD_FAILED);
9000c036:	2101      	movs	r1, #1
9000c038:	6878      	ldr	r0, [r7, #4]
9000c03a:	f000 f8d3 	bl	9000c1e4 <MSC_BOT_SendCSW>
      break;
9000c03e:	e001      	b.n	9000c044 <MSC_BOT_DataOut+0x60>
    return;
9000c040:	bf00      	nop
9000c042:	e000      	b.n	9000c046 <MSC_BOT_DataOut+0x62>
      break;
9000c044:	bf00      	nop
  }
}
9000c046:	3710      	adds	r7, #16
9000c048:	46bd      	mov	sp, r7
9000c04a:	bd80      	pop	{r7, pc}

9000c04c <MSC_BOT_CBW_Decode>:
  *         Decode the CBW command and set the BOT state machine accordingly
  * @param  pdev: device instance
  * @retval None
  */
static void  MSC_BOT_CBW_Decode(USBD_HandleTypeDef *pdev)
{
9000c04c:	b580      	push	{r7, lr}
9000c04e:	b084      	sub	sp, #16
9000c050:	af00      	add	r7, sp, #0
9000c052:	6078      	str	r0, [r7, #4]
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000c054:	687b      	ldr	r3, [r7, #4]
9000c056:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000c05a:	687b      	ldr	r3, [r7, #4]
9000c05c:	32b0      	adds	r2, #176	@ 0xb0
9000c05e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000c062:	60fb      	str	r3, [r7, #12]
  /* Get the Endpoints addresses allocated for this class instance */
  MSCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  MSCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (hmsc == NULL)
9000c064:	68fb      	ldr	r3, [r7, #12]
9000c066:	2b00      	cmp	r3, #0
9000c068:	d07c      	beq.n	9000c164 <MSC_BOT_CBW_Decode+0x118>
  {
    return;
  }

  hmsc->csw.dTag = hmsc->cbw.dTag;
9000c06a:	68fb      	ldr	r3, [r7, #12]
9000c06c:	f8d3 2214 	ldr.w	r2, [r3, #532]	@ 0x214
9000c070:	68fb      	ldr	r3, [r7, #12]
9000c072:	f8c3 2234 	str.w	r2, [r3, #564]	@ 0x234
  hmsc->csw.dDataResidue = hmsc->cbw.dDataLength;
9000c076:	68fb      	ldr	r3, [r7, #12]
9000c078:	f8d3 2218 	ldr.w	r2, [r3, #536]	@ 0x218
9000c07c:	68fb      	ldr	r3, [r7, #12]
9000c07e:	f8c3 2238 	str.w	r2, [r3, #568]	@ 0x238

  if ((USBD_LL_GetRxDataSize(pdev, MSCOutEpAdd) != USBD_BOT_CBW_LENGTH) ||
9000c082:	4b3b      	ldr	r3, [pc, #236]	@ (9000c170 <MSC_BOT_CBW_Decode+0x124>)
9000c084:	781b      	ldrb	r3, [r3, #0]
9000c086:	4619      	mov	r1, r3
9000c088:	6878      	ldr	r0, [r7, #4]
9000c08a:	f7f5 f90d 	bl	900012a8 <USBD_LL_GetRxDataSize>
9000c08e:	4603      	mov	r3, r0
9000c090:	2b1f      	cmp	r3, #31
9000c092:	d117      	bne.n	9000c0c4 <MSC_BOT_CBW_Decode+0x78>
      (hmsc->cbw.dSignature != USBD_BOT_CBW_SIGNATURE) ||
9000c094:	68fb      	ldr	r3, [r7, #12]
9000c096:	f8d3 3210 	ldr.w	r3, [r3, #528]	@ 0x210
  if ((USBD_LL_GetRxDataSize(pdev, MSCOutEpAdd) != USBD_BOT_CBW_LENGTH) ||
9000c09a:	4a36      	ldr	r2, [pc, #216]	@ (9000c174 <MSC_BOT_CBW_Decode+0x128>)
9000c09c:	4293      	cmp	r3, r2
9000c09e:	d111      	bne.n	9000c0c4 <MSC_BOT_CBW_Decode+0x78>
      (hmsc->cbw.bLUN > hmsc->max_lun) || (hmsc->cbw.bCBLength < 1U) ||
9000c0a0:	68fb      	ldr	r3, [r7, #12]
9000c0a2:	f893 321d 	ldrb.w	r3, [r3, #541]	@ 0x21d
9000c0a6:	461a      	mov	r2, r3
9000c0a8:	68fb      	ldr	r3, [r7, #12]
9000c0aa:	681b      	ldr	r3, [r3, #0]
      (hmsc->cbw.dSignature != USBD_BOT_CBW_SIGNATURE) ||
9000c0ac:	429a      	cmp	r2, r3
9000c0ae:	d809      	bhi.n	9000c0c4 <MSC_BOT_CBW_Decode+0x78>
      (hmsc->cbw.bLUN > hmsc->max_lun) || (hmsc->cbw.bCBLength < 1U) ||
9000c0b0:	68fb      	ldr	r3, [r7, #12]
9000c0b2:	f893 321e 	ldrb.w	r3, [r3, #542]	@ 0x21e
9000c0b6:	2b00      	cmp	r3, #0
9000c0b8:	d004      	beq.n	9000c0c4 <MSC_BOT_CBW_Decode+0x78>
      (hmsc->cbw.bCBLength > 16U))
9000c0ba:	68fb      	ldr	r3, [r7, #12]
9000c0bc:	f893 321e 	ldrb.w	r3, [r3, #542]	@ 0x21e
      (hmsc->cbw.bLUN > hmsc->max_lun) || (hmsc->cbw.bCBLength < 1U) ||
9000c0c0:	2b10      	cmp	r3, #16
9000c0c2:	d90e      	bls.n	9000c0e2 <MSC_BOT_CBW_Decode+0x96>
  {
    SCSI_SenseCode(pdev, hmsc->cbw.bLUN, ILLEGAL_REQUEST, INVALID_CDB);
9000c0c4:	68fb      	ldr	r3, [r7, #12]
9000c0c6:	f893 121d 	ldrb.w	r1, [r3, #541]	@ 0x21d
9000c0ca:	2320      	movs	r3, #32
9000c0cc:	2205      	movs	r2, #5
9000c0ce:	6878      	ldr	r0, [r7, #4]
9000c0d0:	f000 fe85 	bl	9000cdde <SCSI_SenseCode>

    hmsc->bot_status = USBD_BOT_STATUS_ERROR;
9000c0d4:	68fb      	ldr	r3, [r7, #12]
9000c0d6:	2202      	movs	r2, #2
9000c0d8:	725a      	strb	r2, [r3, #9]
    MSC_BOT_Abort(pdev);
9000c0da:	6878      	ldr	r0, [r7, #4]
9000c0dc:	f000 f8bc 	bl	9000c258 <MSC_BOT_Abort>
9000c0e0:	e043      	b.n	9000c16a <MSC_BOT_CBW_Decode+0x11e>
  }
  else
  {
    if (SCSI_ProcessCmd(pdev, hmsc->cbw.bLUN, &hmsc->cbw.CB[0]) < 0)
9000c0e2:	68fb      	ldr	r3, [r7, #12]
9000c0e4:	f893 121d 	ldrb.w	r1, [r3, #541]	@ 0x21d
9000c0e8:	68fb      	ldr	r3, [r7, #12]
9000c0ea:	f203 231f 	addw	r3, r3, #543	@ 0x21f
9000c0ee:	461a      	mov	r2, r3
9000c0f0:	6878      	ldr	r0, [r7, #4]
9000c0f2:	f000 f92d 	bl	9000c350 <SCSI_ProcessCmd>
9000c0f6:	4603      	mov	r3, r0
9000c0f8:	2b00      	cmp	r3, #0
9000c0fa:	da0c      	bge.n	9000c116 <MSC_BOT_CBW_Decode+0xca>
    {
      if (hmsc->bot_state == USBD_BOT_NO_DATA)
9000c0fc:	68fb      	ldr	r3, [r7, #12]
9000c0fe:	7a1b      	ldrb	r3, [r3, #8]
9000c100:	2b05      	cmp	r3, #5
9000c102:	d104      	bne.n	9000c10e <MSC_BOT_CBW_Decode+0xc2>
      {
        MSC_BOT_SendCSW(pdev, USBD_CSW_CMD_FAILED);
9000c104:	2101      	movs	r1, #1
9000c106:	6878      	ldr	r0, [r7, #4]
9000c108:	f000 f86c 	bl	9000c1e4 <MSC_BOT_SendCSW>
9000c10c:	e02d      	b.n	9000c16a <MSC_BOT_CBW_Decode+0x11e>
      }
      else
      {
        MSC_BOT_Abort(pdev);
9000c10e:	6878      	ldr	r0, [r7, #4]
9000c110:	f000 f8a2 	bl	9000c258 <MSC_BOT_Abort>
9000c114:	e029      	b.n	9000c16a <MSC_BOT_CBW_Decode+0x11e>
      }
    }
    /* Burst xfer handled internally */
    else if ((hmsc->bot_state != USBD_BOT_DATA_IN) &&
9000c116:	68fb      	ldr	r3, [r7, #12]
9000c118:	7a1b      	ldrb	r3, [r3, #8]
9000c11a:	2b02      	cmp	r3, #2
9000c11c:	d024      	beq.n	9000c168 <MSC_BOT_CBW_Decode+0x11c>
             (hmsc->bot_state != USBD_BOT_DATA_OUT) &&
9000c11e:	68fb      	ldr	r3, [r7, #12]
9000c120:	7a1b      	ldrb	r3, [r3, #8]
    else if ((hmsc->bot_state != USBD_BOT_DATA_IN) &&
9000c122:	2b01      	cmp	r3, #1
9000c124:	d020      	beq.n	9000c168 <MSC_BOT_CBW_Decode+0x11c>
             (hmsc->bot_state != USBD_BOT_LAST_DATA_IN))
9000c126:	68fb      	ldr	r3, [r7, #12]
9000c128:	7a1b      	ldrb	r3, [r3, #8]
             (hmsc->bot_state != USBD_BOT_DATA_OUT) &&
9000c12a:	2b03      	cmp	r3, #3
9000c12c:	d01c      	beq.n	9000c168 <MSC_BOT_CBW_Decode+0x11c>
    {
      if (hmsc->bot_data_length > 0U)
9000c12e:	68fb      	ldr	r3, [r7, #12]
9000c130:	68db      	ldr	r3, [r3, #12]
9000c132:	2b00      	cmp	r3, #0
9000c134:	d009      	beq.n	9000c14a <MSC_BOT_CBW_Decode+0xfe>
      {
        MSC_BOT_SendData(pdev, hmsc->bot_data, hmsc->bot_data_length);
9000c136:	68fb      	ldr	r3, [r7, #12]
9000c138:	f103 0110 	add.w	r1, r3, #16
9000c13c:	68fb      	ldr	r3, [r7, #12]
9000c13e:	68db      	ldr	r3, [r3, #12]
9000c140:	461a      	mov	r2, r3
9000c142:	6878      	ldr	r0, [r7, #4]
9000c144:	f000 f818 	bl	9000c178 <MSC_BOT_SendData>
      if (hmsc->bot_data_length > 0U)
9000c148:	e00f      	b.n	9000c16a <MSC_BOT_CBW_Decode+0x11e>
      }
      else if (hmsc->bot_data_length == 0U)
9000c14a:	68fb      	ldr	r3, [r7, #12]
9000c14c:	68db      	ldr	r3, [r3, #12]
9000c14e:	2b00      	cmp	r3, #0
9000c150:	d104      	bne.n	9000c15c <MSC_BOT_CBW_Decode+0x110>
      {
        MSC_BOT_SendCSW(pdev, USBD_CSW_CMD_PASSED);
9000c152:	2100      	movs	r1, #0
9000c154:	6878      	ldr	r0, [r7, #4]
9000c156:	f000 f845 	bl	9000c1e4 <MSC_BOT_SendCSW>
      if (hmsc->bot_data_length > 0U)
9000c15a:	e006      	b.n	9000c16a <MSC_BOT_CBW_Decode+0x11e>
      }
      else
      {
        MSC_BOT_Abort(pdev);
9000c15c:	6878      	ldr	r0, [r7, #4]
9000c15e:	f000 f87b 	bl	9000c258 <MSC_BOT_Abort>
      if (hmsc->bot_data_length > 0U)
9000c162:	e002      	b.n	9000c16a <MSC_BOT_CBW_Decode+0x11e>
    return;
9000c164:	bf00      	nop
9000c166:	e000      	b.n	9000c16a <MSC_BOT_CBW_Decode+0x11e>
      }
    }
    else
    {
      return;
9000c168:	bf00      	nop
    }
  }
}
9000c16a:	3710      	adds	r7, #16
9000c16c:	46bd      	mov	sp, r7
9000c16e:	bd80      	pop	{r7, pc}
9000c170:	240000e3 	.word	0x240000e3
9000c174:	43425355 	.word	0x43425355

9000c178 <MSC_BOT_SendData>:
  * @param  buf: pointer to data buffer
  * @param  len: Data Length
  * @retval None
  */
static void  MSC_BOT_SendData(USBD_HandleTypeDef *pdev, uint8_t *pbuf, uint32_t len)
{
9000c178:	b580      	push	{r7, lr}
9000c17a:	b086      	sub	sp, #24
9000c17c:	af00      	add	r7, sp, #0
9000c17e:	60f8      	str	r0, [r7, #12]
9000c180:	60b9      	str	r1, [r7, #8]
9000c182:	607a      	str	r2, [r7, #4]
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000c184:	68fb      	ldr	r3, [r7, #12]
9000c186:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000c18a:	68fb      	ldr	r3, [r7, #12]
9000c18c:	32b0      	adds	r2, #176	@ 0xb0
9000c18e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000c192:	617b      	str	r3, [r7, #20]
  /* Get the Endpoints addresses allocated for this class instance */
  MSCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  MSCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (hmsc == NULL)
9000c194:	697b      	ldr	r3, [r7, #20]
9000c196:	2b00      	cmp	r3, #0
9000c198:	d01e      	beq.n	9000c1d8 <MSC_BOT_SendData+0x60>
  {
    return;
  }

  length = MIN(hmsc->cbw.dDataLength, len);
9000c19a:	697b      	ldr	r3, [r7, #20]
9000c19c:	f8d3 3218 	ldr.w	r3, [r3, #536]	@ 0x218
9000c1a0:	687a      	ldr	r2, [r7, #4]
9000c1a2:	4293      	cmp	r3, r2
9000c1a4:	bf28      	it	cs
9000c1a6:	4613      	movcs	r3, r2
9000c1a8:	613b      	str	r3, [r7, #16]

  hmsc->csw.dDataResidue -= len;
9000c1aa:	697b      	ldr	r3, [r7, #20]
9000c1ac:	f8d3 2238 	ldr.w	r2, [r3, #568]	@ 0x238
9000c1b0:	687b      	ldr	r3, [r7, #4]
9000c1b2:	1ad2      	subs	r2, r2, r3
9000c1b4:	697b      	ldr	r3, [r7, #20]
9000c1b6:	f8c3 2238 	str.w	r2, [r3, #568]	@ 0x238
  hmsc->csw.bStatus = USBD_CSW_CMD_PASSED;
9000c1ba:	697b      	ldr	r3, [r7, #20]
9000c1bc:	2200      	movs	r2, #0
9000c1be:	f883 223c 	strb.w	r2, [r3, #572]	@ 0x23c
  hmsc->bot_state = USBD_BOT_SEND_DATA;
9000c1c2:	697b      	ldr	r3, [r7, #20]
9000c1c4:	2204      	movs	r2, #4
9000c1c6:	721a      	strb	r2, [r3, #8]

  (void)USBD_LL_Transmit(pdev, MSCInEpAdd, pbuf, length);
9000c1c8:	4b05      	ldr	r3, [pc, #20]	@ (9000c1e0 <MSC_BOT_SendData+0x68>)
9000c1ca:	7819      	ldrb	r1, [r3, #0]
9000c1cc:	693b      	ldr	r3, [r7, #16]
9000c1ce:	68ba      	ldr	r2, [r7, #8]
9000c1d0:	68f8      	ldr	r0, [r7, #12]
9000c1d2:	f7f5 f827 	bl	90001224 <USBD_LL_Transmit>
9000c1d6:	e000      	b.n	9000c1da <MSC_BOT_SendData+0x62>
    return;
9000c1d8:	bf00      	nop
}
9000c1da:	3718      	adds	r7, #24
9000c1dc:	46bd      	mov	sp, r7
9000c1de:	bd80      	pop	{r7, pc}
9000c1e0:	240000e2 	.word	0x240000e2

9000c1e4 <MSC_BOT_SendCSW>:
  * @param  pdev: device instance
  * @param  status : CSW status
  * @retval None
  */
void  MSC_BOT_SendCSW(USBD_HandleTypeDef *pdev, uint8_t CSW_Status)
{
9000c1e4:	b580      	push	{r7, lr}
9000c1e6:	b084      	sub	sp, #16
9000c1e8:	af00      	add	r7, sp, #0
9000c1ea:	6078      	str	r0, [r7, #4]
9000c1ec:	460b      	mov	r3, r1
9000c1ee:	70fb      	strb	r3, [r7, #3]
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000c1f0:	687b      	ldr	r3, [r7, #4]
9000c1f2:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000c1f6:	687b      	ldr	r3, [r7, #4]
9000c1f8:	32b0      	adds	r2, #176	@ 0xb0
9000c1fa:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000c1fe:	60fb      	str	r3, [r7, #12]
  /* Get the Endpoints addresses allocated for this class instance */
  MSCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  MSCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (hmsc == NULL)
9000c200:	68fb      	ldr	r3, [r7, #12]
9000c202:	2b00      	cmp	r3, #0
9000c204:	d01d      	beq.n	9000c242 <MSC_BOT_SendCSW+0x5e>
  {
    return;
  }

  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
9000c206:	68fb      	ldr	r3, [r7, #12]
9000c208:	4a10      	ldr	r2, [pc, #64]	@ (9000c24c <MSC_BOT_SendCSW+0x68>)
9000c20a:	f8c3 2230 	str.w	r2, [r3, #560]	@ 0x230
  hmsc->csw.bStatus = CSW_Status;
9000c20e:	68fb      	ldr	r3, [r7, #12]
9000c210:	78fa      	ldrb	r2, [r7, #3]
9000c212:	f883 223c 	strb.w	r2, [r3, #572]	@ 0x23c
  hmsc->bot_state = USBD_BOT_IDLE;
9000c216:	68fb      	ldr	r3, [r7, #12]
9000c218:	2200      	movs	r2, #0
9000c21a:	721a      	strb	r2, [r3, #8]

  (void)USBD_LL_Transmit(pdev, MSCInEpAdd, (uint8_t *)&hmsc->csw,
9000c21c:	4b0c      	ldr	r3, [pc, #48]	@ (9000c250 <MSC_BOT_SendCSW+0x6c>)
9000c21e:	7819      	ldrb	r1, [r3, #0]
9000c220:	68fb      	ldr	r3, [r7, #12]
9000c222:	f503 720c 	add.w	r2, r3, #560	@ 0x230
9000c226:	230d      	movs	r3, #13
9000c228:	6878      	ldr	r0, [r7, #4]
9000c22a:	f7f4 fffb 	bl	90001224 <USBD_LL_Transmit>
                         USBD_BOT_CSW_LENGTH);

  /* Prepare EP to Receive next Cmd */
  (void)USBD_LL_PrepareReceive(pdev, MSCOutEpAdd, (uint8_t *)&hmsc->cbw,
9000c22e:	4b09      	ldr	r3, [pc, #36]	@ (9000c254 <MSC_BOT_SendCSW+0x70>)
9000c230:	7819      	ldrb	r1, [r3, #0]
9000c232:	68fb      	ldr	r3, [r7, #12]
9000c234:	f503 7204 	add.w	r2, r3, #528	@ 0x210
9000c238:	231f      	movs	r3, #31
9000c23a:	6878      	ldr	r0, [r7, #4]
9000c23c:	f7f5 f813 	bl	90001266 <USBD_LL_PrepareReceive>
9000c240:	e000      	b.n	9000c244 <MSC_BOT_SendCSW+0x60>
    return;
9000c242:	bf00      	nop
                               USBD_BOT_CBW_LENGTH);
}
9000c244:	3710      	adds	r7, #16
9000c246:	46bd      	mov	sp, r7
9000c248:	bd80      	pop	{r7, pc}
9000c24a:	bf00      	nop
9000c24c:	53425355 	.word	0x53425355
9000c250:	240000e2 	.word	0x240000e2
9000c254:	240000e3 	.word	0x240000e3

9000c258 <MSC_BOT_Abort>:
  * @param  pdev: device instance
  * @retval status
  */

static void  MSC_BOT_Abort(USBD_HandleTypeDef *pdev)
{
9000c258:	b580      	push	{r7, lr}
9000c25a:	b084      	sub	sp, #16
9000c25c:	af00      	add	r7, sp, #0
9000c25e:	6078      	str	r0, [r7, #4]
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000c260:	687b      	ldr	r3, [r7, #4]
9000c262:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000c266:	687b      	ldr	r3, [r7, #4]
9000c268:	32b0      	adds	r2, #176	@ 0xb0
9000c26a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000c26e:	60fb      	str	r3, [r7, #12]
  /* Get the Endpoints addresses allocated for this class instance */
  MSCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  MSCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (hmsc == NULL)
9000c270:	68fb      	ldr	r3, [r7, #12]
9000c272:	2b00      	cmp	r3, #0
9000c274:	d02a      	beq.n	9000c2cc <MSC_BOT_Abort+0x74>
  {
    return;
  }

  if ((hmsc->cbw.bmFlags == 0U) &&
9000c276:	68fb      	ldr	r3, [r7, #12]
9000c278:	f893 321c 	ldrb.w	r3, [r3, #540]	@ 0x21c
9000c27c:	2b00      	cmp	r3, #0
9000c27e:	d10e      	bne.n	9000c29e <MSC_BOT_Abort+0x46>
      (hmsc->cbw.dDataLength != 0U) &&
9000c280:	68fb      	ldr	r3, [r7, #12]
9000c282:	f8d3 3218 	ldr.w	r3, [r3, #536]	@ 0x218
  if ((hmsc->cbw.bmFlags == 0U) &&
9000c286:	2b00      	cmp	r3, #0
9000c288:	d009      	beq.n	9000c29e <MSC_BOT_Abort+0x46>
      (hmsc->bot_status == USBD_BOT_STATUS_NORMAL))
9000c28a:	68fb      	ldr	r3, [r7, #12]
9000c28c:	7a5b      	ldrb	r3, [r3, #9]
      (hmsc->cbw.dDataLength != 0U) &&
9000c28e:	2b00      	cmp	r3, #0
9000c290:	d105      	bne.n	9000c29e <MSC_BOT_Abort+0x46>
  {
    (void)USBD_LL_StallEP(pdev, MSCOutEpAdd);
9000c292:	4b10      	ldr	r3, [pc, #64]	@ (9000c2d4 <MSC_BOT_Abort+0x7c>)
9000c294:	781b      	ldrb	r3, [r3, #0]
9000c296:	4619      	mov	r1, r3
9000c298:	6878      	ldr	r0, [r7, #4]
9000c29a:	f7f4 ff3a 	bl	90001112 <USBD_LL_StallEP>
  }

  (void)USBD_LL_StallEP(pdev, MSCInEpAdd);
9000c29e:	4b0e      	ldr	r3, [pc, #56]	@ (9000c2d8 <MSC_BOT_Abort+0x80>)
9000c2a0:	781b      	ldrb	r3, [r3, #0]
9000c2a2:	4619      	mov	r1, r3
9000c2a4:	6878      	ldr	r0, [r7, #4]
9000c2a6:	f7f4 ff34 	bl	90001112 <USBD_LL_StallEP>

  if (hmsc->bot_status == USBD_BOT_STATUS_ERROR)
9000c2aa:	68fb      	ldr	r3, [r7, #12]
9000c2ac:	7a5b      	ldrb	r3, [r3, #9]
9000c2ae:	2b02      	cmp	r3, #2
9000c2b0:	d10d      	bne.n	9000c2ce <MSC_BOT_Abort+0x76>
  {
    (void)USBD_LL_StallEP(pdev, MSCInEpAdd);
9000c2b2:	4b09      	ldr	r3, [pc, #36]	@ (9000c2d8 <MSC_BOT_Abort+0x80>)
9000c2b4:	781b      	ldrb	r3, [r3, #0]
9000c2b6:	4619      	mov	r1, r3
9000c2b8:	6878      	ldr	r0, [r7, #4]
9000c2ba:	f7f4 ff2a 	bl	90001112 <USBD_LL_StallEP>
    (void)USBD_LL_StallEP(pdev, MSCOutEpAdd);
9000c2be:	4b05      	ldr	r3, [pc, #20]	@ (9000c2d4 <MSC_BOT_Abort+0x7c>)
9000c2c0:	781b      	ldrb	r3, [r3, #0]
9000c2c2:	4619      	mov	r1, r3
9000c2c4:	6878      	ldr	r0, [r7, #4]
9000c2c6:	f7f4 ff24 	bl	90001112 <USBD_LL_StallEP>
9000c2ca:	e000      	b.n	9000c2ce <MSC_BOT_Abort+0x76>
    return;
9000c2cc:	bf00      	nop
  }
}
9000c2ce:	3710      	adds	r7, #16
9000c2d0:	46bd      	mov	sp, r7
9000c2d2:	bd80      	pop	{r7, pc}
9000c2d4:	240000e3 	.word	0x240000e3
9000c2d8:	240000e2 	.word	0x240000e2

9000c2dc <MSC_BOT_CplClrFeature>:
  * @param  epnum: endpoint index
  * @retval None
  */

void  MSC_BOT_CplClrFeature(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
9000c2dc:	b580      	push	{r7, lr}
9000c2de:	b084      	sub	sp, #16
9000c2e0:	af00      	add	r7, sp, #0
9000c2e2:	6078      	str	r0, [r7, #4]
9000c2e4:	460b      	mov	r3, r1
9000c2e6:	70fb      	strb	r3, [r7, #3]
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000c2e8:	687b      	ldr	r3, [r7, #4]
9000c2ea:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000c2ee:	687b      	ldr	r3, [r7, #4]
9000c2f0:	32b0      	adds	r2, #176	@ 0xb0
9000c2f2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000c2f6:	60fb      	str	r3, [r7, #12]
  /* Get the Endpoints addresses allocated for this class instance */
  MSCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  MSCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (hmsc == NULL)
9000c2f8:	68fb      	ldr	r3, [r7, #12]
9000c2fa:	2b00      	cmp	r3, #0
9000c2fc:	d01d      	beq.n	9000c33a <MSC_BOT_CplClrFeature+0x5e>
  {
    return;
  }

  if (hmsc->bot_status == USBD_BOT_STATUS_ERROR) /* Bad CBW Signature */
9000c2fe:	68fb      	ldr	r3, [r7, #12]
9000c300:	7a5b      	ldrb	r3, [r3, #9]
9000c302:	2b02      	cmp	r3, #2
9000c304:	d10c      	bne.n	9000c320 <MSC_BOT_CplClrFeature+0x44>
  {
    (void)USBD_LL_StallEP(pdev, MSCInEpAdd);
9000c306:	4b10      	ldr	r3, [pc, #64]	@ (9000c348 <MSC_BOT_CplClrFeature+0x6c>)
9000c308:	781b      	ldrb	r3, [r3, #0]
9000c30a:	4619      	mov	r1, r3
9000c30c:	6878      	ldr	r0, [r7, #4]
9000c30e:	f7f4 ff00 	bl	90001112 <USBD_LL_StallEP>
    (void)USBD_LL_StallEP(pdev, MSCOutEpAdd);
9000c312:	4b0e      	ldr	r3, [pc, #56]	@ (9000c34c <MSC_BOT_CplClrFeature+0x70>)
9000c314:	781b      	ldrb	r3, [r3, #0]
9000c316:	4619      	mov	r1, r3
9000c318:	6878      	ldr	r0, [r7, #4]
9000c31a:	f7f4 fefa 	bl	90001112 <USBD_LL_StallEP>
9000c31e:	e00f      	b.n	9000c340 <MSC_BOT_CplClrFeature+0x64>
  }
  else if (((epnum & 0x80U) == 0x80U) && (hmsc->bot_status != USBD_BOT_STATUS_RECOVERY))
9000c320:	f997 3003 	ldrsb.w	r3, [r7, #3]
9000c324:	2b00      	cmp	r3, #0
9000c326:	da0a      	bge.n	9000c33e <MSC_BOT_CplClrFeature+0x62>
9000c328:	68fb      	ldr	r3, [r7, #12]
9000c32a:	7a5b      	ldrb	r3, [r3, #9]
9000c32c:	2b01      	cmp	r3, #1
9000c32e:	d006      	beq.n	9000c33e <MSC_BOT_CplClrFeature+0x62>
  {
    MSC_BOT_SendCSW(pdev, USBD_CSW_CMD_FAILED);
9000c330:	2101      	movs	r1, #1
9000c332:	6878      	ldr	r0, [r7, #4]
9000c334:	f7ff ff56 	bl	9000c1e4 <MSC_BOT_SendCSW>
9000c338:	e002      	b.n	9000c340 <MSC_BOT_CplClrFeature+0x64>
    return;
9000c33a:	bf00      	nop
9000c33c:	e000      	b.n	9000c340 <MSC_BOT_CplClrFeature+0x64>
  }
  else
  {
    return;
9000c33e:	bf00      	nop
  }
}
9000c340:	3710      	adds	r7, #16
9000c342:	46bd      	mov	sp, r7
9000c344:	bd80      	pop	{r7, pc}
9000c346:	bf00      	nop
9000c348:	240000e2 	.word	0x240000e2
9000c34c:	240000e3 	.word	0x240000e3

9000c350 <SCSI_ProcessCmd>:
  * @param  lun: Logical unit number
  * @param  params: Command parameters
  * @retval status
  */
int8_t SCSI_ProcessCmd(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t *cmd)
{
9000c350:	b580      	push	{r7, lr}
9000c352:	b086      	sub	sp, #24
9000c354:	af00      	add	r7, sp, #0
9000c356:	60f8      	str	r0, [r7, #12]
9000c358:	460b      	mov	r3, r1
9000c35a:	607a      	str	r2, [r7, #4]
9000c35c:	72fb      	strb	r3, [r7, #11]
  int8_t ret;
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000c35e:	68fb      	ldr	r3, [r7, #12]
9000c360:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000c364:	68fb      	ldr	r3, [r7, #12]
9000c366:	32b0      	adds	r2, #176	@ 0xb0
9000c368:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000c36c:	613b      	str	r3, [r7, #16]

  if (hmsc == NULL)
9000c36e:	693b      	ldr	r3, [r7, #16]
9000c370:	2b00      	cmp	r3, #0
9000c372:	d102      	bne.n	9000c37a <SCSI_ProcessCmd+0x2a>
  {
    return -1;
9000c374:	f04f 33ff 	mov.w	r3, #4294967295
9000c378:	e18f      	b.n	9000c69a <SCSI_ProcessCmd+0x34a>
  }

  switch (cmd[0])
9000c37a:	687b      	ldr	r3, [r7, #4]
9000c37c:	781b      	ldrb	r3, [r3, #0]
9000c37e:	2b5a      	cmp	r3, #90	@ 0x5a
9000c380:	f300 80e0 	bgt.w	9000c544 <SCSI_ProcessCmd+0x1f4>
9000c384:	2b00      	cmp	r3, #0
9000c386:	da21      	bge.n	9000c3cc <SCSI_ProcessCmd+0x7c>
9000c388:	e17c      	b.n	9000c684 <SCSI_ProcessCmd+0x334>
9000c38a:	3b9e      	subs	r3, #158	@ 0x9e
9000c38c:	2b0c      	cmp	r3, #12
9000c38e:	f200 8179 	bhi.w	9000c684 <SCSI_ProcessCmd+0x334>
9000c392:	a201      	add	r2, pc, #4	@ (adr r2, 9000c398 <SCSI_ProcessCmd+0x48>)
9000c394:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
9000c398:	9000c5f5 	.word	0x9000c5f5
9000c39c:	9000c685 	.word	0x9000c685
9000c3a0:	9000c661 	.word	0x9000c661
9000c3a4:	9000c685 	.word	0x9000c685
9000c3a8:	9000c685 	.word	0x9000c685
9000c3ac:	9000c685 	.word	0x9000c685
9000c3b0:	9000c685 	.word	0x9000c685
9000c3b4:	9000c685 	.word	0x9000c685
9000c3b8:	9000c685 	.word	0x9000c685
9000c3bc:	9000c685 	.word	0x9000c685
9000c3c0:	9000c619 	.word	0x9000c619
9000c3c4:	9000c685 	.word	0x9000c685
9000c3c8:	9000c63d 	.word	0x9000c63d
9000c3cc:	2b5a      	cmp	r3, #90	@ 0x5a
9000c3ce:	f200 8159 	bhi.w	9000c684 <SCSI_ProcessCmd+0x334>
9000c3d2:	a201      	add	r2, pc, #4	@ (adr r2, 9000c3d8 <SCSI_ProcessCmd+0x88>)
9000c3d4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
9000c3d8:	9000c553 	.word	0x9000c553
9000c3dc:	9000c685 	.word	0x9000c685
9000c3e0:	9000c685 	.word	0x9000c685
9000c3e4:	9000c565 	.word	0x9000c565
9000c3e8:	9000c685 	.word	0x9000c685
9000c3ec:	9000c685 	.word	0x9000c685
9000c3f0:	9000c685 	.word	0x9000c685
9000c3f4:	9000c685 	.word	0x9000c685
9000c3f8:	9000c685 	.word	0x9000c685
9000c3fc:	9000c685 	.word	0x9000c685
9000c400:	9000c685 	.word	0x9000c685
9000c404:	9000c685 	.word	0x9000c685
9000c408:	9000c685 	.word	0x9000c685
9000c40c:	9000c685 	.word	0x9000c685
9000c410:	9000c685 	.word	0x9000c685
9000c414:	9000c685 	.word	0x9000c685
9000c418:	9000c685 	.word	0x9000c685
9000c41c:	9000c685 	.word	0x9000c685
9000c420:	9000c577 	.word	0x9000c577
9000c424:	9000c685 	.word	0x9000c685
9000c428:	9000c685 	.word	0x9000c685
9000c42c:	9000c685 	.word	0x9000c685
9000c430:	9000c685 	.word	0x9000c685
9000c434:	9000c685 	.word	0x9000c685
9000c438:	9000c685 	.word	0x9000c685
9000c43c:	9000c685 	.word	0x9000c685
9000c440:	9000c5ad 	.word	0x9000c5ad
9000c444:	9000c589 	.word	0x9000c589
9000c448:	9000c673 	.word	0x9000c673
9000c44c:	9000c685 	.word	0x9000c685
9000c450:	9000c59b 	.word	0x9000c59b
9000c454:	9000c685 	.word	0x9000c685
9000c458:	9000c685 	.word	0x9000c685
9000c45c:	9000c685 	.word	0x9000c685
9000c460:	9000c685 	.word	0x9000c685
9000c464:	9000c5d1 	.word	0x9000c5d1
9000c468:	9000c685 	.word	0x9000c685
9000c46c:	9000c5e3 	.word	0x9000c5e3
9000c470:	9000c685 	.word	0x9000c685
9000c474:	9000c685 	.word	0x9000c685
9000c478:	9000c607 	.word	0x9000c607
9000c47c:	9000c685 	.word	0x9000c685
9000c480:	9000c62b 	.word	0x9000c62b
9000c484:	9000c685 	.word	0x9000c685
9000c488:	9000c685 	.word	0x9000c685
9000c48c:	9000c685 	.word	0x9000c685
9000c490:	9000c685 	.word	0x9000c685
9000c494:	9000c64f 	.word	0x9000c64f
9000c498:	9000c685 	.word	0x9000c685
9000c49c:	9000c685 	.word	0x9000c685
9000c4a0:	9000c685 	.word	0x9000c685
9000c4a4:	9000c685 	.word	0x9000c685
9000c4a8:	9000c685 	.word	0x9000c685
9000c4ac:	9000c685 	.word	0x9000c685
9000c4b0:	9000c685 	.word	0x9000c685
9000c4b4:	9000c685 	.word	0x9000c685
9000c4b8:	9000c685 	.word	0x9000c685
9000c4bc:	9000c685 	.word	0x9000c685
9000c4c0:	9000c685 	.word	0x9000c685
9000c4c4:	9000c685 	.word	0x9000c685
9000c4c8:	9000c685 	.word	0x9000c685
9000c4cc:	9000c685 	.word	0x9000c685
9000c4d0:	9000c685 	.word	0x9000c685
9000c4d4:	9000c685 	.word	0x9000c685
9000c4d8:	9000c685 	.word	0x9000c685
9000c4dc:	9000c685 	.word	0x9000c685
9000c4e0:	9000c685 	.word	0x9000c685
9000c4e4:	9000c685 	.word	0x9000c685
9000c4e8:	9000c685 	.word	0x9000c685
9000c4ec:	9000c685 	.word	0x9000c685
9000c4f0:	9000c685 	.word	0x9000c685
9000c4f4:	9000c685 	.word	0x9000c685
9000c4f8:	9000c685 	.word	0x9000c685
9000c4fc:	9000c685 	.word	0x9000c685
9000c500:	9000c685 	.word	0x9000c685
9000c504:	9000c685 	.word	0x9000c685
9000c508:	9000c685 	.word	0x9000c685
9000c50c:	9000c685 	.word	0x9000c685
9000c510:	9000c685 	.word	0x9000c685
9000c514:	9000c685 	.word	0x9000c685
9000c518:	9000c685 	.word	0x9000c685
9000c51c:	9000c685 	.word	0x9000c685
9000c520:	9000c685 	.word	0x9000c685
9000c524:	9000c685 	.word	0x9000c685
9000c528:	9000c685 	.word	0x9000c685
9000c52c:	9000c685 	.word	0x9000c685
9000c530:	9000c685 	.word	0x9000c685
9000c534:	9000c685 	.word	0x9000c685
9000c538:	9000c685 	.word	0x9000c685
9000c53c:	9000c685 	.word	0x9000c685
9000c540:	9000c5bf 	.word	0x9000c5bf
9000c544:	2baa      	cmp	r3, #170	@ 0xaa
9000c546:	f300 809d 	bgt.w	9000c684 <SCSI_ProcessCmd+0x334>
9000c54a:	2b9e      	cmp	r3, #158	@ 0x9e
9000c54c:	f6bf af1d 	bge.w	9000c38a <SCSI_ProcessCmd+0x3a>
9000c550:	e098      	b.n	9000c684 <SCSI_ProcessCmd+0x334>
  {
    case SCSI_TEST_UNIT_READY:
      ret = SCSI_TestUnitReady(pdev, lun, cmd);
9000c552:	7afb      	ldrb	r3, [r7, #11]
9000c554:	687a      	ldr	r2, [r7, #4]
9000c556:	4619      	mov	r1, r3
9000c558:	68f8      	ldr	r0, [r7, #12]
9000c55a:	f000 f8a3 	bl	9000c6a4 <SCSI_TestUnitReady>
9000c55e:	4603      	mov	r3, r0
9000c560:	75fb      	strb	r3, [r7, #23]
      break;
9000c562:	e098      	b.n	9000c696 <SCSI_ProcessCmd+0x346>

    case SCSI_REQUEST_SENSE:
      ret = SCSI_RequestSense(pdev, lun, cmd);
9000c564:	7afb      	ldrb	r3, [r7, #11]
9000c566:	687a      	ldr	r2, [r7, #4]
9000c568:	4619      	mov	r1, r3
9000c56a:	68f8      	ldr	r0, [r7, #12]
9000c56c:	f000 fbb4 	bl	9000ccd8 <SCSI_RequestSense>
9000c570:	4603      	mov	r3, r0
9000c572:	75fb      	strb	r3, [r7, #23]
      break;
9000c574:	e08f      	b.n	9000c696 <SCSI_ProcessCmd+0x346>

    case SCSI_INQUIRY:
      ret = SCSI_Inquiry(pdev, lun, cmd);
9000c576:	7afb      	ldrb	r3, [r7, #11]
9000c578:	687a      	ldr	r2, [r7, #4]
9000c57a:	4619      	mov	r1, r3
9000c57c:	68f8      	ldr	r0, [r7, #12]
9000c57e:	f000 f8eb 	bl	9000c758 <SCSI_Inquiry>
9000c582:	4603      	mov	r3, r0
9000c584:	75fb      	strb	r3, [r7, #23]
      break;
9000c586:	e086      	b.n	9000c696 <SCSI_ProcessCmd+0x346>

    case SCSI_START_STOP_UNIT:
      ret = SCSI_StartStopUnit(pdev, lun, cmd);
9000c588:	7afb      	ldrb	r3, [r7, #11]
9000c58a:	687a      	ldr	r2, [r7, #4]
9000c58c:	4619      	mov	r1, r3
9000c58e:	68f8      	ldr	r0, [r7, #12]
9000c590:	f000 fc70 	bl	9000ce74 <SCSI_StartStopUnit>
9000c594:	4603      	mov	r3, r0
9000c596:	75fb      	strb	r3, [r7, #23]
      break;
9000c598:	e07d      	b.n	9000c696 <SCSI_ProcessCmd+0x346>

    case SCSI_ALLOW_MEDIUM_REMOVAL:
      ret = SCSI_AllowPreventRemovable(pdev, lun, cmd);
9000c59a:	7afb      	ldrb	r3, [r7, #11]
9000c59c:	687a      	ldr	r2, [r7, #4]
9000c59e:	4619      	mov	r1, r3
9000c5a0:	68f8      	ldr	r0, [r7, #12]
9000c5a2:	f000 fcbc 	bl	9000cf1e <SCSI_AllowPreventRemovable>
9000c5a6:	4603      	mov	r3, r0
9000c5a8:	75fb      	strb	r3, [r7, #23]
      break;
9000c5aa:	e074      	b.n	9000c696 <SCSI_ProcessCmd+0x346>

    case SCSI_MODE_SENSE6:
      ret = SCSI_ModeSense6(pdev, lun, cmd);
9000c5ac:	7afb      	ldrb	r3, [r7, #11]
9000c5ae:	687a      	ldr	r2, [r7, #4]
9000c5b0:	4619      	mov	r1, r3
9000c5b2:	68f8      	ldr	r0, [r7, #12]
9000c5b4:	f000 faf2 	bl	9000cb9c <SCSI_ModeSense6>
9000c5b8:	4603      	mov	r3, r0
9000c5ba:	75fb      	strb	r3, [r7, #23]
      break;
9000c5bc:	e06b      	b.n	9000c696 <SCSI_ProcessCmd+0x346>

    case SCSI_MODE_SENSE10:
      ret = SCSI_ModeSense10(pdev, lun, cmd);
9000c5be:	7afb      	ldrb	r3, [r7, #11]
9000c5c0:	687a      	ldr	r2, [r7, #4]
9000c5c2:	4619      	mov	r1, r3
9000c5c4:	68f8      	ldr	r0, [r7, #12]
9000c5c6:	f000 fb39 	bl	9000cc3c <SCSI_ModeSense10>
9000c5ca:	4603      	mov	r3, r0
9000c5cc:	75fb      	strb	r3, [r7, #23]
      break;
9000c5ce:	e062      	b.n	9000c696 <SCSI_ProcessCmd+0x346>

    case SCSI_READ_FORMAT_CAPACITIES:
      ret = SCSI_ReadFormatCapacity(pdev, lun, cmd);
9000c5d0:	7afb      	ldrb	r3, [r7, #11]
9000c5d2:	687a      	ldr	r2, [r7, #4]
9000c5d4:	4619      	mov	r1, r3
9000c5d6:	68f8      	ldr	r0, [r7, #12]
9000c5d8:	f000 fa64 	bl	9000caa4 <SCSI_ReadFormatCapacity>
9000c5dc:	4603      	mov	r3, r0
9000c5de:	75fb      	strb	r3, [r7, #23]
      break;
9000c5e0:	e059      	b.n	9000c696 <SCSI_ProcessCmd+0x346>

    case SCSI_READ_CAPACITY10:
      ret = SCSI_ReadCapacity10(pdev, lun, cmd);
9000c5e2:	7afb      	ldrb	r3, [r7, #11]
9000c5e4:	687a      	ldr	r2, [r7, #4]
9000c5e6:	4619      	mov	r1, r3
9000c5e8:	68f8      	ldr	r0, [r7, #12]
9000c5ea:	f000 f931 	bl	9000c850 <SCSI_ReadCapacity10>
9000c5ee:	4603      	mov	r3, r0
9000c5f0:	75fb      	strb	r3, [r7, #23]
      break;
9000c5f2:	e050      	b.n	9000c696 <SCSI_ProcessCmd+0x346>

    case SCSI_READ_CAPACITY16:
      ret = SCSI_ReadCapacity16(pdev, lun, cmd);
9000c5f4:	7afb      	ldrb	r3, [r7, #11]
9000c5f6:	687a      	ldr	r2, [r7, #4]
9000c5f8:	4619      	mov	r1, r3
9000c5fa:	68f8      	ldr	r0, [r7, #12]
9000c5fc:	f000 f9a2 	bl	9000c944 <SCSI_ReadCapacity16>
9000c600:	4603      	mov	r3, r0
9000c602:	75fb      	strb	r3, [r7, #23]
      break;
9000c604:	e047      	b.n	9000c696 <SCSI_ProcessCmd+0x346>

    case SCSI_READ10:
      ret = SCSI_Read10(pdev, lun, cmd);
9000c606:	7afb      	ldrb	r3, [r7, #11]
9000c608:	687a      	ldr	r2, [r7, #4]
9000c60a:	4619      	mov	r1, r3
9000c60c:	68f8      	ldr	r0, [r7, #12]
9000c60e:	f000 fcb3 	bl	9000cf78 <SCSI_Read10>
9000c612:	4603      	mov	r3, r0
9000c614:	75fb      	strb	r3, [r7, #23]
      break;
9000c616:	e03e      	b.n	9000c696 <SCSI_ProcessCmd+0x346>

    case SCSI_READ12:
      ret = SCSI_Read12(pdev, lun, cmd);
9000c618:	7afb      	ldrb	r3, [r7, #11]
9000c61a:	687a      	ldr	r2, [r7, #4]
9000c61c:	4619      	mov	r1, r3
9000c61e:	68f8      	ldr	r0, [r7, #12]
9000c620:	f000 fd54 	bl	9000d0cc <SCSI_Read12>
9000c624:	4603      	mov	r3, r0
9000c626:	75fb      	strb	r3, [r7, #23]
      break;
9000c628:	e035      	b.n	9000c696 <SCSI_ProcessCmd+0x346>

    case SCSI_WRITE10:
      ret = SCSI_Write10(pdev, lun, cmd);
9000c62a:	7afb      	ldrb	r3, [r7, #11]
9000c62c:	687a      	ldr	r2, [r7, #4]
9000c62e:	4619      	mov	r1, r3
9000c630:	68f8      	ldr	r0, [r7, #12]
9000c632:	f000 fe01 	bl	9000d238 <SCSI_Write10>
9000c636:	4603      	mov	r3, r0
9000c638:	75fb      	strb	r3, [r7, #23]
      break;
9000c63a:	e02c      	b.n	9000c696 <SCSI_ProcessCmd+0x346>

    case SCSI_WRITE12:
      ret = SCSI_Write12(pdev, lun, cmd);
9000c63c:	7afb      	ldrb	r3, [r7, #11]
9000c63e:	687a      	ldr	r2, [r7, #4]
9000c640:	4619      	mov	r1, r3
9000c642:	68f8      	ldr	r0, [r7, #12]
9000c644:	f000 fed0 	bl	9000d3e8 <SCSI_Write12>
9000c648:	4603      	mov	r3, r0
9000c64a:	75fb      	strb	r3, [r7, #23]
      break;
9000c64c:	e023      	b.n	9000c696 <SCSI_ProcessCmd+0x346>

    case SCSI_VERIFY10:
      ret = SCSI_Verify10(pdev, lun, cmd);
9000c64e:	7afb      	ldrb	r3, [r7, #11]
9000c650:	687a      	ldr	r2, [r7, #4]
9000c652:	4619      	mov	r1, r3
9000c654:	68f8      	ldr	r0, [r7, #12]
9000c656:	f000 ffaf 	bl	9000d5b8 <SCSI_Verify10>
9000c65a:	4603      	mov	r3, r0
9000c65c:	75fb      	strb	r3, [r7, #23]
      break;
9000c65e:	e01a      	b.n	9000c696 <SCSI_ProcessCmd+0x346>

    case SCSI_REPORT_LUNS:
      ret = SCSI_ReportLuns(pdev, lun, cmd);
9000c660:	7afb      	ldrb	r3, [r7, #11]
9000c662:	687a      	ldr	r2, [r7, #4]
9000c664:	4619      	mov	r1, r3
9000c666:	68f8      	ldr	r0, [r7, #12]
9000c668:	f000 ffe8 	bl	9000d63c <SCSI_ReportLuns>
9000c66c:	4603      	mov	r3, r0
9000c66e:	75fb      	strb	r3, [r7, #23]
      break;
9000c670:	e011      	b.n	9000c696 <SCSI_ProcessCmd+0x346>

    case SCSI_RECEIVE_DIAGNOSTIC_RESULTS:
      ret = SCSI_ReceiveDiagnosticResults(pdev, lun, cmd);
9000c672:	7afb      	ldrb	r3, [r7, #11]
9000c674:	687a      	ldr	r2, [r7, #4]
9000c676:	4619      	mov	r1, r3
9000c678:	68f8      	ldr	r0, [r7, #12]
9000c67a:	f001 f833 	bl	9000d6e4 <SCSI_ReceiveDiagnosticResults>
9000c67e:	4603      	mov	r3, r0
9000c680:	75fb      	strb	r3, [r7, #23]
      break;
9000c682:	e008      	b.n	9000c696 <SCSI_ProcessCmd+0x346>

    default:
      SCSI_SenseCode(pdev, lun, ILLEGAL_REQUEST, INVALID_CDB);
9000c684:	7af9      	ldrb	r1, [r7, #11]
9000c686:	2320      	movs	r3, #32
9000c688:	2205      	movs	r2, #5
9000c68a:	68f8      	ldr	r0, [r7, #12]
9000c68c:	f000 fba7 	bl	9000cdde <SCSI_SenseCode>
      ret = -1;
9000c690:	23ff      	movs	r3, #255	@ 0xff
9000c692:	75fb      	strb	r3, [r7, #23]
      break;
9000c694:	bf00      	nop
  }

  return ret;
9000c696:	f997 3017 	ldrsb.w	r3, [r7, #23]
}
9000c69a:	4618      	mov	r0, r3
9000c69c:	3718      	adds	r7, #24
9000c69e:	46bd      	mov	sp, r7
9000c6a0:	bd80      	pop	{r7, pc}
9000c6a2:	bf00      	nop

9000c6a4 <SCSI_TestUnitReady>:
  * @param  lun: Logical unit number
  * @param  params: Command parameters
  * @retval status
  */
static int8_t SCSI_TestUnitReady(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t *params)
{
9000c6a4:	b580      	push	{r7, lr}
9000c6a6:	b086      	sub	sp, #24
9000c6a8:	af00      	add	r7, sp, #0
9000c6aa:	60f8      	str	r0, [r7, #12]
9000c6ac:	460b      	mov	r3, r1
9000c6ae:	607a      	str	r2, [r7, #4]
9000c6b0:	72fb      	strb	r3, [r7, #11]
  UNUSED(params);
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000c6b2:	68fb      	ldr	r3, [r7, #12]
9000c6b4:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000c6b8:	68fb      	ldr	r3, [r7, #12]
9000c6ba:	32b0      	adds	r2, #176	@ 0xb0
9000c6bc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000c6c0:	617b      	str	r3, [r7, #20]

  if (hmsc == NULL)
9000c6c2:	697b      	ldr	r3, [r7, #20]
9000c6c4:	2b00      	cmp	r3, #0
9000c6c6:	d102      	bne.n	9000c6ce <SCSI_TestUnitReady+0x2a>
  {
    return -1;
9000c6c8:	f04f 33ff 	mov.w	r3, #4294967295
9000c6cc:	e03f      	b.n	9000c74e <SCSI_TestUnitReady+0xaa>
  }

  /* case 9 : Hi > D0 */
  if (hmsc->cbw.dDataLength != 0U)
9000c6ce:	697b      	ldr	r3, [r7, #20]
9000c6d0:	f8d3 3218 	ldr.w	r3, [r3, #536]	@ 0x218
9000c6d4:	2b00      	cmp	r3, #0
9000c6d6:	d00a      	beq.n	9000c6ee <SCSI_TestUnitReady+0x4a>
  {
    SCSI_SenseCode(pdev, hmsc->cbw.bLUN, ILLEGAL_REQUEST, INVALID_CDB);
9000c6d8:	697b      	ldr	r3, [r7, #20]
9000c6da:	f893 121d 	ldrb.w	r1, [r3, #541]	@ 0x21d
9000c6de:	2320      	movs	r3, #32
9000c6e0:	2205      	movs	r2, #5
9000c6e2:	68f8      	ldr	r0, [r7, #12]
9000c6e4:	f000 fb7b 	bl	9000cdde <SCSI_SenseCode>

    return -1;
9000c6e8:	f04f 33ff 	mov.w	r3, #4294967295
9000c6ec:	e02f      	b.n	9000c74e <SCSI_TestUnitReady+0xaa>
  }

  if (hmsc->scsi_medium_state == SCSI_MEDIUM_EJECTED)
9000c6ee:	697b      	ldr	r3, [r7, #20]
9000c6f0:	f893 3262 	ldrb.w	r3, [r3, #610]	@ 0x262
9000c6f4:	2b02      	cmp	r3, #2
9000c6f6:	d10b      	bne.n	9000c710 <SCSI_TestUnitReady+0x6c>
  {
    SCSI_SenseCode(pdev, lun, NOT_READY, MEDIUM_NOT_PRESENT);
9000c6f8:	7af9      	ldrb	r1, [r7, #11]
9000c6fa:	233a      	movs	r3, #58	@ 0x3a
9000c6fc:	2202      	movs	r2, #2
9000c6fe:	68f8      	ldr	r0, [r7, #12]
9000c700:	f000 fb6d 	bl	9000cdde <SCSI_SenseCode>
    hmsc->bot_state = USBD_BOT_NO_DATA;
9000c704:	697b      	ldr	r3, [r7, #20]
9000c706:	2205      	movs	r2, #5
9000c708:	721a      	strb	r2, [r3, #8]
    return -1;
9000c70a:	f04f 33ff 	mov.w	r3, #4294967295
9000c70e:	e01e      	b.n	9000c74e <SCSI_TestUnitReady+0xaa>
  }

  if (((USBD_StorageTypeDef *)pdev->pUserData[pdev->classId])->IsReady(lun) != 0)
9000c710:	68fb      	ldr	r3, [r7, #12]
9000c712:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
9000c716:	68fa      	ldr	r2, [r7, #12]
9000c718:	33b0      	adds	r3, #176	@ 0xb0
9000c71a:	009b      	lsls	r3, r3, #2
9000c71c:	4413      	add	r3, r2
9000c71e:	685b      	ldr	r3, [r3, #4]
9000c720:	689b      	ldr	r3, [r3, #8]
9000c722:	7afa      	ldrb	r2, [r7, #11]
9000c724:	4610      	mov	r0, r2
9000c726:	4798      	blx	r3
9000c728:	4603      	mov	r3, r0
9000c72a:	2b00      	cmp	r3, #0
9000c72c:	d00b      	beq.n	9000c746 <SCSI_TestUnitReady+0xa2>
  {
    SCSI_SenseCode(pdev, lun, NOT_READY, MEDIUM_NOT_PRESENT);
9000c72e:	7af9      	ldrb	r1, [r7, #11]
9000c730:	233a      	movs	r3, #58	@ 0x3a
9000c732:	2202      	movs	r2, #2
9000c734:	68f8      	ldr	r0, [r7, #12]
9000c736:	f000 fb52 	bl	9000cdde <SCSI_SenseCode>
    hmsc->bot_state = USBD_BOT_NO_DATA;
9000c73a:	697b      	ldr	r3, [r7, #20]
9000c73c:	2205      	movs	r2, #5
9000c73e:	721a      	strb	r2, [r3, #8]

    return -1;
9000c740:	f04f 33ff 	mov.w	r3, #4294967295
9000c744:	e003      	b.n	9000c74e <SCSI_TestUnitReady+0xaa>
  }
  hmsc->bot_data_length = 0U;
9000c746:	697b      	ldr	r3, [r7, #20]
9000c748:	2200      	movs	r2, #0
9000c74a:	60da      	str	r2, [r3, #12]

  return 0;
9000c74c:	2300      	movs	r3, #0
}
9000c74e:	4618      	mov	r0, r3
9000c750:	3718      	adds	r7, #24
9000c752:	46bd      	mov	sp, r7
9000c754:	bd80      	pop	{r7, pc}
	...

9000c758 <SCSI_Inquiry>:
  * @param  lun: Logical unit number
  * @param  params: Command parameters
  * @retval status
  */
static int8_t SCSI_Inquiry(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t *params)
{
9000c758:	b580      	push	{r7, lr}
9000c75a:	b088      	sub	sp, #32
9000c75c:	af00      	add	r7, sp, #0
9000c75e:	60f8      	str	r0, [r7, #12]
9000c760:	460b      	mov	r3, r1
9000c762:	607a      	str	r2, [r7, #4]
9000c764:	72fb      	strb	r3, [r7, #11]
  uint8_t *pPage;
  uint16_t len;
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000c766:	68fb      	ldr	r3, [r7, #12]
9000c768:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000c76c:	68fb      	ldr	r3, [r7, #12]
9000c76e:	32b0      	adds	r2, #176	@ 0xb0
9000c770:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000c774:	61bb      	str	r3, [r7, #24]

  if (hmsc == NULL)
9000c776:	69bb      	ldr	r3, [r7, #24]
9000c778:	2b00      	cmp	r3, #0
9000c77a:	d102      	bne.n	9000c782 <SCSI_Inquiry+0x2a>
  {
    return -1;
9000c77c:	f04f 33ff 	mov.w	r3, #4294967295
9000c780:	e05e      	b.n	9000c840 <SCSI_Inquiry+0xe8>
  }

  if (hmsc->cbw.dDataLength == 0U)
9000c782:	69bb      	ldr	r3, [r7, #24]
9000c784:	f8d3 3218 	ldr.w	r3, [r3, #536]	@ 0x218
9000c788:	2b00      	cmp	r3, #0
9000c78a:	d10a      	bne.n	9000c7a2 <SCSI_Inquiry+0x4a>
  {
    SCSI_SenseCode(pdev, hmsc->cbw.bLUN, ILLEGAL_REQUEST, INVALID_CDB);
9000c78c:	69bb      	ldr	r3, [r7, #24]
9000c78e:	f893 121d 	ldrb.w	r1, [r3, #541]	@ 0x21d
9000c792:	2320      	movs	r3, #32
9000c794:	2205      	movs	r2, #5
9000c796:	68f8      	ldr	r0, [r7, #12]
9000c798:	f000 fb21 	bl	9000cdde <SCSI_SenseCode>
    return -1;
9000c79c:	f04f 33ff 	mov.w	r3, #4294967295
9000c7a0:	e04e      	b.n	9000c840 <SCSI_Inquiry+0xe8>
  }

  if ((params[1] & 0x01U) != 0U) /* Evpd is set */
9000c7a2:	687b      	ldr	r3, [r7, #4]
9000c7a4:	3301      	adds	r3, #1
9000c7a6:	781b      	ldrb	r3, [r3, #0]
9000c7a8:	f003 0301 	and.w	r3, r3, #1
9000c7ac:	2b00      	cmp	r3, #0
9000c7ae:	d020      	beq.n	9000c7f2 <SCSI_Inquiry+0x9a>
  {
    if (params[2] == 0U) /* Request for Supported Vital Product Data Pages*/
9000c7b0:	687b      	ldr	r3, [r7, #4]
9000c7b2:	3302      	adds	r3, #2
9000c7b4:	781b      	ldrb	r3, [r3, #0]
9000c7b6:	2b00      	cmp	r3, #0
9000c7b8:	d105      	bne.n	9000c7c6 <SCSI_Inquiry+0x6e>
    {
      (void)SCSI_UpdateBotData(hmsc, MSC_Page00_Inquiry_Data, LENGTH_INQUIRY_PAGE00);
9000c7ba:	2206      	movs	r2, #6
9000c7bc:	4922      	ldr	r1, [pc, #136]	@ (9000c848 <SCSI_Inquiry+0xf0>)
9000c7be:	69b8      	ldr	r0, [r7, #24]
9000c7c0:	f001 f908 	bl	9000d9d4 <SCSI_UpdateBotData>
9000c7c4:	e03b      	b.n	9000c83e <SCSI_Inquiry+0xe6>
    }
    else if (params[2] == 0x80U) /* Request for VPD page 0x80 Unit Serial Number */
9000c7c6:	687b      	ldr	r3, [r7, #4]
9000c7c8:	3302      	adds	r3, #2
9000c7ca:	781b      	ldrb	r3, [r3, #0]
9000c7cc:	2b80      	cmp	r3, #128	@ 0x80
9000c7ce:	d105      	bne.n	9000c7dc <SCSI_Inquiry+0x84>
    {
      (void)SCSI_UpdateBotData(hmsc, MSC_Page80_Inquiry_Data, LENGTH_INQUIRY_PAGE80);
9000c7d0:	2208      	movs	r2, #8
9000c7d2:	491e      	ldr	r1, [pc, #120]	@ (9000c84c <SCSI_Inquiry+0xf4>)
9000c7d4:	69b8      	ldr	r0, [r7, #24]
9000c7d6:	f001 f8fd 	bl	9000d9d4 <SCSI_UpdateBotData>
9000c7da:	e030      	b.n	9000c83e <SCSI_Inquiry+0xe6>
    }
    else /* Request Not supported */
    {
      SCSI_SenseCode(pdev, hmsc->cbw.bLUN, ILLEGAL_REQUEST,
9000c7dc:	69bb      	ldr	r3, [r7, #24]
9000c7de:	f893 121d 	ldrb.w	r1, [r3, #541]	@ 0x21d
9000c7e2:	2324      	movs	r3, #36	@ 0x24
9000c7e4:	2205      	movs	r2, #5
9000c7e6:	68f8      	ldr	r0, [r7, #12]
9000c7e8:	f000 faf9 	bl	9000cdde <SCSI_SenseCode>
                     INVALID_FIELD_IN_COMMAND);

      return -1;
9000c7ec:	f04f 33ff 	mov.w	r3, #4294967295
9000c7f0:	e026      	b.n	9000c840 <SCSI_Inquiry+0xe8>
    }
  }
  else
  {

    pPage = (uint8_t *) & ((USBD_StorageTypeDef *)pdev->pUserData[pdev->classId]) \
9000c7f2:	68fb      	ldr	r3, [r7, #12]
9000c7f4:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
9000c7f8:	68fa      	ldr	r2, [r7, #12]
9000c7fa:	33b0      	adds	r3, #176	@ 0xb0
9000c7fc:	009b      	lsls	r3, r3, #2
9000c7fe:	4413      	add	r3, r2
9000c800:	685b      	ldr	r3, [r3, #4]
            ->pInquiry[lun * STANDARD_INQUIRY_DATA_LEN];
9000c802:	69d9      	ldr	r1, [r3, #28]
9000c804:	7afa      	ldrb	r2, [r7, #11]
9000c806:	4613      	mov	r3, r2
9000c808:	00db      	lsls	r3, r3, #3
9000c80a:	4413      	add	r3, r2
9000c80c:	009b      	lsls	r3, r3, #2
    pPage = (uint8_t *) & ((USBD_StorageTypeDef *)pdev->pUserData[pdev->classId]) \
9000c80e:	440b      	add	r3, r1
9000c810:	617b      	str	r3, [r7, #20]
    len = (uint16_t)pPage[4] + 5U;
9000c812:	697b      	ldr	r3, [r7, #20]
9000c814:	3304      	adds	r3, #4
9000c816:	781b      	ldrb	r3, [r3, #0]
9000c818:	3305      	adds	r3, #5
9000c81a:	83fb      	strh	r3, [r7, #30]

    if (params[4] <= len)
9000c81c:	687b      	ldr	r3, [r7, #4]
9000c81e:	3304      	adds	r3, #4
9000c820:	781b      	ldrb	r3, [r3, #0]
9000c822:	461a      	mov	r2, r3
9000c824:	8bfb      	ldrh	r3, [r7, #30]
9000c826:	4293      	cmp	r3, r2
9000c828:	d303      	bcc.n	9000c832 <SCSI_Inquiry+0xda>
    {
      len = params[4];
9000c82a:	687b      	ldr	r3, [r7, #4]
9000c82c:	3304      	adds	r3, #4
9000c82e:	781b      	ldrb	r3, [r3, #0]
9000c830:	83fb      	strh	r3, [r7, #30]
    }

    (void)SCSI_UpdateBotData(hmsc, pPage, len);
9000c832:	8bfb      	ldrh	r3, [r7, #30]
9000c834:	461a      	mov	r2, r3
9000c836:	6979      	ldr	r1, [r7, #20]
9000c838:	69b8      	ldr	r0, [r7, #24]
9000c83a:	f001 f8cb 	bl	9000d9d4 <SCSI_UpdateBotData>
  }

  return 0;
9000c83e:	2300      	movs	r3, #0
}
9000c840:	4618      	mov	r0, r3
9000c842:	3720      	adds	r7, #32
9000c844:	46bd      	mov	sp, r7
9000c846:	bd80      	pop	{r7, pc}
9000c848:	240000e4 	.word	0x240000e4
9000c84c:	240000ec 	.word	0x240000ec

9000c850 <SCSI_ReadCapacity10>:
  * @param  lun: Logical unit number
  * @param  params: Command parameters
  * @retval status
  */
static int8_t SCSI_ReadCapacity10(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t *params)
{
9000c850:	b580      	push	{r7, lr}
9000c852:	b088      	sub	sp, #32
9000c854:	af00      	add	r7, sp, #0
9000c856:	60f8      	str	r0, [r7, #12]
9000c858:	460b      	mov	r3, r1
9000c85a:	607a      	str	r2, [r7, #4]
9000c85c:	72fb      	strb	r3, [r7, #11]
  UNUSED(params);
  int8_t ret;
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000c85e:	68fb      	ldr	r3, [r7, #12]
9000c860:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000c864:	68fb      	ldr	r3, [r7, #12]
9000c866:	32b0      	adds	r2, #176	@ 0xb0
9000c868:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000c86c:	61fb      	str	r3, [r7, #28]
  USBD_MSC_BOT_LUN_TypeDef *p_scsi_blk = &hmsc->scsi_blk[lun];
9000c86e:	7afb      	ldrb	r3, [r7, #11]
9000c870:	3326      	adds	r3, #38	@ 0x26
9000c872:	011b      	lsls	r3, r3, #4
9000c874:	69fa      	ldr	r2, [r7, #28]
9000c876:	4413      	add	r3, r2
9000c878:	3304      	adds	r3, #4
9000c87a:	61bb      	str	r3, [r7, #24]

  if (hmsc == NULL)
9000c87c:	69fb      	ldr	r3, [r7, #28]
9000c87e:	2b00      	cmp	r3, #0
9000c880:	d102      	bne.n	9000c888 <SCSI_ReadCapacity10+0x38>
  {
    return -1;
9000c882:	f04f 33ff 	mov.w	r3, #4294967295
9000c886:	e059      	b.n	9000c93c <SCSI_ReadCapacity10+0xec>
  }

  ret = ((USBD_StorageTypeDef *)pdev->pUserData[pdev->classId])->GetCapacity(lun, &p_scsi_blk->nbr,
9000c888:	68fb      	ldr	r3, [r7, #12]
9000c88a:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
9000c88e:	68fa      	ldr	r2, [r7, #12]
9000c890:	33b0      	adds	r3, #176	@ 0xb0
9000c892:	009b      	lsls	r3, r3, #2
9000c894:	4413      	add	r3, r2
9000c896:	685b      	ldr	r3, [r3, #4]
9000c898:	685b      	ldr	r3, [r3, #4]
9000c89a:	69ba      	ldr	r2, [r7, #24]
9000c89c:	1d11      	adds	r1, r2, #4
9000c89e:	69ba      	ldr	r2, [r7, #24]
9000c8a0:	7af8      	ldrb	r0, [r7, #11]
9000c8a2:	4798      	blx	r3
9000c8a4:	4603      	mov	r3, r0
9000c8a6:	75fb      	strb	r3, [r7, #23]
                                                                             &p_scsi_blk->size);

  if ((ret != 0) || (hmsc->scsi_medium_state == SCSI_MEDIUM_EJECTED))
9000c8a8:	f997 3017 	ldrsb.w	r3, [r7, #23]
9000c8ac:	2b00      	cmp	r3, #0
9000c8ae:	d104      	bne.n	9000c8ba <SCSI_ReadCapacity10+0x6a>
9000c8b0:	69fb      	ldr	r3, [r7, #28]
9000c8b2:	f893 3262 	ldrb.w	r3, [r3, #610]	@ 0x262
9000c8b6:	2b02      	cmp	r3, #2
9000c8b8:	d108      	bne.n	9000c8cc <SCSI_ReadCapacity10+0x7c>
  {
    SCSI_SenseCode(pdev, lun, NOT_READY, MEDIUM_NOT_PRESENT);
9000c8ba:	7af9      	ldrb	r1, [r7, #11]
9000c8bc:	233a      	movs	r3, #58	@ 0x3a
9000c8be:	2202      	movs	r2, #2
9000c8c0:	68f8      	ldr	r0, [r7, #12]
9000c8c2:	f000 fa8c 	bl	9000cdde <SCSI_SenseCode>
    return -1;
9000c8c6:	f04f 33ff 	mov.w	r3, #4294967295
9000c8ca:	e037      	b.n	9000c93c <SCSI_ReadCapacity10+0xec>
  }

  hmsc->bot_data[0] = (uint8_t)((p_scsi_blk->nbr - 1U) >> 24);
9000c8cc:	69bb      	ldr	r3, [r7, #24]
9000c8ce:	685b      	ldr	r3, [r3, #4]
9000c8d0:	3b01      	subs	r3, #1
9000c8d2:	0e1b      	lsrs	r3, r3, #24
9000c8d4:	b2da      	uxtb	r2, r3
9000c8d6:	69fb      	ldr	r3, [r7, #28]
9000c8d8:	741a      	strb	r2, [r3, #16]
  hmsc->bot_data[1] = (uint8_t)((p_scsi_blk->nbr - 1U) >> 16);
9000c8da:	69bb      	ldr	r3, [r7, #24]
9000c8dc:	685b      	ldr	r3, [r3, #4]
9000c8de:	3b01      	subs	r3, #1
9000c8e0:	0c1b      	lsrs	r3, r3, #16
9000c8e2:	b2da      	uxtb	r2, r3
9000c8e4:	69fb      	ldr	r3, [r7, #28]
9000c8e6:	745a      	strb	r2, [r3, #17]
  hmsc->bot_data[2] = (uint8_t)((p_scsi_blk->nbr - 1U) >>  8);
9000c8e8:	69bb      	ldr	r3, [r7, #24]
9000c8ea:	685b      	ldr	r3, [r3, #4]
9000c8ec:	3b01      	subs	r3, #1
9000c8ee:	0a1b      	lsrs	r3, r3, #8
9000c8f0:	b2da      	uxtb	r2, r3
9000c8f2:	69fb      	ldr	r3, [r7, #28]
9000c8f4:	749a      	strb	r2, [r3, #18]
  hmsc->bot_data[3] = (uint8_t)(p_scsi_blk->nbr - 1U);
9000c8f6:	69bb      	ldr	r3, [r7, #24]
9000c8f8:	685b      	ldr	r3, [r3, #4]
9000c8fa:	b2db      	uxtb	r3, r3
9000c8fc:	3b01      	subs	r3, #1
9000c8fe:	b2da      	uxtb	r2, r3
9000c900:	69fb      	ldr	r3, [r7, #28]
9000c902:	74da      	strb	r2, [r3, #19]

  hmsc->bot_data[4] = (uint8_t)(p_scsi_blk->size >> 24);
9000c904:	69bb      	ldr	r3, [r7, #24]
9000c906:	881b      	ldrh	r3, [r3, #0]
9000c908:	161b      	asrs	r3, r3, #24
9000c90a:	b2da      	uxtb	r2, r3
9000c90c:	69fb      	ldr	r3, [r7, #28]
9000c90e:	751a      	strb	r2, [r3, #20]
  hmsc->bot_data[5] = (uint8_t)(p_scsi_blk->size >> 16);
9000c910:	69bb      	ldr	r3, [r7, #24]
9000c912:	881b      	ldrh	r3, [r3, #0]
9000c914:	141b      	asrs	r3, r3, #16
9000c916:	b2da      	uxtb	r2, r3
9000c918:	69fb      	ldr	r3, [r7, #28]
9000c91a:	755a      	strb	r2, [r3, #21]
  hmsc->bot_data[6] = (uint8_t)(p_scsi_blk->size >> 8);
9000c91c:	69bb      	ldr	r3, [r7, #24]
9000c91e:	881b      	ldrh	r3, [r3, #0]
9000c920:	0a1b      	lsrs	r3, r3, #8
9000c922:	b29b      	uxth	r3, r3
9000c924:	b2da      	uxtb	r2, r3
9000c926:	69fb      	ldr	r3, [r7, #28]
9000c928:	759a      	strb	r2, [r3, #22]
  hmsc->bot_data[7] = (uint8_t)(p_scsi_blk->size);
9000c92a:	69bb      	ldr	r3, [r7, #24]
9000c92c:	881b      	ldrh	r3, [r3, #0]
9000c92e:	b2da      	uxtb	r2, r3
9000c930:	69fb      	ldr	r3, [r7, #28]
9000c932:	75da      	strb	r2, [r3, #23]

  hmsc->bot_data_length = 8U;
9000c934:	69fb      	ldr	r3, [r7, #28]
9000c936:	2208      	movs	r2, #8
9000c938:	60da      	str	r2, [r3, #12]

  return 0;
9000c93a:	2300      	movs	r3, #0
}
9000c93c:	4618      	mov	r0, r3
9000c93e:	3720      	adds	r7, #32
9000c940:	46bd      	mov	sp, r7
9000c942:	bd80      	pop	{r7, pc}

9000c944 <SCSI_ReadCapacity16>:
  * @param  lun: Logical unit number
  * @param  params: Command parameters
  * @retval status
  */
static int8_t SCSI_ReadCapacity16(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t *params)
{
9000c944:	b580      	push	{r7, lr}
9000c946:	b088      	sub	sp, #32
9000c948:	af00      	add	r7, sp, #0
9000c94a:	60f8      	str	r0, [r7, #12]
9000c94c:	460b      	mov	r3, r1
9000c94e:	607a      	str	r2, [r7, #4]
9000c950:	72fb      	strb	r3, [r7, #11]
  UNUSED(params);
  uint32_t idx;
  int8_t ret;
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000c952:	68fb      	ldr	r3, [r7, #12]
9000c954:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000c958:	68fb      	ldr	r3, [r7, #12]
9000c95a:	32b0      	adds	r2, #176	@ 0xb0
9000c95c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000c960:	61bb      	str	r3, [r7, #24]
  USBD_MSC_BOT_LUN_TypeDef *p_scsi_blk = &hmsc->scsi_blk[lun];
9000c962:	7afb      	ldrb	r3, [r7, #11]
9000c964:	3326      	adds	r3, #38	@ 0x26
9000c966:	011b      	lsls	r3, r3, #4
9000c968:	69ba      	ldr	r2, [r7, #24]
9000c96a:	4413      	add	r3, r2
9000c96c:	3304      	adds	r3, #4
9000c96e:	617b      	str	r3, [r7, #20]

  if (hmsc == NULL)
9000c970:	69bb      	ldr	r3, [r7, #24]
9000c972:	2b00      	cmp	r3, #0
9000c974:	d102      	bne.n	9000c97c <SCSI_ReadCapacity16+0x38>
  {
    return -1;
9000c976:	f04f 33ff 	mov.w	r3, #4294967295
9000c97a:	e08f      	b.n	9000ca9c <SCSI_ReadCapacity16+0x158>
  }

  ret = ((USBD_StorageTypeDef *)pdev->pUserData[pdev->classId])->GetCapacity(lun, &p_scsi_blk->nbr,
9000c97c:	68fb      	ldr	r3, [r7, #12]
9000c97e:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
9000c982:	68fa      	ldr	r2, [r7, #12]
9000c984:	33b0      	adds	r3, #176	@ 0xb0
9000c986:	009b      	lsls	r3, r3, #2
9000c988:	4413      	add	r3, r2
9000c98a:	685b      	ldr	r3, [r3, #4]
9000c98c:	685b      	ldr	r3, [r3, #4]
9000c98e:	697a      	ldr	r2, [r7, #20]
9000c990:	1d11      	adds	r1, r2, #4
9000c992:	697a      	ldr	r2, [r7, #20]
9000c994:	7af8      	ldrb	r0, [r7, #11]
9000c996:	4798      	blx	r3
9000c998:	4603      	mov	r3, r0
9000c99a:	74fb      	strb	r3, [r7, #19]
                                                                             &p_scsi_blk->size);

  if ((ret != 0) || (hmsc->scsi_medium_state == SCSI_MEDIUM_EJECTED))
9000c99c:	f997 3013 	ldrsb.w	r3, [r7, #19]
9000c9a0:	2b00      	cmp	r3, #0
9000c9a2:	d104      	bne.n	9000c9ae <SCSI_ReadCapacity16+0x6a>
9000c9a4:	69bb      	ldr	r3, [r7, #24]
9000c9a6:	f893 3262 	ldrb.w	r3, [r3, #610]	@ 0x262
9000c9aa:	2b02      	cmp	r3, #2
9000c9ac:	d108      	bne.n	9000c9c0 <SCSI_ReadCapacity16+0x7c>
  {
    SCSI_SenseCode(pdev, lun, NOT_READY, MEDIUM_NOT_PRESENT);
9000c9ae:	7af9      	ldrb	r1, [r7, #11]
9000c9b0:	233a      	movs	r3, #58	@ 0x3a
9000c9b2:	2202      	movs	r2, #2
9000c9b4:	68f8      	ldr	r0, [r7, #12]
9000c9b6:	f000 fa12 	bl	9000cdde <SCSI_SenseCode>
    return -1;
9000c9ba:	f04f 33ff 	mov.w	r3, #4294967295
9000c9be:	e06d      	b.n	9000ca9c <SCSI_ReadCapacity16+0x158>
  }

  hmsc->bot_data_length = ((uint32_t)params[10] << 24) |
9000c9c0:	687b      	ldr	r3, [r7, #4]
9000c9c2:	330a      	adds	r3, #10
9000c9c4:	781b      	ldrb	r3, [r3, #0]
9000c9c6:	061a      	lsls	r2, r3, #24
                          ((uint32_t)params[11] << 16) |
9000c9c8:	687b      	ldr	r3, [r7, #4]
9000c9ca:	330b      	adds	r3, #11
9000c9cc:	781b      	ldrb	r3, [r3, #0]
9000c9ce:	041b      	lsls	r3, r3, #16
  hmsc->bot_data_length = ((uint32_t)params[10] << 24) |
9000c9d0:	431a      	orrs	r2, r3
                          ((uint32_t)params[12] <<  8) |
9000c9d2:	687b      	ldr	r3, [r7, #4]
9000c9d4:	330c      	adds	r3, #12
9000c9d6:	781b      	ldrb	r3, [r3, #0]
9000c9d8:	021b      	lsls	r3, r3, #8
                          ((uint32_t)params[11] << 16) |
9000c9da:	4313      	orrs	r3, r2
                          (uint32_t)params[13];
9000c9dc:	687a      	ldr	r2, [r7, #4]
9000c9de:	320d      	adds	r2, #13
9000c9e0:	7812      	ldrb	r2, [r2, #0]
                          ((uint32_t)params[12] <<  8) |
9000c9e2:	431a      	orrs	r2, r3
  hmsc->bot_data_length = ((uint32_t)params[10] << 24) |
9000c9e4:	69bb      	ldr	r3, [r7, #24]
9000c9e6:	60da      	str	r2, [r3, #12]

  for (idx = 0U; idx < hmsc->bot_data_length; idx++)
9000c9e8:	2300      	movs	r3, #0
9000c9ea:	61fb      	str	r3, [r7, #28]
9000c9ec:	e008      	b.n	9000ca00 <SCSI_ReadCapacity16+0xbc>
  {
    hmsc->bot_data[idx] = 0U;
9000c9ee:	69ba      	ldr	r2, [r7, #24]
9000c9f0:	69fb      	ldr	r3, [r7, #28]
9000c9f2:	4413      	add	r3, r2
9000c9f4:	3310      	adds	r3, #16
9000c9f6:	2200      	movs	r2, #0
9000c9f8:	701a      	strb	r2, [r3, #0]
  for (idx = 0U; idx < hmsc->bot_data_length; idx++)
9000c9fa:	69fb      	ldr	r3, [r7, #28]
9000c9fc:	3301      	adds	r3, #1
9000c9fe:	61fb      	str	r3, [r7, #28]
9000ca00:	69bb      	ldr	r3, [r7, #24]
9000ca02:	68db      	ldr	r3, [r3, #12]
9000ca04:	69fa      	ldr	r2, [r7, #28]
9000ca06:	429a      	cmp	r2, r3
9000ca08:	d3f1      	bcc.n	9000c9ee <SCSI_ReadCapacity16+0xaa>
  }

  hmsc->bot_data[4] = (uint8_t)((p_scsi_blk->nbr - 1U) >> 24);
9000ca0a:	697b      	ldr	r3, [r7, #20]
9000ca0c:	685b      	ldr	r3, [r3, #4]
9000ca0e:	3b01      	subs	r3, #1
9000ca10:	0e1b      	lsrs	r3, r3, #24
9000ca12:	b2da      	uxtb	r2, r3
9000ca14:	69bb      	ldr	r3, [r7, #24]
9000ca16:	751a      	strb	r2, [r3, #20]
  hmsc->bot_data[5] = (uint8_t)((p_scsi_blk->nbr - 1U) >> 16);
9000ca18:	697b      	ldr	r3, [r7, #20]
9000ca1a:	685b      	ldr	r3, [r3, #4]
9000ca1c:	3b01      	subs	r3, #1
9000ca1e:	0c1b      	lsrs	r3, r3, #16
9000ca20:	b2da      	uxtb	r2, r3
9000ca22:	69bb      	ldr	r3, [r7, #24]
9000ca24:	755a      	strb	r2, [r3, #21]
  hmsc->bot_data[6] = (uint8_t)((p_scsi_blk->nbr - 1U) >>  8);
9000ca26:	697b      	ldr	r3, [r7, #20]
9000ca28:	685b      	ldr	r3, [r3, #4]
9000ca2a:	3b01      	subs	r3, #1
9000ca2c:	0a1b      	lsrs	r3, r3, #8
9000ca2e:	b2da      	uxtb	r2, r3
9000ca30:	69bb      	ldr	r3, [r7, #24]
9000ca32:	759a      	strb	r2, [r3, #22]
  hmsc->bot_data[7] = (uint8_t)(p_scsi_blk->nbr - 1U);
9000ca34:	697b      	ldr	r3, [r7, #20]
9000ca36:	685b      	ldr	r3, [r3, #4]
9000ca38:	b2db      	uxtb	r3, r3
9000ca3a:	3b01      	subs	r3, #1
9000ca3c:	b2da      	uxtb	r2, r3
9000ca3e:	69bb      	ldr	r3, [r7, #24]
9000ca40:	75da      	strb	r2, [r3, #23]

  hmsc->bot_data[8] = (uint8_t)(p_scsi_blk->size >>  24);
9000ca42:	697b      	ldr	r3, [r7, #20]
9000ca44:	881b      	ldrh	r3, [r3, #0]
9000ca46:	161b      	asrs	r3, r3, #24
9000ca48:	b2da      	uxtb	r2, r3
9000ca4a:	69bb      	ldr	r3, [r7, #24]
9000ca4c:	761a      	strb	r2, [r3, #24]
  hmsc->bot_data[9] = (uint8_t)(p_scsi_blk->size >>  16);
9000ca4e:	697b      	ldr	r3, [r7, #20]
9000ca50:	881b      	ldrh	r3, [r3, #0]
9000ca52:	141b      	asrs	r3, r3, #16
9000ca54:	b2da      	uxtb	r2, r3
9000ca56:	69bb      	ldr	r3, [r7, #24]
9000ca58:	765a      	strb	r2, [r3, #25]
  hmsc->bot_data[10] = (uint8_t)(p_scsi_blk->size >>  8);
9000ca5a:	697b      	ldr	r3, [r7, #20]
9000ca5c:	881b      	ldrh	r3, [r3, #0]
9000ca5e:	0a1b      	lsrs	r3, r3, #8
9000ca60:	b29b      	uxth	r3, r3
9000ca62:	b2da      	uxtb	r2, r3
9000ca64:	69bb      	ldr	r3, [r7, #24]
9000ca66:	769a      	strb	r2, [r3, #26]
  hmsc->bot_data[11] = (uint8_t)(p_scsi_blk->size);
9000ca68:	697b      	ldr	r3, [r7, #20]
9000ca6a:	881b      	ldrh	r3, [r3, #0]
9000ca6c:	b2da      	uxtb	r2, r3
9000ca6e:	69bb      	ldr	r3, [r7, #24]
9000ca70:	76da      	strb	r2, [r3, #27]

  hmsc->bot_data_length = ((uint32_t)params[10] << 24) |
9000ca72:	687b      	ldr	r3, [r7, #4]
9000ca74:	330a      	adds	r3, #10
9000ca76:	781b      	ldrb	r3, [r3, #0]
9000ca78:	061a      	lsls	r2, r3, #24
                          ((uint32_t)params[11] << 16) |
9000ca7a:	687b      	ldr	r3, [r7, #4]
9000ca7c:	330b      	adds	r3, #11
9000ca7e:	781b      	ldrb	r3, [r3, #0]
9000ca80:	041b      	lsls	r3, r3, #16
  hmsc->bot_data_length = ((uint32_t)params[10] << 24) |
9000ca82:	431a      	orrs	r2, r3
                          ((uint32_t)params[12] <<  8) |
9000ca84:	687b      	ldr	r3, [r7, #4]
9000ca86:	330c      	adds	r3, #12
9000ca88:	781b      	ldrb	r3, [r3, #0]
9000ca8a:	021b      	lsls	r3, r3, #8
                          ((uint32_t)params[11] << 16) |
9000ca8c:	4313      	orrs	r3, r2
                          (uint32_t)params[13];
9000ca8e:	687a      	ldr	r2, [r7, #4]
9000ca90:	320d      	adds	r2, #13
9000ca92:	7812      	ldrb	r2, [r2, #0]
                          ((uint32_t)params[12] <<  8) |
9000ca94:	431a      	orrs	r2, r3
  hmsc->bot_data_length = ((uint32_t)params[10] << 24) |
9000ca96:	69bb      	ldr	r3, [r7, #24]
9000ca98:	60da      	str	r2, [r3, #12]

  return 0;
9000ca9a:	2300      	movs	r3, #0
}
9000ca9c:	4618      	mov	r0, r3
9000ca9e:	3720      	adds	r7, #32
9000caa0:	46bd      	mov	sp, r7
9000caa2:	bd80      	pop	{r7, pc}

9000caa4 <SCSI_ReadFormatCapacity>:
  * @param  lun: Logical unit number
  * @param  params: Command parameters
  * @retval status
  */
static int8_t SCSI_ReadFormatCapacity(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t *params)
{
9000caa4:	b580      	push	{r7, lr}
9000caa6:	b088      	sub	sp, #32
9000caa8:	af00      	add	r7, sp, #0
9000caaa:	60f8      	str	r0, [r7, #12]
9000caac:	460b      	mov	r3, r1
9000caae:	607a      	str	r2, [r7, #4]
9000cab0:	72fb      	strb	r3, [r7, #11]
  UNUSED(params);
  uint16_t blk_size;
  uint32_t blk_nbr;
  uint16_t i;
  int8_t ret;
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000cab2:	68fb      	ldr	r3, [r7, #12]
9000cab4:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000cab8:	68fb      	ldr	r3, [r7, #12]
9000caba:	32b0      	adds	r2, #176	@ 0xb0
9000cabc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000cac0:	61bb      	str	r3, [r7, #24]

  if (hmsc == NULL)
9000cac2:	69bb      	ldr	r3, [r7, #24]
9000cac4:	2b00      	cmp	r3, #0
9000cac6:	d102      	bne.n	9000cace <SCSI_ReadFormatCapacity+0x2a>
  {
    return -1;
9000cac8:	f04f 33ff 	mov.w	r3, #4294967295
9000cacc:	e061      	b.n	9000cb92 <SCSI_ReadFormatCapacity+0xee>
  }

  ret = ((USBD_StorageTypeDef *)pdev->pUserData[pdev->classId])->GetCapacity(lun, &blk_nbr, &blk_size);
9000cace:	68fb      	ldr	r3, [r7, #12]
9000cad0:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
9000cad4:	68fa      	ldr	r2, [r7, #12]
9000cad6:	33b0      	adds	r3, #176	@ 0xb0
9000cad8:	009b      	lsls	r3, r3, #2
9000cada:	4413      	add	r3, r2
9000cadc:	685b      	ldr	r3, [r3, #4]
9000cade:	685b      	ldr	r3, [r3, #4]
9000cae0:	f107 0214 	add.w	r2, r7, #20
9000cae4:	f107 0110 	add.w	r1, r7, #16
9000cae8:	7af8      	ldrb	r0, [r7, #11]
9000caea:	4798      	blx	r3
9000caec:	4603      	mov	r3, r0
9000caee:	75fb      	strb	r3, [r7, #23]

  if ((ret != 0) || (hmsc->scsi_medium_state == SCSI_MEDIUM_EJECTED))
9000caf0:	f997 3017 	ldrsb.w	r3, [r7, #23]
9000caf4:	2b00      	cmp	r3, #0
9000caf6:	d104      	bne.n	9000cb02 <SCSI_ReadFormatCapacity+0x5e>
9000caf8:	69bb      	ldr	r3, [r7, #24]
9000cafa:	f893 3262 	ldrb.w	r3, [r3, #610]	@ 0x262
9000cafe:	2b02      	cmp	r3, #2
9000cb00:	d108      	bne.n	9000cb14 <SCSI_ReadFormatCapacity+0x70>
  {
    SCSI_SenseCode(pdev, lun, NOT_READY, MEDIUM_NOT_PRESENT);
9000cb02:	7af9      	ldrb	r1, [r7, #11]
9000cb04:	233a      	movs	r3, #58	@ 0x3a
9000cb06:	2202      	movs	r2, #2
9000cb08:	68f8      	ldr	r0, [r7, #12]
9000cb0a:	f000 f968 	bl	9000cdde <SCSI_SenseCode>
    return -1;
9000cb0e:	f04f 33ff 	mov.w	r3, #4294967295
9000cb12:	e03e      	b.n	9000cb92 <SCSI_ReadFormatCapacity+0xee>
  }

  for (i = 0U; i < 12U ; i++)
9000cb14:	2300      	movs	r3, #0
9000cb16:	83fb      	strh	r3, [r7, #30]
9000cb18:	e007      	b.n	9000cb2a <SCSI_ReadFormatCapacity+0x86>
  {
    hmsc->bot_data[i] = 0U;
9000cb1a:	8bfb      	ldrh	r3, [r7, #30]
9000cb1c:	69ba      	ldr	r2, [r7, #24]
9000cb1e:	4413      	add	r3, r2
9000cb20:	2200      	movs	r2, #0
9000cb22:	741a      	strb	r2, [r3, #16]
  for (i = 0U; i < 12U ; i++)
9000cb24:	8bfb      	ldrh	r3, [r7, #30]
9000cb26:	3301      	adds	r3, #1
9000cb28:	83fb      	strh	r3, [r7, #30]
9000cb2a:	8bfb      	ldrh	r3, [r7, #30]
9000cb2c:	2b0b      	cmp	r3, #11
9000cb2e:	d9f4      	bls.n	9000cb1a <SCSI_ReadFormatCapacity+0x76>
  }

  hmsc->bot_data[3] = 0x08U;
9000cb30:	69bb      	ldr	r3, [r7, #24]
9000cb32:	2208      	movs	r2, #8
9000cb34:	74da      	strb	r2, [r3, #19]
  hmsc->bot_data[4] = (uint8_t)((blk_nbr - 1U) >> 24);
9000cb36:	693b      	ldr	r3, [r7, #16]
9000cb38:	3b01      	subs	r3, #1
9000cb3a:	0e1b      	lsrs	r3, r3, #24
9000cb3c:	b2da      	uxtb	r2, r3
9000cb3e:	69bb      	ldr	r3, [r7, #24]
9000cb40:	751a      	strb	r2, [r3, #20]
  hmsc->bot_data[5] = (uint8_t)((blk_nbr - 1U) >> 16);
9000cb42:	693b      	ldr	r3, [r7, #16]
9000cb44:	3b01      	subs	r3, #1
9000cb46:	0c1b      	lsrs	r3, r3, #16
9000cb48:	b2da      	uxtb	r2, r3
9000cb4a:	69bb      	ldr	r3, [r7, #24]
9000cb4c:	755a      	strb	r2, [r3, #21]
  hmsc->bot_data[6] = (uint8_t)((blk_nbr - 1U) >>  8);
9000cb4e:	693b      	ldr	r3, [r7, #16]
9000cb50:	3b01      	subs	r3, #1
9000cb52:	0a1b      	lsrs	r3, r3, #8
9000cb54:	b2da      	uxtb	r2, r3
9000cb56:	69bb      	ldr	r3, [r7, #24]
9000cb58:	759a      	strb	r2, [r3, #22]
  hmsc->bot_data[7] = (uint8_t)(blk_nbr - 1U);
9000cb5a:	693b      	ldr	r3, [r7, #16]
9000cb5c:	b2db      	uxtb	r3, r3
9000cb5e:	3b01      	subs	r3, #1
9000cb60:	b2da      	uxtb	r2, r3
9000cb62:	69bb      	ldr	r3, [r7, #24]
9000cb64:	75da      	strb	r2, [r3, #23]

  hmsc->bot_data[8] = 0x02U;
9000cb66:	69bb      	ldr	r3, [r7, #24]
9000cb68:	2202      	movs	r2, #2
9000cb6a:	761a      	strb	r2, [r3, #24]
  hmsc->bot_data[9] = (uint8_t)(blk_size >>  16);
9000cb6c:	8abb      	ldrh	r3, [r7, #20]
9000cb6e:	141b      	asrs	r3, r3, #16
9000cb70:	b2da      	uxtb	r2, r3
9000cb72:	69bb      	ldr	r3, [r7, #24]
9000cb74:	765a      	strb	r2, [r3, #25]
  hmsc->bot_data[10] = (uint8_t)(blk_size >>  8);
9000cb76:	8abb      	ldrh	r3, [r7, #20]
9000cb78:	0a1b      	lsrs	r3, r3, #8
9000cb7a:	b29b      	uxth	r3, r3
9000cb7c:	b2da      	uxtb	r2, r3
9000cb7e:	69bb      	ldr	r3, [r7, #24]
9000cb80:	769a      	strb	r2, [r3, #26]
  hmsc->bot_data[11] = (uint8_t)(blk_size);
9000cb82:	8abb      	ldrh	r3, [r7, #20]
9000cb84:	b2da      	uxtb	r2, r3
9000cb86:	69bb      	ldr	r3, [r7, #24]
9000cb88:	76da      	strb	r2, [r3, #27]

  hmsc->bot_data_length = 12U;
9000cb8a:	69bb      	ldr	r3, [r7, #24]
9000cb8c:	220c      	movs	r2, #12
9000cb8e:	60da      	str	r2, [r3, #12]

  return 0;
9000cb90:	2300      	movs	r3, #0
}
9000cb92:	4618      	mov	r0, r3
9000cb94:	3720      	adds	r7, #32
9000cb96:	46bd      	mov	sp, r7
9000cb98:	bd80      	pop	{r7, pc}
	...

9000cb9c <SCSI_ModeSense6>:
  * @param  lun: Logical unit number
  * @param  params: Command parameters
  * @retval status
  */
static int8_t SCSI_ModeSense6(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t *params)
{
9000cb9c:	b580      	push	{r7, lr}
9000cb9e:	b086      	sub	sp, #24
9000cba0:	af00      	add	r7, sp, #0
9000cba2:	60f8      	str	r0, [r7, #12]
9000cba4:	460b      	mov	r3, r1
9000cba6:	607a      	str	r2, [r7, #4]
9000cba8:	72fb      	strb	r3, [r7, #11]
  UNUSED(lun);
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000cbaa:	68fb      	ldr	r3, [r7, #12]
9000cbac:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000cbb0:	68fb      	ldr	r3, [r7, #12]
9000cbb2:	32b0      	adds	r2, #176	@ 0xb0
9000cbb4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000cbb8:	613b      	str	r3, [r7, #16]
  uint16_t len = MODE_SENSE6_LEN;
9000cbba:	2304      	movs	r3, #4
9000cbbc:	82fb      	strh	r3, [r7, #22]

  if (hmsc == NULL)
9000cbbe:	693b      	ldr	r3, [r7, #16]
9000cbc0:	2b00      	cmp	r3, #0
9000cbc2:	d102      	bne.n	9000cbca <SCSI_ModeSense6+0x2e>
  {
    return -1;
9000cbc4:	f04f 33ff 	mov.w	r3, #4294967295
9000cbc8:	e02f      	b.n	9000cc2a <SCSI_ModeSense6+0x8e>
  }

  /* Check If media is write-protected */
  if (((USBD_StorageTypeDef *)pdev->pUserData[pdev->classId])->IsWriteProtected(lun) != 0)
9000cbca:	68fb      	ldr	r3, [r7, #12]
9000cbcc:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
9000cbd0:	68fa      	ldr	r2, [r7, #12]
9000cbd2:	33b0      	adds	r3, #176	@ 0xb0
9000cbd4:	009b      	lsls	r3, r3, #2
9000cbd6:	4413      	add	r3, r2
9000cbd8:	685b      	ldr	r3, [r3, #4]
9000cbda:	68db      	ldr	r3, [r3, #12]
9000cbdc:	7afa      	ldrb	r2, [r7, #11]
9000cbde:	4610      	mov	r0, r2
9000cbe0:	4798      	blx	r3
9000cbe2:	4603      	mov	r3, r0
9000cbe4:	2b00      	cmp	r3, #0
9000cbe6:	d007      	beq.n	9000cbf8 <SCSI_ModeSense6+0x5c>
  {
    MSC_Mode_Sense6_data[2] |= (0x1U << 7); /* Set the WP (write protection) bit */
9000cbe8:	4b12      	ldr	r3, [pc, #72]	@ (9000cc34 <SCSI_ModeSense6+0x98>)
9000cbea:	789b      	ldrb	r3, [r3, #2]
9000cbec:	f063 037f 	orn	r3, r3, #127	@ 0x7f
9000cbf0:	b2da      	uxtb	r2, r3
9000cbf2:	4b10      	ldr	r3, [pc, #64]	@ (9000cc34 <SCSI_ModeSense6+0x98>)
9000cbf4:	709a      	strb	r2, [r3, #2]
9000cbf6:	e006      	b.n	9000cc06 <SCSI_ModeSense6+0x6a>
  }
  else
  {
    MSC_Mode_Sense10_data[2] &= ~(0x1U << 7); /* Clear the WP (write protection) bit */
9000cbf8:	4b0f      	ldr	r3, [pc, #60]	@ (9000cc38 <SCSI_ModeSense6+0x9c>)
9000cbfa:	789b      	ldrb	r3, [r3, #2]
9000cbfc:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
9000cc00:	b2da      	uxtb	r2, r3
9000cc02:	4b0d      	ldr	r3, [pc, #52]	@ (9000cc38 <SCSI_ModeSense6+0x9c>)
9000cc04:	709a      	strb	r2, [r3, #2]
  }

  if (params[4] <= len)
9000cc06:	687b      	ldr	r3, [r7, #4]
9000cc08:	3304      	adds	r3, #4
9000cc0a:	781b      	ldrb	r3, [r3, #0]
9000cc0c:	461a      	mov	r2, r3
9000cc0e:	8afb      	ldrh	r3, [r7, #22]
9000cc10:	4293      	cmp	r3, r2
9000cc12:	d303      	bcc.n	9000cc1c <SCSI_ModeSense6+0x80>
  {
    len = params[4];
9000cc14:	687b      	ldr	r3, [r7, #4]
9000cc16:	3304      	adds	r3, #4
9000cc18:	781b      	ldrb	r3, [r3, #0]
9000cc1a:	82fb      	strh	r3, [r7, #22]
  }

  (void)SCSI_UpdateBotData(hmsc, MSC_Mode_Sense6_data, len);
9000cc1c:	8afb      	ldrh	r3, [r7, #22]
9000cc1e:	461a      	mov	r2, r3
9000cc20:	4904      	ldr	r1, [pc, #16]	@ (9000cc34 <SCSI_ModeSense6+0x98>)
9000cc22:	6938      	ldr	r0, [r7, #16]
9000cc24:	f000 fed6 	bl	9000d9d4 <SCSI_UpdateBotData>

  return 0;
9000cc28:	2300      	movs	r3, #0
}
9000cc2a:	4618      	mov	r0, r3
9000cc2c:	3718      	adds	r7, #24
9000cc2e:	46bd      	mov	sp, r7
9000cc30:	bd80      	pop	{r7, pc}
9000cc32:	bf00      	nop
9000cc34:	240000f4 	.word	0x240000f4
9000cc38:	240000f8 	.word	0x240000f8

9000cc3c <SCSI_ModeSense10>:
  * @param  lun: Logical unit number
  * @param  params: Command parameters
  * @retval status
  */
static int8_t SCSI_ModeSense10(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t *params)
{
9000cc3c:	b580      	push	{r7, lr}
9000cc3e:	b086      	sub	sp, #24
9000cc40:	af00      	add	r7, sp, #0
9000cc42:	60f8      	str	r0, [r7, #12]
9000cc44:	460b      	mov	r3, r1
9000cc46:	607a      	str	r2, [r7, #4]
9000cc48:	72fb      	strb	r3, [r7, #11]
  UNUSED(lun);
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000cc4a:	68fb      	ldr	r3, [r7, #12]
9000cc4c:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000cc50:	68fb      	ldr	r3, [r7, #12]
9000cc52:	32b0      	adds	r2, #176	@ 0xb0
9000cc54:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000cc58:	613b      	str	r3, [r7, #16]
  uint16_t len = MODE_SENSE10_LEN;
9000cc5a:	2308      	movs	r3, #8
9000cc5c:	82fb      	strh	r3, [r7, #22]

  if (hmsc == NULL)
9000cc5e:	693b      	ldr	r3, [r7, #16]
9000cc60:	2b00      	cmp	r3, #0
9000cc62:	d102      	bne.n	9000cc6a <SCSI_ModeSense10+0x2e>
  {
    return -1;
9000cc64:	f04f 33ff 	mov.w	r3, #4294967295
9000cc68:	e02f      	b.n	9000ccca <SCSI_ModeSense10+0x8e>
  }

  /* Check If media is write-protected */
  if (((USBD_StorageTypeDef *)pdev->pUserData[pdev->classId])->IsWriteProtected(lun) != 0)
9000cc6a:	68fb      	ldr	r3, [r7, #12]
9000cc6c:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
9000cc70:	68fa      	ldr	r2, [r7, #12]
9000cc72:	33b0      	adds	r3, #176	@ 0xb0
9000cc74:	009b      	lsls	r3, r3, #2
9000cc76:	4413      	add	r3, r2
9000cc78:	685b      	ldr	r3, [r3, #4]
9000cc7a:	68db      	ldr	r3, [r3, #12]
9000cc7c:	7afa      	ldrb	r2, [r7, #11]
9000cc7e:	4610      	mov	r0, r2
9000cc80:	4798      	blx	r3
9000cc82:	4603      	mov	r3, r0
9000cc84:	2b00      	cmp	r3, #0
9000cc86:	d007      	beq.n	9000cc98 <SCSI_ModeSense10+0x5c>
  {
    MSC_Mode_Sense10_data[3] |= (0x1U << 7); /* Set the WP (write protection) bit */
9000cc88:	4b12      	ldr	r3, [pc, #72]	@ (9000ccd4 <SCSI_ModeSense10+0x98>)
9000cc8a:	78db      	ldrb	r3, [r3, #3]
9000cc8c:	f063 037f 	orn	r3, r3, #127	@ 0x7f
9000cc90:	b2da      	uxtb	r2, r3
9000cc92:	4b10      	ldr	r3, [pc, #64]	@ (9000ccd4 <SCSI_ModeSense10+0x98>)
9000cc94:	70da      	strb	r2, [r3, #3]
9000cc96:	e006      	b.n	9000cca6 <SCSI_ModeSense10+0x6a>
  }
  else
  {
    MSC_Mode_Sense10_data[3] &= ~(0x1U << 7); /* Clear the WP (write protection) bit */
9000cc98:	4b0e      	ldr	r3, [pc, #56]	@ (9000ccd4 <SCSI_ModeSense10+0x98>)
9000cc9a:	78db      	ldrb	r3, [r3, #3]
9000cc9c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
9000cca0:	b2da      	uxtb	r2, r3
9000cca2:	4b0c      	ldr	r3, [pc, #48]	@ (9000ccd4 <SCSI_ModeSense10+0x98>)
9000cca4:	70da      	strb	r2, [r3, #3]
  }

  if (params[8] <= len)
9000cca6:	687b      	ldr	r3, [r7, #4]
9000cca8:	3308      	adds	r3, #8
9000ccaa:	781b      	ldrb	r3, [r3, #0]
9000ccac:	461a      	mov	r2, r3
9000ccae:	8afb      	ldrh	r3, [r7, #22]
9000ccb0:	4293      	cmp	r3, r2
9000ccb2:	d303      	bcc.n	9000ccbc <SCSI_ModeSense10+0x80>
  {
    len = params[8];
9000ccb4:	687b      	ldr	r3, [r7, #4]
9000ccb6:	3308      	adds	r3, #8
9000ccb8:	781b      	ldrb	r3, [r3, #0]
9000ccba:	82fb      	strh	r3, [r7, #22]
  }

  (void)SCSI_UpdateBotData(hmsc, MSC_Mode_Sense10_data, len);
9000ccbc:	8afb      	ldrh	r3, [r7, #22]
9000ccbe:	461a      	mov	r2, r3
9000ccc0:	4904      	ldr	r1, [pc, #16]	@ (9000ccd4 <SCSI_ModeSense10+0x98>)
9000ccc2:	6938      	ldr	r0, [r7, #16]
9000ccc4:	f000 fe86 	bl	9000d9d4 <SCSI_UpdateBotData>

  return 0;
9000ccc8:	2300      	movs	r3, #0
}
9000ccca:	4618      	mov	r0, r3
9000cccc:	3718      	adds	r7, #24
9000ccce:	46bd      	mov	sp, r7
9000ccd0:	bd80      	pop	{r7, pc}
9000ccd2:	bf00      	nop
9000ccd4:	240000f8 	.word	0x240000f8

9000ccd8 <SCSI_RequestSense>:
  * @param  lun: Logical unit number
  * @param  params: Command parameters
  * @retval status
  */
static int8_t SCSI_RequestSense(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t *params)
{
9000ccd8:	b580      	push	{r7, lr}
9000ccda:	b086      	sub	sp, #24
9000ccdc:	af00      	add	r7, sp, #0
9000ccde:	60f8      	str	r0, [r7, #12]
9000cce0:	460b      	mov	r3, r1
9000cce2:	607a      	str	r2, [r7, #4]
9000cce4:	72fb      	strb	r3, [r7, #11]
  UNUSED(lun);
  uint8_t i;
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000cce6:	68fb      	ldr	r3, [r7, #12]
9000cce8:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000ccec:	68fb      	ldr	r3, [r7, #12]
9000ccee:	32b0      	adds	r2, #176	@ 0xb0
9000ccf0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000ccf4:	613b      	str	r3, [r7, #16]

  if (hmsc == NULL)
9000ccf6:	693b      	ldr	r3, [r7, #16]
9000ccf8:	2b00      	cmp	r3, #0
9000ccfa:	d102      	bne.n	9000cd02 <SCSI_RequestSense+0x2a>
  {
    return -1;
9000ccfc:	f04f 33ff 	mov.w	r3, #4294967295
9000cd00:	e069      	b.n	9000cdd6 <SCSI_RequestSense+0xfe>
  }

  if (hmsc->cbw.dDataLength == 0U)
9000cd02:	693b      	ldr	r3, [r7, #16]
9000cd04:	f8d3 3218 	ldr.w	r3, [r3, #536]	@ 0x218
9000cd08:	2b00      	cmp	r3, #0
9000cd0a:	d10a      	bne.n	9000cd22 <SCSI_RequestSense+0x4a>
  {
    SCSI_SenseCode(pdev, hmsc->cbw.bLUN, ILLEGAL_REQUEST, INVALID_CDB);
9000cd0c:	693b      	ldr	r3, [r7, #16]
9000cd0e:	f893 121d 	ldrb.w	r1, [r3, #541]	@ 0x21d
9000cd12:	2320      	movs	r3, #32
9000cd14:	2205      	movs	r2, #5
9000cd16:	68f8      	ldr	r0, [r7, #12]
9000cd18:	f000 f861 	bl	9000cdde <SCSI_SenseCode>
    return -1;
9000cd1c:	f04f 33ff 	mov.w	r3, #4294967295
9000cd20:	e059      	b.n	9000cdd6 <SCSI_RequestSense+0xfe>
  }

  for (i = 0U; i < REQUEST_SENSE_DATA_LEN; i++)
9000cd22:	2300      	movs	r3, #0
9000cd24:	75fb      	strb	r3, [r7, #23]
9000cd26:	e007      	b.n	9000cd38 <SCSI_RequestSense+0x60>
  {
    hmsc->bot_data[i] = 0U;
9000cd28:	7dfb      	ldrb	r3, [r7, #23]
9000cd2a:	693a      	ldr	r2, [r7, #16]
9000cd2c:	4413      	add	r3, r2
9000cd2e:	2200      	movs	r2, #0
9000cd30:	741a      	strb	r2, [r3, #16]
  for (i = 0U; i < REQUEST_SENSE_DATA_LEN; i++)
9000cd32:	7dfb      	ldrb	r3, [r7, #23]
9000cd34:	3301      	adds	r3, #1
9000cd36:	75fb      	strb	r3, [r7, #23]
9000cd38:	7dfb      	ldrb	r3, [r7, #23]
9000cd3a:	2b11      	cmp	r3, #17
9000cd3c:	d9f4      	bls.n	9000cd28 <SCSI_RequestSense+0x50>
  }

  hmsc->bot_data[0] = 0x70U;
9000cd3e:	693b      	ldr	r3, [r7, #16]
9000cd40:	2270      	movs	r2, #112	@ 0x70
9000cd42:	741a      	strb	r2, [r3, #16]
  hmsc->bot_data[7] = REQUEST_SENSE_DATA_LEN - 6U;
9000cd44:	693b      	ldr	r3, [r7, #16]
9000cd46:	220c      	movs	r2, #12
9000cd48:	75da      	strb	r2, [r3, #23]

  if ((hmsc->scsi_sense_head != hmsc->scsi_sense_tail))
9000cd4a:	693b      	ldr	r3, [r7, #16]
9000cd4c:	f893 2260 	ldrb.w	r2, [r3, #608]	@ 0x260
9000cd50:	693b      	ldr	r3, [r7, #16]
9000cd52:	f893 3261 	ldrb.w	r3, [r3, #609]	@ 0x261
9000cd56:	429a      	cmp	r2, r3
9000cd58:	d02e      	beq.n	9000cdb8 <SCSI_RequestSense+0xe0>
  {
    hmsc->bot_data[2] = (uint8_t)hmsc->scsi_sense[hmsc->scsi_sense_head].Skey;
9000cd5a:	693b      	ldr	r3, [r7, #16]
9000cd5c:	f893 3260 	ldrb.w	r3, [r3, #608]	@ 0x260
9000cd60:	461a      	mov	r2, r3
9000cd62:	693b      	ldr	r3, [r7, #16]
9000cd64:	3248      	adds	r2, #72	@ 0x48
9000cd66:	f813 2032 	ldrb.w	r2, [r3, r2, lsl #3]
9000cd6a:	693b      	ldr	r3, [r7, #16]
9000cd6c:	749a      	strb	r2, [r3, #18]
    hmsc->bot_data[12] = (uint8_t)hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASC;
9000cd6e:	693b      	ldr	r3, [r7, #16]
9000cd70:	f893 3260 	ldrb.w	r3, [r3, #608]	@ 0x260
9000cd74:	693a      	ldr	r2, [r7, #16]
9000cd76:	3348      	adds	r3, #72	@ 0x48
9000cd78:	00db      	lsls	r3, r3, #3
9000cd7a:	4413      	add	r3, r2
9000cd7c:	791a      	ldrb	r2, [r3, #4]
9000cd7e:	693b      	ldr	r3, [r7, #16]
9000cd80:	771a      	strb	r2, [r3, #28]
    hmsc->bot_data[13] = (uint8_t)hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASCQ;
9000cd82:	693b      	ldr	r3, [r7, #16]
9000cd84:	f893 3260 	ldrb.w	r3, [r3, #608]	@ 0x260
9000cd88:	693a      	ldr	r2, [r7, #16]
9000cd8a:	3348      	adds	r3, #72	@ 0x48
9000cd8c:	00db      	lsls	r3, r3, #3
9000cd8e:	4413      	add	r3, r2
9000cd90:	795a      	ldrb	r2, [r3, #5]
9000cd92:	693b      	ldr	r3, [r7, #16]
9000cd94:	775a      	strb	r2, [r3, #29]
    hmsc->scsi_sense_head++;
9000cd96:	693b      	ldr	r3, [r7, #16]
9000cd98:	f893 3260 	ldrb.w	r3, [r3, #608]	@ 0x260
9000cd9c:	3301      	adds	r3, #1
9000cd9e:	b2da      	uxtb	r2, r3
9000cda0:	693b      	ldr	r3, [r7, #16]
9000cda2:	f883 2260 	strb.w	r2, [r3, #608]	@ 0x260

    if (hmsc->scsi_sense_head == SENSE_LIST_DEEPTH)
9000cda6:	693b      	ldr	r3, [r7, #16]
9000cda8:	f893 3260 	ldrb.w	r3, [r3, #608]	@ 0x260
9000cdac:	2b04      	cmp	r3, #4
9000cdae:	d103      	bne.n	9000cdb8 <SCSI_RequestSense+0xe0>
    {
      hmsc->scsi_sense_head = 0U;
9000cdb0:	693b      	ldr	r3, [r7, #16]
9000cdb2:	2200      	movs	r2, #0
9000cdb4:	f883 2260 	strb.w	r2, [r3, #608]	@ 0x260
    }
  }

  hmsc->bot_data_length = REQUEST_SENSE_DATA_LEN;
9000cdb8:	693b      	ldr	r3, [r7, #16]
9000cdba:	2212      	movs	r2, #18
9000cdbc:	60da      	str	r2, [r3, #12]

  if (params[4] <= REQUEST_SENSE_DATA_LEN)
9000cdbe:	687b      	ldr	r3, [r7, #4]
9000cdc0:	3304      	adds	r3, #4
9000cdc2:	781b      	ldrb	r3, [r3, #0]
9000cdc4:	2b12      	cmp	r3, #18
9000cdc6:	d805      	bhi.n	9000cdd4 <SCSI_RequestSense+0xfc>
  {
    hmsc->bot_data_length = params[4];
9000cdc8:	687b      	ldr	r3, [r7, #4]
9000cdca:	3304      	adds	r3, #4
9000cdcc:	781b      	ldrb	r3, [r3, #0]
9000cdce:	461a      	mov	r2, r3
9000cdd0:	693b      	ldr	r3, [r7, #16]
9000cdd2:	60da      	str	r2, [r3, #12]
  }

  return 0;
9000cdd4:	2300      	movs	r3, #0
}
9000cdd6:	4618      	mov	r0, r3
9000cdd8:	3718      	adds	r7, #24
9000cdda:	46bd      	mov	sp, r7
9000cddc:	bd80      	pop	{r7, pc}

9000cdde <SCSI_SenseCode>:
  * @param  ASC: Additional Sense Code
  * @retval none

  */
void SCSI_SenseCode(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t sKey, uint8_t ASC)
{
9000cdde:	b480      	push	{r7}
9000cde0:	b085      	sub	sp, #20
9000cde2:	af00      	add	r7, sp, #0
9000cde4:	6078      	str	r0, [r7, #4]
9000cde6:	4608      	mov	r0, r1
9000cde8:	4611      	mov	r1, r2
9000cdea:	461a      	mov	r2, r3
9000cdec:	4603      	mov	r3, r0
9000cdee:	70fb      	strb	r3, [r7, #3]
9000cdf0:	460b      	mov	r3, r1
9000cdf2:	70bb      	strb	r3, [r7, #2]
9000cdf4:	4613      	mov	r3, r2
9000cdf6:	707b      	strb	r3, [r7, #1]
  UNUSED(lun);
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000cdf8:	687b      	ldr	r3, [r7, #4]
9000cdfa:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000cdfe:	687b      	ldr	r3, [r7, #4]
9000ce00:	32b0      	adds	r2, #176	@ 0xb0
9000ce02:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000ce06:	60fb      	str	r3, [r7, #12]

  if (hmsc == NULL)
9000ce08:	68fb      	ldr	r3, [r7, #12]
9000ce0a:	2b00      	cmp	r3, #0
9000ce0c:	d02c      	beq.n	9000ce68 <SCSI_SenseCode+0x8a>
  {
    return;
  }

  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey = sKey;
9000ce0e:	68fb      	ldr	r3, [r7, #12]
9000ce10:	f893 3261 	ldrb.w	r3, [r3, #609]	@ 0x261
9000ce14:	461a      	mov	r2, r3
9000ce16:	68fb      	ldr	r3, [r7, #12]
9000ce18:	3248      	adds	r2, #72	@ 0x48
9000ce1a:	78b9      	ldrb	r1, [r7, #2]
9000ce1c:	f803 1032 	strb.w	r1, [r3, r2, lsl #3]
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.b.ASC = ASC;
9000ce20:	68fb      	ldr	r3, [r7, #12]
9000ce22:	f893 3261 	ldrb.w	r3, [r3, #609]	@ 0x261
9000ce26:	68fa      	ldr	r2, [r7, #12]
9000ce28:	3348      	adds	r3, #72	@ 0x48
9000ce2a:	00db      	lsls	r3, r3, #3
9000ce2c:	4413      	add	r3, r2
9000ce2e:	787a      	ldrb	r2, [r7, #1]
9000ce30:	711a      	strb	r2, [r3, #4]
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.b.ASCQ = 0U;
9000ce32:	68fb      	ldr	r3, [r7, #12]
9000ce34:	f893 3261 	ldrb.w	r3, [r3, #609]	@ 0x261
9000ce38:	68fa      	ldr	r2, [r7, #12]
9000ce3a:	3348      	adds	r3, #72	@ 0x48
9000ce3c:	00db      	lsls	r3, r3, #3
9000ce3e:	4413      	add	r3, r2
9000ce40:	2200      	movs	r2, #0
9000ce42:	715a      	strb	r2, [r3, #5]
  hmsc->scsi_sense_tail++;
9000ce44:	68fb      	ldr	r3, [r7, #12]
9000ce46:	f893 3261 	ldrb.w	r3, [r3, #609]	@ 0x261
9000ce4a:	3301      	adds	r3, #1
9000ce4c:	b2da      	uxtb	r2, r3
9000ce4e:	68fb      	ldr	r3, [r7, #12]
9000ce50:	f883 2261 	strb.w	r2, [r3, #609]	@ 0x261

  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
9000ce54:	68fb      	ldr	r3, [r7, #12]
9000ce56:	f893 3261 	ldrb.w	r3, [r3, #609]	@ 0x261
9000ce5a:	2b04      	cmp	r3, #4
9000ce5c:	d105      	bne.n	9000ce6a <SCSI_SenseCode+0x8c>
  {
    hmsc->scsi_sense_tail = 0U;
9000ce5e:	68fb      	ldr	r3, [r7, #12]
9000ce60:	2200      	movs	r2, #0
9000ce62:	f883 2261 	strb.w	r2, [r3, #609]	@ 0x261
9000ce66:	e000      	b.n	9000ce6a <SCSI_SenseCode+0x8c>
    return;
9000ce68:	bf00      	nop
  }
}
9000ce6a:	3714      	adds	r7, #20
9000ce6c:	46bd      	mov	sp, r7
9000ce6e:	f85d 7b04 	ldr.w	r7, [sp], #4
9000ce72:	4770      	bx	lr

9000ce74 <SCSI_StartStopUnit>:
  * @param  lun: Logical unit number
  * @param  params: Command parameters
  * @retval status
  */
static int8_t SCSI_StartStopUnit(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t *params)
{
9000ce74:	b580      	push	{r7, lr}
9000ce76:	b086      	sub	sp, #24
9000ce78:	af00      	add	r7, sp, #0
9000ce7a:	60f8      	str	r0, [r7, #12]
9000ce7c:	460b      	mov	r3, r1
9000ce7e:	607a      	str	r2, [r7, #4]
9000ce80:	72fb      	strb	r3, [r7, #11]
  UNUSED(lun);
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000ce82:	68fb      	ldr	r3, [r7, #12]
9000ce84:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000ce88:	68fb      	ldr	r3, [r7, #12]
9000ce8a:	32b0      	adds	r2, #176	@ 0xb0
9000ce8c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000ce90:	617b      	str	r3, [r7, #20]

  if (hmsc == NULL)
9000ce92:	697b      	ldr	r3, [r7, #20]
9000ce94:	2b00      	cmp	r3, #0
9000ce96:	d102      	bne.n	9000ce9e <SCSI_StartStopUnit+0x2a>
  {
    return -1;
9000ce98:	f04f 33ff 	mov.w	r3, #4294967295
9000ce9c:	e03b      	b.n	9000cf16 <SCSI_StartStopUnit+0xa2>
  }

  if ((hmsc->scsi_medium_state == SCSI_MEDIUM_LOCKED) && ((params[4] & 0x3U) == 2U))
9000ce9e:	697b      	ldr	r3, [r7, #20]
9000cea0:	f893 3262 	ldrb.w	r3, [r3, #610]	@ 0x262
9000cea4:	2b01      	cmp	r3, #1
9000cea6:	d10f      	bne.n	9000cec8 <SCSI_StartStopUnit+0x54>
9000cea8:	687b      	ldr	r3, [r7, #4]
9000ceaa:	3304      	adds	r3, #4
9000ceac:	781b      	ldrb	r3, [r3, #0]
9000ceae:	f003 0303 	and.w	r3, r3, #3
9000ceb2:	2b02      	cmp	r3, #2
9000ceb4:	d108      	bne.n	9000cec8 <SCSI_StartStopUnit+0x54>
  {
    SCSI_SenseCode(pdev, lun, ILLEGAL_REQUEST, INVALID_FIELD_IN_COMMAND);
9000ceb6:	7af9      	ldrb	r1, [r7, #11]
9000ceb8:	2324      	movs	r3, #36	@ 0x24
9000ceba:	2205      	movs	r2, #5
9000cebc:	68f8      	ldr	r0, [r7, #12]
9000cebe:	f7ff ff8e 	bl	9000cdde <SCSI_SenseCode>

    return -1;
9000cec2:	f04f 33ff 	mov.w	r3, #4294967295
9000cec6:	e026      	b.n	9000cf16 <SCSI_StartStopUnit+0xa2>
  }

  if ((params[4] & 0x3U) == 0x1U) /* START=1 */
9000cec8:	687b      	ldr	r3, [r7, #4]
9000ceca:	3304      	adds	r3, #4
9000cecc:	781b      	ldrb	r3, [r3, #0]
9000cece:	f003 0303 	and.w	r3, r3, #3
9000ced2:	2b01      	cmp	r3, #1
9000ced4:	d104      	bne.n	9000cee0 <SCSI_StartStopUnit+0x6c>
  {
    hmsc->scsi_medium_state = SCSI_MEDIUM_UNLOCKED;
9000ced6:	697b      	ldr	r3, [r7, #20]
9000ced8:	2200      	movs	r2, #0
9000ceda:	f883 2262 	strb.w	r2, [r3, #610]	@ 0x262
9000cede:	e016      	b.n	9000cf0e <SCSI_StartStopUnit+0x9a>
  }
  else if ((params[4] & 0x3U) == 0x2U) /* START=0 and LOEJ Load Eject=1 */
9000cee0:	687b      	ldr	r3, [r7, #4]
9000cee2:	3304      	adds	r3, #4
9000cee4:	781b      	ldrb	r3, [r3, #0]
9000cee6:	f003 0303 	and.w	r3, r3, #3
9000ceea:	2b02      	cmp	r3, #2
9000ceec:	d104      	bne.n	9000cef8 <SCSI_StartStopUnit+0x84>
  {
    hmsc->scsi_medium_state = SCSI_MEDIUM_EJECTED;
9000ceee:	697b      	ldr	r3, [r7, #20]
9000cef0:	2202      	movs	r2, #2
9000cef2:	f883 2262 	strb.w	r2, [r3, #610]	@ 0x262
9000cef6:	e00a      	b.n	9000cf0e <SCSI_StartStopUnit+0x9a>
  }
  else if ((params[4] & 0x3U) == 0x3U) /* START=1 and LOEJ Load Eject=1 */
9000cef8:	687b      	ldr	r3, [r7, #4]
9000cefa:	3304      	adds	r3, #4
9000cefc:	781b      	ldrb	r3, [r3, #0]
9000cefe:	f003 0303 	and.w	r3, r3, #3
9000cf02:	2b03      	cmp	r3, #3
9000cf04:	d103      	bne.n	9000cf0e <SCSI_StartStopUnit+0x9a>
  {
    hmsc->scsi_medium_state = SCSI_MEDIUM_UNLOCKED;
9000cf06:	697b      	ldr	r3, [r7, #20]
9000cf08:	2200      	movs	r2, #0
9000cf0a:	f883 2262 	strb.w	r2, [r3, #610]	@ 0x262
  }
  else
  {
    /* .. */
  }
  hmsc->bot_data_length = 0U;
9000cf0e:	697b      	ldr	r3, [r7, #20]
9000cf10:	2200      	movs	r2, #0
9000cf12:	60da      	str	r2, [r3, #12]

  return 0;
9000cf14:	2300      	movs	r3, #0
}
9000cf16:	4618      	mov	r0, r3
9000cf18:	3718      	adds	r7, #24
9000cf1a:	46bd      	mov	sp, r7
9000cf1c:	bd80      	pop	{r7, pc}

9000cf1e <SCSI_AllowPreventRemovable>:
  * @param  lun: Logical unit number
  * @param  params: Command parameters
  * @retval status
  */
static int8_t SCSI_AllowPreventRemovable(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t *params)
{
9000cf1e:	b480      	push	{r7}
9000cf20:	b087      	sub	sp, #28
9000cf22:	af00      	add	r7, sp, #0
9000cf24:	60f8      	str	r0, [r7, #12]
9000cf26:	460b      	mov	r3, r1
9000cf28:	607a      	str	r2, [r7, #4]
9000cf2a:	72fb      	strb	r3, [r7, #11]
  UNUSED(lun);
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000cf2c:	68fb      	ldr	r3, [r7, #12]
9000cf2e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000cf32:	68fb      	ldr	r3, [r7, #12]
9000cf34:	32b0      	adds	r2, #176	@ 0xb0
9000cf36:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000cf3a:	617b      	str	r3, [r7, #20]

  if (hmsc == NULL)
9000cf3c:	697b      	ldr	r3, [r7, #20]
9000cf3e:	2b00      	cmp	r3, #0
9000cf40:	d102      	bne.n	9000cf48 <SCSI_AllowPreventRemovable+0x2a>
  {
    return -1;
9000cf42:	f04f 33ff 	mov.w	r3, #4294967295
9000cf46:	e011      	b.n	9000cf6c <SCSI_AllowPreventRemovable+0x4e>
  }

  if (params[4] == 0U)
9000cf48:	687b      	ldr	r3, [r7, #4]
9000cf4a:	3304      	adds	r3, #4
9000cf4c:	781b      	ldrb	r3, [r3, #0]
9000cf4e:	2b00      	cmp	r3, #0
9000cf50:	d104      	bne.n	9000cf5c <SCSI_AllowPreventRemovable+0x3e>
  {
    hmsc->scsi_medium_state = SCSI_MEDIUM_UNLOCKED;
9000cf52:	697b      	ldr	r3, [r7, #20]
9000cf54:	2200      	movs	r2, #0
9000cf56:	f883 2262 	strb.w	r2, [r3, #610]	@ 0x262
9000cf5a:	e003      	b.n	9000cf64 <SCSI_AllowPreventRemovable+0x46>
  }
  else
  {
    hmsc->scsi_medium_state = SCSI_MEDIUM_LOCKED;
9000cf5c:	697b      	ldr	r3, [r7, #20]
9000cf5e:	2201      	movs	r2, #1
9000cf60:	f883 2262 	strb.w	r2, [r3, #610]	@ 0x262
  }

  hmsc->bot_data_length = 0U;
9000cf64:	697b      	ldr	r3, [r7, #20]
9000cf66:	2200      	movs	r2, #0
9000cf68:	60da      	str	r2, [r3, #12]

  return 0;
9000cf6a:	2300      	movs	r3, #0
}
9000cf6c:	4618      	mov	r0, r3
9000cf6e:	371c      	adds	r7, #28
9000cf70:	46bd      	mov	sp, r7
9000cf72:	f85d 7b04 	ldr.w	r7, [sp], #4
9000cf76:	4770      	bx	lr

9000cf78 <SCSI_Read10>:
  * @param  lun: Logical unit number
  * @param  params: Command parameters
  * @retval status
  */
static int8_t SCSI_Read10(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t *params)
{
9000cf78:	b580      	push	{r7, lr}
9000cf7a:	b086      	sub	sp, #24
9000cf7c:	af00      	add	r7, sp, #0
9000cf7e:	60f8      	str	r0, [r7, #12]
9000cf80:	460b      	mov	r3, r1
9000cf82:	607a      	str	r2, [r7, #4]
9000cf84:	72fb      	strb	r3, [r7, #11]
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000cf86:	68fb      	ldr	r3, [r7, #12]
9000cf88:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000cf8c:	68fb      	ldr	r3, [r7, #12]
9000cf8e:	32b0      	adds	r2, #176	@ 0xb0
9000cf90:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000cf94:	617b      	str	r3, [r7, #20]
  USBD_MSC_BOT_LUN_TypeDef *p_scsi_blk = &hmsc->scsi_blk[lun];
9000cf96:	7afb      	ldrb	r3, [r7, #11]
9000cf98:	3326      	adds	r3, #38	@ 0x26
9000cf9a:	011b      	lsls	r3, r3, #4
9000cf9c:	697a      	ldr	r2, [r7, #20]
9000cf9e:	4413      	add	r3, r2
9000cfa0:	3304      	adds	r3, #4
9000cfa2:	613b      	str	r3, [r7, #16]

  if (hmsc == NULL)
9000cfa4:	697b      	ldr	r3, [r7, #20]
9000cfa6:	2b00      	cmp	r3, #0
9000cfa8:	d102      	bne.n	9000cfb0 <SCSI_Read10+0x38>
  {
    return -1;
9000cfaa:	f04f 33ff 	mov.w	r3, #4294967295
9000cfae:	e089      	b.n	9000d0c4 <SCSI_Read10+0x14c>
  }

  if (hmsc->bot_state == USBD_BOT_IDLE) /* Idle */
9000cfb0:	697b      	ldr	r3, [r7, #20]
9000cfb2:	7a1b      	ldrb	r3, [r3, #8]
9000cfb4:	2b00      	cmp	r3, #0
9000cfb6:	d17b      	bne.n	9000d0b0 <SCSI_Read10+0x138>
  {
    /* case 10 : Ho <> Di */
    if ((hmsc->cbw.bmFlags & 0x80U) != 0x80U)
9000cfb8:	697b      	ldr	r3, [r7, #20]
9000cfba:	f893 321c 	ldrb.w	r3, [r3, #540]	@ 0x21c
9000cfbe:	b25b      	sxtb	r3, r3
9000cfc0:	2b00      	cmp	r3, #0
9000cfc2:	db0a      	blt.n	9000cfda <SCSI_Read10+0x62>
    {
      SCSI_SenseCode(pdev, hmsc->cbw.bLUN, ILLEGAL_REQUEST, INVALID_CDB);
9000cfc4:	697b      	ldr	r3, [r7, #20]
9000cfc6:	f893 121d 	ldrb.w	r1, [r3, #541]	@ 0x21d
9000cfca:	2320      	movs	r3, #32
9000cfcc:	2205      	movs	r2, #5
9000cfce:	68f8      	ldr	r0, [r7, #12]
9000cfd0:	f7ff ff05 	bl	9000cdde <SCSI_SenseCode>
      return -1;
9000cfd4:	f04f 33ff 	mov.w	r3, #4294967295
9000cfd8:	e074      	b.n	9000d0c4 <SCSI_Read10+0x14c>
    }

    if (hmsc->scsi_medium_state == SCSI_MEDIUM_EJECTED)
9000cfda:	697b      	ldr	r3, [r7, #20]
9000cfdc:	f893 3262 	ldrb.w	r3, [r3, #610]	@ 0x262
9000cfe0:	2b02      	cmp	r3, #2
9000cfe2:	d108      	bne.n	9000cff6 <SCSI_Read10+0x7e>
    {
      SCSI_SenseCode(pdev, lun, NOT_READY, MEDIUM_NOT_PRESENT);
9000cfe4:	7af9      	ldrb	r1, [r7, #11]
9000cfe6:	233a      	movs	r3, #58	@ 0x3a
9000cfe8:	2202      	movs	r2, #2
9000cfea:	68f8      	ldr	r0, [r7, #12]
9000cfec:	f7ff fef7 	bl	9000cdde <SCSI_SenseCode>

      return -1;
9000cff0:	f04f 33ff 	mov.w	r3, #4294967295
9000cff4:	e066      	b.n	9000d0c4 <SCSI_Read10+0x14c>
    }

    if (((USBD_StorageTypeDef *)pdev->pUserData[pdev->classId])->IsReady(lun) != 0)
9000cff6:	68fb      	ldr	r3, [r7, #12]
9000cff8:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
9000cffc:	68fa      	ldr	r2, [r7, #12]
9000cffe:	33b0      	adds	r3, #176	@ 0xb0
9000d000:	009b      	lsls	r3, r3, #2
9000d002:	4413      	add	r3, r2
9000d004:	685b      	ldr	r3, [r3, #4]
9000d006:	689b      	ldr	r3, [r3, #8]
9000d008:	7afa      	ldrb	r2, [r7, #11]
9000d00a:	4610      	mov	r0, r2
9000d00c:	4798      	blx	r3
9000d00e:	4603      	mov	r3, r0
9000d010:	2b00      	cmp	r3, #0
9000d012:	d008      	beq.n	9000d026 <SCSI_Read10+0xae>
    {
      SCSI_SenseCode(pdev, lun, NOT_READY, MEDIUM_NOT_PRESENT);
9000d014:	7af9      	ldrb	r1, [r7, #11]
9000d016:	233a      	movs	r3, #58	@ 0x3a
9000d018:	2202      	movs	r2, #2
9000d01a:	68f8      	ldr	r0, [r7, #12]
9000d01c:	f7ff fedf 	bl	9000cdde <SCSI_SenseCode>
      return -1;
9000d020:	f04f 33ff 	mov.w	r3, #4294967295
9000d024:	e04e      	b.n	9000d0c4 <SCSI_Read10+0x14c>
    }

    p_scsi_blk->addr = ((uint32_t)params[2] << 24) |
9000d026:	687b      	ldr	r3, [r7, #4]
9000d028:	3302      	adds	r3, #2
9000d02a:	781b      	ldrb	r3, [r3, #0]
9000d02c:	061a      	lsls	r2, r3, #24
                       ((uint32_t)params[3] << 16) |
9000d02e:	687b      	ldr	r3, [r7, #4]
9000d030:	3303      	adds	r3, #3
9000d032:	781b      	ldrb	r3, [r3, #0]
9000d034:	041b      	lsls	r3, r3, #16
    p_scsi_blk->addr = ((uint32_t)params[2] << 24) |
9000d036:	431a      	orrs	r2, r3
                       ((uint32_t)params[4] <<  8) |
9000d038:	687b      	ldr	r3, [r7, #4]
9000d03a:	3304      	adds	r3, #4
9000d03c:	781b      	ldrb	r3, [r3, #0]
9000d03e:	021b      	lsls	r3, r3, #8
                       ((uint32_t)params[3] << 16) |
9000d040:	4313      	orrs	r3, r2
                       (uint32_t)params[5];
9000d042:	687a      	ldr	r2, [r7, #4]
9000d044:	3205      	adds	r2, #5
9000d046:	7812      	ldrb	r2, [r2, #0]
                       ((uint32_t)params[4] <<  8) |
9000d048:	431a      	orrs	r2, r3
    p_scsi_blk->addr = ((uint32_t)params[2] << 24) |
9000d04a:	693b      	ldr	r3, [r7, #16]
9000d04c:	609a      	str	r2, [r3, #8]

    p_scsi_blk->len = ((uint32_t)params[7] <<  8) | (uint32_t)params[8];
9000d04e:	687b      	ldr	r3, [r7, #4]
9000d050:	3307      	adds	r3, #7
9000d052:	781b      	ldrb	r3, [r3, #0]
9000d054:	021b      	lsls	r3, r3, #8
9000d056:	687a      	ldr	r2, [r7, #4]
9000d058:	3208      	adds	r2, #8
9000d05a:	7812      	ldrb	r2, [r2, #0]
9000d05c:	431a      	orrs	r2, r3
9000d05e:	693b      	ldr	r3, [r7, #16]
9000d060:	60da      	str	r2, [r3, #12]

    if (SCSI_CheckAddressRange(pdev, lun, p_scsi_blk->addr, p_scsi_blk->len) < 0)
9000d062:	693b      	ldr	r3, [r7, #16]
9000d064:	689a      	ldr	r2, [r3, #8]
9000d066:	693b      	ldr	r3, [r7, #16]
9000d068:	68db      	ldr	r3, [r3, #12]
9000d06a:	7af9      	ldrb	r1, [r7, #11]
9000d06c:	68f8      	ldr	r0, [r7, #12]
9000d06e:	f000 fb6d 	bl	9000d74c <SCSI_CheckAddressRange>
9000d072:	4603      	mov	r3, r0
9000d074:	2b00      	cmp	r3, #0
9000d076:	da02      	bge.n	9000d07e <SCSI_Read10+0x106>
    {
      return -1; /* error */
9000d078:	f04f 33ff 	mov.w	r3, #4294967295
9000d07c:	e022      	b.n	9000d0c4 <SCSI_Read10+0x14c>
    }

    /* cases 4,5 : Hi <> Dn */
    if (hmsc->cbw.dDataLength != (p_scsi_blk->len * p_scsi_blk->size))
9000d07e:	697b      	ldr	r3, [r7, #20]
9000d080:	f8d3 2218 	ldr.w	r2, [r3, #536]	@ 0x218
9000d084:	693b      	ldr	r3, [r7, #16]
9000d086:	68db      	ldr	r3, [r3, #12]
9000d088:	6939      	ldr	r1, [r7, #16]
9000d08a:	8809      	ldrh	r1, [r1, #0]
9000d08c:	fb01 f303 	mul.w	r3, r1, r3
9000d090:	429a      	cmp	r2, r3
9000d092:	d00a      	beq.n	9000d0aa <SCSI_Read10+0x132>
    {
      SCSI_SenseCode(pdev, hmsc->cbw.bLUN, ILLEGAL_REQUEST, INVALID_CDB);
9000d094:	697b      	ldr	r3, [r7, #20]
9000d096:	f893 121d 	ldrb.w	r1, [r3, #541]	@ 0x21d
9000d09a:	2320      	movs	r3, #32
9000d09c:	2205      	movs	r2, #5
9000d09e:	68f8      	ldr	r0, [r7, #12]
9000d0a0:	f7ff fe9d 	bl	9000cdde <SCSI_SenseCode>
      return -1;
9000d0a4:	f04f 33ff 	mov.w	r3, #4294967295
9000d0a8:	e00c      	b.n	9000d0c4 <SCSI_Read10+0x14c>
    }

    hmsc->bot_state = USBD_BOT_DATA_IN;
9000d0aa:	697b      	ldr	r3, [r7, #20]
9000d0ac:	2202      	movs	r2, #2
9000d0ae:	721a      	strb	r2, [r3, #8]
  }
  hmsc->bot_data_length = MSC_MEDIA_PACKET;
9000d0b0:	697b      	ldr	r3, [r7, #20]
9000d0b2:	f44f 7200 	mov.w	r2, #512	@ 0x200
9000d0b6:	60da      	str	r2, [r3, #12]

  return SCSI_ProcessRead(pdev, lun);
9000d0b8:	7afb      	ldrb	r3, [r7, #11]
9000d0ba:	4619      	mov	r1, r3
9000d0bc:	68f8      	ldr	r0, [r7, #12]
9000d0be:	f000 fb77 	bl	9000d7b0 <SCSI_ProcessRead>
9000d0c2:	4603      	mov	r3, r0
}
9000d0c4:	4618      	mov	r0, r3
9000d0c6:	3718      	adds	r7, #24
9000d0c8:	46bd      	mov	sp, r7
9000d0ca:	bd80      	pop	{r7, pc}

9000d0cc <SCSI_Read12>:
  * @param  lun: Logical unit number
  * @param  params: Command parameters
  * @retval status
  */
static int8_t SCSI_Read12(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t *params)
{
9000d0cc:	b580      	push	{r7, lr}
9000d0ce:	b086      	sub	sp, #24
9000d0d0:	af00      	add	r7, sp, #0
9000d0d2:	60f8      	str	r0, [r7, #12]
9000d0d4:	460b      	mov	r3, r1
9000d0d6:	607a      	str	r2, [r7, #4]
9000d0d8:	72fb      	strb	r3, [r7, #11]
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000d0da:	68fb      	ldr	r3, [r7, #12]
9000d0dc:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000d0e0:	68fb      	ldr	r3, [r7, #12]
9000d0e2:	32b0      	adds	r2, #176	@ 0xb0
9000d0e4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000d0e8:	617b      	str	r3, [r7, #20]
  USBD_MSC_BOT_LUN_TypeDef *p_scsi_blk = &hmsc->scsi_blk[lun];
9000d0ea:	7afb      	ldrb	r3, [r7, #11]
9000d0ec:	3326      	adds	r3, #38	@ 0x26
9000d0ee:	011b      	lsls	r3, r3, #4
9000d0f0:	697a      	ldr	r2, [r7, #20]
9000d0f2:	4413      	add	r3, r2
9000d0f4:	3304      	adds	r3, #4
9000d0f6:	613b      	str	r3, [r7, #16]

  if (hmsc == NULL)
9000d0f8:	697b      	ldr	r3, [r7, #20]
9000d0fa:	2b00      	cmp	r3, #0
9000d0fc:	d102      	bne.n	9000d104 <SCSI_Read12+0x38>
  {
    return -1;
9000d0fe:	f04f 33ff 	mov.w	r3, #4294967295
9000d102:	e094      	b.n	9000d22e <SCSI_Read12+0x162>
  }

  if (hmsc->bot_state == USBD_BOT_IDLE) /* Idle */
9000d104:	697b      	ldr	r3, [r7, #20]
9000d106:	7a1b      	ldrb	r3, [r3, #8]
9000d108:	2b00      	cmp	r3, #0
9000d10a:	f040 8086 	bne.w	9000d21a <SCSI_Read12+0x14e>
  {
    /* case 10 : Ho <> Di */
    if ((hmsc->cbw.bmFlags & 0x80U) != 0x80U)
9000d10e:	697b      	ldr	r3, [r7, #20]
9000d110:	f893 321c 	ldrb.w	r3, [r3, #540]	@ 0x21c
9000d114:	b25b      	sxtb	r3, r3
9000d116:	2b00      	cmp	r3, #0
9000d118:	db0a      	blt.n	9000d130 <SCSI_Read12+0x64>
    {
      SCSI_SenseCode(pdev, hmsc->cbw.bLUN, ILLEGAL_REQUEST, INVALID_CDB);
9000d11a:	697b      	ldr	r3, [r7, #20]
9000d11c:	f893 121d 	ldrb.w	r1, [r3, #541]	@ 0x21d
9000d120:	2320      	movs	r3, #32
9000d122:	2205      	movs	r2, #5
9000d124:	68f8      	ldr	r0, [r7, #12]
9000d126:	f7ff fe5a 	bl	9000cdde <SCSI_SenseCode>
      return -1;
9000d12a:	f04f 33ff 	mov.w	r3, #4294967295
9000d12e:	e07e      	b.n	9000d22e <SCSI_Read12+0x162>
    }

    if (hmsc->scsi_medium_state == SCSI_MEDIUM_EJECTED)
9000d130:	697b      	ldr	r3, [r7, #20]
9000d132:	f893 3262 	ldrb.w	r3, [r3, #610]	@ 0x262
9000d136:	2b02      	cmp	r3, #2
9000d138:	d108      	bne.n	9000d14c <SCSI_Read12+0x80>
    {
      SCSI_SenseCode(pdev, lun, NOT_READY, MEDIUM_NOT_PRESENT);
9000d13a:	7af9      	ldrb	r1, [r7, #11]
9000d13c:	233a      	movs	r3, #58	@ 0x3a
9000d13e:	2202      	movs	r2, #2
9000d140:	68f8      	ldr	r0, [r7, #12]
9000d142:	f7ff fe4c 	bl	9000cdde <SCSI_SenseCode>
      return -1;
9000d146:	f04f 33ff 	mov.w	r3, #4294967295
9000d14a:	e070      	b.n	9000d22e <SCSI_Read12+0x162>
    }

    if (((USBD_StorageTypeDef *)pdev->pUserData[pdev->classId])->IsReady(lun) != 0)
9000d14c:	68fb      	ldr	r3, [r7, #12]
9000d14e:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
9000d152:	68fa      	ldr	r2, [r7, #12]
9000d154:	33b0      	adds	r3, #176	@ 0xb0
9000d156:	009b      	lsls	r3, r3, #2
9000d158:	4413      	add	r3, r2
9000d15a:	685b      	ldr	r3, [r3, #4]
9000d15c:	689b      	ldr	r3, [r3, #8]
9000d15e:	7afa      	ldrb	r2, [r7, #11]
9000d160:	4610      	mov	r0, r2
9000d162:	4798      	blx	r3
9000d164:	4603      	mov	r3, r0
9000d166:	2b00      	cmp	r3, #0
9000d168:	d008      	beq.n	9000d17c <SCSI_Read12+0xb0>
    {
      SCSI_SenseCode(pdev, lun, NOT_READY, MEDIUM_NOT_PRESENT);
9000d16a:	7af9      	ldrb	r1, [r7, #11]
9000d16c:	233a      	movs	r3, #58	@ 0x3a
9000d16e:	2202      	movs	r2, #2
9000d170:	68f8      	ldr	r0, [r7, #12]
9000d172:	f7ff fe34 	bl	9000cdde <SCSI_SenseCode>
      return -1;
9000d176:	f04f 33ff 	mov.w	r3, #4294967295
9000d17a:	e058      	b.n	9000d22e <SCSI_Read12+0x162>
    }

    p_scsi_blk->addr = ((uint32_t)params[2] << 24) |
9000d17c:	687b      	ldr	r3, [r7, #4]
9000d17e:	3302      	adds	r3, #2
9000d180:	781b      	ldrb	r3, [r3, #0]
9000d182:	061a      	lsls	r2, r3, #24
                       ((uint32_t)params[3] << 16) |
9000d184:	687b      	ldr	r3, [r7, #4]
9000d186:	3303      	adds	r3, #3
9000d188:	781b      	ldrb	r3, [r3, #0]
9000d18a:	041b      	lsls	r3, r3, #16
    p_scsi_blk->addr = ((uint32_t)params[2] << 24) |
9000d18c:	431a      	orrs	r2, r3
                       ((uint32_t)params[4] <<  8) |
9000d18e:	687b      	ldr	r3, [r7, #4]
9000d190:	3304      	adds	r3, #4
9000d192:	781b      	ldrb	r3, [r3, #0]
9000d194:	021b      	lsls	r3, r3, #8
                       ((uint32_t)params[3] << 16) |
9000d196:	4313      	orrs	r3, r2
                       (uint32_t)params[5];
9000d198:	687a      	ldr	r2, [r7, #4]
9000d19a:	3205      	adds	r2, #5
9000d19c:	7812      	ldrb	r2, [r2, #0]
                       ((uint32_t)params[4] <<  8) |
9000d19e:	431a      	orrs	r2, r3
    p_scsi_blk->addr = ((uint32_t)params[2] << 24) |
9000d1a0:	693b      	ldr	r3, [r7, #16]
9000d1a2:	609a      	str	r2, [r3, #8]

    p_scsi_blk->len = ((uint32_t)params[6] << 24) |
9000d1a4:	687b      	ldr	r3, [r7, #4]
9000d1a6:	3306      	adds	r3, #6
9000d1a8:	781b      	ldrb	r3, [r3, #0]
9000d1aa:	061a      	lsls	r2, r3, #24
                      ((uint32_t)params[7] << 16) |
9000d1ac:	687b      	ldr	r3, [r7, #4]
9000d1ae:	3307      	adds	r3, #7
9000d1b0:	781b      	ldrb	r3, [r3, #0]
9000d1b2:	041b      	lsls	r3, r3, #16
    p_scsi_blk->len = ((uint32_t)params[6] << 24) |
9000d1b4:	431a      	orrs	r2, r3
                      ((uint32_t)params[8] << 8) |
9000d1b6:	687b      	ldr	r3, [r7, #4]
9000d1b8:	3308      	adds	r3, #8
9000d1ba:	781b      	ldrb	r3, [r3, #0]
9000d1bc:	021b      	lsls	r3, r3, #8
                      ((uint32_t)params[7] << 16) |
9000d1be:	4313      	orrs	r3, r2
                      (uint32_t)params[9];
9000d1c0:	687a      	ldr	r2, [r7, #4]
9000d1c2:	3209      	adds	r2, #9
9000d1c4:	7812      	ldrb	r2, [r2, #0]
                      ((uint32_t)params[8] << 8) |
9000d1c6:	431a      	orrs	r2, r3
    p_scsi_blk->len = ((uint32_t)params[6] << 24) |
9000d1c8:	693b      	ldr	r3, [r7, #16]
9000d1ca:	60da      	str	r2, [r3, #12]

    if (SCSI_CheckAddressRange(pdev, lun, p_scsi_blk->addr, p_scsi_blk->len) < 0)
9000d1cc:	693b      	ldr	r3, [r7, #16]
9000d1ce:	689a      	ldr	r2, [r3, #8]
9000d1d0:	693b      	ldr	r3, [r7, #16]
9000d1d2:	68db      	ldr	r3, [r3, #12]
9000d1d4:	7af9      	ldrb	r1, [r7, #11]
9000d1d6:	68f8      	ldr	r0, [r7, #12]
9000d1d8:	f000 fab8 	bl	9000d74c <SCSI_CheckAddressRange>
9000d1dc:	4603      	mov	r3, r0
9000d1de:	2b00      	cmp	r3, #0
9000d1e0:	da02      	bge.n	9000d1e8 <SCSI_Read12+0x11c>
    {
      return -1; /* error */
9000d1e2:	f04f 33ff 	mov.w	r3, #4294967295
9000d1e6:	e022      	b.n	9000d22e <SCSI_Read12+0x162>
    }

    /* cases 4,5 : Hi <> Dn */
    if (hmsc->cbw.dDataLength != (p_scsi_blk->len * p_scsi_blk->size))
9000d1e8:	697b      	ldr	r3, [r7, #20]
9000d1ea:	f8d3 2218 	ldr.w	r2, [r3, #536]	@ 0x218
9000d1ee:	693b      	ldr	r3, [r7, #16]
9000d1f0:	68db      	ldr	r3, [r3, #12]
9000d1f2:	6939      	ldr	r1, [r7, #16]
9000d1f4:	8809      	ldrh	r1, [r1, #0]
9000d1f6:	fb01 f303 	mul.w	r3, r1, r3
9000d1fa:	429a      	cmp	r2, r3
9000d1fc:	d00a      	beq.n	9000d214 <SCSI_Read12+0x148>
    {
      SCSI_SenseCode(pdev, hmsc->cbw.bLUN, ILLEGAL_REQUEST, INVALID_CDB);
9000d1fe:	697b      	ldr	r3, [r7, #20]
9000d200:	f893 121d 	ldrb.w	r1, [r3, #541]	@ 0x21d
9000d204:	2320      	movs	r3, #32
9000d206:	2205      	movs	r2, #5
9000d208:	68f8      	ldr	r0, [r7, #12]
9000d20a:	f7ff fde8 	bl	9000cdde <SCSI_SenseCode>
      return -1;
9000d20e:	f04f 33ff 	mov.w	r3, #4294967295
9000d212:	e00c      	b.n	9000d22e <SCSI_Read12+0x162>
    }

    hmsc->bot_state = USBD_BOT_DATA_IN;
9000d214:	697b      	ldr	r3, [r7, #20]
9000d216:	2202      	movs	r2, #2
9000d218:	721a      	strb	r2, [r3, #8]
  }
  hmsc->bot_data_length = MSC_MEDIA_PACKET;
9000d21a:	697b      	ldr	r3, [r7, #20]
9000d21c:	f44f 7200 	mov.w	r2, #512	@ 0x200
9000d220:	60da      	str	r2, [r3, #12]

  return SCSI_ProcessRead(pdev, lun);
9000d222:	7afb      	ldrb	r3, [r7, #11]
9000d224:	4619      	mov	r1, r3
9000d226:	68f8      	ldr	r0, [r7, #12]
9000d228:	f000 fac2 	bl	9000d7b0 <SCSI_ProcessRead>
9000d22c:	4603      	mov	r3, r0
}
9000d22e:	4618      	mov	r0, r3
9000d230:	3718      	adds	r7, #24
9000d232:	46bd      	mov	sp, r7
9000d234:	bd80      	pop	{r7, pc}
	...

9000d238 <SCSI_Write10>:
  * @param  lun: Logical unit number
  * @param  params: Command parameters
  * @retval status
  */
static int8_t SCSI_Write10(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t *params)
{
9000d238:	b580      	push	{r7, lr}
9000d23a:	b088      	sub	sp, #32
9000d23c:	af00      	add	r7, sp, #0
9000d23e:	60f8      	str	r0, [r7, #12]
9000d240:	460b      	mov	r3, r1
9000d242:	607a      	str	r2, [r7, #4]
9000d244:	72fb      	strb	r3, [r7, #11]
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000d246:	68fb      	ldr	r3, [r7, #12]
9000d248:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000d24c:	68fb      	ldr	r3, [r7, #12]
9000d24e:	32b0      	adds	r2, #176	@ 0xb0
9000d250:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000d254:	61fb      	str	r3, [r7, #28]
  USBD_MSC_BOT_LUN_TypeDef *p_scsi_blk = &hmsc->scsi_blk[lun];
9000d256:	7afb      	ldrb	r3, [r7, #11]
9000d258:	3326      	adds	r3, #38	@ 0x26
9000d25a:	011b      	lsls	r3, r3, #4
9000d25c:	69fa      	ldr	r2, [r7, #28]
9000d25e:	4413      	add	r3, r2
9000d260:	3304      	adds	r3, #4
9000d262:	61bb      	str	r3, [r7, #24]
  uint32_t len;

  if (hmsc == NULL)
9000d264:	69fb      	ldr	r3, [r7, #28]
9000d266:	2b00      	cmp	r3, #0
9000d268:	d102      	bne.n	9000d270 <SCSI_Write10+0x38>
  {
    return -1;
9000d26a:	f04f 33ff 	mov.w	r3, #4294967295
9000d26e:	e0b4      	b.n	9000d3da <SCSI_Write10+0x1a2>
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  MSCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (hmsc->bot_state == USBD_BOT_IDLE) /* Idle */
9000d270:	69fb      	ldr	r3, [r7, #28]
9000d272:	7a1b      	ldrb	r3, [r3, #8]
9000d274:	2b00      	cmp	r3, #0
9000d276:	f040 80aa 	bne.w	9000d3ce <SCSI_Write10+0x196>
  {
    if (hmsc->cbw.dDataLength == 0U)
9000d27a:	69fb      	ldr	r3, [r7, #28]
9000d27c:	f8d3 3218 	ldr.w	r3, [r3, #536]	@ 0x218
9000d280:	2b00      	cmp	r3, #0
9000d282:	d10a      	bne.n	9000d29a <SCSI_Write10+0x62>
    {
      SCSI_SenseCode(pdev, hmsc->cbw.bLUN, ILLEGAL_REQUEST, INVALID_CDB);
9000d284:	69fb      	ldr	r3, [r7, #28]
9000d286:	f893 121d 	ldrb.w	r1, [r3, #541]	@ 0x21d
9000d28a:	2320      	movs	r3, #32
9000d28c:	2205      	movs	r2, #5
9000d28e:	68f8      	ldr	r0, [r7, #12]
9000d290:	f7ff fda5 	bl	9000cdde <SCSI_SenseCode>
      return -1;
9000d294:	f04f 33ff 	mov.w	r3, #4294967295
9000d298:	e09f      	b.n	9000d3da <SCSI_Write10+0x1a2>
    }

    /* case 8 : Hi <> Do */
    if ((hmsc->cbw.bmFlags & 0x80U) == 0x80U)
9000d29a:	69fb      	ldr	r3, [r7, #28]
9000d29c:	f893 321c 	ldrb.w	r3, [r3, #540]	@ 0x21c
9000d2a0:	b25b      	sxtb	r3, r3
9000d2a2:	2b00      	cmp	r3, #0
9000d2a4:	da0a      	bge.n	9000d2bc <SCSI_Write10+0x84>
    {
      SCSI_SenseCode(pdev, hmsc->cbw.bLUN, ILLEGAL_REQUEST, INVALID_CDB);
9000d2a6:	69fb      	ldr	r3, [r7, #28]
9000d2a8:	f893 121d 	ldrb.w	r1, [r3, #541]	@ 0x21d
9000d2ac:	2320      	movs	r3, #32
9000d2ae:	2205      	movs	r2, #5
9000d2b0:	68f8      	ldr	r0, [r7, #12]
9000d2b2:	f7ff fd94 	bl	9000cdde <SCSI_SenseCode>
      return -1;
9000d2b6:	f04f 33ff 	mov.w	r3, #4294967295
9000d2ba:	e08e      	b.n	9000d3da <SCSI_Write10+0x1a2>
    }

    /* Check whether Media is ready */
    if (((USBD_StorageTypeDef *)pdev->pUserData[pdev->classId])->IsReady(lun) != 0)
9000d2bc:	68fb      	ldr	r3, [r7, #12]
9000d2be:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
9000d2c2:	68fa      	ldr	r2, [r7, #12]
9000d2c4:	33b0      	adds	r3, #176	@ 0xb0
9000d2c6:	009b      	lsls	r3, r3, #2
9000d2c8:	4413      	add	r3, r2
9000d2ca:	685b      	ldr	r3, [r3, #4]
9000d2cc:	689b      	ldr	r3, [r3, #8]
9000d2ce:	7afa      	ldrb	r2, [r7, #11]
9000d2d0:	4610      	mov	r0, r2
9000d2d2:	4798      	blx	r3
9000d2d4:	4603      	mov	r3, r0
9000d2d6:	2b00      	cmp	r3, #0
9000d2d8:	d008      	beq.n	9000d2ec <SCSI_Write10+0xb4>
    {
      SCSI_SenseCode(pdev, lun, NOT_READY, MEDIUM_NOT_PRESENT);
9000d2da:	7af9      	ldrb	r1, [r7, #11]
9000d2dc:	233a      	movs	r3, #58	@ 0x3a
9000d2de:	2202      	movs	r2, #2
9000d2e0:	68f8      	ldr	r0, [r7, #12]
9000d2e2:	f7ff fd7c 	bl	9000cdde <SCSI_SenseCode>
      return -1;
9000d2e6:	f04f 33ff 	mov.w	r3, #4294967295
9000d2ea:	e076      	b.n	9000d3da <SCSI_Write10+0x1a2>
    }

    /* Check If media is write-protected */
    if (((USBD_StorageTypeDef *)pdev->pUserData[pdev->classId])->IsWriteProtected(lun) != 0)
9000d2ec:	68fb      	ldr	r3, [r7, #12]
9000d2ee:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
9000d2f2:	68fa      	ldr	r2, [r7, #12]
9000d2f4:	33b0      	adds	r3, #176	@ 0xb0
9000d2f6:	009b      	lsls	r3, r3, #2
9000d2f8:	4413      	add	r3, r2
9000d2fa:	685b      	ldr	r3, [r3, #4]
9000d2fc:	68db      	ldr	r3, [r3, #12]
9000d2fe:	7afa      	ldrb	r2, [r7, #11]
9000d300:	4610      	mov	r0, r2
9000d302:	4798      	blx	r3
9000d304:	4603      	mov	r3, r0
9000d306:	2b00      	cmp	r3, #0
9000d308:	d008      	beq.n	9000d31c <SCSI_Write10+0xe4>
    {
      SCSI_SenseCode(pdev, lun, NOT_READY, WRITE_PROTECTED);
9000d30a:	7af9      	ldrb	r1, [r7, #11]
9000d30c:	2327      	movs	r3, #39	@ 0x27
9000d30e:	2202      	movs	r2, #2
9000d310:	68f8      	ldr	r0, [r7, #12]
9000d312:	f7ff fd64 	bl	9000cdde <SCSI_SenseCode>
      return -1;
9000d316:	f04f 33ff 	mov.w	r3, #4294967295
9000d31a:	e05e      	b.n	9000d3da <SCSI_Write10+0x1a2>
    }

    p_scsi_blk->addr = ((uint32_t)params[2] << 24) |
9000d31c:	687b      	ldr	r3, [r7, #4]
9000d31e:	3302      	adds	r3, #2
9000d320:	781b      	ldrb	r3, [r3, #0]
9000d322:	061a      	lsls	r2, r3, #24
                       ((uint32_t)params[3] << 16) |
9000d324:	687b      	ldr	r3, [r7, #4]
9000d326:	3303      	adds	r3, #3
9000d328:	781b      	ldrb	r3, [r3, #0]
9000d32a:	041b      	lsls	r3, r3, #16
    p_scsi_blk->addr = ((uint32_t)params[2] << 24) |
9000d32c:	431a      	orrs	r2, r3
                       ((uint32_t)params[4] << 8) |
9000d32e:	687b      	ldr	r3, [r7, #4]
9000d330:	3304      	adds	r3, #4
9000d332:	781b      	ldrb	r3, [r3, #0]
9000d334:	021b      	lsls	r3, r3, #8
                       ((uint32_t)params[3] << 16) |
9000d336:	4313      	orrs	r3, r2
                       (uint32_t)params[5];
9000d338:	687a      	ldr	r2, [r7, #4]
9000d33a:	3205      	adds	r2, #5
9000d33c:	7812      	ldrb	r2, [r2, #0]
                       ((uint32_t)params[4] << 8) |
9000d33e:	431a      	orrs	r2, r3
    p_scsi_blk->addr = ((uint32_t)params[2] << 24) |
9000d340:	69bb      	ldr	r3, [r7, #24]
9000d342:	609a      	str	r2, [r3, #8]

    p_scsi_blk->len = ((uint32_t)params[7] << 8) |
9000d344:	687b      	ldr	r3, [r7, #4]
9000d346:	3307      	adds	r3, #7
9000d348:	781b      	ldrb	r3, [r3, #0]
9000d34a:	021b      	lsls	r3, r3, #8
                      (uint32_t)params[8];
9000d34c:	687a      	ldr	r2, [r7, #4]
9000d34e:	3208      	adds	r2, #8
9000d350:	7812      	ldrb	r2, [r2, #0]
    p_scsi_blk->len = ((uint32_t)params[7] << 8) |
9000d352:	431a      	orrs	r2, r3
9000d354:	69bb      	ldr	r3, [r7, #24]
9000d356:	60da      	str	r2, [r3, #12]

    /* check if LBA address is in the right range */
    if (SCSI_CheckAddressRange(pdev, lun, p_scsi_blk->addr, p_scsi_blk->len) < 0)
9000d358:	69bb      	ldr	r3, [r7, #24]
9000d35a:	689a      	ldr	r2, [r3, #8]
9000d35c:	69bb      	ldr	r3, [r7, #24]
9000d35e:	68db      	ldr	r3, [r3, #12]
9000d360:	7af9      	ldrb	r1, [r7, #11]
9000d362:	68f8      	ldr	r0, [r7, #12]
9000d364:	f000 f9f2 	bl	9000d74c <SCSI_CheckAddressRange>
9000d368:	4603      	mov	r3, r0
9000d36a:	2b00      	cmp	r3, #0
9000d36c:	da02      	bge.n	9000d374 <SCSI_Write10+0x13c>
    {
      return -1; /* error */
9000d36e:	f04f 33ff 	mov.w	r3, #4294967295
9000d372:	e032      	b.n	9000d3da <SCSI_Write10+0x1a2>
    }

    len = p_scsi_blk->len * p_scsi_blk->size;
9000d374:	69bb      	ldr	r3, [r7, #24]
9000d376:	68db      	ldr	r3, [r3, #12]
9000d378:	69ba      	ldr	r2, [r7, #24]
9000d37a:	8812      	ldrh	r2, [r2, #0]
9000d37c:	fb02 f303 	mul.w	r3, r2, r3
9000d380:	617b      	str	r3, [r7, #20]

    /* cases 3,11,13 : Hn,Ho <> D0 */
    if (hmsc->cbw.dDataLength != len)
9000d382:	69fb      	ldr	r3, [r7, #28]
9000d384:	f8d3 3218 	ldr.w	r3, [r3, #536]	@ 0x218
9000d388:	697a      	ldr	r2, [r7, #20]
9000d38a:	429a      	cmp	r2, r3
9000d38c:	d00a      	beq.n	9000d3a4 <SCSI_Write10+0x16c>
    {
      SCSI_SenseCode(pdev, hmsc->cbw.bLUN, ILLEGAL_REQUEST, INVALID_CDB);
9000d38e:	69fb      	ldr	r3, [r7, #28]
9000d390:	f893 121d 	ldrb.w	r1, [r3, #541]	@ 0x21d
9000d394:	2320      	movs	r3, #32
9000d396:	2205      	movs	r2, #5
9000d398:	68f8      	ldr	r0, [r7, #12]
9000d39a:	f7ff fd20 	bl	9000cdde <SCSI_SenseCode>
      return -1;
9000d39e:	f04f 33ff 	mov.w	r3, #4294967295
9000d3a2:	e01a      	b.n	9000d3da <SCSI_Write10+0x1a2>
    }

    len = MIN(len, MSC_MEDIA_PACKET);
9000d3a4:	697b      	ldr	r3, [r7, #20]
9000d3a6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
9000d3aa:	bf28      	it	cs
9000d3ac:	f44f 7300 	movcs.w	r3, #512	@ 0x200
9000d3b0:	617b      	str	r3, [r7, #20]

    /* Prepare EP to receive first data packet */
    hmsc->bot_state = USBD_BOT_DATA_OUT;
9000d3b2:	69fb      	ldr	r3, [r7, #28]
9000d3b4:	2201      	movs	r2, #1
9000d3b6:	721a      	strb	r2, [r3, #8]
    (void)USBD_LL_PrepareReceive(pdev, MSCOutEpAdd, hmsc->bot_data, len);
9000d3b8:	4b0a      	ldr	r3, [pc, #40]	@ (9000d3e4 <SCSI_Write10+0x1ac>)
9000d3ba:	7819      	ldrb	r1, [r3, #0]
9000d3bc:	69fb      	ldr	r3, [r7, #28]
9000d3be:	f103 0210 	add.w	r2, r3, #16
9000d3c2:	697b      	ldr	r3, [r7, #20]
9000d3c4:	68f8      	ldr	r0, [r7, #12]
9000d3c6:	f7f3 ff4e 	bl	90001266 <USBD_LL_PrepareReceive>
  else /* Write Process ongoing */
  {
    return SCSI_ProcessWrite(pdev, lun);
  }

  return 0;
9000d3ca:	2300      	movs	r3, #0
9000d3cc:	e005      	b.n	9000d3da <SCSI_Write10+0x1a2>
    return SCSI_ProcessWrite(pdev, lun);
9000d3ce:	7afb      	ldrb	r3, [r7, #11]
9000d3d0:	4619      	mov	r1, r3
9000d3d2:	68f8      	ldr	r0, [r7, #12]
9000d3d4:	f000 fa6e 	bl	9000d8b4 <SCSI_ProcessWrite>
9000d3d8:	4603      	mov	r3, r0
}
9000d3da:	4618      	mov	r0, r3
9000d3dc:	3720      	adds	r7, #32
9000d3de:	46bd      	mov	sp, r7
9000d3e0:	bd80      	pop	{r7, pc}
9000d3e2:	bf00      	nop
9000d3e4:	240000e3 	.word	0x240000e3

9000d3e8 <SCSI_Write12>:
  * @param  lun: Logical unit number
  * @param  params: Command parameters
  * @retval status
  */
static int8_t SCSI_Write12(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t *params)
{
9000d3e8:	b580      	push	{r7, lr}
9000d3ea:	b088      	sub	sp, #32
9000d3ec:	af00      	add	r7, sp, #0
9000d3ee:	60f8      	str	r0, [r7, #12]
9000d3f0:	460b      	mov	r3, r1
9000d3f2:	607a      	str	r2, [r7, #4]
9000d3f4:	72fb      	strb	r3, [r7, #11]
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000d3f6:	68fb      	ldr	r3, [r7, #12]
9000d3f8:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000d3fc:	68fb      	ldr	r3, [r7, #12]
9000d3fe:	32b0      	adds	r2, #176	@ 0xb0
9000d400:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000d404:	61fb      	str	r3, [r7, #28]
  USBD_MSC_BOT_LUN_TypeDef *p_scsi_blk = &hmsc->scsi_blk[lun];
9000d406:	7afb      	ldrb	r3, [r7, #11]
9000d408:	3326      	adds	r3, #38	@ 0x26
9000d40a:	011b      	lsls	r3, r3, #4
9000d40c:	69fa      	ldr	r2, [r7, #28]
9000d40e:	4413      	add	r3, r2
9000d410:	3304      	adds	r3, #4
9000d412:	61bb      	str	r3, [r7, #24]
  uint32_t len;

  if (hmsc == NULL)
9000d414:	69fb      	ldr	r3, [r7, #28]
9000d416:	2b00      	cmp	r3, #0
9000d418:	d102      	bne.n	9000d420 <SCSI_Write12+0x38>
  {
    return -1;
9000d41a:	f04f 33ff 	mov.w	r3, #4294967295
9000d41e:	e0c4      	b.n	9000d5aa <SCSI_Write12+0x1c2>
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  MSCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (hmsc->bot_state == USBD_BOT_IDLE) /* Idle */
9000d420:	69fb      	ldr	r3, [r7, #28]
9000d422:	7a1b      	ldrb	r3, [r3, #8]
9000d424:	2b00      	cmp	r3, #0
9000d426:	f040 80ba 	bne.w	9000d59e <SCSI_Write12+0x1b6>
  {
    if (hmsc->cbw.dDataLength == 0U)
9000d42a:	69fb      	ldr	r3, [r7, #28]
9000d42c:	f8d3 3218 	ldr.w	r3, [r3, #536]	@ 0x218
9000d430:	2b00      	cmp	r3, #0
9000d432:	d10a      	bne.n	9000d44a <SCSI_Write12+0x62>
    {
      SCSI_SenseCode(pdev, hmsc->cbw.bLUN, ILLEGAL_REQUEST, INVALID_CDB);
9000d434:	69fb      	ldr	r3, [r7, #28]
9000d436:	f893 121d 	ldrb.w	r1, [r3, #541]	@ 0x21d
9000d43a:	2320      	movs	r3, #32
9000d43c:	2205      	movs	r2, #5
9000d43e:	68f8      	ldr	r0, [r7, #12]
9000d440:	f7ff fccd 	bl	9000cdde <SCSI_SenseCode>
      return -1;
9000d444:	f04f 33ff 	mov.w	r3, #4294967295
9000d448:	e0af      	b.n	9000d5aa <SCSI_Write12+0x1c2>
    }

    /* case 8 : Hi <> Do */
    if ((hmsc->cbw.bmFlags & 0x80U) == 0x80U)
9000d44a:	69fb      	ldr	r3, [r7, #28]
9000d44c:	f893 321c 	ldrb.w	r3, [r3, #540]	@ 0x21c
9000d450:	b25b      	sxtb	r3, r3
9000d452:	2b00      	cmp	r3, #0
9000d454:	da0a      	bge.n	9000d46c <SCSI_Write12+0x84>
    {
      SCSI_SenseCode(pdev, hmsc->cbw.bLUN, ILLEGAL_REQUEST, INVALID_CDB);
9000d456:	69fb      	ldr	r3, [r7, #28]
9000d458:	f893 121d 	ldrb.w	r1, [r3, #541]	@ 0x21d
9000d45c:	2320      	movs	r3, #32
9000d45e:	2205      	movs	r2, #5
9000d460:	68f8      	ldr	r0, [r7, #12]
9000d462:	f7ff fcbc 	bl	9000cdde <SCSI_SenseCode>
      return -1;
9000d466:	f04f 33ff 	mov.w	r3, #4294967295
9000d46a:	e09e      	b.n	9000d5aa <SCSI_Write12+0x1c2>
    }

    /* Check whether Media is ready */
    if (((USBD_StorageTypeDef *)pdev->pUserData[pdev->classId])->IsReady(lun) != 0)
9000d46c:	68fb      	ldr	r3, [r7, #12]
9000d46e:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
9000d472:	68fa      	ldr	r2, [r7, #12]
9000d474:	33b0      	adds	r3, #176	@ 0xb0
9000d476:	009b      	lsls	r3, r3, #2
9000d478:	4413      	add	r3, r2
9000d47a:	685b      	ldr	r3, [r3, #4]
9000d47c:	689b      	ldr	r3, [r3, #8]
9000d47e:	7afa      	ldrb	r2, [r7, #11]
9000d480:	4610      	mov	r0, r2
9000d482:	4798      	blx	r3
9000d484:	4603      	mov	r3, r0
9000d486:	2b00      	cmp	r3, #0
9000d488:	d00b      	beq.n	9000d4a2 <SCSI_Write12+0xba>
    {
      SCSI_SenseCode(pdev, lun, NOT_READY, MEDIUM_NOT_PRESENT);
9000d48a:	7af9      	ldrb	r1, [r7, #11]
9000d48c:	233a      	movs	r3, #58	@ 0x3a
9000d48e:	2202      	movs	r2, #2
9000d490:	68f8      	ldr	r0, [r7, #12]
9000d492:	f7ff fca4 	bl	9000cdde <SCSI_SenseCode>
      hmsc->bot_state = USBD_BOT_NO_DATA;
9000d496:	69fb      	ldr	r3, [r7, #28]
9000d498:	2205      	movs	r2, #5
9000d49a:	721a      	strb	r2, [r3, #8]
      return -1;
9000d49c:	f04f 33ff 	mov.w	r3, #4294967295
9000d4a0:	e083      	b.n	9000d5aa <SCSI_Write12+0x1c2>
    }

    /* Check If media is write-protected */
    if (((USBD_StorageTypeDef *)pdev->pUserData[pdev->classId])->IsWriteProtected(lun) != 0)
9000d4a2:	68fb      	ldr	r3, [r7, #12]
9000d4a4:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
9000d4a8:	68fa      	ldr	r2, [r7, #12]
9000d4aa:	33b0      	adds	r3, #176	@ 0xb0
9000d4ac:	009b      	lsls	r3, r3, #2
9000d4ae:	4413      	add	r3, r2
9000d4b0:	685b      	ldr	r3, [r3, #4]
9000d4b2:	68db      	ldr	r3, [r3, #12]
9000d4b4:	7afa      	ldrb	r2, [r7, #11]
9000d4b6:	4610      	mov	r0, r2
9000d4b8:	4798      	blx	r3
9000d4ba:	4603      	mov	r3, r0
9000d4bc:	2b00      	cmp	r3, #0
9000d4be:	d00b      	beq.n	9000d4d8 <SCSI_Write12+0xf0>
    {
      SCSI_SenseCode(pdev, lun, NOT_READY, WRITE_PROTECTED);
9000d4c0:	7af9      	ldrb	r1, [r7, #11]
9000d4c2:	2327      	movs	r3, #39	@ 0x27
9000d4c4:	2202      	movs	r2, #2
9000d4c6:	68f8      	ldr	r0, [r7, #12]
9000d4c8:	f7ff fc89 	bl	9000cdde <SCSI_SenseCode>
      hmsc->bot_state = USBD_BOT_NO_DATA;
9000d4cc:	69fb      	ldr	r3, [r7, #28]
9000d4ce:	2205      	movs	r2, #5
9000d4d0:	721a      	strb	r2, [r3, #8]
      return -1;
9000d4d2:	f04f 33ff 	mov.w	r3, #4294967295
9000d4d6:	e068      	b.n	9000d5aa <SCSI_Write12+0x1c2>
    }

    p_scsi_blk->addr = ((uint32_t)params[2] << 24) |
9000d4d8:	687b      	ldr	r3, [r7, #4]
9000d4da:	3302      	adds	r3, #2
9000d4dc:	781b      	ldrb	r3, [r3, #0]
9000d4de:	061a      	lsls	r2, r3, #24
                       ((uint32_t)params[3] << 16) |
9000d4e0:	687b      	ldr	r3, [r7, #4]
9000d4e2:	3303      	adds	r3, #3
9000d4e4:	781b      	ldrb	r3, [r3, #0]
9000d4e6:	041b      	lsls	r3, r3, #16
    p_scsi_blk->addr = ((uint32_t)params[2] << 24) |
9000d4e8:	431a      	orrs	r2, r3
                       ((uint32_t)params[4] << 8) |
9000d4ea:	687b      	ldr	r3, [r7, #4]
9000d4ec:	3304      	adds	r3, #4
9000d4ee:	781b      	ldrb	r3, [r3, #0]
9000d4f0:	021b      	lsls	r3, r3, #8
                       ((uint32_t)params[3] << 16) |
9000d4f2:	4313      	orrs	r3, r2
                       (uint32_t)params[5];
9000d4f4:	687a      	ldr	r2, [r7, #4]
9000d4f6:	3205      	adds	r2, #5
9000d4f8:	7812      	ldrb	r2, [r2, #0]
                       ((uint32_t)params[4] << 8) |
9000d4fa:	431a      	orrs	r2, r3
    p_scsi_blk->addr = ((uint32_t)params[2] << 24) |
9000d4fc:	69bb      	ldr	r3, [r7, #24]
9000d4fe:	609a      	str	r2, [r3, #8]

    p_scsi_blk->len = ((uint32_t)params[6] << 24) |
9000d500:	687b      	ldr	r3, [r7, #4]
9000d502:	3306      	adds	r3, #6
9000d504:	781b      	ldrb	r3, [r3, #0]
9000d506:	061a      	lsls	r2, r3, #24
                      ((uint32_t)params[7] << 16) |
9000d508:	687b      	ldr	r3, [r7, #4]
9000d50a:	3307      	adds	r3, #7
9000d50c:	781b      	ldrb	r3, [r3, #0]
9000d50e:	041b      	lsls	r3, r3, #16
    p_scsi_blk->len = ((uint32_t)params[6] << 24) |
9000d510:	431a      	orrs	r2, r3
                      ((uint32_t)params[8] << 8) |
9000d512:	687b      	ldr	r3, [r7, #4]
9000d514:	3308      	adds	r3, #8
9000d516:	781b      	ldrb	r3, [r3, #0]
9000d518:	021b      	lsls	r3, r3, #8
                      ((uint32_t)params[7] << 16) |
9000d51a:	4313      	orrs	r3, r2
                      (uint32_t)params[9];
9000d51c:	687a      	ldr	r2, [r7, #4]
9000d51e:	3209      	adds	r2, #9
9000d520:	7812      	ldrb	r2, [r2, #0]
                      ((uint32_t)params[8] << 8) |
9000d522:	431a      	orrs	r2, r3
    p_scsi_blk->len = ((uint32_t)params[6] << 24) |
9000d524:	69bb      	ldr	r3, [r7, #24]
9000d526:	60da      	str	r2, [r3, #12]

    /* check if LBA address is in the right range */
    if (SCSI_CheckAddressRange(pdev, lun, p_scsi_blk->addr, p_scsi_blk->len) < 0)
9000d528:	69bb      	ldr	r3, [r7, #24]
9000d52a:	689a      	ldr	r2, [r3, #8]
9000d52c:	69bb      	ldr	r3, [r7, #24]
9000d52e:	68db      	ldr	r3, [r3, #12]
9000d530:	7af9      	ldrb	r1, [r7, #11]
9000d532:	68f8      	ldr	r0, [r7, #12]
9000d534:	f000 f90a 	bl	9000d74c <SCSI_CheckAddressRange>
9000d538:	4603      	mov	r3, r0
9000d53a:	2b00      	cmp	r3, #0
9000d53c:	da02      	bge.n	9000d544 <SCSI_Write12+0x15c>
    {
      return -1; /* error */
9000d53e:	f04f 33ff 	mov.w	r3, #4294967295
9000d542:	e032      	b.n	9000d5aa <SCSI_Write12+0x1c2>
    }

    len = p_scsi_blk->len * p_scsi_blk->size;
9000d544:	69bb      	ldr	r3, [r7, #24]
9000d546:	68db      	ldr	r3, [r3, #12]
9000d548:	69ba      	ldr	r2, [r7, #24]
9000d54a:	8812      	ldrh	r2, [r2, #0]
9000d54c:	fb02 f303 	mul.w	r3, r2, r3
9000d550:	617b      	str	r3, [r7, #20]

    /* cases 3,11,13 : Hn,Ho <> D0 */
    if (hmsc->cbw.dDataLength != len)
9000d552:	69fb      	ldr	r3, [r7, #28]
9000d554:	f8d3 3218 	ldr.w	r3, [r3, #536]	@ 0x218
9000d558:	697a      	ldr	r2, [r7, #20]
9000d55a:	429a      	cmp	r2, r3
9000d55c:	d00a      	beq.n	9000d574 <SCSI_Write12+0x18c>
    {
      SCSI_SenseCode(pdev, hmsc->cbw.bLUN, ILLEGAL_REQUEST, INVALID_CDB);
9000d55e:	69fb      	ldr	r3, [r7, #28]
9000d560:	f893 121d 	ldrb.w	r1, [r3, #541]	@ 0x21d
9000d564:	2320      	movs	r3, #32
9000d566:	2205      	movs	r2, #5
9000d568:	68f8      	ldr	r0, [r7, #12]
9000d56a:	f7ff fc38 	bl	9000cdde <SCSI_SenseCode>
      return -1;
9000d56e:	f04f 33ff 	mov.w	r3, #4294967295
9000d572:	e01a      	b.n	9000d5aa <SCSI_Write12+0x1c2>
    }

    len = MIN(len, MSC_MEDIA_PACKET);
9000d574:	697b      	ldr	r3, [r7, #20]
9000d576:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
9000d57a:	bf28      	it	cs
9000d57c:	f44f 7300 	movcs.w	r3, #512	@ 0x200
9000d580:	617b      	str	r3, [r7, #20]

    /* Prepare EP to receive first data packet */
    hmsc->bot_state = USBD_BOT_DATA_OUT;
9000d582:	69fb      	ldr	r3, [r7, #28]
9000d584:	2201      	movs	r2, #1
9000d586:	721a      	strb	r2, [r3, #8]
    (void)USBD_LL_PrepareReceive(pdev, MSCOutEpAdd, hmsc->bot_data, len);
9000d588:	4b0a      	ldr	r3, [pc, #40]	@ (9000d5b4 <SCSI_Write12+0x1cc>)
9000d58a:	7819      	ldrb	r1, [r3, #0]
9000d58c:	69fb      	ldr	r3, [r7, #28]
9000d58e:	f103 0210 	add.w	r2, r3, #16
9000d592:	697b      	ldr	r3, [r7, #20]
9000d594:	68f8      	ldr	r0, [r7, #12]
9000d596:	f7f3 fe66 	bl	90001266 <USBD_LL_PrepareReceive>
  else /* Write Process ongoing */
  {
    return SCSI_ProcessWrite(pdev, lun);
  }

  return 0;
9000d59a:	2300      	movs	r3, #0
9000d59c:	e005      	b.n	9000d5aa <SCSI_Write12+0x1c2>
    return SCSI_ProcessWrite(pdev, lun);
9000d59e:	7afb      	ldrb	r3, [r7, #11]
9000d5a0:	4619      	mov	r1, r3
9000d5a2:	68f8      	ldr	r0, [r7, #12]
9000d5a4:	f000 f986 	bl	9000d8b4 <SCSI_ProcessWrite>
9000d5a8:	4603      	mov	r3, r0
}
9000d5aa:	4618      	mov	r0, r3
9000d5ac:	3720      	adds	r7, #32
9000d5ae:	46bd      	mov	sp, r7
9000d5b0:	bd80      	pop	{r7, pc}
9000d5b2:	bf00      	nop
9000d5b4:	240000e3 	.word	0x240000e3

9000d5b8 <SCSI_Verify10>:
  * @param  lun: Logical unit number
  * @param  params: Command parameters
  * @retval status
  */
static int8_t SCSI_Verify10(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t *params)
{
9000d5b8:	b580      	push	{r7, lr}
9000d5ba:	b086      	sub	sp, #24
9000d5bc:	af00      	add	r7, sp, #0
9000d5be:	60f8      	str	r0, [r7, #12]
9000d5c0:	460b      	mov	r3, r1
9000d5c2:	607a      	str	r2, [r7, #4]
9000d5c4:	72fb      	strb	r3, [r7, #11]
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000d5c6:	68fb      	ldr	r3, [r7, #12]
9000d5c8:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000d5cc:	68fb      	ldr	r3, [r7, #12]
9000d5ce:	32b0      	adds	r2, #176	@ 0xb0
9000d5d0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000d5d4:	617b      	str	r3, [r7, #20]
  USBD_MSC_BOT_LUN_TypeDef *p_scsi_blk = &hmsc->scsi_blk[lun];
9000d5d6:	7afb      	ldrb	r3, [r7, #11]
9000d5d8:	3326      	adds	r3, #38	@ 0x26
9000d5da:	011b      	lsls	r3, r3, #4
9000d5dc:	697a      	ldr	r2, [r7, #20]
9000d5de:	4413      	add	r3, r2
9000d5e0:	3304      	adds	r3, #4
9000d5e2:	613b      	str	r3, [r7, #16]

  if (hmsc == NULL)
9000d5e4:	697b      	ldr	r3, [r7, #20]
9000d5e6:	2b00      	cmp	r3, #0
9000d5e8:	d102      	bne.n	9000d5f0 <SCSI_Verify10+0x38>
  {
    return -1;
9000d5ea:	f04f 33ff 	mov.w	r3, #4294967295
9000d5ee:	e021      	b.n	9000d634 <SCSI_Verify10+0x7c>
  }

  if ((params[1] & 0x02U) == 0x02U)
9000d5f0:	687b      	ldr	r3, [r7, #4]
9000d5f2:	3301      	adds	r3, #1
9000d5f4:	781b      	ldrb	r3, [r3, #0]
9000d5f6:	f003 0302 	and.w	r3, r3, #2
9000d5fa:	2b00      	cmp	r3, #0
9000d5fc:	d008      	beq.n	9000d610 <SCSI_Verify10+0x58>
  {
    SCSI_SenseCode(pdev, lun, ILLEGAL_REQUEST, INVALID_FIELD_IN_COMMAND);
9000d5fe:	7af9      	ldrb	r1, [r7, #11]
9000d600:	2324      	movs	r3, #36	@ 0x24
9000d602:	2205      	movs	r2, #5
9000d604:	68f8      	ldr	r0, [r7, #12]
9000d606:	f7ff fbea 	bl	9000cdde <SCSI_SenseCode>
    return -1; /* Error, Verify Mode Not supported*/
9000d60a:	f04f 33ff 	mov.w	r3, #4294967295
9000d60e:	e011      	b.n	9000d634 <SCSI_Verify10+0x7c>
  }

  if (SCSI_CheckAddressRange(pdev, lun, p_scsi_blk->addr, p_scsi_blk->len) < 0)
9000d610:	693b      	ldr	r3, [r7, #16]
9000d612:	689a      	ldr	r2, [r3, #8]
9000d614:	693b      	ldr	r3, [r7, #16]
9000d616:	68db      	ldr	r3, [r3, #12]
9000d618:	7af9      	ldrb	r1, [r7, #11]
9000d61a:	68f8      	ldr	r0, [r7, #12]
9000d61c:	f000 f896 	bl	9000d74c <SCSI_CheckAddressRange>
9000d620:	4603      	mov	r3, r0
9000d622:	2b00      	cmp	r3, #0
9000d624:	da02      	bge.n	9000d62c <SCSI_Verify10+0x74>
  {
    return -1; /* error */
9000d626:	f04f 33ff 	mov.w	r3, #4294967295
9000d62a:	e003      	b.n	9000d634 <SCSI_Verify10+0x7c>
  }

  hmsc->bot_data_length = 0U;
9000d62c:	697b      	ldr	r3, [r7, #20]
9000d62e:	2200      	movs	r2, #0
9000d630:	60da      	str	r2, [r3, #12]

  return 0;
9000d632:	2300      	movs	r3, #0
}
9000d634:	4618      	mov	r0, r3
9000d636:	3718      	adds	r7, #24
9000d638:	46bd      	mov	sp, r7
9000d63a:	bd80      	pop	{r7, pc}

9000d63c <SCSI_ReportLuns>:
  * @brief  SCSI_ReportLuns12
  *         Process ReportLuns command
  * @retval status
  */
static int8_t SCSI_ReportLuns(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t *params)
{
9000d63c:	b580      	push	{r7, lr}
9000d63e:	b088      	sub	sp, #32
9000d640:	af00      	add	r7, sp, #0
9000d642:	60f8      	str	r0, [r7, #12]
9000d644:	460b      	mov	r3, r1
9000d646:	607a      	str	r2, [r7, #4]
9000d648:	72fb      	strb	r3, [r7, #11]
  UNUSED(params);

  /* Define the report LUNs buffer Each LUN entry is 8 bytes */
  static uint8_t lun_report[8U * (MSC_BOT_MAX_LUN + 1U)];

  hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000d64a:	68fb      	ldr	r3, [r7, #12]
9000d64c:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000d650:	68fb      	ldr	r3, [r7, #12]
9000d652:	32b0      	adds	r2, #176	@ 0xb0
9000d654:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000d658:	61bb      	str	r3, [r7, #24]

  if (hmsc == NULL)
9000d65a:	69bb      	ldr	r3, [r7, #24]
9000d65c:	2b00      	cmp	r3, #0
9000d65e:	d102      	bne.n	9000d666 <SCSI_ReportLuns+0x2a>
  {
    return -1;
9000d660:	f04f 33ff 	mov.w	r3, #4294967295
9000d664:	e038      	b.n	9000d6d8 <SCSI_ReportLuns+0x9c>
  }

  /* Initialize the report LUNs buffer */
  (void)USBD_memset(lun_report, 0, sizeof(lun_report));
9000d666:	2218      	movs	r2, #24
9000d668:	2100      	movs	r1, #0
9000d66a:	481d      	ldr	r0, [pc, #116]	@ (9000d6e0 <SCSI_ReportLuns+0xa4>)
9000d66c:	f000 f9db 	bl	9000da26 <memset>

  /* Set the LUN list length in the first 4 bytes */
  lun_list_length = 8U * (hmsc->max_lun + 1U);
9000d670:	69bb      	ldr	r3, [r7, #24]
9000d672:	681b      	ldr	r3, [r3, #0]
9000d674:	3301      	adds	r3, #1
9000d676:	00db      	lsls	r3, r3, #3
9000d678:	617b      	str	r3, [r7, #20]
  lun_report[0] = (uint8_t)(lun_list_length >> 24);
9000d67a:	697b      	ldr	r3, [r7, #20]
9000d67c:	0e1b      	lsrs	r3, r3, #24
9000d67e:	b2da      	uxtb	r2, r3
9000d680:	4b17      	ldr	r3, [pc, #92]	@ (9000d6e0 <SCSI_ReportLuns+0xa4>)
9000d682:	701a      	strb	r2, [r3, #0]
  lun_report[1] = (uint8_t)(lun_list_length >> 16);
9000d684:	697b      	ldr	r3, [r7, #20]
9000d686:	0c1b      	lsrs	r3, r3, #16
9000d688:	b2da      	uxtb	r2, r3
9000d68a:	4b15      	ldr	r3, [pc, #84]	@ (9000d6e0 <SCSI_ReportLuns+0xa4>)
9000d68c:	705a      	strb	r2, [r3, #1]
  lun_report[2] = (uint8_t)(lun_list_length >> 8);
9000d68e:	697b      	ldr	r3, [r7, #20]
9000d690:	0a1b      	lsrs	r3, r3, #8
9000d692:	b2da      	uxtb	r2, r3
9000d694:	4b12      	ldr	r3, [pc, #72]	@ (9000d6e0 <SCSI_ReportLuns+0xa4>)
9000d696:	709a      	strb	r2, [r3, #2]
  lun_report[3] = (uint8_t)(lun_list_length & 0xFFU);
9000d698:	697b      	ldr	r3, [r7, #20]
9000d69a:	b2da      	uxtb	r2, r3
9000d69c:	4b10      	ldr	r3, [pc, #64]	@ (9000d6e0 <SCSI_ReportLuns+0xa4>)
9000d69e:	70da      	strb	r2, [r3, #3]

  /* Update the LUN list */
  for (lun_idx = 0U; lun_idx <= hmsc->max_lun; lun_idx++)
9000d6a0:	2300      	movs	r3, #0
9000d6a2:	77fb      	strb	r3, [r7, #31]
9000d6a4:	e008      	b.n	9000d6b8 <SCSI_ReportLuns+0x7c>
  {
    /* LUN identifier is placed at the second byte of each 8-byte entry */
    lun_report[(8U * (lun_idx + 1U)) + 1U] = lun_idx;
9000d6a6:	7ffb      	ldrb	r3, [r7, #31]
9000d6a8:	00db      	lsls	r3, r3, #3
9000d6aa:	3309      	adds	r3, #9
9000d6ac:	490c      	ldr	r1, [pc, #48]	@ (9000d6e0 <SCSI_ReportLuns+0xa4>)
9000d6ae:	7ffa      	ldrb	r2, [r7, #31]
9000d6b0:	54ca      	strb	r2, [r1, r3]
  for (lun_idx = 0U; lun_idx <= hmsc->max_lun; lun_idx++)
9000d6b2:	7ffb      	ldrb	r3, [r7, #31]
9000d6b4:	3301      	adds	r3, #1
9000d6b6:	77fb      	strb	r3, [r7, #31]
9000d6b8:	7ffa      	ldrb	r2, [r7, #31]
9000d6ba:	69bb      	ldr	r3, [r7, #24]
9000d6bc:	681b      	ldr	r3, [r3, #0]
9000d6be:	429a      	cmp	r2, r3
9000d6c0:	d9f1      	bls.n	9000d6a6 <SCSI_ReportLuns+0x6a>
  }

  /* Calculate the total length of the report LUNs buffer */
  total_length = lun_list_length + 8U;
9000d6c2:	697b      	ldr	r3, [r7, #20]
9000d6c4:	3308      	adds	r3, #8
9000d6c6:	613b      	str	r3, [r7, #16]

  /* Update the BOT data with the report LUNs buffer */
  (void)SCSI_UpdateBotData(hmsc, lun_report, (uint16_t)total_length);
9000d6c8:	693b      	ldr	r3, [r7, #16]
9000d6ca:	b29b      	uxth	r3, r3
9000d6cc:	461a      	mov	r2, r3
9000d6ce:	4904      	ldr	r1, [pc, #16]	@ (9000d6e0 <SCSI_ReportLuns+0xa4>)
9000d6d0:	69b8      	ldr	r0, [r7, #24]
9000d6d2:	f000 f97f 	bl	9000d9d4 <SCSI_UpdateBotData>

  return 0;
9000d6d6:	2300      	movs	r3, #0
}
9000d6d8:	4618      	mov	r0, r3
9000d6da:	3720      	adds	r7, #32
9000d6dc:	46bd      	mov	sp, r7
9000d6de:	bd80      	pop	{r7, pc}
9000d6e0:	24000e24 	.word	0x24000e24

9000d6e4 <SCSI_ReceiveDiagnosticResults>:
  * @param  lun: Logical unit number
  * @param  params: Command parameters
  * @retval status
  */
static int8_t SCSI_ReceiveDiagnosticResults(USBD_HandleTypeDef *pdev, uint8_t lun, uint8_t *params)
{
9000d6e4:	b580      	push	{r7, lr}
9000d6e6:	b086      	sub	sp, #24
9000d6e8:	af00      	add	r7, sp, #0
9000d6ea:	60f8      	str	r0, [r7, #12]
9000d6ec:	460b      	mov	r3, r1
9000d6ee:	607a      	str	r2, [r7, #4]
9000d6f0:	72fb      	strb	r3, [r7, #11]
  UNUSED(lun);
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000d6f2:	68fb      	ldr	r3, [r7, #12]
9000d6f4:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000d6f8:	68fb      	ldr	r3, [r7, #12]
9000d6fa:	32b0      	adds	r2, #176	@ 0xb0
9000d6fc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000d700:	613b      	str	r3, [r7, #16]
  uint16_t allocation_length;

  /* Extract the allocation length from the CDB */
  allocation_length = (((uint16_t)params[3] << 8) | (uint16_t)params[4]);
9000d702:	687b      	ldr	r3, [r7, #4]
9000d704:	3303      	adds	r3, #3
9000d706:	781b      	ldrb	r3, [r3, #0]
9000d708:	b21b      	sxth	r3, r3
9000d70a:	021b      	lsls	r3, r3, #8
9000d70c:	b21a      	sxth	r2, r3
9000d70e:	687b      	ldr	r3, [r7, #4]
9000d710:	3304      	adds	r3, #4
9000d712:	781b      	ldrb	r3, [r3, #0]
9000d714:	b21b      	sxth	r3, r3
9000d716:	4313      	orrs	r3, r2
9000d718:	b21b      	sxth	r3, r3
9000d71a:	82fb      	strh	r3, [r7, #22]

  if (allocation_length == 0U)
9000d71c:	8afb      	ldrh	r3, [r7, #22]
9000d71e:	2b00      	cmp	r3, #0
9000d720:	d101      	bne.n	9000d726 <SCSI_ReceiveDiagnosticResults+0x42>
  {
    return 0;
9000d722:	2300      	movs	r3, #0
9000d724:	e00b      	b.n	9000d73e <SCSI_ReceiveDiagnosticResults+0x5a>
  }

  /* Ensure the allocation length does not exceed the diagnostic data length */
  if (allocation_length > DIAGNOSTIC_DATA_LEN)
9000d726:	8afb      	ldrh	r3, [r7, #22]
9000d728:	2b08      	cmp	r3, #8
9000d72a:	d901      	bls.n	9000d730 <SCSI_ReceiveDiagnosticResults+0x4c>
  {
    allocation_length = DIAGNOSTIC_DATA_LEN;
9000d72c:	2308      	movs	r3, #8
9000d72e:	82fb      	strh	r3, [r7, #22]
  }

  /* Send the diagnostic data to the host */
  (void)SCSI_UpdateBotData(hmsc, MSC_Diagnostic_Data, allocation_length);
9000d730:	8afb      	ldrh	r3, [r7, #22]
9000d732:	461a      	mov	r2, r3
9000d734:	4904      	ldr	r1, [pc, #16]	@ (9000d748 <SCSI_ReceiveDiagnosticResults+0x64>)
9000d736:	6938      	ldr	r0, [r7, #16]
9000d738:	f000 f94c 	bl	9000d9d4 <SCSI_UpdateBotData>

  return 0;
9000d73c:	2300      	movs	r3, #0
}
9000d73e:	4618      	mov	r0, r3
9000d740:	3718      	adds	r7, #24
9000d742:	46bd      	mov	sp, r7
9000d744:	bd80      	pop	{r7, pc}
9000d746:	bf00      	nop
9000d748:	24000e1c 	.word	0x24000e1c

9000d74c <SCSI_CheckAddressRange>:
  * @param  blk_nbr: number of block to be processed
  * @retval status
  */
static int8_t SCSI_CheckAddressRange(USBD_HandleTypeDef *pdev, uint8_t lun,
                                     uint32_t blk_offset, uint32_t blk_nbr)
{
9000d74c:	b580      	push	{r7, lr}
9000d74e:	b086      	sub	sp, #24
9000d750:	af00      	add	r7, sp, #0
9000d752:	60f8      	str	r0, [r7, #12]
9000d754:	607a      	str	r2, [r7, #4]
9000d756:	603b      	str	r3, [r7, #0]
9000d758:	460b      	mov	r3, r1
9000d75a:	72fb      	strb	r3, [r7, #11]
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000d75c:	68fb      	ldr	r3, [r7, #12]
9000d75e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000d762:	68fb      	ldr	r3, [r7, #12]
9000d764:	32b0      	adds	r2, #176	@ 0xb0
9000d766:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000d76a:	617b      	str	r3, [r7, #20]
  USBD_MSC_BOT_LUN_TypeDef *p_scsi_blk = &hmsc->scsi_blk[lun];
9000d76c:	7afb      	ldrb	r3, [r7, #11]
9000d76e:	3326      	adds	r3, #38	@ 0x26
9000d770:	011b      	lsls	r3, r3, #4
9000d772:	697a      	ldr	r2, [r7, #20]
9000d774:	4413      	add	r3, r2
9000d776:	3304      	adds	r3, #4
9000d778:	613b      	str	r3, [r7, #16]

  if (hmsc == NULL)
9000d77a:	697b      	ldr	r3, [r7, #20]
9000d77c:	2b00      	cmp	r3, #0
9000d77e:	d102      	bne.n	9000d786 <SCSI_CheckAddressRange+0x3a>
  {
    return -1;
9000d780:	f04f 33ff 	mov.w	r3, #4294967295
9000d784:	e010      	b.n	9000d7a8 <SCSI_CheckAddressRange+0x5c>
  }

  if ((blk_offset + blk_nbr) > p_scsi_blk->nbr)
9000d786:	687a      	ldr	r2, [r7, #4]
9000d788:	683b      	ldr	r3, [r7, #0]
9000d78a:	441a      	add	r2, r3
9000d78c:	693b      	ldr	r3, [r7, #16]
9000d78e:	685b      	ldr	r3, [r3, #4]
9000d790:	429a      	cmp	r2, r3
9000d792:	d908      	bls.n	9000d7a6 <SCSI_CheckAddressRange+0x5a>
  {
    SCSI_SenseCode(pdev, lun, ILLEGAL_REQUEST, ADDRESS_OUT_OF_RANGE);
9000d794:	7af9      	ldrb	r1, [r7, #11]
9000d796:	2321      	movs	r3, #33	@ 0x21
9000d798:	2205      	movs	r2, #5
9000d79a:	68f8      	ldr	r0, [r7, #12]
9000d79c:	f7ff fb1f 	bl	9000cdde <SCSI_SenseCode>
    return -1;
9000d7a0:	f04f 33ff 	mov.w	r3, #4294967295
9000d7a4:	e000      	b.n	9000d7a8 <SCSI_CheckAddressRange+0x5c>
  }

  return 0;
9000d7a6:	2300      	movs	r3, #0
}
9000d7a8:	4618      	mov	r0, r3
9000d7aa:	3718      	adds	r7, #24
9000d7ac:	46bd      	mov	sp, r7
9000d7ae:	bd80      	pop	{r7, pc}

9000d7b0 <SCSI_ProcessRead>:
  *         Handle Read Process
  * @param  lun: Logical unit number
  * @retval status
  */
static int8_t SCSI_ProcessRead(USBD_HandleTypeDef *pdev, uint8_t lun)
{
9000d7b0:	b590      	push	{r4, r7, lr}
9000d7b2:	b087      	sub	sp, #28
9000d7b4:	af00      	add	r7, sp, #0
9000d7b6:	6078      	str	r0, [r7, #4]
9000d7b8:	460b      	mov	r3, r1
9000d7ba:	70fb      	strb	r3, [r7, #3]
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000d7bc:	687b      	ldr	r3, [r7, #4]
9000d7be:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000d7c2:	687b      	ldr	r3, [r7, #4]
9000d7c4:	32b0      	adds	r2, #176	@ 0xb0
9000d7c6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000d7ca:	617b      	str	r3, [r7, #20]
  USBD_MSC_BOT_LUN_TypeDef *p_scsi_blk = &hmsc->scsi_blk[lun];
9000d7cc:	78fb      	ldrb	r3, [r7, #3]
9000d7ce:	3326      	adds	r3, #38	@ 0x26
9000d7d0:	011b      	lsls	r3, r3, #4
9000d7d2:	697a      	ldr	r2, [r7, #20]
9000d7d4:	4413      	add	r3, r2
9000d7d6:	3304      	adds	r3, #4
9000d7d8:	613b      	str	r3, [r7, #16]
  uint32_t len;

  if (hmsc == NULL)
9000d7da:	697b      	ldr	r3, [r7, #20]
9000d7dc:	2b00      	cmp	r3, #0
9000d7de:	d102      	bne.n	9000d7e6 <SCSI_ProcessRead+0x36>
  {
    return -1;
9000d7e0:	f04f 33ff 	mov.w	r3, #4294967295
9000d7e4:	e05f      	b.n	9000d8a6 <SCSI_ProcessRead+0xf6>
  }

  len = p_scsi_blk->len * p_scsi_blk->size;
9000d7e6:	693b      	ldr	r3, [r7, #16]
9000d7e8:	68db      	ldr	r3, [r3, #12]
9000d7ea:	693a      	ldr	r2, [r7, #16]
9000d7ec:	8812      	ldrh	r2, [r2, #0]
9000d7ee:	fb02 f303 	mul.w	r3, r2, r3
9000d7f2:	60fb      	str	r3, [r7, #12]
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  MSCInEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  len = MIN(len, MSC_MEDIA_PACKET);
9000d7f4:	68fb      	ldr	r3, [r7, #12]
9000d7f6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
9000d7fa:	bf28      	it	cs
9000d7fc:	f44f 7300 	movcs.w	r3, #512	@ 0x200
9000d800:	60fb      	str	r3, [r7, #12]

  if (((USBD_StorageTypeDef *)pdev->pUserData[pdev->classId])->Read(lun, hmsc->bot_data,
9000d802:	687b      	ldr	r3, [r7, #4]
9000d804:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
9000d808:	687a      	ldr	r2, [r7, #4]
9000d80a:	33b0      	adds	r3, #176	@ 0xb0
9000d80c:	009b      	lsls	r3, r3, #2
9000d80e:	4413      	add	r3, r2
9000d810:	685b      	ldr	r3, [r3, #4]
9000d812:	691c      	ldr	r4, [r3, #16]
9000d814:	697b      	ldr	r3, [r7, #20]
9000d816:	f103 0110 	add.w	r1, r3, #16
9000d81a:	693b      	ldr	r3, [r7, #16]
9000d81c:	689a      	ldr	r2, [r3, #8]
                                                                    p_scsi_blk->addr,
                                                                    (len / p_scsi_blk->size)) < 0)
9000d81e:	693b      	ldr	r3, [r7, #16]
9000d820:	881b      	ldrh	r3, [r3, #0]
9000d822:	4618      	mov	r0, r3
9000d824:	68fb      	ldr	r3, [r7, #12]
9000d826:	fbb3 f3f0 	udiv	r3, r3, r0
  if (((USBD_StorageTypeDef *)pdev->pUserData[pdev->classId])->Read(lun, hmsc->bot_data,
9000d82a:	b29b      	uxth	r3, r3
9000d82c:	78f8      	ldrb	r0, [r7, #3]
9000d82e:	47a0      	blx	r4
9000d830:	4603      	mov	r3, r0
9000d832:	2b00      	cmp	r3, #0
9000d834:	da08      	bge.n	9000d848 <SCSI_ProcessRead+0x98>
  {
    SCSI_SenseCode(pdev, lun, HARDWARE_ERROR, UNRECOVERED_READ_ERROR);
9000d836:	78f9      	ldrb	r1, [r7, #3]
9000d838:	2311      	movs	r3, #17
9000d83a:	2204      	movs	r2, #4
9000d83c:	6878      	ldr	r0, [r7, #4]
9000d83e:	f7ff face 	bl	9000cdde <SCSI_SenseCode>
    return -1;
9000d842:	f04f 33ff 	mov.w	r3, #4294967295
9000d846:	e02e      	b.n	9000d8a6 <SCSI_ProcessRead+0xf6>
  }

  (void)USBD_LL_Transmit(pdev, MSCInEpAdd, hmsc->bot_data, len);
9000d848:	4b19      	ldr	r3, [pc, #100]	@ (9000d8b0 <SCSI_ProcessRead+0x100>)
9000d84a:	7819      	ldrb	r1, [r3, #0]
9000d84c:	697b      	ldr	r3, [r7, #20]
9000d84e:	f103 0210 	add.w	r2, r3, #16
9000d852:	68fb      	ldr	r3, [r7, #12]
9000d854:	6878      	ldr	r0, [r7, #4]
9000d856:	f7f3 fce5 	bl	90001224 <USBD_LL_Transmit>

  p_scsi_blk->addr += (len / p_scsi_blk->size);
9000d85a:	693b      	ldr	r3, [r7, #16]
9000d85c:	689a      	ldr	r2, [r3, #8]
9000d85e:	693b      	ldr	r3, [r7, #16]
9000d860:	881b      	ldrh	r3, [r3, #0]
9000d862:	4619      	mov	r1, r3
9000d864:	68fb      	ldr	r3, [r7, #12]
9000d866:	fbb3 f3f1 	udiv	r3, r3, r1
9000d86a:	441a      	add	r2, r3
9000d86c:	693b      	ldr	r3, [r7, #16]
9000d86e:	609a      	str	r2, [r3, #8]
  p_scsi_blk->len -= (len / p_scsi_blk->size);
9000d870:	693b      	ldr	r3, [r7, #16]
9000d872:	68da      	ldr	r2, [r3, #12]
9000d874:	693b      	ldr	r3, [r7, #16]
9000d876:	881b      	ldrh	r3, [r3, #0]
9000d878:	4619      	mov	r1, r3
9000d87a:	68fb      	ldr	r3, [r7, #12]
9000d87c:	fbb3 f3f1 	udiv	r3, r3, r1
9000d880:	1ad2      	subs	r2, r2, r3
9000d882:	693b      	ldr	r3, [r7, #16]
9000d884:	60da      	str	r2, [r3, #12]

  /* case 6 : Hi = Di */
  hmsc->csw.dDataResidue -= len;
9000d886:	697b      	ldr	r3, [r7, #20]
9000d888:	f8d3 2238 	ldr.w	r2, [r3, #568]	@ 0x238
9000d88c:	68fb      	ldr	r3, [r7, #12]
9000d88e:	1ad2      	subs	r2, r2, r3
9000d890:	697b      	ldr	r3, [r7, #20]
9000d892:	f8c3 2238 	str.w	r2, [r3, #568]	@ 0x238

  if (p_scsi_blk->len == 0U)
9000d896:	693b      	ldr	r3, [r7, #16]
9000d898:	68db      	ldr	r3, [r3, #12]
9000d89a:	2b00      	cmp	r3, #0
9000d89c:	d102      	bne.n	9000d8a4 <SCSI_ProcessRead+0xf4>
  {
    hmsc->bot_state = USBD_BOT_LAST_DATA_IN;
9000d89e:	697b      	ldr	r3, [r7, #20]
9000d8a0:	2203      	movs	r2, #3
9000d8a2:	721a      	strb	r2, [r3, #8]
  }

  return 0;
9000d8a4:	2300      	movs	r3, #0
}
9000d8a6:	4618      	mov	r0, r3
9000d8a8:	371c      	adds	r7, #28
9000d8aa:	46bd      	mov	sp, r7
9000d8ac:	bd90      	pop	{r4, r7, pc}
9000d8ae:	bf00      	nop
9000d8b0:	240000e2 	.word	0x240000e2

9000d8b4 <SCSI_ProcessWrite>:
  *         Handle Write Process
  * @param  lun: Logical unit number
  * @retval status
  */
static int8_t SCSI_ProcessWrite(USBD_HandleTypeDef *pdev, uint8_t lun)
{
9000d8b4:	b590      	push	{r4, r7, lr}
9000d8b6:	b087      	sub	sp, #28
9000d8b8:	af00      	add	r7, sp, #0
9000d8ba:	6078      	str	r0, [r7, #4]
9000d8bc:	460b      	mov	r3, r1
9000d8be:	70fb      	strb	r3, [r7, #3]
  USBD_MSC_BOT_HandleTypeDef *hmsc = (USBD_MSC_BOT_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
9000d8c0:	687b      	ldr	r3, [r7, #4]
9000d8c2:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
9000d8c6:	687b      	ldr	r3, [r7, #4]
9000d8c8:	32b0      	adds	r2, #176	@ 0xb0
9000d8ca:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000d8ce:	617b      	str	r3, [r7, #20]
  USBD_MSC_BOT_LUN_TypeDef *p_scsi_blk = &hmsc->scsi_blk[lun];
9000d8d0:	78fb      	ldrb	r3, [r7, #3]
9000d8d2:	3326      	adds	r3, #38	@ 0x26
9000d8d4:	011b      	lsls	r3, r3, #4
9000d8d6:	697a      	ldr	r2, [r7, #20]
9000d8d8:	4413      	add	r3, r2
9000d8da:	3304      	adds	r3, #4
9000d8dc:	613b      	str	r3, [r7, #16]
  uint32_t len;

  if (hmsc == NULL)
9000d8de:	697b      	ldr	r3, [r7, #20]
9000d8e0:	2b00      	cmp	r3, #0
9000d8e2:	d102      	bne.n	9000d8ea <SCSI_ProcessWrite+0x36>
  {
    return -1;
9000d8e4:	f04f 33ff 	mov.w	r3, #4294967295
9000d8e8:	e06d      	b.n	9000d9c6 <SCSI_ProcessWrite+0x112>
  }

  len = p_scsi_blk->len * p_scsi_blk->size;
9000d8ea:	693b      	ldr	r3, [r7, #16]
9000d8ec:	68db      	ldr	r3, [r3, #12]
9000d8ee:	693a      	ldr	r2, [r7, #16]
9000d8f0:	8812      	ldrh	r2, [r2, #0]
9000d8f2:	fb02 f303 	mul.w	r3, r2, r3
9000d8f6:	60fb      	str	r3, [r7, #12]
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  MSCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  len = MIN(len, MSC_MEDIA_PACKET);
9000d8f8:	68fb      	ldr	r3, [r7, #12]
9000d8fa:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
9000d8fe:	bf28      	it	cs
9000d900:	f44f 7300 	movcs.w	r3, #512	@ 0x200
9000d904:	60fb      	str	r3, [r7, #12]

  if (((USBD_StorageTypeDef *)pdev->pUserData[pdev->classId])->Write(lun, hmsc->bot_data, p_scsi_blk->addr,
9000d906:	687b      	ldr	r3, [r7, #4]
9000d908:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
9000d90c:	687a      	ldr	r2, [r7, #4]
9000d90e:	33b0      	adds	r3, #176	@ 0xb0
9000d910:	009b      	lsls	r3, r3, #2
9000d912:	4413      	add	r3, r2
9000d914:	685b      	ldr	r3, [r3, #4]
9000d916:	695c      	ldr	r4, [r3, #20]
9000d918:	697b      	ldr	r3, [r7, #20]
9000d91a:	f103 0110 	add.w	r1, r3, #16
9000d91e:	693b      	ldr	r3, [r7, #16]
9000d920:	689a      	ldr	r2, [r3, #8]
                                                                     (len / p_scsi_blk->size)) < 0)
9000d922:	693b      	ldr	r3, [r7, #16]
9000d924:	881b      	ldrh	r3, [r3, #0]
9000d926:	4618      	mov	r0, r3
9000d928:	68fb      	ldr	r3, [r7, #12]
9000d92a:	fbb3 f3f0 	udiv	r3, r3, r0
  if (((USBD_StorageTypeDef *)pdev->pUserData[pdev->classId])->Write(lun, hmsc->bot_data, p_scsi_blk->addr,
9000d92e:	b29b      	uxth	r3, r3
9000d930:	78f8      	ldrb	r0, [r7, #3]
9000d932:	47a0      	blx	r4
9000d934:	4603      	mov	r3, r0
9000d936:	2b00      	cmp	r3, #0
9000d938:	da08      	bge.n	9000d94c <SCSI_ProcessWrite+0x98>
  {
    SCSI_SenseCode(pdev, lun, HARDWARE_ERROR, WRITE_FAULT);
9000d93a:	78f9      	ldrb	r1, [r7, #3]
9000d93c:	2303      	movs	r3, #3
9000d93e:	2204      	movs	r2, #4
9000d940:	6878      	ldr	r0, [r7, #4]
9000d942:	f7ff fa4c 	bl	9000cdde <SCSI_SenseCode>
    return -1;
9000d946:	f04f 33ff 	mov.w	r3, #4294967295
9000d94a:	e03c      	b.n	9000d9c6 <SCSI_ProcessWrite+0x112>
  }

  p_scsi_blk->addr += (len / p_scsi_blk->size);
9000d94c:	693b      	ldr	r3, [r7, #16]
9000d94e:	689a      	ldr	r2, [r3, #8]
9000d950:	693b      	ldr	r3, [r7, #16]
9000d952:	881b      	ldrh	r3, [r3, #0]
9000d954:	4619      	mov	r1, r3
9000d956:	68fb      	ldr	r3, [r7, #12]
9000d958:	fbb3 f3f1 	udiv	r3, r3, r1
9000d95c:	441a      	add	r2, r3
9000d95e:	693b      	ldr	r3, [r7, #16]
9000d960:	609a      	str	r2, [r3, #8]
  p_scsi_blk->len -= (len / p_scsi_blk->size);
9000d962:	693b      	ldr	r3, [r7, #16]
9000d964:	68da      	ldr	r2, [r3, #12]
9000d966:	693b      	ldr	r3, [r7, #16]
9000d968:	881b      	ldrh	r3, [r3, #0]
9000d96a:	4619      	mov	r1, r3
9000d96c:	68fb      	ldr	r3, [r7, #12]
9000d96e:	fbb3 f3f1 	udiv	r3, r3, r1
9000d972:	1ad2      	subs	r2, r2, r3
9000d974:	693b      	ldr	r3, [r7, #16]
9000d976:	60da      	str	r2, [r3, #12]

  /* case 12 : Ho = Do */
  hmsc->csw.dDataResidue -= len;
9000d978:	697b      	ldr	r3, [r7, #20]
9000d97a:	f8d3 2238 	ldr.w	r2, [r3, #568]	@ 0x238
9000d97e:	68fb      	ldr	r3, [r7, #12]
9000d980:	1ad2      	subs	r2, r2, r3
9000d982:	697b      	ldr	r3, [r7, #20]
9000d984:	f8c3 2238 	str.w	r2, [r3, #568]	@ 0x238

  if (p_scsi_blk->len == 0U)
9000d988:	693b      	ldr	r3, [r7, #16]
9000d98a:	68db      	ldr	r3, [r3, #12]
9000d98c:	2b00      	cmp	r3, #0
9000d98e:	d104      	bne.n	9000d99a <SCSI_ProcessWrite+0xe6>
  {
    MSC_BOT_SendCSW(pdev, USBD_CSW_CMD_PASSED);
9000d990:	2100      	movs	r1, #0
9000d992:	6878      	ldr	r0, [r7, #4]
9000d994:	f7fe fc26 	bl	9000c1e4 <MSC_BOT_SendCSW>
9000d998:	e014      	b.n	9000d9c4 <SCSI_ProcessWrite+0x110>
  }
  else
  {
    len = MIN((p_scsi_blk->len * p_scsi_blk->size), MSC_MEDIA_PACKET);
9000d99a:	693b      	ldr	r3, [r7, #16]
9000d99c:	68db      	ldr	r3, [r3, #12]
9000d99e:	693a      	ldr	r2, [r7, #16]
9000d9a0:	8812      	ldrh	r2, [r2, #0]
9000d9a2:	fb02 f303 	mul.w	r3, r2, r3
9000d9a6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
9000d9aa:	bf28      	it	cs
9000d9ac:	f44f 7300 	movcs.w	r3, #512	@ 0x200
9000d9b0:	60fb      	str	r3, [r7, #12]

    /* Prepare EP to Receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, MSCOutEpAdd, hmsc->bot_data, len);
9000d9b2:	4b07      	ldr	r3, [pc, #28]	@ (9000d9d0 <SCSI_ProcessWrite+0x11c>)
9000d9b4:	7819      	ldrb	r1, [r3, #0]
9000d9b6:	697b      	ldr	r3, [r7, #20]
9000d9b8:	f103 0210 	add.w	r2, r3, #16
9000d9bc:	68fb      	ldr	r3, [r7, #12]
9000d9be:	6878      	ldr	r0, [r7, #4]
9000d9c0:	f7f3 fc51 	bl	90001266 <USBD_LL_PrepareReceive>
  }

  return 0;
9000d9c4:	2300      	movs	r3, #0
}
9000d9c6:	4618      	mov	r0, r3
9000d9c8:	371c      	adds	r7, #28
9000d9ca:	46bd      	mov	sp, r7
9000d9cc:	bd90      	pop	{r4, r7, pc}
9000d9ce:	bf00      	nop
9000d9d0:	240000e3 	.word	0x240000e3

9000d9d4 <SCSI_UpdateBotData>:
  * @param  length: Data length
  * @retval status
  */
static int8_t SCSI_UpdateBotData(USBD_MSC_BOT_HandleTypeDef *hmsc,
                                 uint8_t *pBuff, uint16_t length)
{
9000d9d4:	b480      	push	{r7}
9000d9d6:	b087      	sub	sp, #28
9000d9d8:	af00      	add	r7, sp, #0
9000d9da:	60f8      	str	r0, [r7, #12]
9000d9dc:	60b9      	str	r1, [r7, #8]
9000d9de:	4613      	mov	r3, r2
9000d9e0:	80fb      	strh	r3, [r7, #6]
  uint16_t len = length;
9000d9e2:	88fb      	ldrh	r3, [r7, #6]
9000d9e4:	82fb      	strh	r3, [r7, #22]

  if (hmsc == NULL)
9000d9e6:	68fb      	ldr	r3, [r7, #12]
9000d9e8:	2b00      	cmp	r3, #0
9000d9ea:	d102      	bne.n	9000d9f2 <SCSI_UpdateBotData+0x1e>
  {
    return -1;
9000d9ec:	f04f 33ff 	mov.w	r3, #4294967295
9000d9f0:	e013      	b.n	9000da1a <SCSI_UpdateBotData+0x46>
  }

  hmsc->bot_data_length = len;
9000d9f2:	8afa      	ldrh	r2, [r7, #22]
9000d9f4:	68fb      	ldr	r3, [r7, #12]
9000d9f6:	60da      	str	r2, [r3, #12]

  while (len != 0U)
9000d9f8:	e00b      	b.n	9000da12 <SCSI_UpdateBotData+0x3e>
  {
    len--;
9000d9fa:	8afb      	ldrh	r3, [r7, #22]
9000d9fc:	3b01      	subs	r3, #1
9000d9fe:	82fb      	strh	r3, [r7, #22]
    hmsc->bot_data[len] = pBuff[len];
9000da00:	8afb      	ldrh	r3, [r7, #22]
9000da02:	68ba      	ldr	r2, [r7, #8]
9000da04:	441a      	add	r2, r3
9000da06:	8afb      	ldrh	r3, [r7, #22]
9000da08:	7811      	ldrb	r1, [r2, #0]
9000da0a:	68fa      	ldr	r2, [r7, #12]
9000da0c:	4413      	add	r3, r2
9000da0e:	460a      	mov	r2, r1
9000da10:	741a      	strb	r2, [r3, #16]
  while (len != 0U)
9000da12:	8afb      	ldrh	r3, [r7, #22]
9000da14:	2b00      	cmp	r3, #0
9000da16:	d1f0      	bne.n	9000d9fa <SCSI_UpdateBotData+0x26>
  }

  return 0;
9000da18:	2300      	movs	r3, #0
}
9000da1a:	4618      	mov	r0, r3
9000da1c:	371c      	adds	r7, #28
9000da1e:	46bd      	mov	sp, r7
9000da20:	f85d 7b04 	ldr.w	r7, [sp], #4
9000da24:	4770      	bx	lr

9000da26 <memset>:
9000da26:	4402      	add	r2, r0
9000da28:	4603      	mov	r3, r0
9000da2a:	4293      	cmp	r3, r2
9000da2c:	d100      	bne.n	9000da30 <memset+0xa>
9000da2e:	4770      	bx	lr
9000da30:	f803 1b01 	strb.w	r1, [r3], #1
9000da34:	e7f9      	b.n	9000da2a <memset+0x4>
	...

9000da38 <__libc_init_array>:
9000da38:	b570      	push	{r4, r5, r6, lr}
9000da3a:	4d0d      	ldr	r5, [pc, #52]	@ (9000da70 <__libc_init_array+0x38>)
9000da3c:	4c0d      	ldr	r4, [pc, #52]	@ (9000da74 <__libc_init_array+0x3c>)
9000da3e:	1b64      	subs	r4, r4, r5
9000da40:	10a4      	asrs	r4, r4, #2
9000da42:	2600      	movs	r6, #0
9000da44:	42a6      	cmp	r6, r4
9000da46:	d109      	bne.n	9000da5c <__libc_init_array+0x24>
9000da48:	4d0b      	ldr	r5, [pc, #44]	@ (9000da78 <__libc_init_array+0x40>)
9000da4a:	4c0c      	ldr	r4, [pc, #48]	@ (9000da7c <__libc_init_array+0x44>)
9000da4c:	f000 f818 	bl	9000da80 <_init>
9000da50:	1b64      	subs	r4, r4, r5
9000da52:	10a4      	asrs	r4, r4, #2
9000da54:	2600      	movs	r6, #0
9000da56:	42a6      	cmp	r6, r4
9000da58:	d105      	bne.n	9000da66 <__libc_init_array+0x2e>
9000da5a:	bd70      	pop	{r4, r5, r6, pc}
9000da5c:	f855 3b04 	ldr.w	r3, [r5], #4
9000da60:	4798      	blx	r3
9000da62:	3601      	adds	r6, #1
9000da64:	e7ee      	b.n	9000da44 <__libc_init_array+0xc>
9000da66:	f855 3b04 	ldr.w	r3, [r5], #4
9000da6a:	4798      	blx	r3
9000da6c:	3601      	adds	r6, #1
9000da6e:	e7f2      	b.n	9000da56 <__libc_init_array+0x1e>
9000da70:	9000db08 	.word	0x9000db08
9000da74:	9000db08 	.word	0x9000db08
9000da78:	9000db08 	.word	0x9000db08
9000da7c:	9000db0c 	.word	0x9000db0c

9000da80 <_init>:
9000da80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
9000da82:	bf00      	nop
9000da84:	bcf8      	pop	{r3, r4, r5, r6, r7}
9000da86:	bc08      	pop	{r3}
9000da88:	469e      	mov	lr, r3
9000da8a:	4770      	bx	lr

9000da8c <_fini>:
9000da8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
9000da8e:	bf00      	nop
9000da90:	bcf8      	pop	{r3, r4, r5, r6, r7}
9000da92:	bc08      	pop	{r3}
9000da94:	469e      	mov	lr, r3
9000da96:	4770      	bx	lr
